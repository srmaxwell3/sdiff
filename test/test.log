# ../sdiff --normal dif.0.cpp dif.1.cpp >& dif.0.1.diff--normal.test
# dif.0.1.diff--normal ---------------------------------------------------------
32d31
< 24c31
# ../sdiff --normal dif.1.cpp dif.0.cpp >& dif.1.0.diff--normal.test
# dif.1.0.diff--normal ---------------------------------------------------------
33d32
< 31c24
# ../sdiff --normal dif.1.cpp dif.2.cpp >& dif.1.2.diff--normal.test
# dif.1.2.diff--normal ---------------------------------------------------------
4c4,9
< 8a11,22
---
> 9,12c11,18
> < int main (int argc, char *argv[])
> < {
> <   map<string, int> table;
> <   vector<vector<int *> *> fileLines;
> ---
13c18,23
< > 
---
> 14,17c20,21
> <   for (int a = 1; a < argc; a += 1) {
> <     if (FILE *f = fopen (argv[a], "r")) {
> <       fprintf (stderr, "# Reading %s...", argv[a]);
> <       vector<int *> *lines = new vector<int *> ();
> ---
16,20c26,28
< > 
< 11,12c25,26
< <   map<string, int> table;
< <   vector<vector<int *> *> fileLines;
< ---
---
> 18a23,32
> > int main (int argc, char *argv[])
> > {
23,25c31
< 14c28
< <   for (int a = 1; a < argc; a += 1) {
< ---
---
> > 
27,29c33,35
< 17d30
< <       vector<int *> *lines = new vector<int *> ();
< 18a32
---
> >     if (FILE *f = fopen (argv[a], "r")) {
> >       fprintf (stderr, "# Reading %s...", argv[a]);
> > 
# ../sdiff --normal dif.2.cpp dif.1.cpp >& dif.2.1.diff--normal.test
./test: line 46: 23210 Aborted                 (core dumped) ${DIFF} "${option}" "${oSrc}" "${nSrc}" 1>&"${dst}.test"
# dif.2.1.diff--normal ---------------------------------------------------------
0a1
> sdiff: sdiff.cpp:1637: void pass6n(): Assertion `lines[0][o].line == lines[1][n].line' failed.
4,20c5,8
< 11,22d8
< < struct Line : public string {
< <   Line (string _text) :
< <     text (_text)
< <   {
< <   }
< <   string text;
< <   list<unsigned> counts[2];
< < };
< < 
< < typedef map<string, Line *> MapStringToLinePtr;
< < typedef vector<Line *> VectorLinePtr;
< < 
< 25,26c11,12
< <   MapStringToLinePtr table;
< <   VectorLinePtr lines[2];
< ---
---
> 9a8,14
> > 
> > int main (int argc, char *argv[])
> > {
23,25c11
< 28c14
< <   for (int a = 1; a < argc && a <= 2; a += 1) {
< ---
---
> > 
27,65d12
< 30a17
< >       vector<int *> *lines = new vector<int *> ();
< 32d18
< <       VectorLinePtr *lines = new VectorLinePtr ();
< 35,43c21,23
< <         string text (buffer);
< < 
< <         Line *line = table[text];
< < 
< <         if (!line) {
< <           table[text] = line = new Line (text);
< <         }
< <         line->counts[a - 1].push_back (lines[a - 1].size ());
< <         lines[a - 1].push_back (line);
< ---
< >         int *line = &table[buffer];
< >         lines->push_back (line);
< >         *line += 1;
< 45c25,26
< <       fprintf (stderr, " %u lines.\n", lines[a - 1]->size ());
< ---
< >       fprintf (stderr, " %u lines.\n", lines->size ());
< >       fileLines.push_back (lines);
< 53,54c34
< <     Line *l = i->second;
< <     counts[l->counts[0].size () + l->counts[1].size ()] += 1;
< ---
< >     counts[i->second] += 1;
< 59,62c39,43
< <   for (int f = 0; f < 2; f += 1) {
< <     fprintf (stderr, "# file #%d\n", f + 1);
< <     for (int l = 0; l < lines[f].size (); l += 1) {
< <       fprintf (stderr, "#   [%d] = %d\n", l, lines[f][l]->counts[f].size ());
< ---
< >   for (int f = 0; f < fileLines.size (); f += 1) {
< >     fprintf (stderr, "# file #%d\n", f);
< >     vector<int *> *lines = fileLines[f];
< >     for (int l = 0; l < lines->size (); l += 1) {
< >       fprintf (stderr, "#   [%d] = %d\n", l, *(*lines)[l]);
# ../sdiff --normal dif.2.cpp dif.3.cpp >& dif.2.3.diff--normal.test
# dif.2.3.diff--normal ---------------------------------------------------------
4c4,25
< 10a13,28
---
> 11,30c13,14
> < struct Line : public string {
> <   Line (string _text) :
> <     text (_text)
> <   {
> <   }
> <   string text;
> <   list<unsigned> counts[2];
> < };
> < 
> < typedef map<string, Line *> MapStringToLinePtr;
> < typedef vector<Line *> VectorLinePtr;
> < 
> < int main (int argc, char *argv[])
> < {
> <   MapStringToLinePtr table;
> <   VectorLinePtr lines[2];
> < 
> <   for (int a = 1; a < argc && a <= 2; a += 1) {
> <     if (FILE *f = fopen (argv[a], "r")) {
> <       fprintf (stderr, "# Reading %s...", argv[a]);
> ---
7c28,46
< > 
---
> 32,48c16,36
> <       VectorLinePtr *lines = new VectorLinePtr ();
> <       char buffer[1024];
> <       while (fgets (buffer, sizeof (buffer), f)) {
> <         string text (buffer);
> < 
> <         Line *line = table[text];
> < 
> <         if (!line) {
> <           table[text] = line = new Line (text);
> <         }
> <         line->counts[a - 1].push_back (lines[a - 1].size ());
> <         lines[a - 1].push_back (line);
> <       }
> <       fprintf (stderr, " %u lines.\n", lines[a - 1]->size ());
> <     } else {
> <       fprintf (stderr, "%s: Unable to open %s!  Ignoring....\n", argv[a]);
> <     }
> ---
21,23c60,61
< 13c31
< <     text (_text)
< ---
---
> > struct Line : public string {
> >   Line (string _text) :
25,28c63,64
< 16,17c34,63
< <   string text;
< <   list<unsigned> counts[2];
< ---
---
> >   {
> >   }
32c68,82
< >   }
---
> 50,62c38,45
> <   printf ("# table.size () = %d\n", table.size ());
> <   map<int, int> counts;
> <   for (map<string, int>::iterator i = table.begin (); i != table.end (); i++) {
> <     Line *l = i->second;
> <     counts[l->counts[0].size () + l->counts[1].size ()] += 1;
> <   }
> <   for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
> <     fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
> <   }
> <   for (int f = 0; f < 2; f += 1) {
> <     fprintf (stderr, "# file #%d\n", f + 1);
> <     for (int l = 0; l < lines[f].size (); l += 1) {
> <       fprintf (stderr, "#   [%d] = %d\n", l, lines[f][l]->counts[f].size ());
> ---
41c91
< >     }
---
> 63a47,745
59,61c109,111
< 21c67,69
< < typedef vector<Line *> VectorLinePtr;
< ---
---
> > };
> > 
> > typedef map<string, Line *> MapStringToLinePtr;
65c115,117
< 24a73,74
---
> > 
> > int main (int argc, char *argv[])
> > {
68,72c120,122
< 28,30c78,91
< <   for (int a = 1; a < argc && a <= 2; a += 1) {
< <     if (FILE *f = fopen (argv[a], "r")) {
< <       fprintf (stderr, "# Reading %s...", argv[a]);
< ---
---
> >   MapStringToLinePtr table;
> >   VectorLinePtr lines[2];
> > 
87,89c137,138
< 32d92
< <       VectorLinePtr *lines = new VectorLinePtr ();
< 33a94,95
---
> > 
> >       char buffer[1024];
92c141,147
< 40a103
---
> >       while (fgets (buffer, sizeof (buffer), f)) {
> >         string text (buffer);
> > 
> >         Line *line = table[text];
> > 
> >         if (!line) {
> >           table[text] = line = new Line (text);
94,97c149
< 42,43c105,110
< <         line->counts[a - 1].push_back (lines[a - 1].size ());
< <         lines[a - 1].push_back (line);
< ---
---
> >         }
104,108c156,157
< 45d111
< <       fprintf (stderr, " %u lines.\n", lines[a - 1]->size ());
< 47c113,115
< <       fprintf (stderr, "%s: Unable to open %s!  Ignoring....\n", argv[a]);
< ---
---
> >       }
> >     } else {
112,116c161,162
< 50,52c118,142
< <   printf ("# table.size () = %d\n", table.size ());
< <   map<int, int> counts;
< <   for (map<string, int>::iterator i = table.begin (); i != table.end (); i++) {
< ---
---
> >     }
> >   }
142,144c188
< 54c144,281
< <     counts[l->counts[0].size () + l->counts[1].size ()] += 1;
< ---
---
> >     Line *l = i->second;
283,286c327
< 56,57c283,288
< <   for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
< <     fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
< ---
---
> >   }
293,298c334
< 59,62c290,742
< <   for (int f = 0; f < 2; f += 1) {
< <     fprintf (stderr, "# file #%d\n", f + 1);
< <     for (int l = 0; l < lines[f].size (); l += 1) {
< <       fprintf (stderr, "#   [%d] = %d\n", l, lines[f][l]->counts[f].size ());
< ---
---
> >   }
752c788
< 63a744,745
---
> >     }
# ../sdiff --normal dif.3.cpp dif.2.cpp >& dif.3.2.diff--normal.test
./test: line 46: 23223 Aborted                 (core dumped) ${DIFF} "${option}" "${oSrc}" "${nSrc}" 1>&"${dst}.test"
# dif.3.2.diff--normal ---------------------------------------------------------
0a1
> sdiff: sdiff.cpp:1637: void pass6n(): Assertion `lines[0][o].line == lines[1][n].line' failed.
4,23c5,8
< 13,28d10
< < enum DiffFormat {
< <   Default,
< < 
< <   Context,
< <   EdScript,
< <   IfThenElse,
< <   Normal,
< <   RCS,
< <   SideBySide,
< <   Unified
< < };
< < 
< < DiffFormat diffFormat = Unified;
< < 
< < int optVerbose = 1;
< < 
< 31c13
< <     string (_text)
< ---
---
> 11a10,13
> > 
> > struct Line : public string {
> >   Line (string _text) :
25,754d9
< 34,63c16,17
< <   ~Line () {
< <     copies[0].erase (copies[0].begin (), copies[0].end ());
< <     copies[1].erase (copies[1].begin (), copies[1].end ());
< <   }
< <   void Dump (FILE *out) {
< <     fprintf (out, "{{ ");
< <     for (list<unsigned>::iterator i = copies[0].begin (); i != copies[0].end (); i++) {
< <       fprintf (out, "%u ", *i);
< <     }
< <     fprintf (out, "},{ ");
< <     for (list<unsigned>::iterator i = copies[1].begin (); i != copies[1].end (); i++) {
< <       fprintf (out, "%u ", *i);
< <     }
< <     fprintf (out, "}}\t%s", c_str ());
< <   }
< <   list<unsigned> copies[2];
< < };
< < 
< < struct LinePtr {
< <   LinePtr (Line *_line) :
< <     line (_line),
< <     l (~0u)
< <   {
< <   }
< <   void Dump (FILE *out) {
< <     fprintf (out, "[%d] ", l);
< <     line->Dump (out);
< <   }
< <   Line *line;
< <   unsigned l;
< ---
< >   string text;
< >   list<unsigned> counts[2];
< 67,69c21
< < typedef vector<LinePtr> VectorLinePtr;
< < 
< < char *ARGV0 = "dif2";
< ---
< > typedef vector<Line *> VectorLinePtr;
< 73,74d24
< <   char const *files[2] = { 0, 0 };
< < 
< 78,91c28,30
< <   unsigned nTotalMatchedBlocks = 0;
< <   unsigned nMatchedBlocks = 0;
< <   unsigned nTotalMatchedLines = 0;
< <   unsigned nMatchedLines = 0;
< < 
< <   // Read the old [0] file, and the new [1] file.
< < 
< <   for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
< <     files[n] = argv[a];
< < 
< <     if (FILE *f = fopen (files[n], "r")) {
< <       if (0 < optVerbose) {
< <         fprintf (stderr, "# Reading %s...", files[n]);
< <       }
< ---
< >   for (int a = 1; a < argc && a <= 2; a += 1) {
< >     if (FILE *f = fopen (argv[a], "r")) {
< >       fprintf (stderr, "# Reading %s...", argv[a]);
< 92a32
< >       VectorLinePtr *lines = new VectorLinePtr ();
< 94,95d33
< <       unsigned nUniq = 0;
< < 
< 103d40
< <           nUniq += 1;
< 105,110c42,43
< <         line->copies[n].push_back (lines[n].size ());
< <         lines[n].push_back (line);
< <       }
< < 
< <       if (0 < optVerbose) {
< <         fprintf (stderr, " %u lines, %u unique.\n", lines[n].size (), nUniq);
< ---
< >         line->counts[a - 1].push_back (lines[a - 1].size ());
< >         lines[a - 1].push_back (line);
< 111a45
< >       fprintf (stderr, " %u lines.\n", lines[a - 1]->size ());
< 113,115c47
< <       fprintf (stderr, "%s: Unable to open %s!  Exiting....\n", ARGV0, files[n]);
< <       perror (ARGV0);
< <       exit (1);
< ---
< >       fprintf (stderr, "%s: Unable to open %s!  Ignoring....\n", argv[a]);
< 118,142c50,52
< < 
< <   if (0 < optVerbose) {
< <     printf ("# Total unique lines = %d\n", table.size ());
< <   }
< < 
< <   // map<int, int> counts;
< <   // for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
< <   //   Line *l = i->second;
< <   //   counts[l->counts[0].size () + l->counts[1].size ()] += 1;
< <   // }
< <   // for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
< <   //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
< <   // }
< < 
< <   // Perform pass #1, in which we find all explicit matches amongst
< <   // the unique lines.  For every unique line that appears the same
< <   // number of times in both files, we declare the lines to match.
< < 
< <   if (0 < optVerbose) {
< <     fprintf (stderr, "# Pass 1 (finding matches amongst unique lines)...");
< <   }
< < 
< <   nMatchedLines = 0;
< < 
< <   for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
< ---
< >   printf ("# table.size () = %d\n", table.size ());
< >   map<int, int> counts;
< >   for (map<string, int>::iterator i = table.begin (); i != table.end (); i++) {
< 144,281c54
< < 
< <     // If the number of old and new lines match, then we declare that
< <     // they are (all) the same line.  Note, it isn't possible for the
< <     // numbers of both files to be 0.
< < 
< <     // (In the original algorithm, we only recognized a match, here,
< <     // if there was exactly 1 copy for each file.)
< < 
< <     if (l->copies[0].size () == l->copies[1].size ()) {
< <       nMatchedLines += 1;
< < 
< <       // For each matched line in the new file, mark it with the
< <       // corresponding line (number) in the old file.
< < 
< <       while (!l->copies[0].empty ()) {
< <         unsigned o = l->copies[0].front ();
< <         unsigned n = l->copies[1].front ();
< < 
< <         // Match up the pair.
< < 
< <         lines[0][o].l = n;
< <         lines[1][n].l = o;
< < 
< <         // Remove the matched line numbers from the lists.
< < 
< <         l->copies[0].pop_front ();
< <         l->copies[1].pop_front ();
< <       }
< <     }
< <   }
< <   nTotalMatchedLines += nMatchedLines;
< < 
< <   // Let's see the intermediate results.
< < 
< <   if (0 < optVerbose) {
< <     fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
< < 
< <     if (1 < optVerbose) {
< <       for (int f = 0; f < 2; f += 1) {
< <         fprintf (stderr, "# file #%d\n", f + 1);
< <         for (int l = 0; l < lines[f].size (); l += 1) {
< <           fprintf (stderr, "#   [%d] ", l);
< <           lines[f][l].Dump (stderr);
< <         }
< <       }
< <     }
< <   }
< < 
< <   // Perform Pass #2, in which we attempt to 'widen' blocks of matched
< <   // lines, by appending lines which are the same in both files.
< < 
< <   if (0 < optVerbose) {
< <     fprintf (stderr, "# Pass #2 (spreading matches down)...");
< <   }
< < 
< <   nMatchedBlocks = 0;
< <   nMatchedLines = 0;
< < 
< <   // Starting at the top of the old file,...
< < 
< <   for (unsigned o = 0; o < lines[0].size (); o += 1) {
< < 
< <     // ... skip any currently unmatched lines...
< < 
< <     if (lines[0][o].l == ~0) {
< <       continue;
< <     }
< < 
< <     // ... until we find an [already] matched line.  Then, skip over
< <     // the set of 1 or more matched lines, until we reach any
< <     // following, still-unmatched line.
< < 
< <     unsigned n;
< <     do {
< <       n = lines[0][o].l + 1;
< <       o += 1;
< <     } while (o < lines[0].size () && lines[0][o].l != ~0);
< < 
< <     // Now, o - 1 is the line number of the last matched old line, and
< <     // n - 1 is the line number of the last matched new line.  We want
< <     // to add new old and new lines, if they match.
< < 
< <     // Finally, attempt to add unmatched lines to the preceeding
< <     // matched set.
< < 
< <     for (; o < lines[0].size () && lines[0][o].l == ~0; o += 1, n += 1) {
< < 
< <       // If the [next] pair of old and new lines aren't the same line, we're done.
< < 
< <       if (lines[0][o].line != lines[1][n].line) {
< <         break;
< <       }
< < 
< <       // Match up the pair.
< < 
< <       lines[0][o].l = n;
< <       lines[1][n].l = o;
< < 
< <       // Remove the matched line numbers form the lists.
< < 
< <       Line *line = lines[0][o].line;
< <       list<unsigned> &oldCopies = line->copies[0];
< <       list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
< <       if (oL != oldCopies.end ()) {
< <         oldCopies.erase (oL);
< <       }
< <       list<unsigned> &newCopies = line->copies[0];
< <       list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
< <       if (nL != newCopies.end ()) {
< <         newCopies.erase (nL);
< <       }
< < 
< <       nMatchedLines += 1;
< <     }
< <     nMatchedBlocks += 1;
< <   }
< <   nTotalMatchedLines += nMatchedLines;
< <   nTotalMatchedBlocks += nMatchedBlocks;
< < 
< <   // Let's see the intermediate results.
< < 
< <   if (0 < optVerbose) {
< <     fprintf (stderr,
< <              " found %u/%u matched lines/blocks (%u/%u totals).\n",
< <              nMatchedLines,
< <              nMatchedBlocks,
< <              nTotalMatchedLines,
< <              nTotalMatchedBlocks
< <             );
< <     if (1 < optVerbose) {
< <       for (int f = 0; f < 2; f += 1) {
< <         fprintf (stderr, "# file #%d\n", f + 1);
< <         for (int l = 0; l < lines[f].size (); l += 1) {
< <           fprintf (stderr, "#   [%d] ", l);
< <           lines[f][l].Dump (stderr);
< <         }
< <       }
< <     }
< ---
< >     counts[l->counts[0].size () + l->counts[1].size ()] += 1;
< 283,288c56,57
< < 
< <   // Perform Pass #3, in which we attempt to 'widen' blocks of matched
< <   // lines, by prepending lines which are the same in both files.
< < 
< <   if (0 < optVerbose) {
< <     fprintf (stderr, "# Pass #3 (spreading matches up)...");
< ---
< >   for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
< >     fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
< 290,742c59,62
< < 
< <   nMatchedBlocks = 0;
< <   nMatchedLines = 0;
< < 
< <   // Starting at the bottom of the old file,...
< < 
< <   for (int o = lines[0].size (); 0 <= o; o -= 1) {
< < 
< <     // ... skip any currently unmatched lines...
< < 
< <     if (lines[0][o].l == ~0) {
< <       continue;
< <     }
< < 
< <     // ... until we find an [already] matched line.  Then, skip over
< <     // the set of 1 or more matched lines, until we reach any
< <     // following, still-unmatched line.
< < 
< <     unsigned n;
< <     do {
< <       n = lines[0][o].l - 1;
< <       o -= 1;
< <     } while (0 <= o && lines[0][o].l != ~0);
< < 
< <     // Now, o + 1 is the line number of the last matched old line, and
< <     // n + 1 is the line number of the last matched new line.  We want
< <     // to add new old and new lines, if they match.
< < 
< <     // Finally, attempt to add unmatched lines to the preceeding
< <     // matched set.
< < 
< <     for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
< < 
< <       // If the [next] pair of old and new lines aren't the same line, we're done.
< < 
< <       if (lines[0][o].line != lines[1][n].line) {
< <         break;
< <       }
< < 
< <       // Match up the pair.
< < 
< <       lines[0][o].l = n;
< <       lines[1][n].l = o;
< < 
< <       // Remove the matched line numbers form the lists.
< < 
< <       Line *line = lines[0][o].line;
< <       list<unsigned> &oldCopies = line->copies[0];
< <       list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
< <       if (oL != oldCopies.end ()) {
< <         oldCopies.erase (oL);
< <       }
< <       list<unsigned> &newCopies = line->copies[0];
< <       list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
< <       if (nL != newCopies.end ()) {
< <         newCopies.erase (nL);
< <       }
< < 
< <       nMatchedLines += 1;
< <     }
< <     nMatchedBlocks += 1;
< <   }
< <   nTotalMatchedLines += nMatchedLines;
< < 
< <   // Let's see the intermediate results.
< < 
< <   if (0 < optVerbose) {
< <     fprintf (stderr,
< <              " found %u/%u matched lines/blocks (%u/%u totals).\n",
< <              nMatchedLines,
< <              nMatchedBlocks,
< <              nTotalMatchedLines,
< <              nTotalMatchedBlocks
< <             );
< < 
< <     if (1 < optVerbose) {
< <       for (int f = 0; f < 2; f += 1) {
< <         fprintf (stderr, "# file #%d\n", f + 1);
< <         for (int l = 0; l < lines[f].size (); l += 1) {
< <           fprintf (stderr, "#   [%d] ", l);
< <           lines[f][l].Dump (stderr);
< <         }
< <       }
< <     }
< <   }
< < 
< <   // Perform pass #4, in which we find any remaining matches amongst
< <   // the unique lines.  For every unique line that has more than 1
< <   // copy in both files, we declare the copies to match.
< < 
< <   if (0 < optVerbose) {
< <     fprintf (stderr, "# Pass 4 (finding remaining matches amongst unique lines)...");
< <   }
< < 
< <   nMatchedLines = 0;
< < 
< <   for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
< <     Line *l = i->second;
< < 
< <     // If there's more than 1 matching old and new lines, then we
< <     // declare that each pair are (all) the same line.
< < 
< <     // (In the original algorithm, we only recognized a match, here,
< <     // if there was exactly 1 copy for each file.)
< < 
< <     while (0 < l->copies[0].size () && 0 < l->copies[1].size ()) {
< <       nMatchedLines += 1;
< < 
< <       // For each matched line in the new file, mark it with the
< <       // corresponding line (number) in the old file.
< < 
< <       unsigned o = l->copies[0].front ();
< <       unsigned n = l->copies[1].front ();
< < 
< <       // Match up the pair.
< < 
< <       lines[0][o].l = n;
< <       lines[1][n].l = o;
< < 
< <       // Remove the matched line numbers from the lists.
< < 
< <       l->copies[0].pop_front ();
< <       l->copies[1].pop_front ();
< <     }
< <   }
< <   nTotalMatchedLines += nMatchedLines;
< < 
< <   // Let's see the intermediate results.
< < 
< <   if (0 < optVerbose) {
< <     fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
< < 
< <     if (1 < optVerbose) {
< <       for (int f = 0; f < 2; f += 1) {
< <         fprintf (stderr, "# file #%d\n", f + 1);
< <         for (int l = 0; l < lines[f].size (); l += 1) {
< <           fprintf (stderr, "#   [%d] ", l);
< <           lines[f][l].Dump (stderr);
< <         }
< <       }
< <     }
< <   }
< < 
< <   // Perform Pass #5, in which we look for blocks which match, but are
< <   // the result of a move (their not in their original position).  For
< <   // these, we'll unmatch the blocks, turning them into a delete and
< <   // an insert.
< < 
< <   if (0 < optVerbose) {
< <     fprintf (stderr, "# Pass #5 (unmatching block moves)...\n");
< <   }
< < 
< <   nMatchedBlocks = 0;
< <   nMatchedLines = 0;
< < 
< <   // Starting at the top of both files,...
< < 
< <   unsigned o = 0;
< <   unsigned n = 0;
< < 
< <   while (o < lines[0].size () || n < lines[1].size ()) {
< < 
< <     // Skip any unmatched lines at this point in the old file.  These
< <     // are deletes.
< < 
< <     //    Old     New
< <     //   +---+
< <     // 0 | a |
< <     //   +---+   +---+
< <     //         0 | b |
< <     //   +---+   +---+
< <     // 1 | c | 1 | c |
< <     //   +---+   +---+
< <     //         2 | z |
< <     //   +---+   +---+
< <     // 2 | d | 3 | d |
< <     //   +---+   +---+
< < 
< <     while (o < lines[0].size () && lines[0][o].l == ~0) {
< <       o += 1;
< <     }
< < 
< <     // Skip any unmatched lines at this point in the new file.  These
< <     // are inserts.
< < 
< <     while (n < lines[1].size () && lines[1][n].l == ~0) {
< <       n += 1;
< <     }
< < 
< <     // When we get here, we know that we're dealing with matching
< <     // lines (or the end of one or both files).  We're done with this
< <     // pass, if we've reached the end of either file.
< < 
< <     if (lines[0].size () <= o || lines[1].size () <= n) {
< <       break;
< <     }
< < 
< <     // We now know that we've got a pair of matching lines, the start
< <     // of a matching block.  If the new file's line number is what we
< <     // expect, then the matched pair is unmoved, and we can skip over
< <     // the pair.  (If this is really the start of a block of more than
< <     // 1 lines, we'll handle it one pair at a time.)
< < 
< <     if (lines[0][o].l == n) {
< <       o += 1;
< <       n += 1;
< <       continue;
< <     }
< < 
< <     // If, on the other hand, we don't expect this [new] line number,
< <     // then this matching block has been moved.  We need to turn the
< <     // matched pair into an *unmatched* pair, one of deletes, and one
< <     // of inserts.  First, though, we need to know how big this block
< <     // is, and how far it was moved....
< < 
< <     // Remember where we were when we started.
< < 
< <     unsigned oOld = o;
< <     unsigned nOld = n;
< < 
< <     // Remember where the block came from.
< < 
< <     unsigned nNew = lines[0][o].l;
< < 
< <     // Find the end of this matched pair.
< < 
< <     for (n = nNew; o < lines[0].size () && n < lines[1].size (); o += 1, n += 1) {
< <       if (lines[0][o].l != n) {
< <         break;
< <       }
< <     }
< < 
< <     // When we get here:
< <     // * oOld..o is the old file's block,
< <     // * nNew..n is the new file's *moved* block, and
< <     // * nOld is where we originally expected the new block from.
< <  
< <     // We can now calculate the length of the block...
< <     
< <     unsigned bSize = o - oOld;  // (or n - nNew)
< < 
< <     // ... and we can calculate how far the block moved:
< < 
< <     unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
< < 
< <     // The larger of the two will become our delete, and the smaller
< <     // will become our insert.
< < 
< <     //    Old     New
< <     //   +---+   +---+
< <     // 0 | a | 0 | b |
< <     //   +---+ 1 | b |
< <     // 1 | b |   +---+
< <     // 2 | b | 2 | a |
< <     //   +---+   +---+
< <     // 3 | c | 3 | c |
< <     //   +---+   +---+
< < 
< <     // (1) Delete a@0, insert a@2, or
< <     // (2) insert bb@0, delete bb@1?
< < 
< <     // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and bMove
< <     // (of a) is 2-0 or 2, the size of b@0.  We choose to delete a@0,
< <     // and reinsert a@2.
< < 
< <     // if (bSize <= bMove) {
< <       for (unsigned a = oOld; a < o; a += 1) {
< <         lines[0][a].l = ~0;
< <       }
< <       for (unsigned d = nNew; d < n; d += 1) {
< <         lines[1][d].l = ~0;
< <       }
< <     // } else {
< <       // for (unsigned a = oOld; a < o; a += 1) {
< <       //   lines[0][a].l = ~0;
< <       // }
< <       // for (unsigned d = nNew; d < n; d += 1) {
< <       //   lines[1][d].l = ~0;
< <       // }
< <     // }
< < 
< <     // Continue from where we left off.
< < 
< <     n = nOld;
< <   }
< <   nTotalMatchedLines -= nMatchedLines;
< <   nTotalMatchedBlocks -= nMatchedBlocks;
< < 
< <   // Let's see the intermediate results.
< < 
< <   if (0 < optVerbose) {
< <     fprintf (stderr,
< <              " found %u/%u matched lines/blocks (%u/%u totals).\n",
< <              nMatchedLines,
< <              nMatchedBlocks,
< <              nTotalMatchedLines,
< <              nTotalMatchedBlocks
< <             );
< < 
< <     if (1 < optVerbose) {
< <       for (int f = 0; f < 2; f += 1) {
< <         fprintf (stderr, "# file #%d\n", f + 1);
< <         for (int l = 0; l < lines[f].size (); l += 1) {
< <           fprintf (stderr, "#   [%d] ", l);
< <           lines[f][l].Dump (stderr);
< <         }
< <       }
< <     }
< <   }
< < 
< <   // Perform Pass #6, in which we create the desired output.
< < 
< <   if (0 < optVerbose) {
< <     fprintf (stderr, "# Pass #6 (walking the differences)...\n");
< <   }
< < 
< <   nMatchedLines = 0;
< < 
< <   // Write the header.
< < 
< <   switch (diffFormat) {
< <   case Default:
< <   case Normal:
< <     break;
< <   case Unified:
< <     fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
< <     fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
< <     fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), lines[1].size ());
< <     break;
< <   }
< < 
< <   // Starting at the top of both files,...
< < 
< <   o = 0;
< <   n = 0;
< < 
< <   while (o < lines[0].size () || n < lines[1].size ()) {
< < 
< <     // Find any unmatched lines at this point in the old file.  These
< <     // are deletes.
< < 
< <     unsigned boDeletes;
< <     for (boDeletes = o;
< <          o < lines[0].size () && lines[0][o].l == ~0;
< <          o += 1
< <         )
< <     {}
< < 
< <     // Find any unmatched lines at this point in the new file.  These
< <     // are inserts.
< < 
< <     unsigned boInserts;
< <     for (boInserts = n;
< <          n < lines[1].size () && lines[1][n].l == ~0;
< <          n += 1
< <         )
< <     {}
< < 
< <     // We've got deleted line(s) from boDeletes .. o.
< <     // We've got deleted line(s) from boInserts .. n.
< < 
< <     unsigned nDeletes = o - boDeletes;
< <     unsigned nInserts = n - boInserts;
< < 
< <     // We've got...
< < 
< <     if (nDeletes && nInserts) {
< < 
< <       // ... deletes and inserts.
< < 
< <       switch (diffFormat) {
< <       case Default:
< <       case Normal:
< <         if (1 < nDeletes && 1 < nInserts) {
< <           fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, boInserts + 1, n);
< <         } else if (1 < nDeletes) {
< <           fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boInserts + 1);
< <         } else if (1 < nInserts) {
< <           fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInserts + 1, n);
< <         } 
< <         for (unsigned l = boDeletes; l < o; l += 1) {
< <           fprintf (stdout, "< %s", lines[0][l].line->c_str ());
< <         }
< <         fprintf (stderr, "---\n");
< <         for (unsigned l = boInserts; l < n; l += 1) {
< <           fprintf (stdout, "> %s", lines[1][l].line->c_str ());
< <         }
< <         break;
< < 
< <       case Unified:
< <         for (unsigned l = boDeletes; l < o; l += 1) {
< <           fprintf (stdout, "-%s", lines[0][l].line->c_str ());
< <         }
< <         for (unsigned l = boInserts; l < n; l += 1) {
< <           fprintf (stdout, "+%s", lines[1][l].line->c_str ());
< <         }
< <         break;
< <       }
< <     } else if (nDeletes) {
< < 
< <       //  ... just deletes.
< < 
< <       switch (diffFormat) {
< <       case Default:
< <       case Normal:
< <         if (1 < nDeletes) {
< <           fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
< <         } else {
< <           fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
< <         }
< <         for (unsigned l = boDeletes; l < o; l += 1) {
< <           fprintf (stdout, "< %s", lines[0][l].line->c_str ());
< <         }
< <         break;
< <       case Unified:
< <         for (unsigned l = boDeletes; l < o; l += 1) {
< <           fprintf (stdout, "-%s", lines[0][l].line->c_str ());
< <         }
< <         break;
< <       }
< <     } else if (nInserts) {
< < 
< <       //  ... just inserts.
< < 
< <       switch (diffFormat) {
< <       case Default:
< <       case Normal:
< <         if (1 < nInserts) {
< <           fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
< <         } else {
< <           fprintf (stdout, "%da%d\n", o, boInserts + 1);
< <         }
< <         for (unsigned l = boInserts; l < n; l += 1) {
< <           fprintf (stdout, "> %s", lines[1][l].line->c_str ());
< <         }
< <         break;
< <       case Unified:
< <         for (unsigned l = boInserts; l < n; l += 1) {
< <           fprintf (stdout, "+%s", lines[1][l].line->c_str ());
< <         }
< <         break;
< <       }
< <     }
< < 
< <     // When we get here, we're dealing with matching lines.
< < 
< <     switch (diffFormat) {
< <     case Default:
< <     case Normal:
< <       break;
< <     case Unified:
< <       fprintf (stdout, " %s", lines[0][o].line->c_str ());
< <       break;
< ---
< >   for (int f = 0; f < 2; f += 1) {
< >     fprintf (stderr, "# file #%d\n", f + 1);
< >     for (int l = 0; l < lines[f].size (); l += 1) {
< >       fprintf (stderr, "#   [%d] = %d\n", l, lines[f][l]->counts[f].size ());
< 744,745d63
< <     o += 1;
< <     n += 1;
# ../sdiff --normal dif.3.cpp dif.4.cpp >& dif.3.4.diff--normal.test
# dif.3.4.diff--normal ---------------------------------------------------------
# ../sdiff --normal dif.4.cpp dif.3.cpp >& dif.4.3.diff--normal.test
# dif.4.3.diff--normal ---------------------------------------------------------
# ../sdiff --normal dif.4.cpp dif.5.cpp >& dif.4.5.diff--normal.test
# dif.4.5.diff--normal ---------------------------------------------------------
6c6
< 69c70
---
> 69,73c70
8,10c8
< ---
< > // Our name.
< 71,73c72,84
---
> < 
14a13,17
> > // Our name.
> 75,76c72
> <   MapStringToLinePtr table;
> <   VectorLinePtr lines[2];
> ---
16c19,24
< > 
---
> 78,81c74
> <   unsigned nTotalMatchedBlocks = 0;
> <   unsigned nMatchedBlocks = 0;
> <   unsigned nTotalMatchedLines = 0;
> <   unsigned nMatchedLines = 0;
> ---
18c26,79
< > 
---
> 83,134c76
> <   // Read the old [0] file, and the new [1] file.
> < 
> <   for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
> <     files[n] = argv[a];
> < 
> <     if (FILE *f = fopen (files[n], "r")) {
> <       if (0 < optVerbose) {
> <         fprintf (stderr, "# Reading %s...", files[n]);
> <       }
> < 
> <       char buffer[1024];
> <       unsigned nUniq = 0;
> < 
> <       while (fgets (buffer, sizeof (buffer), f)) {
> <         string text (buffer);
> < 
> <         Line *line = table[text];
> < 
> <         if (!line) {
> <           table[text] = line = new Line (text);
> <           nUniq += 1;
> <         }
> <         line->copies[n].push_back (lines[n].size ());
> <         lines[n].push_back (line);
> <       }
> < 
> <       if (0 < optVerbose) {
> <         fprintf (stderr, " %u lines, %u unique.\n", lines[n].size (), nUniq);
> <       }
> <     } else {
> <       fprintf (stderr, "%s: Unable to open %s!  Exiting....\n", ARGV0, files[n]);
> <       perror (ARGV0);
> <       exit (1);
> <     }
> <   }
> < 
> <   if (0 < optVerbose) {
> <     printf ("# Total unique lines = %d\n", table.size ());
> <   }
> < 
> <   // map<int, int> counts;
> <   // for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> <   //   Line *l = i->second;
> <   //   counts[l->counts[0].size () + l->counts[1].size ()] += 1;
> <   // }
> <   // for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
> <   //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
> <   // }
> < 
> <   // Perform pass #1, in which we find all explicit matches amongst
> <   // the unique lines.  For every unique line that appears the same
> <   // number of times in both files, we declare the lines to match.
> ---
20c81,137
< > 
---
> 136,190c78
> <   if (0 < optVerbose) {
> <     fprintf (stderr, "# Pass 1 (finding matches amongst unique lines)...");
> <   }
> < 
> <   nMatchedLines = 0;
> < 
> <   for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> <     Line *l = i->second;
> < 
> <     // If the number of old and new lines match, then we declare that
> <     // they are (all) the same line.  Note, it isn't possible for the
> <     // numbers of both files to be 0.
> < 
> <     // (In the original algorithm, we only recognized a match, here,
> <     // if there was exactly 1 copy for each file.)
> < 
> <     if (l->copies[0].size () == l->copies[1].size ()) {
> <       nMatchedLines += 1;
> < 
> <       // For each matched line in the new file, mark it with the
> <       // corresponding line (number) in the old file.
> < 
> <       while (!l->copies[0].empty ()) {
> <         unsigned o = l->copies[0].front ();
> <         unsigned n = l->copies[1].front ();
> < 
> <         // Match up the pair.
> < 
> <         lines[0][o].l = n;
> <         lines[1][n].l = o;
> < 
> <         // Remove the matched line numbers from the lists.
> < 
> <         l->copies[0].pop_front ();
> <         l->copies[1].pop_front ();
> <       }
> <     }
> <   }
> <   nTotalMatchedLines += nMatchedLines;
> < 
> <   // Let's see the intermediate results.
> < 
> <   if (0 < optVerbose) {
> <     fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
> < 
> <     if (1 < optVerbose) {
> <       for (int f = 0; f < 2; f += 1) {
> <         fprintf (stderr, "# file #%d\n", f + 1);
> <         for (int l = 0; l < lines[f].size (); l += 1) {
> <           fprintf (stderr, "#   [%d] ", l);
> <           lines[f][l].Dump (stderr);
> <         }
> <       }
> <     }
> <   }
> ---
22c139,142
< > 
---
> 192,193c80
> <   // Perform Pass #2, in which we attempt to 'widen' blocks of matched
> <   // lines, by appending lines which are the same in both files.
> ---
24c144,233
< > 
---
> 195,282c82
> <   if (0 < optVerbose) {
> <     fprintf (stderr, "# Pass #2 (spreading matches down)...");
> <   }
> < 
> <   nMatchedBlocks = 0;
> <   nMatchedLines = 0;
> < 
> <   // Starting at the top of the old file,...
> < 
> <   for (unsigned o = 0; o < lines[0].size (); o += 1) {
> < 
> <     // ... skip any currently unmatched lines...
> < 
> <     if (lines[0][o].l == ~0) {
> <       continue;
> <     }
> < 
> <     // ... until we find an [already] matched line.  Then, skip over
> <     // the set of 1 or more matched lines, until we reach any
> <     // following, still-unmatched line.
> < 
> <     unsigned n;
> <     do {
> <       n = lines[0][o].l + 1;
> <       o += 1;
> <     } while (o < lines[0].size () && lines[0][o].l != ~0);
> < 
> <     // Now, o - 1 is the line number of the last matched old line, and
> <     // n - 1 is the line number of the last matched new line.  We want
> <     // to add new old and new lines, if they match.
> < 
> <     // Finally, attempt to add unmatched lines to the preceeding
> <     // matched set.
> < 
> <     for (; o < lines[0].size () && lines[0][o].l == ~0; o += 1, n += 1) {
> < 
> <       // If the [next] pair of old and new lines aren't the same line, we're done.
> < 
> <       if (lines[0][o].line != lines[1][n].line) {
> <         break;
> <       }
> < 
> <       // Match up the pair.
> < 
> <       lines[0][o].l = n;
> <       lines[1][n].l = o;
> < 
> <       // Remove the matched line numbers form the lists.
> < 
> <       Line *line = lines[0][o].line;
> <       list<unsigned> &oldCopies = line->copies[0];
> <       list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
> <       if (oL != oldCopies.end ()) {
> <         oldCopies.erase (oL);
> <       }
> <       list<unsigned> &newCopies = line->copies[0];
> <       list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
> <       if (nL != newCopies.end ()) {
> <         newCopies.erase (nL);
> <       }
> < 
> <       nMatchedLines += 1;
> <     }
> <     nMatchedBlocks += 1;
> <   }
> <   nTotalMatchedLines += nMatchedLines;
> <   nTotalMatchedBlocks += nMatchedBlocks;
> < 
> <   // Let's see the intermediate results.
> < 
> <   if (0 < optVerbose) {
> <     fprintf (stderr,
> <              " found %u/%u matched lines/blocks (%u/%u totals).\n",
> <              nMatchedLines,
> <              nMatchedBlocks,
> <              nTotalMatchedLines,
> <              nTotalMatchedBlocks
> <             );
> <     if (1 < optVerbose) {
> <       for (int f = 0; f < 2; f += 1) {
> <         fprintf (stderr, "# file #%d\n", f + 1);
> <         for (int l = 0; l < lines[f].size (); l += 1) {
> <           fprintf (stderr, "#   [%d] ", l);
> <           lines[f][l].Dump (stderr);
> <         }
> <       }
> <     }
> <   }
> ---
26c235,238
< > 
---
> 284,285c84
> <   // Perform Pass #3, in which we attempt to 'widen' blocks of matched
> <   // lines, by prepending lines which are the same in both files.
> ---
28,30c240,328
< 75,76c86
< <   MapStringToLinePtr table;
< <   VectorLinePtr lines[2];
---
> 287,374c86
> <   if (0 < optVerbose) {
> <     fprintf (stderr, "# Pass #3 (spreading matches up)...");
> <   }
> < 
> <   nMatchedBlocks = 0;
> <   nMatchedLines = 0;
> < 
> <   // Starting at the bottom of the old file,...
> < 
> <   for (int o = lines[0].size (); 0 <= o; o -= 1) {
> < 
> <     // ... skip any currently unmatched lines...
> < 
> <     if (lines[0][o].l == ~0) {
> <       continue;
> <     }
> < 
> <     // ... until we find an [already] matched line.  Then, skip over
> <     // the set of 1 or more matched lines, until we reach any
> <     // following, still-unmatched line.
> < 
> <     unsigned n;
> <     do {
> <       n = lines[0][o].l - 1;
> <       o -= 1;
> <     } while (0 <= o && lines[0][o].l != ~0);
> < 
> <     // Now, o + 1 is the line number of the last matched old line, and
> <     // n + 1 is the line number of the last matched new line.  We want
> <     // to add new old and new lines, if they match.
> < 
> <     // Finally, attempt to add unmatched lines to the preceeding
> <     // matched set.
> < 
> <     for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
> < 
> <       // If the [next] pair of old and new lines aren't the same line, we're done.
> < 
> <       if (lines[0][o].line != lines[1][n].line) {
> <         break;
> <       }
> < 
> <       // Match up the pair.
> < 
> <       lines[0][o].l = n;
> <       lines[1][n].l = o;
> < 
> <       // Remove the matched line numbers form the lists.
> < 
> <       Line *line = lines[0][o].line;
> <       list<unsigned> &oldCopies = line->copies[0];
> <       list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
> <       if (oL != oldCopies.end ()) {
> <         oldCopies.erase (oL);
> <       }
> <       list<unsigned> &newCopies = line->copies[0];
> <       list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
> <       if (nL != newCopies.end ()) {
> <         newCopies.erase (nL);
> <       }
> < 
> <       nMatchedLines += 1;
> <     }
> <     nMatchedBlocks += 1;
> <   }
> <   nTotalMatchedLines += nMatchedLines;
> < 
> <   // Let's see the intermediate results.
> < 
> <   if (0 < optVerbose) {
> <     fprintf (stderr,
> <              " found %u/%u matched lines/blocks (%u/%u totals).\n",
> <              nMatchedLines,
> <              nMatchedBlocks,
> <              nTotalMatchedLines,
> <              nTotalMatchedBlocks
> <             );
> < 
> <     if (1 < optVerbose) {
> <       for (int f = 0; f < 2; f += 1) {
> <         fprintf (stderr, "# file #%d\n", f + 1);
> <         for (int l = 0; l < lines[f].size (); l += 1) {
> <           fprintf (stderr, "#   [%d] ", l);
> <           lines[f][l].Dump (stderr);
> <         }
> <       }
> <     }
> <   }
33,37c331,334
< 78,81c88,91
< <   unsigned nTotalMatchedBlocks = 0;
< <   unsigned nMatchedBlocks = 0;
< <   unsigned nTotalMatchedLines = 0;
< <   unsigned nMatchedLines = 0;
---
> 376,378c88,91
> <   // Perform pass #4, in which we find any remaining matches amongst
> <   // the unique lines.  For every unique line that has more than 1
> <   // copy in both files, we declare the copies to match.
43c340,393
< 82a93,101
---
> 380,431c93,156
> <   if (0 < optVerbose) {
> <     fprintf (stderr, "# Pass 4 (finding remaining matches amongst unique lines)...");
> <   }
> < 
> <   nMatchedLines = 0;
> < 
> <   for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> <     Line *l = i->second;
> < 
> <     // If there's more than 1 matching old and new lines, then we
> <     // declare that each pair are (all) the same line.
> < 
> <     // (In the original algorithm, we only recognized a match, here,
> <     // if there was exactly 1 copy for each file.)
> < 
> <     while (0 < l->copies[0].size () && 0 < l->copies[1].size ()) {
> <       nMatchedLines += 1;
> < 
> <       // For each matched line in the new file, mark it with the
> <       // corresponding line (number) in the old file.
> < 
> <       unsigned o = l->copies[0].front ();
> <       unsigned n = l->copies[1].front ();
> < 
> <       // Match up the pair.
> < 
> <       lines[0][o].l = n;
> <       lines[1][n].l = o;
> < 
> <       // Remove the matched line numbers from the lists.
> < 
> <       l->copies[0].pop_front ();
> <       l->copies[1].pop_front ();
> <     }
> <   }
> <   nTotalMatchedLines += nMatchedLines;
> < 
> <   // Let's see the intermediate results.
> < 
> <   if (0 < optVerbose) {
> <     fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
> < 
> <     if (1 < optVerbose) {
> <       for (int f = 0; f < 2; f += 1) {
> <         fprintf (stderr, "# file #%d\n", f + 1);
> <         for (int l = 0; l < lines[f].size (); l += 1) {
> <           fprintf (stderr, "#   [%d] ", l);
> <           lines[f][l].Dump (stderr);
> <         }
> <       }
> <     }
> <   }
> ---
53,55c403,439
< 120c139
< <     printf ("# Total unique lines = %d\n", table.size ());
< ---
---
> >   // Read the old [0] file, and the new [1] file.
> > 
> >   for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
> >     files[n] = argv[a];
> > 
> >     if (FILE *f = fopen (files[n], "r")) {
> >       if (0 < optVerbose) {
> >         fprintf (stderr, "# Reading %s...", files[n]);
> >       }
> > 
> >       char buffer[1024];
> >       unsigned nUniq = 0;
> > 
> >       while (fgets (buffer, sizeof (buffer), f)) {
> >         string text (buffer);
> > 
> >         Line *line = table[text];
> > 
> >         if (!line) {
> >           table[text] = line = new Line (text);
> >           nUniq += 1;
> >         }
> >         line->copies[n].push_back (lines[n].size ());
> >         lines[n].push_back (line);
> >       }
> > 
> >       if (0 < optVerbose) {
> >         fprintf (stderr, " %u lines, %u unique.\n", lines[n].size (), nUniq);
> >       }
> >     } else {
> >       fprintf (stderr, "%s: Unable to open %s!  Exiting....\n", ARGV0, files[n]);
> >       perror (ARGV0);
> >       exit (1);
> >     }
> >   }
> > 
> >   if (0 < optVerbose) {
57,61c441,451
< 132,134c151,156
< <   // Perform pass #1, in which we find all explicit matches amongst
< <   // the unique lines.  For every unique line that appears the same
< <   // number of times in both files, we declare the lines to match.
< ---
---
> >   }
> > 
> >   // map<int, int> counts;
> >   // for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> >   //   Line *l = i->second;
> >   //   counts[l->counts[0].size () + l->counts[1].size ()] += 1;
> >   // }
> >   // for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
> >   //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
> >   // }
> > 
68c458,463
< 135a158,166
---
> 433,436c158,159
> <   // Perform Pass #5, in which we look for blocks which match, but are
> <   // the result of a move (their not in their original position).  For
> <   // these, we'll unmatch the blocks, turning them into a delete and
> <   // an insert.
> ---
71c466,628
< > 
---
> 438,598c161,163
> <   if (0 < optVerbose) {
> <     fprintf (stderr, "# Pass #5 (unmatching block moves)...\n");
> <   }
> < 
> <   nMatchedBlocks = 0;
> <   nMatchedLines = 0;
> < 
> <   // Starting at the top of both files,...
> < 
> <   unsigned o = 0;
> <   unsigned n = 0;
> < 
> <   while (o < lines[0].size () || n < lines[1].size ()) {
> < 
> <     // Skip any unmatched lines at this point in the old file.  These
> <     // are deletes.
> < 
> <     //    Old     New
> <     //   +---+
> <     // 0 | a |
> <     //   +---+   +---+
> <     //         0 | b |
> <     //   +---+   +---+
> <     // 1 | c | 1 | c |
> <     //   +---+   +---+
> <     //         2 | z |
> <     //   +---+   +---+
> <     // 2 | d | 3 | d |
> <     //   +---+   +---+
> < 
> <     while (o < lines[0].size () && lines[0][o].l == ~0) {
> <       o += 1;
> <     }
> < 
> <     // Skip any unmatched lines at this point in the new file.  These
> <     // are inserts.
> < 
> <     while (n < lines[1].size () && lines[1][n].l == ~0) {
> <       n += 1;
> <     }
> < 
> <     // When we get here, we know that we're dealing with matching
> <     // lines (or the end of one or both files).  We're done with this
> <     // pass, if we've reached the end of either file.
> < 
> <     if (lines[0].size () <= o || lines[1].size () <= n) {
> <       break;
> <     }
> < 
> <     // We now know that we've got a pair of matching lines, the start
> <     // of a matching block.  If the new file's line number is what we
> <     // expect, then the matched pair is unmoved, and we can skip over
> <     // the pair.  (If this is really the start of a block of more than
> <     // 1 lines, we'll handle it one pair at a time.)
> < 
> <     if (lines[0][o].l == n) {
> <       o += 1;
> <       n += 1;
> <       continue;
> <     }
> < 
> <     // If, on the other hand, we don't expect this [new] line number,
> <     // then this matching block has been moved.  We need to turn the
> <     // matched pair into an *unmatched* pair, one of deletes, and one
> <     // of inserts.  First, though, we need to know how big this block
> <     // is, and how far it was moved....
> < 
> <     // Remember where we were when we started.
> < 
> <     unsigned oOld = o;
> <     unsigned nOld = n;
> < 
> <     // Remember where the block came from.
> < 
> <     unsigned nNew = lines[0][o].l;
> < 
> <     // Find the end of this matched pair.
> < 
> <     for (n = nNew; o < lines[0].size () && n < lines[1].size (); o += 1, n += 1) {
> <       if (lines[0][o].l != n) {
> <         break;
> <       }
> <     }
> < 
> <     // When we get here:
> <     // * oOld..o is the old file's block,
> <     // * nNew..n is the new file's *moved* block, and
> <     // * nOld is where we originally expected the new block from.
> <  
> <     // We can now calculate the length of the block...
> <     
> <     unsigned bSize = o - oOld;  // (or n - nNew)
> < 
> <     // ... and we can calculate how far the block moved:
> < 
> <     unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
> < 
> <     // The larger of the two will become our delete, and the smaller
> <     // will become our insert.
> < 
> <     //    Old     New
> <     //   +---+   +---+
> <     // 0 | a | 0 | b |
> <     //   +---+ 1 | b |
> <     // 1 | b |   +---+
> <     // 2 | b | 2 | a |
> <     //   +---+   +---+
> <     // 3 | c | 3 | c |
> <     //   +---+   +---+
> < 
> <     // (1) Delete a@0, insert a@2, or
> <     // (2) insert bb@0, delete bb@1?
> < 
> <     // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and bMove
> <     // (of a) is 2-0 or 2, the size of b@0.  We choose to delete a@0,
> <     // and reinsert a@2.
> < 
> <     // if (bSize <= bMove) {
> <       for (unsigned a = oOld; a < o; a += 1) {
> <         lines[0][a].l = ~0;
> <       }
> <       for (unsigned d = nNew; d < n; d += 1) {
> <         lines[1][d].l = ~0;
> <       }
> <     // } else {
> <       // for (unsigned a = oOld; a < o; a += 1) {
> <       //   lines[0][a].l = ~0;
> <       // }
> <       // for (unsigned d = nNew; d < n; d += 1) {
> <       //   lines[1][d].l = ~0;
> <       // }
> <     // }
> < 
> <     // Continue from where we left off.
> < 
> <     n = nOld;
> <   }
> <   nTotalMatchedLines -= nMatchedLines;
> <   nTotalMatchedBlocks -= nMatchedBlocks;
> < 
> <   // Let's see the intermediate results.
> < 
> <   if (0 < optVerbose) {
> <     fprintf (stderr,
> <              " found %u/%u matched lines/blocks (%u/%u totals).\n",
> <              nMatchedLines,
> <              nMatchedBlocks,
> <              nTotalMatchedLines,
> <              nTotalMatchedBlocks
> <             );
> < 
> <     if (1 < optVerbose) {
> <       for (int f = 0; f < 2; f += 1) {
> <         fprintf (stderr, "# file #%d\n", f + 1);
> <         for (int l = 0; l < lines[f].size (); l += 1) {
> <           fprintf (stderr, "#   [%d] ", l);
> <           lines[f][l].Dump (stderr);
> <         }
> <       }
> <     }
> <   }
> ---
75c632,634
< > 
---
> 600c165,222
> <   // Perform Pass #6, in which we create the desired output.
> ---
78c637,691
< 190a222
---
> >   if (0 < optVerbose) {
> >     fprintf (stderr, "# Pass 1 (finding matches amongst unique lines)...");
> >   }
> > 
> >   nMatchedLines = 0;
> > 
> >   for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> >     Line *l = i->second;
> > 
> >     // If the number of old and new lines match, then we declare that
> >     // they are (all) the same line.  Note, it isn't possible for the
> >     // numbers of both files to be 0.
> > 
> >     // (In the original algorithm, we only recognized a match, here,
> >     // if there was exactly 1 copy for each file.)
> > 
> >     if (l->copies[0].size () == l->copies[1].size ()) {
> >       nMatchedLines += 1;
> > 
> >       // For each matched line in the new file, mark it with the
> >       // corresponding line (number) in the old file.
> > 
> >       while (!l->copies[0].empty ()) {
> >         unsigned o = l->copies[0].front ();
> >         unsigned n = l->copies[1].front ();
> > 
> >         // Match up the pair.
> > 
> >         lines[0][o].l = n;
> >         lines[1][n].l = o;
> > 
> >         // Remove the matched line numbers from the lists.
> > 
> >         l->copies[0].pop_front ();
> >         l->copies[1].pop_front ();
> >       }
> >     }
> >   }
> >   nTotalMatchedLines += nMatchedLines;
> > 
> >   // Let's see the intermediate results.
> > 
> >   if (0 < optVerbose) {
> >     fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
> > 
> >     if (1 < optVerbose) {
> >       for (int f = 0; f < 2; f += 1) {
> >         fprintf (stderr, "# file #%d\n", f + 1);
> >         for (int l = 0; l < lines[f].size (); l += 1) {
> >           fprintf (stderr, "#   [%d] ", l);
> >           lines[f][l].Dump (stderr);
> >         }
> >       }
> >     }
> >   }
80,82c693,696
< 192,193c224,225
< <   // Perform Pass #2, in which we attempt to 'widen' blocks of matched
< <   // lines, by appending lines which are the same in both files.
---
> 602,604c224,225
> <   if (0 < optVerbose) {
> <     fprintf (stderr, "# Pass #6 (walking the differences)...\n");
> <   }
86c700,702
< 194a227,228
---
> 606c227,317
> <   nMatchedLines = 0;
> ---
89c705,792
< 282a317
---
> >   if (0 < optVerbose) {
> >     fprintf (stderr, "# Pass #2 (spreading matches down)...");
> >   }
> > 
> >   nMatchedBlocks = 0;
> >   nMatchedLines = 0;
> > 
> >   // Starting at the top of the old file,...
> > 
> >   for (unsigned o = 0; o < lines[0].size (); o += 1) {
> > 
> >     // ... skip any currently unmatched lines...
> > 
> >     if (lines[0][o].l == ~0) {
> >       continue;
> >     }
> > 
> >     // ... until we find an [already] matched line.  Then, skip over
> >     // the set of 1 or more matched lines, until we reach any
> >     // following, still-unmatched line.
> > 
> >     unsigned n;
> >     do {
> >       n = lines[0][o].l + 1;
> >       o += 1;
> >     } while (o < lines[0].size () && lines[0][o].l != ~0);
> > 
> >     // Now, o - 1 is the line number of the last matched old line, and
> >     // n - 1 is the line number of the last matched new line.  We want
> >     // to add new old and new lines, if they match.
> > 
> >     // Finally, attempt to add unmatched lines to the preceeding
> >     // matched set.
> > 
> >     for (; o < lines[0].size () && lines[0][o].l == ~0; o += 1, n += 1) {
> > 
> >       // If the [next] pair of old and new lines aren't the same line, we're done.
> > 
> >       if (lines[0][o].line != lines[1][n].line) {
> >         break;
> >       }
> > 
> >       // Match up the pair.
> > 
> >       lines[0][o].l = n;
> >       lines[1][n].l = o;
> > 
> >       // Remove the matched line numbers form the lists.
> > 
> >       Line *line = lines[0][o].line;
> >       list<unsigned> &oldCopies = line->copies[0];
> >       list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
> >       if (oL != oldCopies.end ()) {
> >         oldCopies.erase (oL);
> >       }
> >       list<unsigned> &newCopies = line->copies[0];
> >       list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
> >       if (nL != newCopies.end ()) {
> >         newCopies.erase (nL);
> >       }
> > 
> >       nMatchedLines += 1;
> >     }
> >     nMatchedBlocks += 1;
> >   }
> >   nTotalMatchedLines += nMatchedLines;
> >   nTotalMatchedBlocks += nMatchedBlocks;
> > 
> >   // Let's see the intermediate results.
> > 
> >   if (0 < optVerbose) {
> >     fprintf (stderr,
> >              " found %u/%u matched lines/blocks (%u/%u totals).\n",
> >              nMatchedLines,
> >              nMatchedBlocks,
> >              nTotalMatchedLines,
> >              nTotalMatchedBlocks
> >             );
> >     if (1 < optVerbose) {
> >       for (int f = 0; f < 2; f += 1) {
> >         fprintf (stderr, "# file #%d\n", f + 1);
> >         for (int l = 0; l < lines[f].size (); l += 1) {
> >           fprintf (stderr, "#   [%d] ", l);
> >           lines[f][l].Dump (stderr);
> >         }
> >       }
> >     }
> >   }
91,93c794,806
< 284,285c319,320
< <   // Perform Pass #3, in which we attempt to 'widen' blocks of matched
< <   // lines, by prepending lines which are the same in both files.
---
> 608,619c319,320
> <   // Write the header.
> < 
> <   switch (diffFormat) {
> <   case Default:
> <   case Normal:
> <     break;
> <   case Unified:
> <     fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
> <     fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
> <     fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), lines[1].size ());
> <     break;
> <   }
97c810,812
< 286a322,323
---
> 621c322,412
> <   // Starting at the top of both files,...
> ---
100c815,902
< 374a412
---
> >   if (0 < optVerbose) {
> >     fprintf (stderr, "# Pass #3 (spreading matches up)...");
> >   }
> > 
> >   nMatchedBlocks = 0;
> >   nMatchedLines = 0;
> > 
> >   // Starting at the bottom of the old file,...
> > 
> >   for (int o = lines[0].size (); 0 <= o; o -= 1) {
> > 
> >     // ... skip any currently unmatched lines...
> > 
> >     if (lines[0][o].l == ~0) {
> >       continue;
> >     }
> > 
> >     // ... until we find an [already] matched line.  Then, skip over
> >     // the set of 1 or more matched lines, until we reach any
> >     // following, still-unmatched line.
> > 
> >     unsigned n;
> >     do {
> >       n = lines[0][o].l - 1;
> >       o -= 1;
> >     } while (0 <= o && lines[0][o].l != ~0);
> > 
> >     // Now, o + 1 is the line number of the last matched old line, and
> >     // n + 1 is the line number of the last matched new line.  We want
> >     // to add new old and new lines, if they match.
> > 
> >     // Finally, attempt to add unmatched lines to the preceeding
> >     // matched set.
> > 
> >     for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
> > 
> >       // If the [next] pair of old and new lines aren't the same line, we're done.
> > 
> >       if (lines[0][o].line != lines[1][n].line) {
> >         break;
> >       }
> > 
> >       // Match up the pair.
> > 
> >       lines[0][o].l = n;
> >       lines[1][n].l = o;
> > 
> >       // Remove the matched line numbers form the lists.
> > 
> >       Line *line = lines[0][o].line;
> >       list<unsigned> &oldCopies = line->copies[0];
> >       list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
> >       if (oL != oldCopies.end ()) {
> >         oldCopies.erase (oL);
> >       }
> >       list<unsigned> &newCopies = line->copies[0];
> >       list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
> >       if (nL != newCopies.end ()) {
> >         newCopies.erase (nL);
> >       }
> > 
> >       nMatchedLines += 1;
> >     }
> >     nMatchedBlocks += 1;
> >   }
> >   nTotalMatchedLines += nMatchedLines;
> > 
> >   // Let's see the intermediate results.
> > 
> >   if (0 < optVerbose) {
> >     fprintf (stderr,
> >              " found %u/%u matched lines/blocks (%u/%u totals).\n",
> >              nMatchedLines,
> >              nMatchedBlocks,
> >              nTotalMatchedLines,
> >              nTotalMatchedBlocks
> >             );
> > 
> >     if (1 < optVerbose) {
> >       for (int f = 0; f < 2; f += 1) {
> >         fprintf (stderr, "# file #%d\n", f + 1);
> >         for (int l = 0; l < lines[f].size (); l += 1) {
> >           fprintf (stderr, "#   [%d] ", l);
> >           lines[f][l].Dump (stderr);
> >         }
> >       }
> >     }
> >   }
102,105c904,906
< 376,378c414,416
< <   // Perform pass #4, in which we find any remaining matches amongst
< <   // the unique lines.  For every unique line that has more than 1
< <   // copy in both files, we declare the copies to match.
---
> 623,624c414,416
> <   o = 0;
> <   n = 0;
110c911,913
< 379a418,419
---
> 626c418,472
> <   while (o < lines[0].size () || n < lines[1].size ()) {
> ---
113c916,967
< 431a472
---
> >   if (0 < optVerbose) {
> >     fprintf (stderr, "# Pass 4 (finding remaining matches amongst unique lines)...");
> >   }
> > 
> >   nMatchedLines = 0;
> > 
> >   for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> >     Line *l = i->second;
> > 
> >     // If there's more than 1 matching old and new lines, then we
> >     // declare that each pair are (all) the same line.
> > 
> >     // (In the original algorithm, we only recognized a match, here,
> >     // if there was exactly 1 copy for each file.)
> > 
> >     while (0 < l->copies[0].size () && 0 < l->copies[1].size ()) {
> >       nMatchedLines += 1;
> > 
> >       // For each matched line in the new file, mark it with the
> >       // corresponding line (number) in the old file.
> > 
> >       unsigned o = l->copies[0].front ();
> >       unsigned n = l->copies[1].front ();
> > 
> >       // Match up the pair.
> > 
> >       lines[0][o].l = n;
> >       lines[1][n].l = o;
> > 
> >       // Remove the matched line numbers from the lists.
> > 
> >       l->copies[0].pop_front ();
> >       l->copies[1].pop_front ();
> >     }
> >   }
> >   nTotalMatchedLines += nMatchedLines;
> > 
> >   // Let's see the intermediate results.
> > 
> >   if (0 < optVerbose) {
> >     fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
> > 
> >     if (1 < optVerbose) {
> >       for (int f = 0; f < 2; f += 1) {
> >         fprintf (stderr, "# file #%d\n", f + 1);
> >         for (int l = 0; l < lines[f].size (); l += 1) {
> >           fprintf (stderr, "#   [%d] ", l);
> >           lines[f][l].Dump (stderr);
> >         }
> >       }
> >     }
> >   }
115,119c969,971
< 433,436c474,477
< <   // Perform Pass #5, in which we look for blocks which match, but are
< <   // the result of a move (their not in their original position).  For
< <   // these, we'll unmatch the blocks, turning them into a delete and
< <   // an insert.
---
> 628,629c474,477
> <     // Find any unmatched lines at this point in the old file.  These
> <     // are deletes.
125c977,984
< 437a479,480
---
> 631,636c479,642
> <     unsigned boDeletes;
> <     for (boDeletes = o;
> <          o < lines[0].size () && lines[0][o].l == ~0;
> <          o += 1
> <         )
> <     {}
> ---
128c987,1147
< 598a642
---
> >   if (0 < optVerbose) {
> >     fprintf (stderr, "# Pass #5 (unmatching block moves)...\n");
> >   }
> > 
> >   nMatchedBlocks = 0;
> >   nMatchedLines = 0;
> > 
> >   // Starting at the top of both files,...
> > 
> >   unsigned o = 0;
> >   unsigned n = 0;
> > 
> >   while (o < lines[0].size () || n < lines[1].size ()) {
> > 
> >     // Skip any unmatched lines at this point in the old file.  These
> >     // are deletes.
> > 
> >     //    Old     New
> >     //   +---+
> >     // 0 | a |
> >     //   +---+   +---+
> >     //         0 | b |
> >     //   +---+   +---+
> >     // 1 | c | 1 | c |
> >     //   +---+   +---+
> >     //         2 | z |
> >     //   +---+   +---+
> >     // 2 | d | 3 | d |
> >     //   +---+   +---+
> > 
> >     while (o < lines[0].size () && lines[0][o].l == ~0) {
> >       o += 1;
> >     }
> > 
> >     // Skip any unmatched lines at this point in the new file.  These
> >     // are inserts.
> > 
> >     while (n < lines[1].size () && lines[1][n].l == ~0) {
> >       n += 1;
> >     }
> > 
> >     // When we get here, we know that we're dealing with matching
> >     // lines (or the end of one or both files).  We're done with this
> >     // pass, if we've reached the end of either file.
> > 
> >     if (lines[0].size () <= o || lines[1].size () <= n) {
> >       break;
> >     }
> > 
> >     // We now know that we've got a pair of matching lines, the start
> >     // of a matching block.  If the new file's line number is what we
> >     // expect, then the matched pair is unmoved, and we can skip over
> >     // the pair.  (If this is really the start of a block of more than
> >     // 1 lines, we'll handle it one pair at a time.)
> > 
> >     if (lines[0][o].l == n) {
> >       o += 1;
> >       n += 1;
> >       continue;
> >     }
> > 
> >     // If, on the other hand, we don't expect this [new] line number,
> >     // then this matching block has been moved.  We need to turn the
> >     // matched pair into an *unmatched* pair, one of deletes, and one
> >     // of inserts.  First, though, we need to know how big this block
> >     // is, and how far it was moved....
> > 
> >     // Remember where we were when we started.
> > 
> >     unsigned oOld = o;
> >     unsigned nOld = n;
> > 
> >     // Remember where the block came from.
> > 
> >     unsigned nNew = lines[0][o].l;
> > 
> >     // Find the end of this matched pair.
> > 
> >     for (n = nNew; o < lines[0].size () && n < lines[1].size (); o += 1, n += 1) {
> >       if (lines[0][o].l != n) {
> >         break;
> >       }
> >     }
> > 
> >     // When we get here:
> >     // * oOld..o is the old file's block,
> >     // * nNew..n is the new file's *moved* block, and
> >     // * nOld is where we originally expected the new block from.
> >  
> >     // We can now calculate the length of the block...
> >     
> >     unsigned bSize = o - oOld;  // (or n - nNew)
> > 
> >     // ... and we can calculate how far the block moved:
> > 
> >     unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
> > 
> >     // The larger of the two will become our delete, and the smaller
> >     // will become our insert.
> > 
> >     //    Old     New
> >     //   +---+   +---+
> >     // 0 | a | 0 | b |
> >     //   +---+ 1 | b |
> >     // 1 | b |   +---+
> >     // 2 | b | 2 | a |
> >     //   +---+   +---+
> >     // 3 | c | 3 | c |
> >     //   +---+   +---+
> > 
> >     // (1) Delete a@0, insert a@2, or
> >     // (2) insert bb@0, delete bb@1?
> > 
> >     // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and bMove
> >     // (of a) is 2-0 or 2, the size of b@0.  We choose to delete a@0,
> >     // and reinsert a@2.
> > 
> >     // if (bSize <= bMove) {
> >       for (unsigned a = oOld; a < o; a += 1) {
> >         lines[0][a].l = ~0;
> >       }
> >       for (unsigned d = nNew; d < n; d += 1) {
> >         lines[1][d].l = ~0;
> >       }
> >     // } else {
> >       // for (unsigned a = oOld; a < o; a += 1) {
> >       //   lines[0][a].l = ~0;
> >       // }
> >       // for (unsigned d = nNew; d < n; d += 1) {
> >       //   lines[1][d].l = ~0;
> >       // }
> >     // }
> > 
> >     // Continue from where we left off.
> > 
> >     n = nOld;
> >   }
> >   nTotalMatchedLines -= nMatchedLines;
> >   nTotalMatchedBlocks -= nMatchedBlocks;
> > 
> >   // Let's see the intermediate results.
> > 
> >   if (0 < optVerbose) {
> >     fprintf (stderr,
> >              " found %u/%u matched lines/blocks (%u/%u totals).\n",
> >              nMatchedLines,
> >              nMatchedBlocks,
> >              nTotalMatchedLines,
> >              nTotalMatchedBlocks
> >             );
> > 
> >     if (1 < optVerbose) {
> >       for (int f = 0; f < 2; f += 1) {
> >         fprintf (stderr, "# file #%d\n", f + 1);
> >         for (int l = 0; l < lines[f].size (); l += 1) {
> >           fprintf (stderr, "#   [%d] ", l);
> >           lines[f][l].Dump (stderr);
> >         }
> >       }
> >     }
> >   }
130,131c1149,1151
< 600c644
< <   // Perform Pass #6, in which we create the desired output.
---
> 638,639c644
> <     // Find any unmatched lines at this point in the new file.  These
> <     // are inserts.
134,137c1154,1160
< 602,604c646,652
< <   if (0 < optVerbose) {
< <     fprintf (stderr, "# Pass #6 (walking the differences)...\n");
< <   }
---
> 641,646c646,652
> <     unsigned boInserts;
> <     for (boInserts = n;
> <          n < lines[1].size () && lines[1][n].l == ~0;
> <          n += 1
> <         )
> <     {}
146,149c1169,1171
< 606,608c654,655
< <   nMatchedLines = 0;
< < 
< <   // Write the header.
---
> 648,649c654,660
> <     // We've got deleted line(s) from boDeletes .. o.
> <     // We've got deleted line(s) from boInserts .. n.
153,155c1175,1176
< 611c658,669
< <   case Default:
< ---
---
> > 
> >   switch (diffFormat) {
159c1180,1183
< > 
---
> 651,652c662,664
> <     unsigned nDeletes = o - boDeletes;
> <     unsigned nInserts = n - boInserts;
> ---
163c1187,1189
< > 
---
> 654c666,668
> <     // We've got...
> ---
167,168c1193,1196
< > 
< 612a671
---
> 656c670,672
> <     if (nDeletes && nInserts) {
> ---
> >   case Normal:
170,171c1198,1201
< 613a673,681
< > 
---
> >     break;
> 658c674,676
> <       // ... deletes and inserts.
> ---
175c1205,1224
< > 
---
> 660,677c678,680
> <       switch (diffFormat) {
> <       case Default:
> <       case Normal:
> <         if (1 < nDeletes && 1 < nInserts) {
> <           fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, boInserts + 1, n);
> <         } else if (1 < nDeletes) {
> <           fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boInserts + 1);
> <         } else if (1 < nInserts) {
> <           fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInserts + 1, n);
> <         } 
> <         for (unsigned l = boDeletes; l < o; l += 1) {
> <           fprintf (stdout, "< %s", lines[0][l].line->c_str ());
> <         }
> <         fprintf (stderr, "---\n");
> <         for (unsigned l = boInserts; l < n; l += 1) {
> <           fprintf (stdout, "> %s", lines[1][l].line->c_str ());
> <         }
> <         break;
> ---
179,183c1228,1238
< > 
< 615,617c683,688
< <     fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
< <     fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
< <     fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), lines[1].size ());
---
> 679,688c682,684
> <       case Unified:
> <         for (unsigned l = boDeletes; l < o; l += 1) {
> <           fprintf (stdout, "-%s", lines[0][l].line->c_str ());
> <         }
> <         for (unsigned l = boInserts; l < n; l += 1) {
> <           fprintf (stdout, "+%s", lines[1][l].line->c_str ());
> <         }
> <         break;
> <       }
> <     } else if (nDeletes) {
184a1240
> >   case Unified:
187c1243,1245
< > 
---
> 690c686,691
> <       //  ... just deletes.
> ---
191c1249,1250
< 619a691,717
---
> >     break;
> >   }
193c1252,1272
< > 
---
> 692,710c693,698
> <       switch (diffFormat) {
> <       case Default:
> <       case Normal:
> <         if (1 < nDeletes) {
> <           fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
> <         } else {
> <           fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
> <         }
> <         for (unsigned l = boDeletes; l < o; l += 1) {
> <           fprintf (stdout, "< %s", lines[0][l].line->c_str ());
> <         }
> <         break;
> <       case Unified:
> <         for (unsigned l = boDeletes; l < o; l += 1) {
> <           fprintf (stdout, "-%s", lines[0][l].line->c_str ());
> <         }
> <         break;
> <       }
> <     } else if (nInserts) {
> ---
200c1279,1281
< > 
---
> 712c700,705
> <       //  ... just inserts.
> ---
207c1288,1308
< > 
---
> 714,732c707,710
> <       switch (diffFormat) {
> <       case Default:
> <       case Normal:
> <         if (1 < nInserts) {
> <           fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
> <         } else {
> <           fprintf (stdout, "%da%d\n", o, boInserts + 1);
> <         }
> <         for (unsigned l = boInserts; l < n; l += 1) {
> <           fprintf (stdout, "> %s", lines[1][l].line->c_str ());
> <         }
> <         break;
> <       case Unified:
> <         for (unsigned l = boInserts; l < n; l += 1) {
> <           fprintf (stdout, "+%s", lines[1][l].line->c_str ());
> <         }
> <         break;
> <       }
> <     }
> ---
212c1313,1314
< > 
---
> <     // When we get here, we're dealing with matching lines.
> ---
214c1316,1324
< > 
---
> 736,742c714,914
> <     switch (diffFormat) {
> <     case Default:
> <     case Normal:
> <       break;
> <     case Unified:
> <       fprintf (stdout, " %s", lines[0][o].line->c_str ());
> <       break;
> ---
219,222c1329,1331
< 623,624c721,722
< <   o = 0;
< <   n = 0;
< ---
---
> > 
> >   // Starting at the top of both files,...
> > 
225,227c1334,1362
< 654c752
< <     // We've got...
< ---
---
> > 
> >   while (o < lines[0].size () || n < lines[1].size ()) {
> > 
> >     // Find any unmatched lines at this point in the old file.  These
> >     // are deletes.
> > 
> >     unsigned boDeletes;
> >     for (boDeletes = o;
> >          o < lines[0].size () && lines[0][o].l == ~0;
> >          o += 1
> >         )
> >     {}
> > 
> >     // Find any unmatched lines at this point in the new file.  These
> >     // are inserts.
> > 
> >     unsigned boInserts;
> >     for (boInserts = n;
> >          n < lines[1].size () && lines[1][n].l == ~0;
> >          n += 1
> >         )
> >     {}
> > 
> >     // We've got deleted line(s) from boDeletes .. o.
> >     // We've got deleted line(s) from boInserts .. n.
> > 
> >     unsigned nDeletes = o - boDeletes;
> >     unsigned nInserts = n - boInserts;
> > 
229,231c1364
< 656c754,756
< <     if (nDeletes && nInserts) {
< ---
---
> > 
235,237c1368
< 658c758,770
< <       // ... deletes and inserts.
< ---
---
> > 
251,268c1382,1383
< 660,669d771
< <       switch (diffFormat) {
< <       case Default:
< <       case Normal:
< <         if (1 < nDeletes && 1 < nInserts) {
< <           fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, boInserts + 1, n);
< <         } else if (1 < nDeletes) {
< <           fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boInserts + 1);
< <         } else if (1 < nInserts) {
< <           fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInserts + 1, n);
< <         } 
< 671,675c773
< <           fprintf (stdout, "< %s", lines[0][l].line->c_str ());
< <         }
< <         fprintf (stderr, "---\n");
< <         for (unsigned l = boInserts; l < n; l += 1) {
< <           fprintf (stdout, "> %s", lines[1][l].line->c_str ());
< ---
---
> > 
> >         for (unsigned l = boDeletes; l < o; l += 1) {
270,272c1385
< 677c775,777
< <         break;
< ---
---
> >         }
276,280c1389,1390
< 679d778
< <       case Unified:
< 681c780,799
< <           fprintf (stdout, "-%s", lines[0][l].line->c_str ());
< ---
---
> > 
> >         for (unsigned l = boDeletes; l < o; l += 1) {
301c1411
< 682a801,804
---
> >         }
306,308c1416
< 684c806
< <           fprintf (stdout, "+%s", lines[1][l].line->c_str ());
< ---
---
> >         for (unsigned l = boInserts; l < n; l += 1) {
310,312c1418
< 686c808,889
< <         break;
< ---
---
> >         }
395,413c1501,1505
< 692,708c895,901
< <       switch (diffFormat) {
< <       case Default:
< <       case Normal:
< <         if (1 < nDeletes) {
< <           fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
< <         } else {
< <           fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
< <         }
< <         for (unsigned l = boDeletes; l < o; l += 1) {
< <           fprintf (stdout, "< %s", lines[0][l].line->c_str ());
< <         }
< <         break;
< <       case Unified:
< <         for (unsigned l = boDeletes; l < o; l += 1) {
< <           fprintf (stdout, "-%s", lines[0][l].line->c_str ());
< <         }
< <         break;
< ---
---
> >       }
> >     } else if (nDeletes) {
> > 
> >       //  ... just deletes.
> > 
421,439c1513,1517
< 714,730c907,913
< <       switch (diffFormat) {
< <       case Default:
< <       case Normal:
< <         if (1 < nInserts) {
< <           fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
< <         } else {
< <           fprintf (stdout, "%da%d\n", o, boInserts + 1);
< <         }
< <         for (unsigned l = boInserts; l < n; l += 1) {
< <           fprintf (stdout, "> %s", lines[1][l].line->c_str ());
< <         }
< <         break;
< <       case Unified:
< <         for (unsigned l = boInserts; l < n; l += 1) {
< <           fprintf (stdout, "+%s", lines[1][l].line->c_str ());
< <         }
< <         break;
< ---
---
> >       }
> >     } else if (nInserts) {
> > 
> >       //  ... just inserts.
> > 
447,455c1525,1529
< 736,742c919,1002
< <     switch (diffFormat) {
< <     case Default:
< <     case Normal:
< <       break;
< <     case Unified:
< <       fprintf (stdout, " %s", lines[0][o].line->c_str ());
< <       break;
< ---
---
> >       }
> 743a916,1007
> > 
> >     // When we get here, we're dealing with matching lines.
> > 
540c1614
< 743a1004,1007
---
> >     }
# ../sdiff --normal dif.5.cpp dif.4.cpp >& dif.5.4.diff--normal.test
# dif.5.4.diff--normal ---------------------------------------------------------
6c6
< 70c69
---
> 70,98c69
8,10c8
< ---
< > char *ARGV0 = "dif2";
< 72,86c71,73
---
> < 
26,30c24
< ---
< > int main (int argc, char *argv[])
< > {
< >   char const *files[2] = { 0, 0 };
< 88,91c75,76
---
> < 
35,38c29
< ---
< >   MapStringToLinePtr table;
< >   VectorLinePtr lines[2];
< 93,98c78,81
---
> < 
45a37,43
> > char *ARGV0 = "dif2";
> 101a73,82
> >   char const *files[2] = { 0, 0 };
> > 
> >   MapStringToLinePtr table;
> >   VectorLinePtr lines[2];
> > 
50,53c48
< 100,101d82
< < int main (int argc, char *argv[])
< < {
< 139c120
---
> > 
57c52
< 151,156c132,134
---
> 151,166c132,135
64,68c59
< ---
< >   // Perform pass #1, in which we find all explicit matches amongst
< >   // the unique lines.  For every unique line that appears the same
< >   // number of times in both files, we declare the lines to match.
< 158,166d135
---
> < 
78c69,74
< 222d190
---
> ---
> >   // Perform pass #1, in which we find all explicit matches amongst
> >   // the unique lines.  For every unique line that appears the same
> >   // number of times in both files, we declare the lines to match.
> > 
> 222,228c191,194
80c76
< 224,225c192,193
---
> < 
82a79,81
> < 
> < void pass2 ()
> < {
83a83
> > 
86,89c86,87
< 227,228d194
< < void pass2 ()
< < {
< 317d282
---
> > 
> 317,323c283,286
91c89
< 319,320c284,285
---
> < 
93a92,94
> < 
> < void pass3 ()
> < {
94a96
> > 
97,100c99,100
< 322,323d286
< < void pass3 ()
< < {
< 412d374
---
> > 
> 412,419c375,379
102c102
< 414,416c376,378
---
> < 
105a106,108
> < 
> < void pass4 ()
> < {
106a110
> > 
110,113c114,115
< 418,419d379
< < void pass4 ()
< < {
< 472d431
---
> > 
> 472,480c432,437
115c117
< 474,477c433,436
---
> < 
119a122,124
> < 
> < void pass5 ()
> < {
120a126
> > 
125,128c131,132
< 479,480d437
< < void pass5 ()
< < {
< 642,644d598
---
> > 
> 642,707c599,601
132c136
< 646,655c600
---
> < 
143,145c147
< ---
< >   // Perform Pass #6, in which we create the desired output.
< 657,660c602,604
---
> < 
150,154c152
< ---
< >   if (0 < optVerbose) {
< >     fprintf (stderr, "# Pass #6 (walking the differences)...\n");
< >   }
< 662,664c606
---
> < 
158,160c156
< ---
< >   nMatchedLines = 0;
< 666,668c608
---
> < 
164,169c160,161
< ---
< >   // Write the header.
< 669a610,611
< >   switch (diffFormat) {
< >   case Default:
< 671d612
---
> < 
> <   case Normal:
171c163
< 673,681d613
---
> <     break;
181c173
< 683,688c615,617
---
> <   case Unified:
188,192c180,181
< ---
< >     fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
< >     fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
< >     fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), lines[1].size ());
< 691,717d619
---
> <     break;
> <   }
210c199,203
< <   if (0 < optVerbose) {
---
> ---
> > 
> >   // Perform Pass #6, in which we create the desired output.
> > 
> 709,711c603,605
214c207,210
< <   nMatchedLines = 0;
---
> ---
> >     fprintf (stderr, "# Pass #6 (walking the differences)...\n");
> >   }
> > 
216c212,214
< <   // Write the header.
---
> ---
> > 
> 715,718c609,620
220c218,233
< 721,722c623,624
---
> < 
> ---
> > 
> >   switch (diffFormat) {
> >   case Default:
> >   case Normal:
> >     break;
> >   case Unified:
> >     fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
> >     fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
> >     fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), lines[1].size ());
> >     break;
> >   }
> > 
> 720,723c622,625
> < 
222a236
> < 
223a238
> > 
226c241,261
< 752,770c654
---
> > 
> < 
> ---
> > 
> < 
> ---
> > 
> < 
> ---
> > 
> < 
> ---
> > 
> < 
> ---
> > 
> < 
> ---
> > 
> 751,870c653
> < 
246,248c281
< ---
< >     // We've got...
< 772,775c656
---
> < 
253,255c286
< ---
< >     if (nDeletes && nInserts) {
< 777c658
---
> < 
257,270c288,289
< ---
< >       // ... deletes and inserts.
< 778a660,669
< >       switch (diffFormat) {
< >       case Default:
< >       case Normal:
< >         if (1 < nDeletes && 1 < nInserts) {
< >           fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, boInserts + 1, n);
< >         } else if (1 < nDeletes) {
< >           fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boInserts + 1);
< >         } else if (1 < nInserts) {
< >           fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInserts + 1, n);
< >         } 
< 780c671
---
> < 
> <         for (unsigned l = boDeletes; l < o; l += 1) {
272,274c291
< ---
< >           fprintf (stdout, "< %s", lines[0][l].line->c_str ());
< 782,797c673
---
> <         }
291,293c308
< ---
< >         fprintf (stderr, "---\n");
< 799c675
---
> <         for (unsigned l = boInserts; l < n; l += 1) {
295,297c310
< ---
< >           fprintf (stdout, "> %s", lines[1][l].line->c_str ());
< 801,803c677
---
> <         }
301,308c314,315
< ---
< >         break;
< 804a679,682
< >       case Unified:
< >         for (unsigned l = boDeletes; l < o; l += 1) {
< >           fprintf (stdout, "-%s", lines[0][l].line->c_str ());
< >         }
< 806c684
---
> < 
> <         for (unsigned l = boInserts; l < n; l += 1) {
310,312c317
< ---
< >           fprintf (stdout, "+%s", lines[1][l].line->c_str ());
< 808,889c686
---
> <         }
376c381,382
< <     // We've got...
---
> ---
> > 
378c384,385
< <     if (nDeletes && nInserts) {
---
> ---
> > 
380c387,389
< <       // ... deletes and inserts.
---
> ---
> > 
> 876,890c659,687
394a404
> <       }
395a406,432
> > 
> >       switch (diffFormat) {
> >       case Default:
> >       case Normal:
> >         if (1 < nDeletes && 1 < nInserts) {
> >           fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, boInserts + 1, n);
> >         } else if (1 < nDeletes) {
> >           fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boInserts + 1);
> >         } else if (1 < nInserts) {
> >           fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInserts + 1, n);
> >         } 
> >         for (unsigned l = boDeletes; l < o; l += 1) {
> >           fprintf (stdout, "< %s", lines[0][l].line->c_str ());
> >         }
> >         fprintf (stderr, "---\n");
> >         for (unsigned l = boInserts; l < n; l += 1) {
> >           fprintf (stdout, "> %s", lines[1][l].line->c_str ());
> >         }
> >         break;
> > 
> >       case Unified:
> >         for (unsigned l = boDeletes; l < o; l += 1) {
> >           fprintf (stdout, "-%s", lines[0][l].line->c_str ());
> >         }
> >         for (unsigned l = boInserts; l < n; l += 1) {
> >           fprintf (stdout, "+%s", lines[1][l].line->c_str ());
> >         }
397c434,439
< 895,901c692,708
---
> >       }
> < 
> ---
> > 
> 894,902c691,709
> < 
404a447
> <       }
405a449
> > 
423c467,472
< 907,913c714,730
---
> >       }
> < 
> ---
> > 
> 906,914c713,742
> < 
430a480
> <       }
431a482
> > 
449c500,515
< 919,1002c736,742
---
> >       }
> >     }
> > 
> >     // When we get here, we're dealing with matching lines.
> > 
> >     switch (diffFormat) {
> >     case Default:
> >     case Normal:
> >       break;
> >     case Unified:
> >       fprintf (stdout, " %s", lines[0][o].line->c_str ());
> >       break;
> 916,1007d743
> < 
> <     // When we get here, we're dealing with matching lines.
> < 
534,542c600
< ---
< >     switch (diffFormat) {
< >     case Default:
< >     case Normal:
< >       break;
< >     case Unified:
< >       fprintf (stdout, " %s", lines[0][o].line->c_str ());
< >       break;
< 1004,1007d743
---
> <     }
# ../sdiff --normal dif.5.cpp dif.6.cpp >& dif.5.6.diff--normal.test
# dif.5.6.diff--normal ---------------------------------------------------------
16c16
< 736,737c731,735
---
> 736,812c731,734
19,25c19
< ---
< >     if (lines[0][o].l != ~0 && lines[1][n].l != ~0) {
< >       o += 1;
< >       n += 1;
< >       continue;
< >     }
< 739,744c737,777
---
> < 
31a26,93
> < 
> <     // We've got deleted line(s) from boDeletes .. o.
> <     // We've got deleted line(s) from boInserts .. n.
> < 
> <     unsigned nDeletes = o - boDeletes;
> <     unsigned nInserts = n - boInserts;
> < 
> <     // Have we got anything?
> < 
> <     if (nDeletes || nInserts) {
> <       int boOldWindow = max (0, int (boDeletes) - int(optCopyContext));
> <       int eoOldWindow = min (int (lines[0].size ()), int(o) + int(optCopyContext));
> < 
> <       int boNewWindow = max (0, int (boInserts) - int (optCopyContext));
> <       int eoNewWindow = min (int (lines[1].size ()), int(n) + int (optCopyContext));
> < 
> <       fprintf (stdout, "***************\n*** %d,%d ****", boOldWindow, eoOldWindow);
> <       for (unsigned l = boOldWindow; l < boDeletes; l += 1) {
> <         fprintf (stdout, "  %s", lines[0][l].line->c_str ());
> <       }
> < 
> <       // We've got...
> < 
> <       if (nDeletes && nInserts) {
> < 
> <         // ... deletes and inserts.
> < 
> <         for (unsigned l = boDeletes; l < o; l += 1) {
> <           fprintf (stdout, "! %s", lines[0][l].line->c_str ());
> <         }
> <       } else if (nDeletes) {
> < 
> <         //  ... just deletes.
> < 
> <         for (unsigned l = boDeletes; l < o; l += 1) {
> <           fprintf (stdout, "- %s", lines[0][l].line->c_str ());
> <         }
> <       }
> < 
> <       for (unsigned l = o; l < eoOldWindow; l += 1) {
> <         fprintf (stdout, "  %s", lines[0][l].line->c_str ());
> <       }
> <       fprintf (stdout, "--- %d,%d ----", boNewWindow, eoNewWindow);
> <       for (unsigned l = boNewWindow; l < boInserts; l += 1) {
> <         fprintf (stdout, "  %s", lines[1][l].line->c_str ());
> <       }
> < 
> <       // We've got...
> < 
> <       if (nDeletes && nInserts) {
> < 
> <         // ... deletes and inserts.
> < 
> <         for (unsigned l = boInserts; l < n; l += 1) {
> <           fprintf (stdout, "! %s", lines[1][l].line->c_str ());
> <         }
> <       } else if (nInserts) {
> < 
> <         //  ... just inserts.
> < 
> <         for (unsigned l = boInserts; l < n; l += 1) {
> <           fprintf (stdout, "+ %s", lines[1][l].line->c_str ());
> <         }
> <       }
> < 
> <       for (unsigned l = n; l < eoNewWindow; l += 1) {
> <         fprintf (stdout, "  %s", lines[1][l].line->c_str ());
> <       }
32a95,100
> >     if (lines[0][o].l != ~0 && lines[1][n].l != ~0) {
> >       o += 1;
> >       n += 1;
> >       continue;
> 813a736,777
> > 
74,76c142
< 746,747c779
< <     // We've got deleted line(s) from boDeletes .. o.
< <     // We've got deleted line(s) from boInserts .. n.
---
> <     // When we get here, we're dealing with matching lines.
79,81c145,147
< 749,750c781,789
< <     unsigned nDeletes = o - boDeletes;
< <     unsigned nInserts = n - boInserts;
---
> 817,818c781,895
> <     o += 1;
> <     n += 1;
92,94c158
< 752c791,792
< <     // Have we got anything?
< ---
---
> > 
97,108c161
< 754,763c794,801
< <     if (nDeletes || nInserts) {
< <       int boOldWindow = max (0, int (boDeletes) - int(optCopyContext));
< <       int eoOldWindow = min (int (lines[0].size ()), int(o) + int(optCopyContext));
< < 
< <       int boNewWindow = max (0, int (boInserts) - int (optCopyContext));
< <       int eoNewWindow = min (int (lines[1].size ()), int(n) + int (optCopyContext));
< < 
< <       fprintf (stdout, "***************\n*** %d,%d ****", boOldWindow, eoOldWindow);
< <       for (unsigned l = boOldWindow; l < boDeletes; l += 1) {
< <         fprintf (stdout, "  %s", lines[0][l].line->c_str ());
< ---
---
> > 
117c170,171
< 765a804,817
---
> >       }
> > 
132,135c186,203
< 784,785c836,855
< <       for (unsigned l = o; l < eoOldWindow; l += 1) {
< <         fprintf (stdout, "  %s", lines[0][l].line->c_str ());
< ---
---
> >       // We've got...
> > 
> >       if (nDeletes && nInserts) {
> > 
> >         // ... deletes and inserts.
> > 
> >         for (unsigned l = boDeletes; l < o; l += 1) {
> >           fprintf (stdout, "! %s", lines[0][l].line->c_str ());
> >         }
> >       } else if (nDeletes) {
> > 
> >         //  ... just deletes.
> > 
> >         for (unsigned l = boDeletes; l < o; l += 1) {
> >           fprintf (stdout, "- %s", lines[0][l].line->c_str ());
> >         }
> >       }
> > 
156,160c224
< 787,789c857,863
< <       fprintf (stdout, "--- %d,%d ----", boNewWindow, eoNewWindow);
< <       for (unsigned l = boNewWindow; l < boInserts; l += 1) {
< <         fprintf (stdout, "  %s", lines[1][l].line->c_str ());
< ---
---
> >       }
168c232,233
< 791a866,871
---
> >       }
> > 
175,182c240,257
< 810,815c890
< <       for (unsigned l = n; l < eoNewWindow; l += 1) {
< <         fprintf (stdout, "  %s", lines[1][l].line->c_str ());
< <       }
< <     }
< < 
< <     // When we get here, we're dealing with matching lines.
< ---
---
> >       // We've got...
> > 
> >       if (nDeletes && nInserts) {
> > 
> >         // ... deletes and inserts.
> > 
> >         for (unsigned l = boInserts; l < n; l += 1) {
> >           fprintf (stdout, "! %s", lines[1][l].line->c_str ());
> >         }
> >       } else if (nInserts) {
> > 
> >         //  ... just inserts.
> > 
> >         for (unsigned l = boInserts; l < n; l += 1) {
> >           fprintf (stdout, "+ %s", lines[1][l].line->c_str ());
> >         }
> >       }
> > 
184,187c259
< 817,818c892,895
< <     o += 1;
< <     n += 1;
< ---
---
> > 
# ../sdiff --normal dif.6.cpp dif.5.cpp >& dif.6.5.diff--normal.test
# dif.6.5.diff--normal ---------------------------------------------------------
1c1
< 726,786c726,727
---
> 726c726,727
3c3,6
< < 
---
> ---
> >     // Find any unmatched lines at this point in the old file.  These
> >     // are deletes.
> 728,729c729,734
6c9,16
< < 
---
> ---
> >     unsigned boDeletes;
> >     for (boDeletes = o;
> >          o < lines[0].size () && lines[0][o].l == ~0;
> >          o += 1
> >         )
> >     {}
> 731,735c736,737
12c22,25
< < 
---
> ---
> >     // Find any unmatched lines at this point in the new file.  These
> >     // are inserts.
> 737,741c739,744
18c31,38
< < 
---
> ---
> >     unsigned boInserts;
> >     for (boInserts = n;
> >          n < lines[1].size () && lines[1][n].l == ~0;
> >          n += 1
> >         )
> >     {}
> 743c746,747
20c40,43
< < 
---
> ---
> >     // We've got deleted line(s) from boDeletes .. o.
> >     // We've got deleted line(s) from boInserts .. n.
> 745,746c749,750
23c46,49
< < 
---
> ---
> >     unsigned nDeletes = o - boDeletes;
> >     unsigned nInserts = n - boInserts;
> 748,749c752
26c52,54
< < 
---
> ---
> >     // Have we got anything?
> 751,756c754,756
33c61,65
< < 
---
> ---
> >     if (nDeletes || nInserts) {
> >       int boOldWindow = max (0, int (boDeletes) - int(optCopyContext));
> >       int eoOldWindow = min (int (lines[0].size ()), int(o) + int(optCopyContext));
> 758,761c758,759
38c70,73
< < 
---
> ---
> >       int boNewWindow = max (0, int (boInserts) - int (optCopyContext));
> >       int eoNewWindow = min (int (lines[1].size ()), int(n) + int (optCopyContext));
> 763,816c761,764
63,66c98
< ---
< >     // Find any unmatched lines at this point in the old file.  These
< >     // are deletes.
< 788,789c729,734
---
> < 
69,76c101
< ---
< >     unsigned boDeletes;
< >     for (boDeletes = o;
< >          o < lines[0].size () && lines[0][o].l == ~0;
< >          o += 1
< >         )
< >     {}
< 791,792c736,737
---
> < 
79,82c104
< ---
< >     // Find any unmatched lines at this point in the new file.  These
< >     // are inserts.
< 794c739,744
---
> < 
84,91c106
< ---
< >     unsigned boInserts;
< >     for (boInserts = n;
< >          n < lines[1].size () && lines[1][n].l == ~0;
< >          n += 1
< >         )
< >     {}
< 796,797c746,747
---
> < 
94,97c109
< ---
< >     // We've got deleted line(s) from boDeletes .. o.
< >     // We've got deleted line(s) from boInserts .. n.
< 799,802c749,750
---
> < 
102,105c114
< ---
< >     unsigned nDeletes = o - boDeletes;
< >     unsigned nInserts = n - boInserts;
< 804,805c752
---
> < 
108,110c117
< ---
< >     // Have we got anything?
< 807,809c754,763
---
> < 
114,125c121,122
< ---
< >     if (nDeletes || nInserts) {
< >       int boOldWindow = max (0, int (boDeletes) - int(optCopyContext));
< >       int eoOldWindow = min (int (lines[0].size ()), int(o) + int(optCopyContext));
< > 
< >       int boNewWindow = max (0, int (boInserts) - int (optCopyContext));
< >       int eoNewWindow = min (int (lines[1].size ()), int(n) + int (optCopyContext));
< > 
< >       fprintf (stdout, "***************\n*** %d,%d ****", boOldWindow, eoOldWindow);
< >       for (unsigned l = boOldWindow; l < boDeletes; l += 1) {
< >         fprintf (stdout, "  %s", lines[0][l].line->c_str ());
< 812,817d765
---
> <       }
> < 
131,132c128,133
< < 
< 836,855c784,785
---
> ---
> >       fprintf (stdout, "***************\n*** %d,%d ****", boOldWindow, eoOldWindow);
> >       for (unsigned l = boOldWindow; l < boDeletes; l += 1) {
> >         fprintf (stdout, "  %s", lines[0][l].line->c_str ());
> >       }
> 836,870c784,790
153,156c154
< ---
< >       for (unsigned l = o; l < eoOldWindow; l += 1) {
< >         fprintf (stdout, "  %s", lines[0][l].line->c_str ());
< 857,863c787,789
---
> <       }
164,168c162,163
< ---
< >       fprintf (stdout, "--- %d,%d ----", boNewWindow, eoNewWindow);
< >       for (unsigned l = boNewWindow; l < boInserts; l += 1) {
< >         fprintf (stdout, "  %s", lines[1][l].line->c_str ());
< 866,871d791
---
> <       }
> < 
174,175c169,177
< < 
< 890,894c810,812
---
> ---
> >       for (unsigned l = o; l < eoOldWindow; l += 1) {
> >         fprintf (stdout, "  %s", lines[0][l].line->c_str ());
> >       }
> >       fprintf (stdout, "--- %d,%d ----", boNewWindow, eoNewWindow);
> >       for (unsigned l = boNewWindow; l < boInserts; l += 1) {
> >         fprintf (stdout, "  %s", lines[1][l].line->c_str ());
> >       }
> 890,895c810,818
180a183
> <     }
185c188
< 895a814,818
---
> >     }
# ../sdiff --normal dif.6.cpp dif.7.cpp >& dif.6.7.diff--normal.test
# dif.6.7.diff--normal ---------------------------------------------------------
12d11
< 48c49
18c17,111
< 117a120,121
---
> 118,210c120
> <         Line *line = table[text];
> < 
> <         if (!line) {
> <           table[text] = line = new Line (text);
> <           nUniq += 1;
> <         }
> <         line->copies[n].push_back (lines[n].size ());
> <         lines[n].push_back (line);
> <       }
> < 
> <       if (0 < optVerbose) {
> <         fprintf (stderr, " %u lines, %u unique.\n", lines[n].size (), nUniq);
> <       }
> <     } else {
> <       fprintf (stderr, "%s: Unable to open %s!  Exiting....\n", ARGV0, files[n]);
> <       perror (ARGV0);
> <       exit (1);
> <     }
> <   }
> < 
> <   if (0 < optVerbose) {
> <     fprintf (stderr, "# Total unique lines = %d\n", table.size ());
> <   }
> < 
> <   // map<int, int> counts;
> <   // for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> <   //   Line *l = i->second;
> <   //   counts[l->counts[0].size () + l->counts[1].size ()] += 1;
> <   // }
> <   // for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
> <   //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
> <   // }
> < 
> <   pass1 ();
> <   pass2 ();
> <   pass3 ();
> <   pass4 ();
> <   pass5 ();
> <   pass6 ();
> < 
> <   return 0;
> < }
> < 
> < // Perform pass #1, in which we find all explicit matches amongst the
> < // unique lines.  For every unique line that appears the same number
> < // of times in both files, we declare the lines to match.
> < 
> < void pass1 ()
> < {
> <   if (0 < optVerbose) {
> <     fprintf (stderr, "# Pass 1 (finding matches amongst unique lines)...");
> <   }
> < 
> <   nMatchedLines = 0;
> < 
> <   for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> <     Line *l = i->second;
> < 
> <     // If the number of old and new lines match, then we declare that
> <     // they are (all) the same line.  Note, it isn't possible for the
> <     // numbers of both files to be 0.
> < 
> <     // (In the original algorithm, we only recognized a match, here,
> <     // if there was exactly 1 copy for each file.)
> < 
> <     if (l->copies[0].size () == l->copies[1].size ()) {
> <       nMatchedLines += 1;
> < 
> <       // For each matched line in the new file, mark it with the
> <       // corresponding line (number) in the old file.
> < 
> <       while (!l->copies[0].empty ()) {
> <         unsigned o = l->copies[0].front ();
> <         unsigned n = l->copies[1].front ();
> < 
> <         // Match up the pair.
> < 
> <         lines[0][o].l = n;
> <         lines[1][n].l = o;
> < 
> <         // Remove the matched line numbers from the lists.
> < 
> <         l->copies[0].pop_front ();
> <         l->copies[1].pop_front ();
> <       }
> <     }
> <   }
> <   nTotalMatchedLines += nMatchedLines;
> < 
> <   // Let's see the intermediate results.
> < 
> <   if (0 < optVerbose) {
> <     fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
> ---
19a113,312
> 212,400c122,219
> <     if (1 < optVerbose) {
> <       for (int f = 0; f < 2; f += 1) {
> <         fprintf (stderr, "# file #%d\n", f + 1);
> <         for (int l = 0; l < lines[f].size (); l += 1) {
> <           fprintf (stderr, "#   [%d] ", l);
> <           lines[f][l].Dump (stderr);
> <         }
> <       }
> <     }
> <   }
> < }
> < 
> < // Perform Pass #2, in which we attempt to 'widen' blocks of matched
> < // lines, by appending lines which are the same in both files.
> < 
> < void pass2 ()
> < {
> <   if (0 < optVerbose) {
> <     fprintf (stderr, "# Pass #2 (spreading matches down)...");
> <   }
> < 
> <   nMatchedBlocks = 0;
> <   nMatchedLines = 0;
> < 
> <   // Starting at the top of the old file,...
> < 
> <   for (unsigned o = 0; o < lines[0].size (); o += 1) {
> < 
> <     // ... skip any currently unmatched lines...
> < 
> <     if (lines[0][o].l == ~0) {
> <       continue;
> <     }
> < 
> <     // ... until we find an [already] matched line.  Then, skip over
> <     // the set of 1 or more matched lines, until we reach any
> <     // following, still-unmatched line.
> < 
> <     unsigned n;
> <     do {
> <       n = lines[0][o].l + 1;
> <       o += 1;
> <     } while (o < lines[0].size () && lines[0][o].l != ~0);
> < 
> <     // Now, o - 1 is the line number of the last matched old line, and
> <     // n - 1 is the line number of the last matched new line.  We want
> <     // to add new old and new lines, if they match.
> < 
> <     // Finally, attempt to add unmatched lines to the preceeding
> <     // matched set.
> < 
> <     for (; o < lines[0].size () && lines[0][o].l == ~0; o += 1, n += 1) {
> < 
> <       // If the [next] pair of old and new lines aren't the same line, we're done.
> < 
> <       if (lines[0][o].line != lines[1][n].line) {
> <         break;
> <       }
> < 
> <       // Match up the pair.
> < 
> <       lines[0][o].l = n;
> <       lines[1][n].l = o;
> < 
> <       // Remove the matched line numbers form the lists.
> < 
> <       Line *line = lines[0][o].line;
> <       list<unsigned> &oldCopies = line->copies[0];
> <       list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
> <       if (oL != oldCopies.end ()) {
> <         oldCopies.erase (oL);
> <       }
> <       list<unsigned> &newCopies = line->copies[0];
> <       list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
> <       if (nL != newCopies.end ()) {
> <         newCopies.erase (nL);
> <       }
> < 
> <       nMatchedLines += 1;
> <     }
> <     nMatchedBlocks += 1;
> <   }
> <   nTotalMatchedLines += nMatchedLines;
> <   nTotalMatchedBlocks += nMatchedBlocks;
> < 
> <   // Let's see the intermediate results.
> < 
> <   if (0 < optVerbose) {
> <     fprintf (stderr,
> <              " found %u/%u matched lines/blocks (%u/%u totals).\n",
> <              nMatchedLines,
> <              nMatchedBlocks,
> <              nTotalMatchedLines,
> <              nTotalMatchedBlocks
> <             );
> <     if (1 < optVerbose) {
> <       for (int f = 0; f < 2; f += 1) {
> <         fprintf (stderr, "# file #%d\n", f + 1);
> <         for (int l = 0; l < lines[f].size (); l += 1) {
> <           fprintf (stderr, "#   [%d] ", l);
> <           lines[f][l].Dump (stderr);
> <         }
> <       }
> <     }
> <   }
> < }
> < 
> < // Perform Pass #3, in which we attempt to 'widen' blocks of matched
> < // lines, by prepending lines which are the same in both files.
> < 
> < void pass3 ()
> < {
> <   if (0 < optVerbose) {
> <     fprintf (stderr, "# Pass #3 (spreading matches up)...");
> <   }
> < 
> <   nMatchedBlocks = 0;
> <   nMatchedLines = 0;
> < 
> <   // Starting at the bottom of the old file,...
> < 
> <   for (int o = lines[0].size (); 0 <= o; o -= 1) {
> < 
> <     // ... skip any currently unmatched lines...
> < 
> <     if (lines[0][o].l == ~0) {
> <       continue;
> <     }
> < 
> <     // ... until we find an [already] matched line.  Then, skip over
> <     // the set of 1 or more matched lines, until we reach any
> <     // following, still-unmatched line.
> < 
> <     unsigned n;
> <     do {
> <       n = lines[0][o].l - 1;
> <       o -= 1;
> <     } while (0 <= o && lines[0][o].l != ~0);
> < 
> <     // Now, o + 1 is the line number of the last matched old line, and
> <     // n + 1 is the line number of the last matched new line.  We want
> <     // to add new old and new lines, if they match.
> < 
> <     // Finally, attempt to add unmatched lines to the preceeding
> <     // matched set.
> < 
> <     for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
> < 
> <       // If the [next] pair of old and new lines aren't the same line, we're done.
> < 
> <       if (lines[0][o].line != lines[1][n].line) {
> <         break;
> <       }
> < 
> <       // Match up the pair.
> < 
> <       lines[0][o].l = n;
> <       lines[1][n].l = o;
> < 
> <       // Remove the matched line numbers form the lists.
> < 
> <       Line *line = lines[0][o].line;
> <       list<unsigned> &oldCopies = line->copies[0];
> <       list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
> <       if (oL != oldCopies.end ()) {
> <         oldCopies.erase (oL);
> <       }
> <       list<unsigned> &newCopies = line->copies[0];
> <       list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
> <       if (nL != newCopies.end ()) {
> <         newCopies.erase (nL);
> <       }
> < 
> <       nMatchedLines += 1;
> <     }
> <     nMatchedBlocks += 1;
> <   }
> <   nTotalMatchedLines += nMatchedLines;
> < 
> <   // Let's see the intermediate results.
> < 
> <   if (0 < optVerbose) {
> <     fprintf (stderr,
> <              " found %u/%u matched lines/blocks (%u/%u totals).\n",
> <              nMatchedLines,
> <              nMatchedBlocks,
> <              nTotalMatchedLines,
> <              nTotalMatchedBlocks
> <             );
> ---
> >         Line *line = table[text];
> > 
> >         if (!line) {
> >           table[text] = line = new Line (text);
> >           nUniq += 1;
> >         }
> >         line->copies[n].push_back (lines[n].size ());
> >         lines[n].push_back (line);
> >       }
21c314,315
< 129a134
---
> >       if (0 < optVerbose) {
> >         fprintf (stderr, " %u lines, %u unique.\n", lines[n].size (), nUniq);
23c317,319
< 132a138
---
> >       }
> >     } else {
> >       fprintf (stderr, "%s: Unable to open %s!  Exiting....\n", ARGV0, files[n]);
25c321,327
< 139a146
---
> >       perror (ARGV0);
> >       exit (1);
> >     }
> >   }
> > 
> >   if (0 < optVerbose) {
> >     fprintf (stderr, "# Total unique lines = %d\n", table.size ());
27c329,357
< 168a176
---
> >   }
> > 
> >   // map<int, int> counts;
> >   // for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> >   //   Line *l = i->second;
> >   //   counts[l->counts[0].size () + l->counts[1].size ()] += 1;
> >   // }
> >   // for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
> >   //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
> >   // }
> > 
> >   pass1 ();
> >   pass2 ();
> >   pass3 ();
> >   pass4 ();
> >   pass5 ();
> >   pass6 ();
> > 
> >   return 0;
> > }
> > 
> > // Perform pass #1, in which we find all explicit matches amongst the
> > // unique lines.  For every unique line that appears the same number
> > // of times in both files, we declare the lines to match.
> > 
> > void pass1 ()
> > {
> >   if (0 < optVerbose) {
> >     fprintf (stderr, "# Pass 1 (finding matches amongst unique lines)...");
29c359,400
< 210a219
---
> >   }
> > 
> >   nMatchedLines = 0;
> > 
> >   for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> >     Line *l = i->second;
> > 
> >     // If the number of old and new lines match, then we declare that
> >     // they are (all) the same line.  Note, it isn't possible for the
> >     // numbers of both files to be 0.
> > 
> >     // (In the original algorithm, we only recognized a match, here,
> >     // if there was exactly 1 copy for each file.)
> > 
> >     if (l->copies[0].size () == l->copies[1].size ()) {
> >       nMatchedLines += 1;
> > 
> >       // For each matched line in the new file, mark it with the
> >       // corresponding line (number) in the old file.
> > 
> >       while (!l->copies[0].empty ()) {
> >         unsigned o = l->copies[0].front ();
> >         unsigned n = l->copies[1].front ();
> > 
> >         // Match up the pair.
> > 
> >         lines[0][o].l = n;
> >         lines[1][n].l = o;
> > 
> >         // Remove the matched line numbers from the lists.
> > 
> >         l->copies[0].pop_front ();
> >         l->copies[1].pop_front ();
> >       }
> >     }
> >   }
> >   nTotalMatchedLines += nMatchedLines;
> > 
> >   // Let's see the intermediate results.
> > 
> >   if (0 < optVerbose) {
> >     fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
31c402
< 212c221
---
> 402,460c221,417
32a404,461
> <       for (int f = 0; f < 2; f += 1) {
> <         fprintf (stderr, "# file #%d\n", f + 1);
> <         for (int l = 0; l < lines[f].size (); l += 1) {
> <           fprintf (stderr, "#   [%d] ", l);
> <           lines[f][l].Dump (stderr);
> <         }
> <       }
> <     }
> <   }
> < }
> < 
> < // Perform pass #4, in which we find any remaining matches amongst the
> < // unique lines.  For every unique line that has more than 1 copy in
> < // both files, we declare the copies to match.
> < 
> < void pass4 ()
> < {
> <   if (0 < optVerbose) {
> <     fprintf (stderr, "# Pass 4 (finding remaining matches amongst unique lines)...");
> <   }
> < 
> <   nMatchedLines = 0;
> < 
> <   for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> <     Line *l = i->second;
> < 
> <     // If there's more than 1 matching old and new lines, then we
> <     // declare that each pair are (all) the same line.
> < 
> <     // (In the original algorithm, we only recognized a match, here,
> <     // if there was exactly 1 copy for each file.)
> < 
> <     while (0 < l->copies[0].size () && 0 < l->copies[1].size ()) {
> <       nMatchedLines += 1;
> < 
> <       // For each matched line in the new file, mark it with the
> <       // corresponding line (number) in the old file.
> < 
> <       unsigned o = l->copies[0].front ();
> <       unsigned n = l->copies[1].front ();
> < 
> <       // Match up the pair.
> < 
> <       lines[0][o].l = n;
> <       lines[1][n].l = o;
> < 
> <       // Remove the matched line numbers from the lists.
> < 
> <       l->copies[0].pop_front ();
> <       l->copies[1].pop_front ();
> <     }
> <   }
> <   nTotalMatchedLines += nMatchedLines;
> < 
> <   // Let's see the intermediate results.
> < 
> <   if (0 < optVerbose) {
> <     fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
35c464,465
< 214a224
---
> >       for (int f = 0; f < 2; f += 1) {
> >         fprintf (stderr, "# file #%d\n", f + 1);
37c467,468
< 216a227
---
> >         for (int l = 0; l < lines[f].size (); l += 1) {
> >           fprintf (stderr, "#   [%d] ", l);
39c470,483
< 230a242
---
> >           lines[f][l].Dump (stderr);
> >         }
> >       }
> >     }
> >   }
> > }
> > 
> > // Perform Pass #2, in which we attempt to 'widen' blocks of matched
> > // lines, by appending lines which are the same in both files.
> > 
> > void pass2 ()
> > {
> >   if (0 < optVerbose) {
> >     fprintf (stderr, "# Pass #2 (spreading matches down)...");
41,43c485,560
< 307c319,320
< <     if (1 < optVerbose) {
< ---
---
> >   }
> > 
> >   nMatchedBlocks = 0;
> >   nMatchedLines = 0;
> > 
> >   // Starting at the top of the old file,...
> > 
> >   for (unsigned o = 0; o < lines[0].size (); o += 1) {
> > 
> >     // ... skip any currently unmatched lines...
> > 
> >     if (lines[0][o].l == ~0) {
> >       continue;
> >     }
> > 
> >     // ... until we find an [already] matched line.  Then, skip over
> >     // the set of 1 or more matched lines, until we reach any
> >     // following, still-unmatched line.
> > 
> >     unsigned n;
> >     do {
> >       n = lines[0][o].l + 1;
> >       o += 1;
> >     } while (o < lines[0].size () && lines[0][o].l != ~0);
> > 
> >     // Now, o - 1 is the line number of the last matched old line, and
> >     // n - 1 is the line number of the last matched new line.  We want
> >     // to add new old and new lines, if they match.
> > 
> >     // Finally, attempt to add unmatched lines to the preceeding
> >     // matched set.
> > 
> >     for (; o < lines[0].size () && lines[0][o].l == ~0; o += 1, n += 1) {
> > 
> >       // If the [next] pair of old and new lines aren't the same line, we're done.
> > 
> >       if (lines[0][o].line != lines[1][n].line) {
> >         break;
> >       }
> > 
> >       // Match up the pair.
> > 
> >       lines[0][o].l = n;
> >       lines[1][n].l = o;
> > 
> >       // Remove the matched line numbers form the lists.
> > 
> >       Line *line = lines[0][o].line;
> >       list<unsigned> &oldCopies = line->copies[0];
> >       list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
> >       if (oL != oldCopies.end ()) {
> >         oldCopies.erase (oL);
> >       }
> >       list<unsigned> &newCopies = line->copies[0];
> >       list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
> >       if (nL != newCopies.end ()) {
> >         newCopies.erase (nL);
> >       }
> > 
> >       nMatchedLines += 1;
> >     }
> >     nMatchedBlocks += 1;
> >   }
> >   nTotalMatchedLines += nMatchedLines;
> >   nTotalMatchedBlocks += nMatchedBlocks;
> > 
> >   // Let's see the intermediate results.
> > 
> >   if (0 < optVerbose) {
> >     fprintf (stderr,
> >              " found %u/%u matched lines/blocks (%u/%u totals).\n",
> >              nMatchedLines,
> >              nMatchedBlocks,
> >              nTotalMatchedLines,
> >              nTotalMatchedBlocks
> >             );
46c563,564
< 309a323
---
> >       for (int f = 0; f < 2; f += 1) {
> >         fprintf (stderr, "# file #%d\n", f + 1);
48c566,567
< 311a326
---
> >         for (int l = 0; l < lines[f].size (); l += 1) {
> >           fprintf (stderr, "#   [%d] ", l);
50c569,582
< 325a341
---
> >           lines[f][l].Dump (stderr);
> >         }
> >       }
> >     }
> >   }
> > }
> > 
> > // Perform Pass #3, in which we attempt to 'widen' blocks of matched
> > // lines, by prepending lines which are the same in both files.
> > 
> > void pass3 ()
> > {
> >   if (0 < optVerbose) {
> >     fprintf (stderr, "# Pass #3 (spreading matches up)...");
52c584,658
< 400a417
---
> >   }
> > 
> >   nMatchedBlocks = 0;
> >   nMatchedLines = 0;
> > 
> >   // Starting at the bottom of the old file,...
> > 
> >   for (int o = lines[0].size (); 0 <= o; o -= 1) {
> > 
> >     // ... skip any currently unmatched lines...
> > 
> >     if (lines[0][o].l == ~0) {
> >       continue;
> >     }
> > 
> >     // ... until we find an [already] matched line.  Then, skip over
> >     // the set of 1 or more matched lines, until we reach any
> >     // following, still-unmatched line.
> > 
> >     unsigned n;
> >     do {
> >       n = lines[0][o].l - 1;
> >       o -= 1;
> >     } while (0 <= o && lines[0][o].l != ~0);
> > 
> >     // Now, o + 1 is the line number of the last matched old line, and
> >     // n + 1 is the line number of the last matched new line.  We want
> >     // to add new old and new lines, if they match.
> > 
> >     // Finally, attempt to add unmatched lines to the preceeding
> >     // matched set.
> > 
> >     for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
> > 
> >       // If the [next] pair of old and new lines aren't the same line, we're done.
> > 
> >       if (lines[0][o].line != lines[1][n].line) {
> >         break;
> >       }
> > 
> >       // Match up the pair.
> > 
> >       lines[0][o].l = n;
> >       lines[1][n].l = o;
> > 
> >       // Remove the matched line numbers form the lists.
> > 
> >       Line *line = lines[0][o].line;
> >       list<unsigned> &oldCopies = line->copies[0];
> >       list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
> >       if (oL != oldCopies.end ()) {
> >         oldCopies.erase (oL);
> >       }
> >       list<unsigned> &newCopies = line->copies[0];
> >       list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
> >       if (nL != newCopies.end ()) {
> >         newCopies.erase (nL);
> >       }
> > 
> >       nMatchedLines += 1;
> >     }
> >     nMatchedBlocks += 1;
> >   }
> >   nTotalMatchedLines += nMatchedLines;
> > 
> >   // Let's see the intermediate results.
> > 
> >   if (0 < optVerbose) {
> >     fprintf (stderr,
> >              " found %u/%u matched lines/blocks (%u/%u totals).\n",
> >              nMatchedLines,
> >              nMatchedBlocks,
> >              nTotalMatchedLines,
> >              nTotalMatchedBlocks
> >             );
54c660
< 402c419
---
> 462,630c419,481
55a662,829
> <       for (int f = 0; f < 2; f += 1) {
> <         fprintf (stderr, "# file #%d\n", f + 1);
> <         for (int l = 0; l < lines[f].size (); l += 1) {
> <           fprintf (stderr, "#   [%d] ", l);
> <           lines[f][l].Dump (stderr);
> <         }
> <       }
> <     }
> <   }
> < }
> < 
> < // Perform Pass #5, in which we look for blocks which match, but are
> < // the result of a move (their not in their original position).  For
> < // these, we'll unmatch the blocks, turning them into a delete and an
> < // insert.
> < 
> < void pass5 ()
> < {
> <   if (0 < optVerbose) {
> <     fprintf (stderr, "# Pass #5 (unmatching block moves)...\n");
> <   }
> < 
> <   nMatchedBlocks = 0;
> <   nMatchedLines = 0;
> < 
> <   // Starting at the top of both files,...
> < 
> <   unsigned o = 0;
> <   unsigned n = 0;
> < 
> <   while (o < lines[0].size () || n < lines[1].size ()) {
> < 
> <     // Skip any unmatched lines at this point in the old file.  These
> <     // are deletes.
> < 
> <     //    Old     New
> <     //   +---+
> <     // 0 | a |
> <     //   +---+   +---+
> <     //         0 | b |
> <     //   +---+   +---+
> <     // 1 | c | 1 | c |
> <     //   +---+   +---+
> <     //         2 | z |
> <     //   +---+   +---+
> <     // 2 | d | 3 | d |
> <     //   +---+   +---+
> < 
> <     while (o < lines[0].size () && lines[0][o].l == ~0) {
> <       o += 1;
> <     }
> < 
> <     // Skip any unmatched lines at this point in the new file.  These
> <     // are inserts.
> < 
> <     while (n < lines[1].size () && lines[1][n].l == ~0) {
> <       n += 1;
> <     }
> < 
> <     // When we get here, we know that we're dealing with matching
> <     // lines (or the end of one or both files).  We're done with this
> <     // pass, if we've reached the end of either file.
> < 
> <     if (lines[0].size () <= o || lines[1].size () <= n) {
> <       break;
> <     }
> < 
> <     // We now know that we've got a pair of matching lines, the start
> <     // of a matching block.  If the new file's line number is what we
> <     // expect, then the matched pair is unmoved, and we can skip over
> <     // the pair.  (If this is really the start of a block of more than
> <     // 1 lines, we'll handle it one pair at a time.)
> < 
> <     if (lines[0][o].l == n) {
> <       o += 1;
> <       n += 1;
> <       continue;
> <     }
> < 
> <     // If, on the other hand, we don't expect this [new] line number,
> <     // then this matching block has been moved.  We need to turn the
> <     // matched pair into an *unmatched* pair, one of deletes, and one
> <     // of inserts.  First, though, we need to know how big this block
> <     // is, and how far it was moved....
> < 
> <     // Remember where we were when we started.
> < 
> <     unsigned oOld = o;
> <     unsigned nOld = n;
> < 
> <     // Remember where the block came from.
> < 
> <     unsigned nNew = lines[0][o].l;
> < 
> <     // Find the end of this matched pair.
> < 
> <     for (n = nNew; o < lines[0].size () && n < lines[1].size (); o += 1, n += 1) {
> <       if (lines[0][o].l != n) {
> <         break;
> <       }
> <     }
> < 
> <     // When we get here:
> <     // * oOld..o is the old file's block,
> <     // * nNew..n is the new file's *moved* block, and
> <     // * nOld is where we originally expected the new block from.
> <  
> <     // We can now calculate the length of the block...
> <     
> <     unsigned bSize = o - oOld;  // (or n - nNew)
> < 
> <     // ... and we can calculate how far the block moved:
> < 
> <     unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
> < 
> <     // The larger of the two will become our delete, and the smaller
> <     // will become our insert.
> < 
> <     //    Old     New
> <     //   +---+   +---+
> <     // 0 | a | 0 | b |
> <     //   +---+ 1 | b |
> <     // 1 | b |   +---+
> <     // 2 | b | 2 | a |
> <     //   +---+   +---+
> <     // 3 | c | 3 | c |
> <     //   +---+   +---+
> < 
> <     // (1) Delete a@0, insert a@2, or
> <     // (2) insert bb@0, delete bb@1?
> < 
> <     // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and bMove
> <     // (of a) is 2-0 or 2, the size of b@0.  We choose to delete a@0,
> <     // and reinsert a@2.
> < 
> <     // if (bSize <= bMove) {
> <       for (unsigned a = oOld; a < o; a += 1) {
> <         lines[0][a].l = ~0;
> <       }
> <       for (unsigned d = nNew; d < n; d += 1) {
> <         lines[1][d].l = ~0;
> <       }
> <     // } else {
> <       // for (unsigned a = oOld; a < o; a += 1) {
> <       //   lines[0][a].l = ~0;
> <       // }
> <       // for (unsigned d = nNew; d < n; d += 1) {
> <       //   lines[1][d].l = ~0;
> <       // }
> <     // }
> < 
> <     // Continue from where we left off.
> < 
> <     n = nOld;
> <   }
> <   nTotalMatchedLines -= nMatchedLines;
> <   nTotalMatchedBlocks -= nMatchedBlocks;
> < 
> <   // Let's see the intermediate results.
> < 
> <   if (0 < optVerbose) {
> <     fprintf (stderr,
> <              " found %u/%u matched lines/blocks (%u/%u totals).\n",
> <              nMatchedLines,
> <              nMatchedBlocks,
> <              nTotalMatchedLines,
> <              nTotalMatchedBlocks
> <             );
58c832,833
< 404a422
---
> >       for (int f = 0; f < 2; f += 1) {
> >         fprintf (stderr, "# file #%d\n", f + 1);
60c835,836
< 406a425
---
> >         for (int l = 0; l < lines[f].size (); l += 1) {
> >           fprintf (stderr, "#   [%d] ", l);
62c838,852
< 421a441
---
> >           lines[f][l].Dump (stderr);
> >         }
> >       }
> >     }
> >   }
> > }
> > 
> > // Perform pass #4, in which we find any remaining matches amongst the
> > // unique lines.  For every unique line that has more than 1 copy in
> > // both files, we declare the copies to match.
> > 
> > void pass4 ()
> > {
> >   if (0 < optVerbose) {
> >     fprintf (stderr, "# Pass 4 (finding remaining matches amongst unique lines)...");
64c854,892
< 460a481
---
> >   }
> > 
> >   nMatchedLines = 0;
> > 
> >   for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> >     Line *l = i->second;
> > 
> >     // If there's more than 1 matching old and new lines, then we
> >     // declare that each pair are (all) the same line.
> > 
> >     // (In the original algorithm, we only recognized a match, here,
> >     // if there was exactly 1 copy for each file.)
> > 
> >     while (0 < l->copies[0].size () && 0 < l->copies[1].size ()) {
> >       nMatchedLines += 1;
> > 
> >       // For each matched line in the new file, mark it with the
> >       // corresponding line (number) in the old file.
> > 
> >       unsigned o = l->copies[0].front ();
> >       unsigned n = l->copies[1].front ();
> > 
> >       // Match up the pair.
> > 
> >       lines[0][o].l = n;
> >       lines[1][n].l = o;
> > 
> >       // Remove the matched line numbers from the lists.
> > 
> >       l->copies[0].pop_front ();
> >       l->copies[1].pop_front ();
> >     }
> >   }
> >   nTotalMatchedLines += nMatchedLines;
> > 
> >   // Let's see the intermediate results.
> > 
> >   if (0 < optVerbose) {
> >     fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
66c894
< 462c483
---
> 632,741c483,655
67a896,1004
> <       for (int f = 0; f < 2; f += 1) {
> <         fprintf (stderr, "# file #%d\n", f + 1);
> <         for (int l = 0; l < lines[f].size (); l += 1) {
> <           fprintf (stderr, "#   [%d] ", l);
> <           lines[f][l].Dump (stderr);
> <         }
> <       }
> <     }
> <   }
> < }
> < 
> < // Perform Pass #6, in which we create the desired output.
> < 
> < void pass6c ();
> < void pass6e ();
> < void pass6i ();
> < void pass6n ();
> < void pass6r ();
> < void pass6s ();
> < void pass6u ();
> < 
> < void pass6 ()
> < {
> < 
> <   switch (diffFormat) {
> <   case Context:
> <     pass6c ();
> <     break;
> < 
> <   case EdScript:
> <     pass6e ();
> <     break;
> < 
> <   case IfThenElse:
> <     pass6i ();
> <     break;
> < 
> <   case Normal:
> <     pass6n ();
> <     break;
> < 
> <   case RCS:
> <     pass6r ();
> <     break;
> < 
> <   case SideBySide:
> <     pass6s ();
> <     break;
> < 
> <   case Unified:
> <     pass6u ();
> <     break;
> < 
> <   case Default:
> <   default:
> <     pass6c ();
> <     break;
> <   }
> < }
> < 
> < template<typename T> T min (T l, T r) {
> <   if (l < r) {
> <     return l;
> <   }
> <   return r;
> < }
> < 
> < template<typename T> T max (T l, T r) {
> <   if (l < r) {
> <     return r;
> <   }
> <   return l;
> < }
> < 
> < void pass6c () {
> <   if (0 < optVerbose) {
> <     fprintf (stderr, "# Pass #6u (walking the differences)...\n");
> <   }
> < 
> <   nMatchedLines = 0;
> < 
> <   // Write the header.
> < 
> <   fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
> <   fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
> < 
> <   // Starting at the top of both files,...
> < 
> <   unsigned o = 0;
> <   unsigned n = 0;
> < 
> <   while (o < lines[0].size () || n < lines[1].size ()) {
> < 
> <     // Find the bounds of the current contextual 'window'.
> < 
> <     // If we aren't looking at a delete or an insert, we're not at the
> <     // start of a context window.
> < 
> <     if (lines[0][o].l != ~0 && lines[1][n].l != ~0) {
> <       o += 1;
> <       n += 1;
> <       continue;
> <     }
> < 
> <     // We're looking at at least 1 delete or insert, so a window
> <     // begins here (or, rather, optCopyContext lines earlier).
> <     
> <     int boOldWindow = max (0, int (boDeletes) - int(optCopyContext));
> <     int eoOldWindow = min (int (lines[0].size ()), int(o) + int(optCopyContext));
70c1007,1008
< 464a486
---
> >       for (int f = 0; f < 2; f += 1) {
> >         fprintf (stderr, "# file #%d\n", f + 1);
72c1010,1011
< 466a489
---
> >         for (int l = 0; l < lines[f].size (); l += 1) {
> >           fprintf (stderr, "#   [%d] ", l);
74c1013,1028
< 482a506
---
> >           lines[f][l].Dump (stderr);
> >         }
> >       }
> >     }
> >   }
> > }
> > 
> > // Perform Pass #5, in which we look for blocks which match, but are
> > // the result of a move (their not in their original position).  For
> > // these, we'll unmatch the blocks, turning them into a delete and an
> > // insert.
> > 
> > void pass5 ()
> > {
> >   if (0 < optVerbose) {
> >     fprintf (stderr, "# Pass #5 (unmatching block moves)...\n");
76c1030,1177
< 630a655
---
> >   }
> > 
> >   nMatchedBlocks = 0;
> >   nMatchedLines = 0;
> > 
> >   // Starting at the top of both files,...
> > 
> >   unsigned o = 0;
> >   unsigned n = 0;
> > 
> >   while (o < lines[0].size () || n < lines[1].size ()) {
> > 
> >     // Skip any unmatched lines at this point in the old file.  These
> >     // are deletes.
> > 
> >     //    Old     New
> >     //   +---+
> >     // 0 | a |
> >     //   +---+   +---+
> >     //         0 | b |
> >     //   +---+   +---+
> >     // 1 | c | 1 | c |
> >     //   +---+   +---+
> >     //         2 | z |
> >     //   +---+   +---+
> >     // 2 | d | 3 | d |
> >     //   +---+   +---+
> > 
> >     while (o < lines[0].size () && lines[0][o].l == ~0) {
> >       o += 1;
> >     }
> > 
> >     // Skip any unmatched lines at this point in the new file.  These
> >     // are inserts.
> > 
> >     while (n < lines[1].size () && lines[1][n].l == ~0) {
> >       n += 1;
> >     }
> > 
> >     // When we get here, we know that we're dealing with matching
> >     // lines (or the end of one or both files).  We're done with this
> >     // pass, if we've reached the end of either file.
> > 
> >     if (lines[0].size () <= o || lines[1].size () <= n) {
> >       break;
> >     }
> > 
> >     // We now know that we've got a pair of matching lines, the start
> >     // of a matching block.  If the new file's line number is what we
> >     // expect, then the matched pair is unmoved, and we can skip over
> >     // the pair.  (If this is really the start of a block of more than
> >     // 1 lines, we'll handle it one pair at a time.)
> > 
> >     if (lines[0][o].l == n) {
> >       o += 1;
> >       n += 1;
> >       continue;
> >     }
> > 
> >     // If, on the other hand, we don't expect this [new] line number,
> >     // then this matching block has been moved.  We need to turn the
> >     // matched pair into an *unmatched* pair, one of deletes, and one
> >     // of inserts.  First, though, we need to know how big this block
> >     // is, and how far it was moved....
> > 
> >     // Remember where we were when we started.
> > 
> >     unsigned oOld = o;
> >     unsigned nOld = n;
> > 
> >     // Remember where the block came from.
> > 
> >     unsigned nNew = lines[0][o].l;
> > 
> >     // Find the end of this matched pair.
> > 
> >     for (n = nNew; o < lines[0].size () && n < lines[1].size (); o += 1, n += 1) {
> >       if (lines[0][o].l != n) {
> >         break;
> >       }
> >     }
> > 
> >     // When we get here:
> >     // * oOld..o is the old file's block,
> >     // * nNew..n is the new file's *moved* block, and
> >     // * nOld is where we originally expected the new block from.
> >  
> >     // We can now calculate the length of the block...
> >     
> >     unsigned bSize = o - oOld;  // (or n - nNew)
> > 
> >     // ... and we can calculate how far the block moved:
> > 
> >     unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
> > 
> >     // The larger of the two will become our delete, and the smaller
> >     // will become our insert.
> > 
> >     //    Old     New
> >     //   +---+   +---+
> >     // 0 | a | 0 | b |
> >     //   +---+ 1 | b |
> >     // 1 | b |   +---+
> >     // 2 | b | 2 | a |
> >     //   +---+   +---+
> >     // 3 | c | 3 | c |
> >     //   +---+   +---+
> > 
> >     // (1) Delete a@0, insert a@2, or
> >     // (2) insert bb@0, delete bb@1?
> > 
> >     // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and bMove
> >     // (of a) is 2-0 or 2, the size of b@0.  We choose to delete a@0,
> >     // and reinsert a@2.
> > 
> >     // if (bSize <= bMove) {
> >       for (unsigned a = oOld; a < o; a += 1) {
> >         lines[0][a].l = ~0;
> >       }
> >       for (unsigned d = nNew; d < n; d += 1) {
> >         lines[1][d].l = ~0;
> >       }
> >     // } else {
> >       // for (unsigned a = oOld; a < o; a += 1) {
> >       //   lines[0][a].l = ~0;
> >       // }
> >       // for (unsigned d = nNew; d < n; d += 1) {
> >       //   lines[1][d].l = ~0;
> >       // }
> >     // }
> > 
> >     // Continue from where we left off.
> > 
> >     n = nOld;
> >   }
> >   nTotalMatchedLines -= nMatchedLines;
> >   nTotalMatchedBlocks -= nMatchedBlocks;
> > 
> >   // Let's see the intermediate results.
> > 
> >   if (0 < optVerbose) {
> >     fprintf (stderr,
> >              " found %u/%u matched lines/blocks (%u/%u totals).\n",
> >              nMatchedLines,
> >              nMatchedBlocks,
> >              nTotalMatchedLines,
> >              nTotalMatchedBlocks
> >             );
78,79c1179,1180
< 632c657
< <     if (1 < optVerbose) {
---
> 743c657,770
> <     // Look for the end of the window.
82c1183,1184
< 634a660
---
> >       for (int f = 0; f < 2; f += 1) {
> >         fprintf (stderr, "# file #%d\n", f + 1);
84c1186,1187
< 636a663
---
> >         for (int l = 0; l < lines[f].size (); l += 1) {
> >           fprintf (stderr, "#   [%d] ", l);
86c1189,1204
< 652a680
---
> >           lines[f][l].Dump (stderr);
> >         }
> >       }
> >     }
> >   }
> > }
> > 
> > // Perform Pass #6, in which we create the desired output.
> > 
> > void pass6c ();
> > void pass6e ();
> > void pass6i ();
> > void pass6n ();
> > void pass6r ();
> > void pass6s ();
> > void pass6u ();
88,90c1206,1231
< 679c707
< <     pass6s ();
< ---
---
> > 
> > void pass6 ()
> > {
> > 
> >   switch (diffFormat) {
> >   case Context:
> >     pass6c ();
> >     break;
> > 
> >   case EdScript:
> >     pass6e ();
> >     break;
> > 
> >   case IfThenElse:
> >     pass6i ();
> >     break;
> > 
> >   case Normal:
> >     pass6n ();
> >     break;
> > 
> >   case RCS:
> >     pass6r ();
> >     break;
> > 
> >   case SideBySide:
92,94c1233,1261
< 709c737,738
< <     fprintf (stderr, "# Pass #6u (walking the differences)...\n");
< ---
---
> >     break;
> > 
> >   case Unified:
> >     pass6u ();
> >     break;
> > 
> >   case Default:
> >   default:
> >     pass6c ();
> >     break;
> >   }
> > }
> > 
> > template<typename T> T min (T l, T r) {
> >   if (l < r) {
> >     return l;
> >   }
> >   return r;
> > }
> > 
> > template<typename T> T max (T l, T r) {
> >   if (l < r) {
> >     return r;
> >   }
> >   return l;
> > }
> > 
> > void pass6c () {
> >   if (0 < optVerbose) {
97,99c1264,1290
< 737c766
< <     // We're looking at at least 1 delete or insert, so a window
< ---
---
> >   }
> > 
> >   nMatchedLines = 0;
> > 
> >   // Write the header.
> > 
> >   fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
> >   fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
> > 
> >   // Starting at the top of both files,...
> > 
> >   unsigned o = 0;
> >   unsigned n = 0;
> > 
> >   while (o < lines[0].size () || n < lines[1].size ()) {
> > 
> >     // Find the bounds of the current contextual 'window'.
> > 
> >     // If we aren't looking at a delete or an insert, we're not at the
> >     // start of a context window.
> > 
> >     if (lines[0][o].l != ~0 && lines[1][n].l != ~0) {
> >       o += 1;
> >       n += 1;
> >       continue;
> >     }
> > 
101,104c1292,1293
< 740,741c769,770
< <     int boOldWindow = max (0, int (boDeletes) - int(optCopyContext));
< <     int eoOldWindow = min (int (lines[0].size ()), int(o) + int(optCopyContext));
< ---
---
> >     // begins here (or, rather, optCopyContext lines earlier).
> >     
107,114c1296
< 743c772,775
< <     // Look for the end of the window.
< ---
< >     if (1 < optVerbose) {
< >       fprintf (stderr, "boOldWindow = %d, boNewWindow = %d\n", boOldWindow, boNewWindow);
< >       fflush (stderr);
< >     }
< 745,746c777,783
---
> 745,840c772,774
116a1299,1392
> < 
> <       // Skip over the delete(s) and/or insert(s) defining the current
> <       // context.
> < 
> <       while (o < lines[0].size () && lines[0][o].l == ~0) {
> <         o += 1;
> <       }
> <       while (n < lines[1].size () && lines[1][n].l == ~0) {
> <         n += 1;
> <       }
> < 
> <       // ...  This context will end optCopyContext lines past the last
> <       // set of deletes or inserts we find.  However, since another
> <       // window could follow, we look 2 * optCopyContext ahead for
> <       // another delete or insert.
> < 
> <       for (unsigned l = 0; l < (2 * optCopyContext); i += 1) {
> <         if (o < lines[0].size ()) {
> <           if (widenWindow |= lines[0][o].l == ~0) {
> <             break;
> <           }
> <           o += 1;
> <         }
> <         if (n < lines[1].size ()) {
> <           if (widenWindow |= lines[1][o].l == ~0) {
> <             break;
> <           }
> <           n += 1;
> <         }
> <       }
> <     } while (widenWindow);
> < 
> <     // We've found the end of the window.
> < 
> <     int boNewWindow = max (0, int (boInserts) - int (optCopyContext));
> <     int eoNewWindow = min (int (lines[1].size ()), int(n) + int (optCopyContext));
> < 
> <     // Now, reset ourselves to the start of the window, and walk it to
> <     // produce the output.  We'll walk it twice, first for the old
> <     // file part, then for the new file part.
> < 
> <     fprintf (stdout, "***************\n");
> <     fprintf (stdout, "*** %d,%d ****\n", boOldWindow + 1, eoOldWindow + 1);
> < 
> <     o = boOldWindow;
> <     n = boNewWindow;
> < 
> <     while (o < eoOldWindow && n < eoNewWindow) {
> < 
> <       // Find any unmatched lines at this point in the old file.  These
> <       // are deletes.
> < 
> <       unsigned boDeletes = o;
> <       while (o < eoOldWindow && lines[0][o].l == ~0) {
> <         o += 1;
> <       }
> < 
> <       // Find any unmatched lines at this point in the new file.  These
> <       // are inserts.
> < 
> <       unsigned boInserts = n;
> <       while (n < eoNewWindow && lines[1][n].l == ~0) {
> <         n += 1;
> <       }
> < 
> <       // We've got deleted line(s) from boDeletes .. o.
> <       // We've got deleted line(s) from boInserts .. n.
> < 
> <       unsigned nDeletes = o - boDeletes;
> <       unsigned nInserts = n - boInserts;
> < 
> <       // We've got...
> < 
> <       if (nDeletes && nInserts) {
> < 
> <         // ... deletes and inserts.
> < 
> <         for (unsigned l = boDeletes; l < o; l += 1) {
> <           fprintf (stdout, "! %s", lines[0][l].line->c_str ());
> <         }
> <       } else if (nDeletes) {
> < 
> <         //  ... just deletes.
> < 
> <         for (unsigned l = boDeletes; l < o; l += 1) {
> <           fprintf (stdout, "- %s", lines[0][l].line->c_str ());
> <         }
> <       }
> < 
> <       // When we get here, we're dealing with matching lines.
> < 
> <       fprintf (stdout, "  %s", lines[0][l].line->c_str ());
> <       o += 1;
> <       n += 1;
118c1394,1397
< >     // Look for the end of the current window.
---
> >     if (1 < optVerbose) {
> >       fprintf (stderr, "boOldWindow = %d, boNewWindow = %d\n", boOldWindow, boNewWindow);
> >       fflush (stderr);
> 841a776,777
119a1399,1459
> >     // Look for the end of the current window.
> 843,900c779,780
> <     fprintf (stdout, "--- %d,%d ----\n", boNewWindow + 1, eoNewWindow + 1);
> < 
> <     o = boOldWindow;
> <     n = boNewWindow;
> < 
> <     while (o < eoOldWindow && n < eoNewWindow) {
> < 
> <       // Find any unmatched lines at this point in the old file.  These
> <       // are deletes.
> < 
> <       unsigned boDeletes = o;
> <       while (o < eoOldWindow && lines[0][o].l == ~0) {
> <         o += 1;
> <       }
> < 
> <       // Find any unmatched lines at this point in the new file.  These
> <       // are inserts.
> < 
> <       unsigned boInserts = n;
> <       while (n < eoNewWindow && lines[1][n].l == ~0) {
> <         n += 1;
> <       }
> < 
> <       // We've got deleted line(s) from boDeletes .. o.
> <       // We've got deleted line(s) from boInserts .. n.
> < 
> <       unsigned nDeletes = o - boDeletes;
> <       unsigned nInserts = n - boInserts;
> < 
> <       // We've got...
> < 
> <       if (nDeletes && nInserts) {
> < 
> <         // ... deletes and inserts.
> < 
> <         for (unsigned l = boInserts; l < n; l += 1) {
> <           fprintf (stdout, "! %s", lines[1][l].line->c_str ());
> <         }
> <       } else if (nInserts) {
> < 
> <         //  ... just inserts.
> < 
> <         for (unsigned l = boInserts; l < n; l += 1) {
> <           fprintf (stdout, "+ %s", lines[1][l].line->c_str ());
> <         }
> <       }
> < 
> <       // When we get here, we're dealing with matching lines.
> < 
> <       fprintf (stdout, "  %s", lines[1][l].line->c_str ());
> <       o += 1;
> <       n += 1;
> <     }
> <   }
> < }
> < 
> < void pass6e () {
> < }
> ---
122c1462,1564
< > 
---
> 902,1002c782,796
> < void pass6i () {
> < }
> < 
> < void pass6n ()
> < {
> <   if (0 < optVerbose) {
> <     fprintf (stderr, "# Pass #6n (walking the differences)...\n");
> <   }
> < 
> <   nMatchedLines = 0;
> < 
> <   // Write the header.  (None for normal.)
> < 
> <   // Starting at the top of both files,...
> < 
> <   unsigned o = 0;
> <   unsigned n = 0;
> < 
> <   while (o < lines[0].size () || n < lines[1].size ()) {
> < 
> <     // Find any unmatched lines at this point in the old file.  These
> <     // are deletes.
> < 
> <     unsigned boDeletes;
> <     for (boDeletes = o;
> <          o < lines[0].size () && lines[0][o].l == ~0;
> <          o += 1
> <         )
> <     {}
> < 
> <     // Find any unmatched lines at this point in the new file.  These
> <     // are inserts.
> < 
> <     unsigned boInserts;
> <     for (boInserts = n;
> <          n < lines[1].size () && lines[1][n].l == ~0;
> <          n += 1
> <         )
> <     {}
> < 
> <     // We've got deleted line(s) from boDeletes .. o.
> <     // We've got deleted line(s) from boInserts .. n.
> < 
> <     unsigned nDeletes = o - boDeletes;
> <     unsigned nInserts = n - boInserts;
> < 
> <     // We've got...
> < 
> <     if (nDeletes && nInserts) {
> < 
> <       // ... deletes and inserts.
> < 
> <       if (1 < nDeletes && 1 < nInserts) {
> <         fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, boInserts + 1, n);
> <       } else if (1 < nDeletes) {
> <         fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boInserts + 1);
> <       } else if (1 < nInserts) {
> <         fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInserts + 1, n);
> <       } 
> <       for (unsigned l = boDeletes; l < o; l += 1) {
> <         fprintf (stdout, "< %s", lines[0][l].line->c_str ());
> <       }
> <       fprintf (stderr, "---\n");
> <       for (unsigned l = boInserts; l < n; l += 1) {
> <         fprintf (stdout, "> %s", lines[1][l].line->c_str ());
> <       }
> <     } else if (nDeletes) {
> < 
> <       //  ... just deletes.
> < 
> <       if (1 < nDeletes) {
> <         fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
> <       } else {
> <         fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
> <       }
> <       for (unsigned l = boDeletes; l < o; l += 1) {
> <         fprintf (stdout, "< %s", lines[0][l].line->c_str ());
> <       }
> <     } else if (nInserts) {
> < 
> <       //  ... just inserts.
> < 
> <       if (1 < nInserts) {
> <         fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
> <       } else {
> <         fprintf (stdout, "%da%d\n", o, boInserts + 1);
> <       }
> <       for (unsigned l = boInserts; l < n; l += 1) {
> <         fprintf (stdout, "> %s", lines[1][l].line->c_str ());
> <       }
> <     }
> < 
> <     // When we get here, we're dealing with matching lines.
> < 
> <     o += 1;
> <     n += 1;
> <   }
> < }
> < 
> < void pass6r () {
> < }
> ---
125,130c1567,1577
< 758,761c795,796
< <       // ...  This context will end optCopyContext lines past the last
< <       // set of deletes or inserts we find.  However, since another
< <       // window could follow, we look 2 * optCopyContext ahead for
< <       // another delete or insert.
< ---
---
> > 
> >       // Skip over the delete(s) and/or insert(s) defining the current
> >       // context.
> > 
> >       while (o < lines[0].size () && lines[0][o].l == ~0) {
> >         o += 1;
> >       }
> >       while (n < lines[1].size () && lines[1][n].l == ~0) {
> >         n += 1;
> >       }
> > 
133,134c1580,1657
< 763c798,799
< <       for (unsigned l = 0; l < (2 * optCopyContext); i += 1) {
---
> 1004,1080c798,808
> < void pass6s () {
> < }
> < 
> < void pass6u ()
> < {
> <   if (0 < optVerbose) {
> <     fprintf (stderr, "# Pass #6u (walking the differences)...\n");
> <   }
> < 
> <   nMatchedLines = 0;
> < 
> <   // Write the header.
> < 
> <   fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
> <   fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
> <   fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), lines[1].size ());
> < 
> <   // Starting at the top of both files,...
> < 
> <   unsigned o = 0;
> <   unsigned n = 0;
> < 
> <   while (o < lines[0].size () || n < lines[1].size ()) {
> < 
> <     // Find any unmatched lines at this point in the old file.  These
> <     // are deletes.
> < 
> <     unsigned boDeletes;
> <     for (boDeletes = o;
> <          o < lines[0].size () && lines[0][o].l == ~0;
> <          o += 1
> <         )
> <     {}
> < 
> <     // Find any unmatched lines at this point in the new file.  These
> <     // are inserts.
> < 
> <     unsigned boInserts;
> <     for (boInserts = n;
> <          n < lines[1].size () && lines[1][n].l == ~0;
> <          n += 1
> <         )
> <     {}
> < 
> <     // We've got deleted line(s) from boDeletes .. o.
> <     // We've got deleted line(s) from boInserts .. n.
> < 
> <     unsigned nDeletes = o - boDeletes;
> <     unsigned nInserts = n - boInserts;
> < 
> <     // We've got...
> < 
> <     if (nDeletes && nInserts) {
> < 
> <       // ... deletes and inserts.
> < 
> <       for (unsigned l = boDeletes; l < o; l += 1) {
> <         fprintf (stdout, "-%s", lines[0][l].line->c_str ());
> <       }
> <       for (unsigned l = boInserts; l < n; l += 1) {
> <         fprintf (stdout, "+%s", lines[1][l].line->c_str ());
> <       }
> <     } else if (nDeletes) {
> < 
> <       //  ... just deletes.
> < 
> <       for (unsigned l = boDeletes; l < o; l += 1) {
> <         fprintf (stdout, "-%s", lines[0][l].line->c_str ());
> <       }
> <     } else if (nInserts) {
> < 
> <       //  ... just inserts.
> < 
> <       for (unsigned l = boInserts; l < n; l += 1) {
> <         fprintf (stdout, "+%s", lines[1][l].line->c_str ());
> <       }
> <     }
138,142c1661
< 765,767c801
< <           if (widenWindow |= lines[0][o].l == ~0) {
< <             break;
< <           }
< ---
---
> >         if (o < lines[0].size ()) {
144,148c1663,1665
< 771,773c805
< <           if (widenWindow |= lines[1][o].l == ~0) {
< <             break;
< <           }
< ---
---
> >           o += 1;
> >         }
> >         if (n < lines[1].size ()) {
150,151c1667,1671
< 777c809,828
< <     } while (widenWindow);
---
> >           n += 1;
> >         }
> >       }
> 1082c810,811
> <     // When we get here, we're dealing with matching lines.
153d1672
< > 
156c1675,1677
< > 
---
> 1084c813,1248
> <     fprintf (stdout, " %s", lines[0][o].line->c_str ());
> ---
173,176c1694,1696
< 781,782c832,835
< <     int boNewWindow = max (0, int (boInserts) - int (optCopyContext));
< <     int eoNewWindow = min (int (lines[1].size ()), int(n) + int (optCopyContext));
< ---
---
> > 
> >     // We've found the end of the window.
> > 
181,183c1701,1706
< 789c842
< <     fprintf (stdout, "*** %d,%d ****\n", boOldWindow + 1, eoOldWindow + 1);
< ---
---
> > 
> >     // Now, reset ourselves to the start of the window, and walk it to
> >     // produce the output.  We'll walk it twice, first for the old
> >     // file part, then for the new file part.
> > 
> >     fprintf (stdout, "***************\n");
185,187c1708,1711
< 794c847
< <     while (o < eoOldWindow && n < eoNewWindow) {
< ---
---
> > 
> >     o = boOldWindow;
> >     n = boNewWindow;
> > 
189,191c1713,1742
< 825c878
< <           fprintf (stdout, "! %s", lines[0][l].line->c_str ());
< ---
---
> > 
> >       // Find any unmatched lines at this point in the old file.  These
> >       // are deletes.
> > 
> >       unsigned boDeletes = o;
> >       while (o < eoOldWindow && lines[0][o].l == ~0) {
> >         o += 1;
> >       }
> > 
> >       // Find any unmatched lines at this point in the new file.  These
> >       // are inserts.
> > 
> >       unsigned boInserts = n;
> >       while (n < eoNewWindow && lines[1][n].l == ~0) {
> >         n += 1;
> >       }
> > 
> >       // We've got deleted line(s) from boDeletes .. o.
> >       // We've got deleted line(s) from boInserts .. n.
> > 
> >       unsigned nDeletes = o - boDeletes;
> >       unsigned nInserts = n - boInserts;
> > 
> >       // We've got...
> > 
> >       if (nDeletes && nInserts) {
> > 
> >         // ... deletes and inserts.
> > 
> >         for (unsigned l = boDeletes; l < o; l += 1) {
193,195c1744,1749
< 832c885
< <           fprintf (stdout, "- %s", lines[0][l].line->c_str ());
< ---
---
> >         }
> >       } else if (nDeletes) {
> > 
> >         //  ... just deletes.
> > 
> >         for (unsigned l = boDeletes; l < o; l += 1) {
197,199c1751,1755
< 838c891
< <       fprintf (stdout, "  %s", lines[0][l].line->c_str ());
< ---
---
> >         }
> >       }
> > 
> >       // When we get here, we're dealing with matching lines.
> > 
201,203c1757,1760
< 843c896
< <     fprintf (stdout, "--- %d,%d ----\n", boNewWindow + 1, eoNewWindow + 1);
< ---
---
> >       o += 1;
> >       n += 1;
> >     }
> > 
205,207c1762,1796
< 879c932
< <           fprintf (stdout, "! %s", lines[1][l].line->c_str ());
< ---
---
> > 
> >     o = boOldWindow;
> >     n = boNewWindow;
> > 
> >     while (o < eoOldWindow && n < eoNewWindow) {
> > 
> >       // Find any unmatched lines at this point in the old file.  These
> >       // are deletes.
> > 
> >       unsigned boDeletes = o;
> >       while (o < eoOldWindow && lines[0][o].l == ~0) {
> >         o += 1;
> >       }
> > 
> >       // Find any unmatched lines at this point in the new file.  These
> >       // are inserts.
> > 
> >       unsigned boInserts = n;
> >       while (n < eoNewWindow && lines[1][n].l == ~0) {
> >         n += 1;
> >       }
> > 
> >       // We've got deleted line(s) from boDeletes .. o.
> >       // We've got deleted line(s) from boInserts .. n.
> > 
> >       unsigned nDeletes = o - boDeletes;
> >       unsigned nInserts = n - boInserts;
> > 
> >       // We've got...
> > 
> >       if (nDeletes && nInserts) {
> > 
> >         // ... deletes and inserts.
> > 
> >         for (unsigned l = boInserts; l < n; l += 1) {
209,211c1798,1803
< 886c939
< <           fprintf (stdout, "+ %s", lines[1][l].line->c_str ());
< ---
---
> >         }
> >       } else if (nInserts) {
> > 
> >         //  ... just inserts.
> > 
> >         for (unsigned l = boInserts; l < n; l += 1) {
213,215c1805,1809
< 892c945
< <       fprintf (stdout, "  %s", lines[1][l].line->c_str ());
< ---
---
> >         }
> >       }
> > 
> >       // When we get here, we're dealing with matching lines.
> > 
217c1811,1813
< 895a949,953
---
> >       o += 1;
> >       n += 1;
> >     }
223c1819,1822
< 899a958,959
---
> >   }
> > }
> > 
> > void pass6e () {
226c1825,1827
< 902a963,964
---
> > }
> > 
> > void pass6i () {
229c1830,1835
< 908a971
---
> > }
> > 
> > void pass6n ()
> > {
> >   if (0 < optVerbose) {
> >     fprintf (stderr, "# Pass #6n (walking the differences)...\n");
231,233c1837,1889
< 962c1025
< <         fprintf (stdout, "< %s", lines[0][l].line->c_str ());
< ---
---
> >   }
> > 
> >   nMatchedLines = 0;
> > 
> >   // Write the header.  (None for normal.)
> > 
> >   // Starting at the top of both files,...
> > 
> >   unsigned o = 0;
> >   unsigned n = 0;
> > 
> >   while (o < lines[0].size () || n < lines[1].size ()) {
> > 
> >     // Find any unmatched lines at this point in the old file.  These
> >     // are deletes.
> > 
> >     unsigned boDeletes;
> >     for (boDeletes = o;
> >          o < lines[0].size () && lines[0][o].l == ~0;
> >          o += 1
> >         )
> >     {}
> > 
> >     // Find any unmatched lines at this point in the new file.  These
> >     // are inserts.
> > 
> >     unsigned boInserts;
> >     for (boInserts = n;
> >          n < lines[1].size () && lines[1][n].l == ~0;
> >          n += 1
> >         )
> >     {}
> > 
> >     // We've got deleted line(s) from boDeletes .. o.
> >     // We've got deleted line(s) from boInserts .. n.
> > 
> >     unsigned nDeletes = o - boDeletes;
> >     unsigned nInserts = n - boInserts;
> > 
> >     // We've got...
> > 
> >     if (nDeletes && nInserts) {
> > 
> >       // ... deletes and inserts.
> > 
> >       if (1 < nDeletes && 1 < nInserts) {
> >         fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, boInserts + 1, n);
> >       } else if (1 < nDeletes) {
> >         fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boInserts + 1);
> >       } else if (1 < nInserts) {
> >         fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInserts + 1, n);
> >       } 
> >       for (unsigned l = boDeletes; l < o; l += 1) {
235,237c1891
< 964c1027
< <       fprintf (stderr, "---\n");
< ---
---
> >       }
239,241c1893
< 966c1029
< <         fprintf (stdout, "> %s", lines[1][l].line->c_str ());
< ---
---
> >       for (unsigned l = boInserts; l < n; l += 1) {
243,245c1895,1905
< 978c1041
< <         fprintf (stdout, "< %s", lines[0][l].line->c_str ());
< ---
---
> >       }
> >     } else if (nDeletes) {
> > 
> >       //  ... just deletes.
> > 
> >       if (1 < nDeletes) {
> >         fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
> >       } else {
> >         fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
> >       }
> >       for (unsigned l = boDeletes; l < o; l += 1) {
247,249c1907,1917
< 990c1053
< <         fprintf (stdout, "> %s", lines[1][l].line->c_str ());
< ---
---
> >       }
> >     } else if (nInserts) {
> > 
> >       //  ... just inserts.
> > 
> >       if (1 < nInserts) {
> >         fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
> >       } else {
> >         fprintf (stdout, "%da%d\n", o, boInserts + 1);
> >       }
> >       for (unsigned l = boInserts; l < n; l += 1) {
251c1919,1929
< 1001a1065,1066
---
> >       }
> >     }
> > 
> >     // When we get here, we're dealing with matching lines.
> > 
> >     o += 1;
> >     n += 1;
> >   }
> > }
> > 
> > void pass6r () {
254c1932,1934
< 1004a1070,1071
---
> > }
> > 
> > void pass6s () {
257c1937,1942
< 1010a1078
---
> > }
> > 
> > void pass6u ()
> > {
> >   if (0 < optVerbose) {
> >     fprintf (stderr, "# Pass #6u (walking the differences)...\n");
259,261c1944,1993
< 1061c1129
< <         fprintf (stdout, "-%s", lines[0][l].line->c_str ());
< ---
---
> >   }
> > 
> >   nMatchedLines = 0;
> > 
> >   // Write the header.
> > 
> >   fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
> >   fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
> >   fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), lines[1].size ());
> > 
> >   // Starting at the top of both files,...
> > 
> >   unsigned o = 0;
> >   unsigned n = 0;
> > 
> >   while (o < lines[0].size () || n < lines[1].size ()) {
> > 
> >     // Find any unmatched lines at this point in the old file.  These
> >     // are deletes.
> > 
> >     unsigned boDeletes;
> >     for (boDeletes = o;
> >          o < lines[0].size () && lines[0][o].l == ~0;
> >          o += 1
> >         )
> >     {}
> > 
> >     // Find any unmatched lines at this point in the new file.  These
> >     // are inserts.
> > 
> >     unsigned boInserts;
> >     for (boInserts = n;
> >          n < lines[1].size () && lines[1][n].l == ~0;
> >          n += 1
> >         )
> >     {}
> > 
> >     // We've got deleted line(s) from boDeletes .. o.
> >     // We've got deleted line(s) from boInserts .. n.
> > 
> >     unsigned nDeletes = o - boDeletes;
> >     unsigned nInserts = n - boInserts;
> > 
> >     // We've got...
> > 
> >     if (nDeletes && nInserts) {
> > 
> >       // ... deletes and inserts.
> > 
> >       for (unsigned l = boDeletes; l < o; l += 1) {
263,265c1995,1996
< 1064c1132
< <         fprintf (stdout, "+%s", lines[1][l].line->c_str ());
< ---
---
> >       }
> >       for (unsigned l = boInserts; l < n; l += 1) {
267,269c1998,2003
< 1071c1139
< <         fprintf (stdout, "-%s", lines[0][l].line->c_str ());
< ---
---
> >       }
> >     } else if (nDeletes) {
> > 
> >       //  ... just deletes.
> > 
> >       for (unsigned l = boDeletes; l < o; l += 1) {
271,273c2005,2010
< 1078c1146
< <         fprintf (stdout, "+%s", lines[1][l].line->c_str ());
< ---
---
> >       }
> >     } else if (nInserts) {
> > 
> >       //  ... just inserts.
> > 
> >       for (unsigned l = boInserts; l < n; l += 1) {
275,277c2012,2016
< 1084c1152,1248
< <     fprintf (stdout, " %s", lines[0][o].line->c_str ());
< ---
---
> >       }
> >     }
> > 
> >     // When we get here, we're dealing with matching lines.
> > 
# ../sdiff --normal dif.7.cpp dif.6.cpp >& dif.7.6.diff--normal.test
./test: line 46: 23275 Aborted                 (core dumped) ${DIFF} "${option}" "${oSrc}" "${nSrc}" 1>&"${dst}.test"
# dif.7.6.diff--normal ---------------------------------------------------------
0a1
> sdiff: sdiff.cpp:1637: void pass6n(): Assertion `lines[0][o].line == lines[1][n].line' failed.
12d12
< 49c48
18,374c18,31
< 120,121d117
< <         text.erase (text.end () - 1);
< < 
< 134d129
< <         fflush (stderr);
< 138d132
< <       fflush (stderr);
< 146d139
< <     fflush (stderr);
< 176d168
< <     fflush (stderr);
< 219d210
< <     fflush (stderr);
< 221c212
< <     if (2 < optVerbose) {
< ---
< >     if (1 < optVerbose) {
< 224d214
< <         fflush (stderr);
< 227d216
< <           fflush (stderr);
< 242d230
< <     fflush (stderr);
< 319,320c307
< <     fflush (stderr);
< <     if (2 < optVerbose) {
< ---
< >     if (1 < optVerbose) {
< 323d309
< <         fflush (stderr);
< 326d311
< <           fflush (stderr);
< 341d325
< <     fflush (stderr);
< 417d400
< <     fflush (stderr);
< 419c402
< <     if (2 < optVerbose) {
< ---
< >     if (1 < optVerbose) {
< 422d404
< <         fflush (stderr);
< 425d406
< <           fflush (stderr);
< 441d421
< <     fflush (stderr);
< 481d460
< <     fflush (stderr);
< 483c462
< <     if (2 < optVerbose) {
< ---
< >     if (1 < optVerbose) {
< 486d464
< <         fflush (stderr);
< 489d466
< <           fflush (stderr);
< 506d482
< <     fflush (stderr);
< 655d630
< <     fflush (stderr);
< 657c632
< <     if (2 < optVerbose) {
< ---
< >     if (1 < optVerbose) {
< 660d634
< <         fflush (stderr);
< 663d636
< <           fflush (stderr);
< 680d652
< < void pass6y ();
< 707c679
< <     pass6y ();
< ---
< >     pass6s ();
< 737,738c709
< <     fprintf (stderr, "# Pass #6c (walking the differences)...\n");
< <     fflush (stderr);
< ---
< >     fprintf (stderr, "# Pass #6u (walking the differences)...\n");
< 766c737
< <     // We're now looking at at least 1 delete or insert, so a window
< ---
< >     // We're looking at at least 1 delete or insert, so a window
< 769,775c740,741
< <     int boOldWindow = max (0, int (o) - int (optCopyContext));
< <     int boNewWindow = max (0, int (n) - int (optCopyContext));
< < 
< <     if (1 < optVerbose) {
< <       fprintf (stderr, "boOldWindow = %d, boNewWindow = %d\n", boOldWindow, boNewWindow);
< <       fflush (stderr);
< <     }
< ---
< >     int boOldWindow = max (0, int (boDeletes) - int(optCopyContext));
< >     int eoOldWindow = min (int (lines[0].size ()), int(o) + int(optCopyContext));
< 777c743
< <     // Look for the end of the current window.
< ---
< >     // Look for the end of the window.
< 779,783c745,746
< <     int eoOldWindow;
< <     int eoNewWindow;
< < 
< <     bool widenWindow = true;
< <     while (widenWindow && o < lines[0].size () || n < lines[1].size ()) {
< ---
< >     bool widenWindow = false;
< >     do {
< 795,796c758,761
< <       // This context will end optCopyContext matched lines past the
< <       // last set of deletes or inserts we find.
< ---
< >       // ...  This context will end optCopyContext lines past the last
< >       // set of deletes or inserts we find.  However, since another
< >       // window could follow, we look 2 * optCopyContext ahead for
< >       // another delete or insert.
< 798,799c763
< <       widenWindow = false;
< <       for (unsigned l = 0; !widenWindow && l < optCopyContext; l += 1) {
< ---
< >       for (unsigned l = 0; l < (2 * optCopyContext); i += 1) {
< 801c765,767
< <           widenWindow |= lines[0][o].l == ~0;
< ---
< >           if (widenWindow |= lines[0][o].l == ~0) {
< >             break;
< >           }
< 805c771,773
< <           widenWindow |= lines[1][n].l == ~0;
< ---
< >           if (widenWindow |= lines[1][o].l == ~0) {
< >             break;
< >           }
< 809,828c777
< < 
< <       eoOldWindow = o;
< <       eoNewWindow = n;
< < 
< <       // However, since another window could follow, we look
< <       // optCopyContext ahead for another delete or insert.
< < 
< <       if (!widenWindow) {
< <         for (unsigned l = 0; l < (2 * optCopyContext + 1); l += 1) {
< <           if (o < lines[0].size ()) {
< <             widenWindow |= lines[0][o].l == ~0;
< <             o += 1;
< <           }
< <           if (n < lines[1].size ()) {
< <             widenWindow |= lines[1][n].l == ~0;
< <             n += 1;
< <           }
< <         }
< <       }
< <     }
< ---
< >     } while (widenWindow);
< 832,835c781,782
< <     if (1 < optVerbose) {
< <       fprintf (stderr, "eoOldWindow = %d, eoNewWindow = %d\n", eoOldWindow, eoNewWindow);
< <       fflush (stderr);
< <     }
< ---
< >     int boNewWindow = max (0, int (boInserts) - int (optCopyContext));
< >     int eoNewWindow = min (int (lines[1].size ()), int(n) + int (optCopyContext));
< 842c789
< <     fprintf (stdout, "*** %d,%d ****\n", boOldWindow + 1, eoOldWindow);
< ---
< >     fprintf (stdout, "*** %d,%d ****\n", boOldWindow + 1, eoOldWindow + 1);
< 847c794
< <     while (o < eoOldWindow || n < eoNewWindow) {
< ---
< >     while (o < eoOldWindow && n < eoNewWindow) {
< 878c825
< <           fprintf (stdout, "! %s\n", lines[0][l].line->c_str ());
< ---
< >           fprintf (stdout, "! %s", lines[0][l].line->c_str ());
< 885c832
< <           fprintf (stdout, "- %s\n", lines[0][l].line->c_str ());
< ---
< >           fprintf (stdout, "- %s", lines[0][l].line->c_str ());
< 891c838
< <       fprintf (stdout, "  %s\n", lines[0][o].line->c_str ());
< ---
< >       fprintf (stdout, "  %s", lines[0][l].line->c_str ());
< 896c843
< <     fprintf (stdout, "--- %d,%d ----\n", boNewWindow + 1, eoNewWindow);
< ---
< >     fprintf (stdout, "--- %d,%d ----\n", boNewWindow + 1, eoNewWindow + 1);
< 932c879
< <           fprintf (stdout, "! %s\n", lines[1][l].line->c_str ());
< ---
< >           fprintf (stdout, "! %s", lines[1][l].line->c_str ());
< 939c886
< <           fprintf (stdout, "+ %s\n", lines[1][l].line->c_str ());
< ---
< >           fprintf (stdout, "+ %s", lines[1][l].line->c_str ());
< 945c892
< <       fprintf (stdout, "  %s\n", lines[1][n].line->c_str ());
< ---
< >       fprintf (stdout, "  %s", lines[1][l].line->c_str ());
< 949,953d895
< < 
< <     // Reset to the end of the current window.
< < 
< <     o = eoOldWindow;
< <     n = eoNewWindow;
< 958,959d899
< <   fprintf (stderr, "pass6e() is unimplemented!\n");
< <   fflush (stderr);
< 963,964d902
< <   fprintf (stderr, "pass6i() is unimplemented!\n");
< <   fflush (stderr);
< 971d908
< <     fflush (stderr);
< 1025c962
< <         fprintf (stdout, "< %s\n", lines[0][l].line->c_str ());
< ---
< >         fprintf (stdout, "< %s", lines[0][l].line->c_str ());
< 1027c964
< <       fprintf (stdout, "---\n");
< ---
< >       fprintf (stderr, "---\n");
< 1029c966
< <         fprintf (stdout, "> %s\n", lines[1][l].line->c_str ());
< ---
< >         fprintf (stdout, "> %s", lines[1][l].line->c_str ());
< 1041c978
< <         fprintf (stdout, "< %s\n", lines[0][l].line->c_str ());
< ---
< >         fprintf (stdout, "< %s", lines[0][l].line->c_str ());
< 1053c990
< <         fprintf (stdout, "> %s\n", lines[1][l].line->c_str ());
< ---
< >         fprintf (stdout, "> %s", lines[1][l].line->c_str ());
< 1065,1066d1001
< <   fprintf (stderr, "pass6r() is unimplemented!\n");
< <   fflush (stderr);
< 1070,1071d1004
< <   fprintf (stderr, "pass6s() is unimplemented!\n");
< <   fflush (stderr);
< 1078d1010
< <     fflush (stderr);
< 1129c1061
< <         fprintf (stdout, "-%s\n", lines[0][l].line->c_str ());
< ---
< >         fprintf (stdout, "-%s", lines[0][l].line->c_str ());
< 1132c1064
< <         fprintf (stdout, "+%s\n", lines[1][l].line->c_str ());
< ---
< >         fprintf (stdout, "+%s", lines[1][l].line->c_str ());
< 1139c1071
< <         fprintf (stdout, "-%s\n", lines[0][l].line->c_str ());
< ---
< >         fprintf (stdout, "-%s", lines[0][l].line->c_str ());
< 1146c1078
< <         fprintf (stdout, "+%s\n", lines[1][l].line->c_str ());
< ---
< >         fprintf (stdout, "+%s", lines[1][l].line->c_str ());
< 1152,1248c1084
< <     fprintf (stdout, " %s\n", lines[0][o].line->c_str ());
< <     o += 1;
< <     n += 1;
< <   }
< < }
< < 
< < void pass6y ()
< < {
< <   if (0 < optVerbose) {
< <     fprintf (stderr, "# Pass #6y (walking the differences)...\n");
< <     fflush (stderr);
< <   }
< < 
< <   // Write the header.
< < 
< <   // None for side-by-side.
< < 
< <   // Starting at the top of both files,...
< < 
< <   int columnWidth = (optPageWidth - 7) / 2;
< < 
< <   unsigned o = 0;
< <   unsigned n = 0;
< < 
< <   while (o < lines[0].size () || n < lines[1].size ()) {
< < 
< <     // Find any unmatched lines at this point in the old file.  These
< <     // are deletes.
< < 
< <     unsigned boDeletes = o;
< <     while (o < lines[0].size () && lines[0][o].l == ~0) {
< <       o += 1;
< <     }
< < 
< <     // Find any unmatched lines at this point in the new file.  These
< <     // are inserts.
< < 
< <     unsigned boInserts = n;
< <     while (n < lines[1].size () && lines[1][n].l == ~0) {
< <       n += 1;
< <     }
< < 
< <     // We've got deleted line(s) from boDeletes .. o.
< <     // We've got deleted line(s) from boInserts .. n.
< < 
< <     unsigned nDeletes = o - boDeletes;
< <     unsigned nInserts = n - boInserts;
< < 
< <     // We've got...
< < 
< <     while (boDeletes < o && boInserts < n) {
< < 
< <       // ... deletes and inserts.
< < 
< <       fprintf (stdout,
< <                "%-*s | %s\n",
< <                columnWidth,
< <                lines[0][boDeletes].line->substr (0, columnWidth).c_str (),
< <                lines[1][boInserts].line->substr (0, columnWidth).c_str ()
< <               );
< <       boDeletes += 1;
< <       boInserts += 1;
< <     }
< < 
< <     while (boDeletes < o) {
< < 
< <       //  ... just deletes.
< < 
< <       fprintf (stdout,
< <                "%-*s <\n",
< <                columnWidth,
< <                lines[0][boDeletes].line->substr (0, columnWidth).c_str ()
< <               );
< <       boDeletes += 1;
< <     }
< < 
< <     while (boInserts < n) {
< < 
< <       //  ... just inserts.
< < 
< <       fprintf (stdout,
< <                "%-*s > %s\n",
< <                columnWidth,
< <                "",
< <                lines[1][boInserts].line->substr (0, columnWidth).c_str ()
< <               );
< <       boInserts += 1;
< <     }
< < 
< <     // When we get here, we're dealing with matching lines.
< < 
< <     fprintf (stdout,
< <              "%-*s   %s\n",
< <              columnWidth,
< <              lines[0][o].line->substr (0, columnWidth).c_str (),
< <              lines[1][n].line->substr (0, columnWidth).c_str ()
< <             );
< ---
< >     fprintf (stdout, " %s", lines[0][o].line->c_str ());
---
> 118a117,129
> > 
> >         Line *line = table[text];
> > 
> >         if (!line) {
> >           table[text] = line = new Line (text);
> >           nUniq += 1;
> >         }
> >         line->copies[n].push_back (lines[n].size ());
> >         lines[n].push_back (line);
> >       }
> > 
> >       if (0 < optVerbose) {
> >         fprintf (stderr, " %u lines, %u unique.\n", lines[n].size (), nUniq);
# ../sdiff --normal dif.7.cpp dif.8.cpp >& dif.7.8.diff--normal.test
# dif.7.8.diff--normal ---------------------------------------------------------
54,57c54,61
< 93a117,118
< > void getopts (int argc, char const *const argv[]);
< > 
< 101c126
---
> 94,683c117
> < void pass1 ();
> < void pass2 ();
> < void pass3 ();
> < void pass4 ();
> < void pass5 ();
> < void pass6 ();
> < 
58a63,644
> < {
> <   // Read the old [0] file, and the new [1] file.
> < 
> <   for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
> <     files[n] = argv[a];
> < 
> <     if (FILE *f = fopen (files[n], "r")) {
> <       if (0 < optVerbose) {
> <         fprintf (stderr, "# Reading %s...", files[n]);
> <         fflush (stderr);
> <       }
> < 
> <       char buffer[1024];
> <       unsigned nUniq = 0;
> < 
> <       while (fgets (buffer, sizeof (buffer), f)) {
> <         string text (buffer);
> < 
> <         text.erase (text.end () - 1);
> < 
> <         Line *line = table[text];
> < 
> <         if (!line) {
> <           table[text] = line = new Line (text);
> <           nUniq += 1;
> <         }
> <         line->copies[n].push_back (lines[n].size ());
> <         lines[n].push_back (line);
> <       }
> < 
> <       if (0 < optVerbose) {
> <         fprintf (stderr, " %u lines, %u unique.\n", lines[n].size (), nUniq);
> <         fflush (stderr);
> <       }
> <     } else {
> <       fprintf (stderr, "%s: Unable to open %s!  Exiting....\n", ARGV0, files[n]);
> <       fflush (stderr);
> <       perror (ARGV0);
> <       exit (1);
> <     }
> <   }
> < 
> <   if (0 < optVerbose) {
> <     fprintf (stderr, "# Total unique lines = %d\n", table.size ());
> <     fflush (stderr);
> <   }
> < 
> <   // map<int, int> counts;
> <   // for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> <   //   Line *l = i->second;
> <   //   counts[l->counts[0].size () + l->counts[1].size ()] += 1;
> <   // }
> <   // for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
> <   //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
> <   // }
> < 
> <   pass1 ();
> <   pass2 ();
> <   pass3 ();
> <   pass4 ();
> <   pass5 ();
> <   pass6 ();
> < 
> <   return 0;
> < }
> < 
> < // Perform pass #1, in which we find all explicit matches amongst the
> < // unique lines.  For every unique line that appears the same number
> < // of times in both files, we declare the lines to match.
> < 
> < void pass1 ()
> < {
> <   if (0 < optVerbose) {
> <     fprintf (stderr, "# Pass 1 (finding matches amongst unique lines)...");
> <     fflush (stderr);
> <   }
> < 
> <   nMatchedLines = 0;
> < 
> <   for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> <     Line *l = i->second;
> < 
> <     // If the number of old and new lines match, then we declare that
> <     // they are (all) the same line.  Note, it isn't possible for the
> <     // numbers of both files to be 0.
> < 
> <     // (In the original algorithm, we only recognized a match, here,
> <     // if there was exactly 1 copy for each file.)
> < 
> <     if (l->copies[0].size () == l->copies[1].size ()) {
> <       nMatchedLines += 1;
> < 
> <       // For each matched line in the new file, mark it with the
> <       // corresponding line (number) in the old file.
> < 
> <       while (!l->copies[0].empty ()) {
> <         unsigned o = l->copies[0].front ();
> <         unsigned n = l->copies[1].front ();
> < 
> <         // Match up the pair.
> < 
> <         lines[0][o].l = n;
> <         lines[1][n].l = o;
> < 
> <         // Remove the matched line numbers from the lists.
> < 
> <         l->copies[0].pop_front ();
> <         l->copies[1].pop_front ();
> <       }
> <     }
> <   }
> <   nTotalMatchedLines += nMatchedLines;
> < 
> <   // Let's see the intermediate results.
> < 
> <   if (0 < optVerbose) {
> <     fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
> <     fflush (stderr);
> < 
> <     if (2 < optVerbose) {
> <       for (int f = 0; f < 2; f += 1) {
> <         fprintf (stderr, "# file #%d\n", f + 1);
> <         fflush (stderr);
> <         for (int l = 0; l < lines[f].size (); l += 1) {
> <           fprintf (stderr, "#   [%d] ", l);
> <           fflush (stderr);
> <           lines[f][l].Dump (stderr);
> <         }
> <       }
> <     }
> <   }
> < }
> < 
> < // Perform Pass #2, in which we attempt to 'widen' blocks of matched
> < // lines, by appending lines which are the same in both files.
> < 
> < void pass2 ()
> < {
> <   if (0 < optVerbose) {
> <     fprintf (stderr, "# Pass #2 (spreading matches down)...");
> <     fflush (stderr);
> <   }
> < 
> <   nMatchedBlocks = 0;
> <   nMatchedLines = 0;
> < 
> <   // Starting at the top of the old file,...
> < 
> <   for (unsigned o = 0; o < lines[0].size (); o += 1) {
> < 
> <     // ... skip any currently unmatched lines...
> < 
> <     if (lines[0][o].l == ~0) {
> <       continue;
> <     }
> < 
> <     // ... until we find an [already] matched line.  Then, skip over
> <     // the set of 1 or more matched lines, until we reach any
> <     // following, still-unmatched line.
> < 
> <     unsigned n;
> <     do {
> <       n = lines[0][o].l + 1;
> <       o += 1;
> <     } while (o < lines[0].size () && lines[0][o].l != ~0);
> < 
> <     // Now, o - 1 is the line number of the last matched old line, and
> <     // n - 1 is the line number of the last matched new line.  We want
> <     // to add new old and new lines, if they match.
> < 
> <     // Finally, attempt to add unmatched lines to the preceeding
> <     // matched set.
> < 
> <     for (; o < lines[0].size () && lines[0][o].l == ~0; o += 1, n += 1) {
> < 
> <       // If the [next] pair of old and new lines aren't the same line, we're done.
> < 
> <       if (lines[0][o].line != lines[1][n].line) {
> <         break;
> <       }
> < 
> <       // Match up the pair.
> < 
> <       lines[0][o].l = n;
> <       lines[1][n].l = o;
> < 
> <       // Remove the matched line numbers form the lists.
> < 
> <       Line *line = lines[0][o].line;
> <       list<unsigned> &oldCopies = line->copies[0];
> <       list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
> <       if (oL != oldCopies.end ()) {
> <         oldCopies.erase (oL);
> <       }
> <       list<unsigned> &newCopies = line->copies[0];
> <       list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
> <       if (nL != newCopies.end ()) {
> <         newCopies.erase (nL);
> <       }
> < 
> <       nMatchedLines += 1;
> <     }
> <     nMatchedBlocks += 1;
> <   }
> <   nTotalMatchedLines += nMatchedLines;
> <   nTotalMatchedBlocks += nMatchedBlocks;
> < 
> <   // Let's see the intermediate results.
> < 
> <   if (0 < optVerbose) {
> <     fprintf (stderr,
> <              " found %u/%u matched lines/blocks (%u/%u totals).\n",
> <              nMatchedLines,
> <              nMatchedBlocks,
> <              nTotalMatchedLines,
> <              nTotalMatchedBlocks
> <             );
> <     fflush (stderr);
> <     if (2 < optVerbose) {
> <       for (int f = 0; f < 2; f += 1) {
> <         fprintf (stderr, "# file #%d\n", f + 1);
> <         fflush (stderr);
> <         for (int l = 0; l < lines[f].size (); l += 1) {
> <           fprintf (stderr, "#   [%d] ", l);
> <           fflush (stderr);
> <           lines[f][l].Dump (stderr);
> <         }
> <       }
> <     }
> <   }
> < }
> < 
> < // Perform Pass #3, in which we attempt to 'widen' blocks of matched
> < // lines, by prepending lines which are the same in both files.
> < 
> < void pass3 ()
> < {
> <   if (0 < optVerbose) {
> <     fprintf (stderr, "# Pass #3 (spreading matches up)...");
> <     fflush (stderr);
> <   }
> < 
> <   nMatchedBlocks = 0;
> <   nMatchedLines = 0;
> < 
> <   // Starting at the bottom of the old file,...
> < 
> <   for (int o = lines[0].size (); 0 <= o; o -= 1) {
> < 
> <     // ... skip any currently unmatched lines...
> < 
> <     if (lines[0][o].l == ~0) {
> <       continue;
> <     }
> < 
> <     // ... until we find an [already] matched line.  Then, skip over
> <     // the set of 1 or more matched lines, until we reach any
> <     // following, still-unmatched line.
> < 
> <     unsigned n;
> <     do {
> <       n = lines[0][o].l - 1;
> <       o -= 1;
> <     } while (0 <= o && lines[0][o].l != ~0);
> < 
> <     // Now, o + 1 is the line number of the last matched old line, and
> <     // n + 1 is the line number of the last matched new line.  We want
> <     // to add new old and new lines, if they match.
> < 
> <     // Finally, attempt to add unmatched lines to the preceeding
> <     // matched set.
> < 
> <     for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
> < 
> <       // If the [next] pair of old and new lines aren't the same line, we're done.
> < 
> <       if (lines[0][o].line != lines[1][n].line) {
> <         break;
> <       }
> < 
> <       // Match up the pair.
> < 
> <       lines[0][o].l = n;
> <       lines[1][n].l = o;
> < 
> <       // Remove the matched line numbers form the lists.
> < 
> <       Line *line = lines[0][o].line;
> <       list<unsigned> &oldCopies = line->copies[0];
> <       list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
> <       if (oL != oldCopies.end ()) {
> <         oldCopies.erase (oL);
> <       }
> <       list<unsigned> &newCopies = line->copies[0];
> <       list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
> <       if (nL != newCopies.end ()) {
> <         newCopies.erase (nL);
> <       }
> < 
> <       nMatchedLines += 1;
> <     }
> <     nMatchedBlocks += 1;
> <   }
> <   nTotalMatchedLines += nMatchedLines;
> < 
> <   // Let's see the intermediate results.
> < 
> <   if (0 < optVerbose) {
> <     fprintf (stderr,
> <              " found %u/%u matched lines/blocks (%u/%u totals).\n",
> <              nMatchedLines,
> <              nMatchedBlocks,
> <              nTotalMatchedLines,
> <              nTotalMatchedBlocks
> <             );
> <     fflush (stderr);
> < 
> <     if (2 < optVerbose) {
> <       for (int f = 0; f < 2; f += 1) {
> <         fprintf (stderr, "# file #%d\n", f + 1);
> <         fflush (stderr);
> <         for (int l = 0; l < lines[f].size (); l += 1) {
> <           fprintf (stderr, "#   [%d] ", l);
> <           fflush (stderr);
> <           lines[f][l].Dump (stderr);
> <         }
> <       }
> <     }
> <   }
> < }
> < 
> < // Perform pass #4, in which we find any remaining matches amongst the
> < // unique lines.  For every unique line that has more than 1 copy in
> < // both files, we declare the copies to match.
> < 
> < void pass4 ()
> < {
> <   if (0 < optVerbose) {
> <     fprintf (stderr, "# Pass 4 (finding remaining matches amongst unique lines)...");
> <     fflush (stderr);
> <   }
> < 
> <   nMatchedLines = 0;
> < 
> <   for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> <     Line *l = i->second;
> < 
> <     // If there's more than 1 matching old and new lines, then we
> <     // declare that each pair are (all) the same line.
> < 
> <     // (In the original algorithm, we only recognized a match, here,
> <     // if there was exactly 1 copy for each file.)
> < 
> <     while (0 < l->copies[0].size () && 0 < l->copies[1].size ()) {
> <       nMatchedLines += 1;
> < 
> <       // For each matched line in the new file, mark it with the
> <       // corresponding line (number) in the old file.
> < 
> <       unsigned o = l->copies[0].front ();
> <       unsigned n = l->copies[1].front ();
> < 
> <       // Match up the pair.
> < 
> <       lines[0][o].l = n;
> <       lines[1][n].l = o;
> < 
> <       // Remove the matched line numbers from the lists.
> < 
> <       l->copies[0].pop_front ();
> <       l->copies[1].pop_front ();
> <     }
> <   }
> <   nTotalMatchedLines += nMatchedLines;
> < 
> <   // Let's see the intermediate results.
> < 
> <   if (0 < optVerbose) {
> <     fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
> <     fflush (stderr);
> < 
> <     if (2 < optVerbose) {
> <       for (int f = 0; f < 2; f += 1) {
> <         fprintf (stderr, "# file #%d\n", f + 1);
> <         fflush (stderr);
> <         for (int l = 0; l < lines[f].size (); l += 1) {
> <           fprintf (stderr, "#   [%d] ", l);
> <           fflush (stderr);
> <           lines[f][l].Dump (stderr);
> <         }
> <       }
> <     }
> <   }
> < }
> < 
> < // Perform Pass #5, in which we look for blocks which match, but are
> < // the result of a move (their not in their original position).  For
> < // these, we'll unmatch the blocks, turning them into a delete and an
> < // insert.
> < 
> < void pass5 ()
> < {
> <   if (0 < optVerbose) {
> <     fprintf (stderr, "# Pass #5 (unmatching block moves)...\n");
> <     fflush (stderr);
> <   }
> < 
> <   nMatchedBlocks = 0;
> <   nMatchedLines = 0;
> < 
> <   // Starting at the top of both files,...
> < 
> <   unsigned o = 0;
> <   unsigned n = 0;
> < 
> <   while (o < lines[0].size () || n < lines[1].size ()) {
> < 
> <     // Skip any unmatched lines at this point in the old file.  These
> <     // are deletes.
> < 
> <     //    Old     New
> <     //   +---+
> <     // 0 | a |
> <     //   +---+   +---+
> <     //         0 | b |
> <     //   +---+   +---+
> <     // 1 | c | 1 | c |
> <     //   +---+   +---+
> <     //         2 | z |
> <     //   +---+   +---+
> <     // 2 | d | 3 | d |
> <     //   +---+   +---+
> < 
> <     while (o < lines[0].size () && lines[0][o].l == ~0) {
> <       o += 1;
> <     }
> < 
> <     // Skip any unmatched lines at this point in the new file.  These
> <     // are inserts.
> < 
> <     while (n < lines[1].size () && lines[1][n].l == ~0) {
> <       n += 1;
> <     }
> < 
> <     // When we get here, we know that we're dealing with matching
> <     // lines (or the end of one or both files).  We're done with this
> <     // pass, if we've reached the end of either file.
> < 
> <     if (lines[0].size () <= o || lines[1].size () <= n) {
> <       break;
> <     }
> < 
> <     // We now know that we've got a pair of matching lines, the start
> <     // of a matching block.  If the new file's line number is what we
> <     // expect, then the matched pair is unmoved, and we can skip over
> <     // the pair.  (If this is really the start of a block of more than
> <     // 1 lines, we'll handle it one pair at a time.)
> < 
> <     if (lines[0][o].l == n) {
> <       o += 1;
> <       n += 1;
> <       continue;
> <     }
> < 
> <     // If, on the other hand, we don't expect this [new] line number,
> <     // then this matching block has been moved.  We need to turn the
> <     // matched pair into an *unmatched* pair, one of deletes, and one
> <     // of inserts.  First, though, we need to know how big this block
> <     // is, and how far it was moved....
> < 
> <     // Remember where we were when we started.
> < 
> <     unsigned oOld = o;
> <     unsigned nOld = n;
> < 
> <     // Remember where the block came from.
> < 
> <     unsigned nNew = lines[0][o].l;
> < 
> <     // Find the end of this matched pair.
> < 
> <     for (n = nNew; o < lines[0].size () && n < lines[1].size (); o += 1, n += 1) {
> <       if (lines[0][o].l != n) {
> <         break;
> <       }
> <     }
> < 
> <     // When we get here:
> <     // * oOld..o is the old file's block,
> <     // * nNew..n is the new file's *moved* block, and
> <     // * nOld is where we originally expected the new block from.
> <  
> <     // We can now calculate the length of the block...
> <     
> <     unsigned bSize = o - oOld;  // (or n - nNew)
> < 
> <     // ... and we can calculate how far the block moved:
> < 
> <     unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
> < 
> <     // The larger of the two will become our delete, and the smaller
> <     // will become our insert.
> < 
> <     //    Old     New
> <     //   +---+   +---+
> <     // 0 | a | 0 | b |
> <     //   +---+ 1 | b |
> <     // 1 | b |   +---+
> <     // 2 | b | 2 | a |
> <     //   +---+   +---+
> <     // 3 | c | 3 | c |
> <     //   +---+   +---+
> < 
> <     // (1) Delete a@0, insert a@2, or
> <     // (2) insert bb@0, delete bb@1?
> < 
> <     // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and bMove
> <     // (of a) is 2-0 or 2, the size of b@0.  We choose to delete a@0,
> <     // and reinsert a@2.
> < 
> <     // if (bSize <= bMove) {
> <       for (unsigned a = oOld; a < o; a += 1) {
> <         lines[0][a].l = ~0;
> <       }
> <       for (unsigned d = nNew; d < n; d += 1) {
> <         lines[1][d].l = ~0;
> <       }
> <     // } else {
> <       // for (unsigned a = oOld; a < o; a += 1) {
> <       //   lines[0][a].l = ~0;
> <       // }
> <       // for (unsigned d = nNew; d < n; d += 1) {
> <       //   lines[1][d].l = ~0;
> <       // }
> <     // }
> < 
> <     // Continue from where we left off.
> < 
> <     n = nOld;
> <   }
> <   nTotalMatchedLines -= nMatchedLines;
> <   nTotalMatchedBlocks -= nMatchedBlocks;
> < 
> <   // Let's see the intermediate results.
> < 
> <   if (0 < optVerbose) {
> <     fprintf (stderr,
> <              " found %u/%u matched lines/blocks (%u/%u totals).\n",
> <              nMatchedLines,
> <              nMatchedBlocks,
> <              nTotalMatchedLines,
> <              nTotalMatchedBlocks
> <             );
> <     fflush (stderr);
> < 
> <     if (2 < optVerbose) {
> <       for (int f = 0; f < 2; f += 1) {
> <         fprintf (stderr, "# file #%d\n", f + 1);
> <         fflush (stderr);
> <         for (int l = 0; l < lines[f].size (); l += 1) {
> <           fprintf (stderr, "#   [%d] ", l);
> <           fflush (stderr);
> <           lines[f][l].Dump (stderr);
> <         }
> <       }
> <     }
> <   }
> < }
> < 
> < // Perform Pass #6, in which we create the desired output.
> < 
> < void pass6c ();
> < void pass6e ();
> < void pass6i ();
> < void pass6n ();
> < void pass6r ();
> < void pass6s ();
> < void pass6u ();
> < void pass6y ();
> < 
> < void pass6 ()
> < {
59a646,1140
> > void getopts (int argc, char const *const argv[]);
> 685,1169c119,128
> <   switch (diffFormat) {
> <   case Context:
> <     pass6c ();
> <     break;
> < 
> <   case EdScript:
> <     pass6e ();
> <     break;
> < 
> <   case IfThenElse:
> <     pass6i ();
> <     break;
> < 
> <   case Normal:
> <     pass6n ();
> <     break;
> < 
> <   case RCS:
> <     pass6r ();
> <     break;
> < 
> <   case SideBySide:
> <     pass6y ();
> <     break;
> < 
> <   case Unified:
> <     pass6u ();
> <     break;
> < 
> <   case Default:
> <   default:
> <     pass6c ();
> <     break;
> <   }
> < }
> < 
> < template<typename T> T min (T l, T r) {
> <   if (l < r) {
> <     return l;
> <   }
> <   return r;
> < }
> < 
> < template<typename T> T max (T l, T r) {
> <   if (l < r) {
> <     return r;
> <   }
> <   return l;
> < }
> < 
> < void pass6c () {
> <   if (0 < optVerbose) {
> <     fprintf (stderr, "# Pass #6c (walking the differences)...\n");
> <     fflush (stderr);
> <   }
> < 
> <   nMatchedLines = 0;
> < 
> <   // Write the header.
> < 
> <   fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
> <   fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
> < 
> <   // Starting at the top of both files,...
> < 
> <   unsigned o = 0;
> <   unsigned n = 0;
> < 
> <   while (o < lines[0].size () || n < lines[1].size ()) {
> < 
> <     // Find the bounds of the current contextual 'window'.
> < 
> <     // If we aren't looking at a delete or an insert, we're not at the
> <     // start of a context window.
> < 
> <     if (lines[0][o].l != ~0 && lines[1][n].l != ~0) {
> <       o += 1;
> <       n += 1;
> <       continue;
> <     }
> < 
> <     // We're now looking at at least 1 delete or insert, so a window
> <     // begins here (or, rather, optCopyContext lines earlier).
> <     
> <     int boOldWindow = max (0, int (o) - int (optCopyContext));
> <     int boNewWindow = max (0, int (n) - int (optCopyContext));
> < 
> <     if (1 < optVerbose) {
> <       fprintf (stderr, "boOldWindow = %d, boNewWindow = %d\n", boOldWindow, boNewWindow);
> <       fflush (stderr);
> <     }
> < 
> <     // Look for the end of the current window.
> < 
> <     int eoOldWindow;
> <     int eoNewWindow;
> < 
> <     bool widenWindow = true;
> <     while (widenWindow && o < lines[0].size () || n < lines[1].size ()) {
> < 
> <       // Skip over the delete(s) and/or insert(s) defining the current
> <       // context.
> < 
> <       while (o < lines[0].size () && lines[0][o].l == ~0) {
> <         o += 1;
> <       }
> <       while (n < lines[1].size () && lines[1][n].l == ~0) {
> <         n += 1;
> <       }
> < 
> <       // This context will end optCopyContext matched lines past the
> <       // last set of deletes or inserts we find.
> < 
> <       widenWindow = false;
> <       for (unsigned l = 0; !widenWindow && l < optCopyContext; l += 1) {
> <         if (o < lines[0].size ()) {
> <           widenWindow |= lines[0][o].l == ~0;
> <           o += 1;
> <         }
> <         if (n < lines[1].size ()) {
> <           widenWindow |= lines[1][n].l == ~0;
> <           n += 1;
> <         }
> <       }
> < 
> <       eoOldWindow = o;
> <       eoNewWindow = n;
> < 
> <       // However, since another window could follow, we look
> <       // optCopyContext ahead for another delete or insert.
> < 
> <       if (!widenWindow) {
> <         for (unsigned l = 0; l < (2 * optCopyContext + 1); l += 1) {
> <           if (o < lines[0].size ()) {
> <             widenWindow |= lines[0][o].l == ~0;
> <             o += 1;
> <           }
> <           if (n < lines[1].size ()) {
> <             widenWindow |= lines[1][n].l == ~0;
> <             n += 1;
> <           }
> <         }
> <       }
> <     }
> < 
> <     // We've found the end of the window.
> < 
> <     if (1 < optVerbose) {
> <       fprintf (stderr, "eoOldWindow = %d, eoNewWindow = %d\n", eoOldWindow, eoNewWindow);
> <       fflush (stderr);
> <     }
> < 
> <     // Now, reset ourselves to the start of the window, and walk it to
> <     // produce the output.  We'll walk it twice, first for the old
> <     // file part, then for the new file part.
> < 
> <     fprintf (stdout, "***************\n");
> <     fprintf (stdout, "*** %d,%d ****\n", boOldWindow + 1, eoOldWindow);
> < 
> <     o = boOldWindow;
> <     n = boNewWindow;
> < 
> <     while (o < eoOldWindow || n < eoNewWindow) {
> < 
> <       // Find any unmatched lines at this point in the old file.  These
> <       // are deletes.
> < 
> <       unsigned boDeletes = o;
> <       while (o < eoOldWindow && lines[0][o].l == ~0) {
> <         o += 1;
> <       }
> < 
> <       // Find any unmatched lines at this point in the new file.  These
> <       // are inserts.
> < 
> <       unsigned boInserts = n;
> <       while (n < eoNewWindow && lines[1][n].l == ~0) {
> <         n += 1;
> <       }
> < 
> <       // We've got deleted line(s) from boDeletes .. o.
> <       // We've got deleted line(s) from boInserts .. n.
> < 
> <       unsigned nDeletes = o - boDeletes;
> <       unsigned nInserts = n - boInserts;
> < 
> <       // We've got...
> < 
> <       if (nDeletes && nInserts) {
> < 
> <         // ... deletes and inserts.
> < 
> <         for (unsigned l = boDeletes; l < o; l += 1) {
> <           fprintf (stdout, "! %s\n", lines[0][l].line->c_str ());
> <         }
> <       } else if (nDeletes) {
> < 
> <         //  ... just deletes.
> < 
> <         for (unsigned l = boDeletes; l < o; l += 1) {
> <           fprintf (stdout, "- %s\n", lines[0][l].line->c_str ());
> <         }
> <       }
> < 
> <       // When we get here, we're dealing with matching lines.
> < 
> <       fprintf (stdout, "  %s\n", lines[0][o].line->c_str ());
> <       o += 1;
> <       n += 1;
> <     }
> < 
> <     fprintf (stdout, "--- %d,%d ----\n", boNewWindow + 1, eoNewWindow);
> < 
> <     o = boOldWindow;
> <     n = boNewWindow;
> < 
> <     while (o < eoOldWindow && n < eoNewWindow) {
> < 
> <       // Find any unmatched lines at this point in the old file.  These
> <       // are deletes.
> < 
> <       unsigned boDeletes = o;
> <       while (o < eoOldWindow && lines[0][o].l == ~0) {
> <         o += 1;
> <       }
> < 
> <       // Find any unmatched lines at this point in the new file.  These
> <       // are inserts.
> < 
> <       unsigned boInserts = n;
> <       while (n < eoNewWindow && lines[1][n].l == ~0) {
> <         n += 1;
> <       }
> < 
> <       // We've got deleted line(s) from boDeletes .. o.
> <       // We've got deleted line(s) from boInserts .. n.
> < 
> <       unsigned nDeletes = o - boDeletes;
> <       unsigned nInserts = n - boInserts;
> < 
> <       // We've got...
> < 
> <       if (nDeletes && nInserts) {
> < 
> <         // ... deletes and inserts.
> < 
> <         for (unsigned l = boInserts; l < n; l += 1) {
> <           fprintf (stdout, "! %s\n", lines[1][l].line->c_str ());
> <         }
> <       } else if (nInserts) {
> < 
> <         //  ... just inserts.
> < 
> <         for (unsigned l = boInserts; l < n; l += 1) {
> <           fprintf (stdout, "+ %s\n", lines[1][l].line->c_str ());
> <         }
> <       }
> < 
> <       // When we get here, we're dealing with matching lines.
> < 
> <       fprintf (stdout, "  %s\n", lines[1][n].line->c_str ());
> <       o += 1;
> <       n += 1;
> <     }
> < 
> <     // Reset to the end of the current window.
> < 
> <     o = eoOldWindow;
> <     n = eoNewWindow;
> <   }
> < }
> < 
> < void pass6e () {
> <   fprintf (stderr, "pass6e() is unimplemented!\n");
> <   fflush (stderr);
> < }
> < 
> < void pass6i () {
> <   fprintf (stderr, "pass6i() is unimplemented!\n");
> <   fflush (stderr);
> < }
> < 
> < void pass6n ()
> < {
> <   if (0 < optVerbose) {
> <     fprintf (stderr, "# Pass #6n (walking the differences)...\n");
> <     fflush (stderr);
> <   }
> < 
> <   nMatchedLines = 0;
> < 
> <   // Write the header.  (None for normal.)
> < 
> <   // Starting at the top of both files,...
> < 
> <   unsigned o = 0;
> <   unsigned n = 0;
> < 
> <   while (o < lines[0].size () || n < lines[1].size ()) {
> < 
> <     // Find any unmatched lines at this point in the old file.  These
> <     // are deletes.
> < 
> <     unsigned boDeletes;
> <     for (boDeletes = o;
> <          o < lines[0].size () && lines[0][o].l == ~0;
> <          o += 1
> <         )
> <     {}
> < 
> <     // Find any unmatched lines at this point in the new file.  These
> <     // are inserts.
> < 
> <     unsigned boInserts;
> <     for (boInserts = n;
> <          n < lines[1].size () && lines[1][n].l == ~0;
> <          n += 1
> <         )
> <     {}
> < 
> <     // We've got deleted line(s) from boDeletes .. o.
> <     // We've got deleted line(s) from boInserts .. n.
> < 
> <     unsigned nDeletes = o - boDeletes;
> <     unsigned nInserts = n - boInserts;
> < 
> <     // We've got...
> < 
> <     if (nDeletes && nInserts) {
> < 
> <       // ... deletes and inserts.
> < 
> <       if (1 < nDeletes && 1 < nInserts) {
> <         fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, boInserts + 1, n);
> <       } else if (1 < nDeletes) {
> <         fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boInserts + 1);
> <       } else if (1 < nInserts) {
> <         fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInserts + 1, n);
> <       } 
> <       for (unsigned l = boDeletes; l < o; l += 1) {
> <         fprintf (stdout, "< %s\n", lines[0][l].line->c_str ());
> <       }
> <       fprintf (stdout, "---\n");
> <       for (unsigned l = boInserts; l < n; l += 1) {
> <         fprintf (stdout, "> %s\n", lines[1][l].line->c_str ());
> <       }
> <     } else if (nDeletes) {
> < 
> <       //  ... just deletes.
> < 
> <       if (1 < nDeletes) {
> <         fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
> <       } else {
> <         fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
> <       }
> <       for (unsigned l = boDeletes; l < o; l += 1) {
> <         fprintf (stdout, "< %s\n", lines[0][l].line->c_str ());
> <       }
> <     } else if (nInserts) {
> < 
> <       //  ... just inserts.
> < 
> <       if (1 < nInserts) {
> <         fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
> <       } else {
> <         fprintf (stdout, "%da%d\n", o, boInserts + 1);
> <       }
> <       for (unsigned l = boInserts; l < n; l += 1) {
> <         fprintf (stdout, "> %s\n", lines[1][l].line->c_str ());
> <       }
> <     }
> < 
> <     // When we get here, we're dealing with matching lines.
> < 
> <     o += 1;
> <     n += 1;
> <   }
> < }
> < 
> < void pass6r () {
> <   fprintf (stderr, "pass6r() is unimplemented!\n");
> <   fflush (stderr);
> < }
> < 
> < void pass6s () {
> <   fprintf (stderr, "pass6s() is unimplemented!\n");
> <   fflush (stderr);
> < }
> < 
> < void pass6u ()
> < {
> <   if (0 < optVerbose) {
> <     fprintf (stderr, "# Pass #6u (walking the differences)...\n");
> <     fflush (stderr);
> <   }
> < 
> <   nMatchedLines = 0;
> < 
> <   // Write the header.
> < 
> <   fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
> <   fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
> <   fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), lines[1].size ());
> < 
> <   // Starting at the top of both files,...
> < 
> <   unsigned o = 0;
> <   unsigned n = 0;
> < 
> <   while (o < lines[0].size () || n < lines[1].size ()) {
> < 
> <     // Find any unmatched lines at this point in the old file.  These
> <     // are deletes.
> < 
> <     unsigned boDeletes;
> <     for (boDeletes = o;
> <          o < lines[0].size () && lines[0][o].l == ~0;
> <          o += 1
> <         )
> <     {}
> < 
> <     // Find any unmatched lines at this point in the new file.  These
> <     // are inserts.
> < 
> <     unsigned boInserts;
> <     for (boInserts = n;
> <          n < lines[1].size () && lines[1][n].l == ~0;
> <          n += 1
> <         )
> <     {}
> < 
> <     // We've got deleted line(s) from boDeletes .. o.
> <     // We've got deleted line(s) from boInserts .. n.
> < 
> <     unsigned nDeletes = o - boDeletes;
> <     unsigned nInserts = n - boInserts;
> < 
> <     // We've got...
> < 
> <     if (nDeletes && nInserts) {
> < 
> <       // ... deletes and inserts.
> < 
> <       for (unsigned l = boDeletes; l < o; l += 1) {
> <         fprintf (stdout, "-%s\n", lines[0][l].line->c_str ());
> <       }
> <       for (unsigned l = boInserts; l < n; l += 1) {
> <         fprintf (stdout, "+%s\n", lines[1][l].line->c_str ());
> <       }
> <     } else if (nDeletes) {
> < 
> <       //  ... just deletes.
> < 
> <       for (unsigned l = boDeletes; l < o; l += 1) {
> <         fprintf (stdout, "-%s\n", lines[0][l].line->c_str ());
> <       }
> <     } else if (nInserts) {
> < 
> <       //  ... just inserts.
> < 
> <       for (unsigned l = boInserts; l < n; l += 1) {
> <         fprintf (stdout, "+%s\n", lines[1][l].line->c_str ());
> <       }
> <     }
> < 
> <     // When we get here, we're dealing with matching lines.
> < 
> <     fprintf (stdout, " %s\n", lines[0][o].line->c_str ());
> <     o += 1;
> <     n += 1;
> <   }
> < }
> < 
> < void pass6y ()
> < {
> <   if (0 < optVerbose) {
> <     fprintf (stderr, "# Pass #6y (walking the differences)...\n");
> <     fflush (stderr);
> <   }
> < 
> <   // Write the header.
> < 
> <   // None for side-by-side.
> < 
> <   // Starting at the top of both files,...
> ---
> > void pass1 ();
> > void pass2 ();
> > void pass3 ();
> > void pass4 ();
> > void pass5 ();
> > void pass6 ();
> > 
61c1142
< 102a128,145
---
> > {
63c1144,1146
< > 
---
> 1171c130,1593
> <   int columnWidth = (optPageWidth - 7) / 2;
> ---
80,82c1163,1164
< 105c148
< <   for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
< ---
---
> >   // Read the old [0] file, and the new [1] file.
> > 
84c1166,1227
< 167a211,591
---
> >     files[n] = argv[a];
> > 
> >     if (FILE *f = fopen (files[n], "r")) {
> >       if (0 < optVerbose) {
> >         fprintf (stderr, "# Reading %s...", files[n]);
> >         fflush (stderr);
> >       }
> > 
> >       char buffer[1024];
> >       unsigned nUniq = 0;
> > 
> >       while (fgets (buffer, sizeof (buffer), f)) {
> >         string text (buffer);
> > 
> >         text.erase (text.end () - 1);
> > 
> >         Line *line = table[text];
> > 
> >         if (!line) {
> >           table[text] = line = new Line (text);
> >           nUniq += 1;
> >         }
> >         line->copies[n].push_back (lines[n].size ());
> >         lines[n].push_back (line);
> >       }
> > 
> >       if (0 < optVerbose) {
> >         fprintf (stderr, " %u lines, %u unique.\n", lines[n].size (), nUniq);
> >         fflush (stderr);
> >       }
> >     } else {
> >       fprintf (stderr, "%s: Unable to open %s!  Exiting....\n", ARGV0, files[n]);
> >       fflush (stderr);
> >       perror (ARGV0);
> >       exit (1);
> >     }
> >   }
> > 
> >   if (0 < optVerbose) {
> >     fprintf (stderr, "# Total unique lines = %d\n", table.size ());
> >     fflush (stderr);
> >   }
> > 
> >   // map<int, int> counts;
> >   // for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> >   //   Line *l = i->second;
> >   //   counts[l->counts[0].size () + l->counts[1].size ()] += 1;
> >   // }
> >   // for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
> >   //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
> >   // }
> > 
> >   pass1 ();
> >   pass2 ();
> >   pass3 ();
> >   pass4 ();
> >   pass5 ();
> >   pass6 ();
> > 
> >   return 0;
> > }
> > 
466,470c1609,2124
< 684,686c1108,1109
< < 
< <   switch (diffFormat) {
< <   case Context:
< ---
---
> > // Perform pass #1, in which we find all explicit matches amongst the
> > // unique lines.  For every unique line that appears the same number
> > // of times in both files, we declare the lines to match.
> > 
> > void pass1 ()
> > {
> >   if (0 < optVerbose) {
> >     fprintf (stderr, "# Pass 1 (finding matches amongst unique lines)...");
> >     fflush (stderr);
> >   }
> > 
> >   nMatchedLines = 0;
> > 
> >   for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> >     Line *l = i->second;
> > 
> >     // If the number of old and new lines match, then we declare that
> >     // they are (all) the same line.  Note, it isn't possible for the
> >     // numbers of both files to be 0.
> > 
> >     // (In the original algorithm, we only recognized a match, here,
> >     // if there was exactly 1 copy for each file.)
> > 
> >     if (l->copies[0].size () == l->copies[1].size ()) {
> >       nMatchedLines += 1;
> > 
> >       // For each matched line in the new file, mark it with the
> >       // corresponding line (number) in the old file.
> > 
> >       while (!l->copies[0].empty ()) {
> >         unsigned o = l->copies[0].front ();
> >         unsigned n = l->copies[1].front ();
> > 
> >         // Match up the pair.
> > 
> >         lines[0][o].l = n;
> >         lines[1][n].l = o;
> > 
> >         // Remove the matched line numbers from the lists.
> > 
> >         l->copies[0].pop_front ();
> >         l->copies[1].pop_front ();
> >       }
> >     }
> >   }
> >   nTotalMatchedLines += nMatchedLines;
> > 
> >   // Let's see the intermediate results.
> > 
> >   if (0 < optVerbose) {
> >     fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
> >     fflush (stderr);
> > 
> >     if (2 < optVerbose) {
> >       for (int f = 0; f < 2; f += 1) {
> >         fprintf (stderr, "# file #%d\n", f + 1);
> >         fflush (stderr);
> >         for (int l = 0; l < lines[f].size (); l += 1) {
> >           fprintf (stderr, "#   [%d] ", l);
> >           fflush (stderr);
> >           lines[f][l].Dump (stderr);
> >         }
> >       }
> >     }
> >   }
> > }
> > 
> > // Perform Pass #2, in which we attempt to 'widen' blocks of matched
> > // lines, by appending lines which are the same in both files.
> > 
> > void pass2 ()
> > {
> >   if (0 < optVerbose) {
> >     fprintf (stderr, "# Pass #2 (spreading matches down)...");
> >     fflush (stderr);
> >   }
> > 
> >   nMatchedBlocks = 0;
> >   nMatchedLines = 0;
> > 
> >   // Starting at the top of the old file,...
> > 
> >   for (unsigned o = 0; o < lines[0].size (); o += 1) {
> > 
> >     // ... skip any currently unmatched lines...
> > 
> >     if (lines[0][o].l == ~0) {
> >       continue;
> >     }
> > 
> >     // ... until we find an [already] matched line.  Then, skip over
> >     // the set of 1 or more matched lines, until we reach any
> >     // following, still-unmatched line.
> > 
> >     unsigned n;
> >     do {
> >       n = lines[0][o].l + 1;
> >       o += 1;
> >     } while (o < lines[0].size () && lines[0][o].l != ~0);
> > 
> >     // Now, o - 1 is the line number of the last matched old line, and
> >     // n - 1 is the line number of the last matched new line.  We want
> >     // to add new old and new lines, if they match.
> > 
> >     // Finally, attempt to add unmatched lines to the preceeding
> >     // matched set.
> > 
> >     for (; o < lines[0].size () && lines[0][o].l == ~0; o += 1, n += 1) {
> > 
> >       // If the [next] pair of old and new lines aren't the same line, we're done.
> > 
> >       if (lines[0][o].line != lines[1][n].line) {
> >         break;
> >       }
> > 
> >       // Match up the pair.
> > 
> >       lines[0][o].l = n;
> >       lines[1][n].l = o;
> > 
> >       // Remove the matched line numbers form the lists.
> > 
> >       Line *line = lines[0][o].line;
> >       list<unsigned> &oldCopies = line->copies[0];
> >       list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
> >       if (oL != oldCopies.end ()) {
> >         oldCopies.erase (oL);
> >       }
> >       list<unsigned> &newCopies = line->copies[0];
> >       list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
> >       if (nL != newCopies.end ()) {
> >         newCopies.erase (nL);
> >       }
> > 
> >       nMatchedLines += 1;
> >     }
> >     nMatchedBlocks += 1;
> >   }
> >   nTotalMatchedLines += nMatchedLines;
> >   nTotalMatchedBlocks += nMatchedBlocks;
> > 
> >   // Let's see the intermediate results.
> > 
> >   if (0 < optVerbose) {
> >     fprintf (stderr,
> >              " found %u/%u matched lines/blocks (%u/%u totals).\n",
> >              nMatchedLines,
> >              nMatchedBlocks,
> >              nTotalMatchedLines,
> >              nTotalMatchedBlocks
> >             );
> >     fflush (stderr);
> >     if (2 < optVerbose) {
> >       for (int f = 0; f < 2; f += 1) {
> >         fprintf (stderr, "# file #%d\n", f + 1);
> >         fflush (stderr);
> >         for (int l = 0; l < lines[f].size (); l += 1) {
> >           fprintf (stderr, "#   [%d] ", l);
> >           fflush (stderr);
> >           lines[f][l].Dump (stderr);
> >         }
> >       }
> >     }
> >   }
> > }
> > 
> > // Perform Pass #3, in which we attempt to 'widen' blocks of matched
> > // lines, by prepending lines which are the same in both files.
> > 
> > void pass3 ()
> > {
> >   if (0 < optVerbose) {
> >     fprintf (stderr, "# Pass #3 (spreading matches up)...");
> >     fflush (stderr);
> >   }
> > 
> >   nMatchedBlocks = 0;
> >   nMatchedLines = 0;
> > 
> >   // Starting at the bottom of the old file,...
> > 
> >   for (int o = lines[0].size (); 0 <= o; o -= 1) {
> > 
> >     // ... skip any currently unmatched lines...
> > 
> >     if (lines[0][o].l == ~0) {
> >       continue;
> >     }
> > 
> >     // ... until we find an [already] matched line.  Then, skip over
> >     // the set of 1 or more matched lines, until we reach any
> >     // following, still-unmatched line.
> > 
> >     unsigned n;
> >     do {
> >       n = lines[0][o].l - 1;
> >       o -= 1;
> >     } while (0 <= o && lines[0][o].l != ~0);
> > 
> >     // Now, o + 1 is the line number of the last matched old line, and
> >     // n + 1 is the line number of the last matched new line.  We want
> >     // to add new old and new lines, if they match.
> > 
> >     // Finally, attempt to add unmatched lines to the preceeding
> >     // matched set.
> > 
> >     for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
> > 
> >       // If the [next] pair of old and new lines aren't the same line, we're done.
> > 
> >       if (lines[0][o].line != lines[1][n].line) {
> >         break;
> >       }
> > 
> >       // Match up the pair.
> > 
> >       lines[0][o].l = n;
> >       lines[1][n].l = o;
> > 
> >       // Remove the matched line numbers form the lists.
> > 
> >       Line *line = lines[0][o].line;
> >       list<unsigned> &oldCopies = line->copies[0];
> >       list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
> >       if (oL != oldCopies.end ()) {
> >         oldCopies.erase (oL);
> >       }
> >       list<unsigned> &newCopies = line->copies[0];
> >       list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
> >       if (nL != newCopies.end ()) {
> >         newCopies.erase (nL);
> >       }
> > 
> >       nMatchedLines += 1;
> >     }
> >     nMatchedBlocks += 1;
> >   }
> >   nTotalMatchedLines += nMatchedLines;
> > 
> >   // Let's see the intermediate results.
> > 
> >   if (0 < optVerbose) {
> >     fprintf (stderr,
> >              " found %u/%u matched lines/blocks (%u/%u totals).\n",
> >              nMatchedLines,
> >              nMatchedBlocks,
> >              nTotalMatchedLines,
> >              nTotalMatchedBlocks
> >             );
> >     fflush (stderr);
> > 
> >     if (2 < optVerbose) {
> >       for (int f = 0; f < 2; f += 1) {
> >         fprintf (stderr, "# file #%d\n", f + 1);
> >         fflush (stderr);
> >         for (int l = 0; l < lines[f].size (); l += 1) {
> >           fprintf (stderr, "#   [%d] ", l);
> >           fflush (stderr);
> >           lines[f][l].Dump (stderr);
> >         }
> >       }
> >     }
> >   }
> > }
> > 
> > // Perform pass #4, in which we find any remaining matches amongst the
> > // unique lines.  For every unique line that has more than 1 copy in
> > // both files, we declare the copies to match.
> > 
> > void pass4 ()
> > {
> >   if (0 < optVerbose) {
> >     fprintf (stderr, "# Pass 4 (finding remaining matches amongst unique lines)...");
> >     fflush (stderr);
> >   }
> > 
> >   nMatchedLines = 0;
> > 
> >   for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> >     Line *l = i->second;
> > 
> >     // If there's more than 1 matching old and new lines, then we
> >     // declare that each pair are (all) the same line.
> > 
> >     // (In the original algorithm, we only recognized a match, here,
> >     // if there was exactly 1 copy for each file.)
> > 
> >     while (0 < l->copies[0].size () && 0 < l->copies[1].size ()) {
> >       nMatchedLines += 1;
> > 
> >       // For each matched line in the new file, mark it with the
> >       // corresponding line (number) in the old file.
> > 
> >       unsigned o = l->copies[0].front ();
> >       unsigned n = l->copies[1].front ();
> > 
> >       // Match up the pair.
> > 
> >       lines[0][o].l = n;
> >       lines[1][n].l = o;
> > 
> >       // Remove the matched line numbers from the lists.
> > 
> >       l->copies[0].pop_front ();
> >       l->copies[1].pop_front ();
> >     }
> >   }
> >   nTotalMatchedLines += nMatchedLines;
> > 
> >   // Let's see the intermediate results.
> > 
> >   if (0 < optVerbose) {
> >     fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
> >     fflush (stderr);
> > 
> >     if (2 < optVerbose) {
> >       for (int f = 0; f < 2; f += 1) {
> >         fprintf (stderr, "# file #%d\n", f + 1);
> >         fflush (stderr);
> >         for (int l = 0; l < lines[f].size (); l += 1) {
> >           fprintf (stderr, "#   [%d] ", l);
> >           fflush (stderr);
> >           lines[f][l].Dump (stderr);
> >         }
> >       }
> >     }
> >   }
> > }
> > 
> > // Perform Pass #5, in which we look for blocks which match, but are
> > // the result of a move (their not in their original position).  For
> > // these, we'll unmatch the blocks, turning them into a delete and an
> > // insert.
> > 
> > void pass5 ()
> > {
> >   if (0 < optVerbose) {
> >     fprintf (stderr, "# Pass #5 (unmatching block moves)...\n");
> >     fflush (stderr);
> >   }
> > 
> >   nMatchedBlocks = 0;
> >   nMatchedLines = 0;
> > 
> >   // Starting at the top of both files,...
> > 
> >   unsigned o = 0;
> >   unsigned n = 0;
> > 
> >   while (o < lines[0].size () || n < lines[1].size ()) {
> > 
> >     // Skip any unmatched lines at this point in the old file.  These
> >     // are deletes.
> > 
> >     //    Old     New
> >     //   +---+
> >     // 0 | a |
> >     //   +---+   +---+
> >     //         0 | b |
> >     //   +---+   +---+
> >     // 1 | c | 1 | c |
> >     //   +---+   +---+
> >     //         2 | z |
> >     //   +---+   +---+
> >     // 2 | d | 3 | d |
> >     //   +---+   +---+
> > 
> >     while (o < lines[0].size () && lines[0][o].l == ~0) {
> >       o += 1;
> >     }
> > 
> >     // Skip any unmatched lines at this point in the new file.  These
> >     // are inserts.
> > 
> >     while (n < lines[1].size () && lines[1][n].l == ~0) {
> >       n += 1;
> >     }
> > 
> >     // When we get here, we know that we're dealing with matching
> >     // lines (or the end of one or both files).  We're done with this
> >     // pass, if we've reached the end of either file.
> > 
> >     if (lines[0].size () <= o || lines[1].size () <= n) {
> >       break;
> >     }
> > 
> >     // We now know that we've got a pair of matching lines, the start
> >     // of a matching block.  If the new file's line number is what we
> >     // expect, then the matched pair is unmoved, and we can skip over
> >     // the pair.  (If this is really the start of a block of more than
> >     // 1 lines, we'll handle it one pair at a time.)
> > 
> >     if (lines[0][o].l == n) {
> >       o += 1;
> >       n += 1;
> >       continue;
> >     }
> > 
> >     // If, on the other hand, we don't expect this [new] line number,
> >     // then this matching block has been moved.  We need to turn the
> >     // matched pair into an *unmatched* pair, one of deletes, and one
> >     // of inserts.  First, though, we need to know how big this block
> >     // is, and how far it was moved....
> > 
> >     // Remember where we were when we started.
> > 
> >     unsigned oOld = o;
> >     unsigned nOld = n;
> > 
> >     // Remember where the block came from.
> > 
> >     unsigned nNew = lines[0][o].l;
> > 
> >     // Find the end of this matched pair.
> > 
> >     for (n = nNew; o < lines[0].size () && n < lines[1].size (); o += 1, n += 1) {
> >       if (lines[0][o].l != n) {
> >         break;
> >       }
> >     }
> > 
> >     // When we get here:
> >     // * oOld..o is the old file's block,
> >     // * nNew..n is the new file's *moved* block, and
> >     // * nOld is where we originally expected the new block from.
> >  
> >     // We can now calculate the length of the block...
> >     
> >     unsigned bSize = o - oOld;  // (or n - nNew)
> > 
> >     // ... and we can calculate how far the block moved:
> > 
> >     unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
> > 
> >     // The larger of the two will become our delete, and the smaller
> >     // will become our insert.
> > 
> >     //    Old     New
> >     //   +---+   +---+
> >     // 0 | a | 0 | b |
> >     //   +---+ 1 | b |
> >     // 1 | b |   +---+
> >     // 2 | b | 2 | a |
> >     //   +---+   +---+
> >     // 3 | c | 3 | c |
> >     //   +---+   +---+
> > 
> >     // (1) Delete a@0, insert a@2, or
> >     // (2) insert bb@0, delete bb@1?
> > 
> >     // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and bMove
> >     // (of a) is 2-0 or 2, the size of b@0.  We choose to delete a@0,
> >     // and reinsert a@2.
> > 
> >     // if (bSize <= bMove) {
> >       for (unsigned a = oOld; a < o; a += 1) {
> >         lines[0][a].l = ~0;
> >       }
> >       for (unsigned d = nNew; d < n; d += 1) {
> >         lines[1][d].l = ~0;
> >       }
> >     // } else {
> >       // for (unsigned a = oOld; a < o; a += 1) {
> >       //   lines[0][a].l = ~0;
> >       // }
> >       // for (unsigned d = nNew; d < n; d += 1) {
> >       //   lines[1][d].l = ~0;
> >       // }
> >     // }
> > 
> >     // Continue from where we left off.
> > 
> >     n = nOld;
> >   }
> >   nTotalMatchedLines -= nMatchedLines;
> >   nTotalMatchedBlocks -= nMatchedBlocks;
> > 
> >   // Let's see the intermediate results.
> > 
> >   if (0 < optVerbose) {
> >     fprintf (stderr,
> >              " found %u/%u matched lines/blocks (%u/%u totals).\n",
> >              nMatchedLines,
> >              nMatchedBlocks,
> >              nTotalMatchedLines,
> >              nTotalMatchedBlocks
> >             );
> >     fflush (stderr);
> > 
> >     if (2 < optVerbose) {
> >       for (int f = 0; f < 2; f += 1) {
> >         fprintf (stderr, "# file #%d\n", f + 1);
> >         fflush (stderr);
> >         for (int l = 0; l < lines[f].size (); l += 1) {
> >           fprintf (stderr, "#   [%d] ", l);
> >           fflush (stderr);
> >           lines[f][l].Dump (stderr);
> >         }
> >       }
> >     }
> >   }
> > }
> > 
> > // Perform Pass #6, in which we create the desired output.
> > 
> > void pass6c ();
> > void pass6e ();
> > void pass6i ();
> > void pass6n ();
> > void pass6r ();
> > void pass6s ();
> > void pass6u ();
> > void pass6y ();
> > 
> > void pass6 ()
> > {
473,475c2127,2129
< 690c1113
< <   case EdScript:
< ---
---
> >     pass6c ();
> >     break;
> > 
477,479c2131,2133
< 694c1117
< <   case IfThenElse:
< ---
---
> >     pass6e ();
> >     break;
> > 
481,483c2135,2137
< 698c1121
< <   case Normal:
< ---
---
> >     pass6i ();
> >     break;
> > 
485,487c2139,2141
< 702c1125
< <   case RCS:
< ---
---
> >     pass6n ();
> >     break;
> > 
489,491c2143,2145
< 706c1129
< <   case SideBySide:
< ---
---
> >     pass6r ();
> >     break;
> > 
493,495c2147,2149
< 710c1133
< <   case Unified:
< ---
---
> >     pass6y ();
> >     break;
> > 
497,501c2151,2154
< 714d1136
< <   case Default:
< 716c1138
< <     pass6c ();
< ---
---
> >     pass6u ();
> >     break;
> > 
> >   default:
503,505c2156,2205
< 767c1189
< <     // begins here (or, rather, optCopyContext lines earlier).
< ---
---
> >     break;
> >   }
> > }
> > 
> > template<typename T> T min (T l, T r) {
> >   if (l < r) {
> >     return l;
> >   }
> >   return r;
> > }
> > 
> > template<typename T> T max (T l, T r) {
> >   if (l < r) {
> >     return r;
> >   }
> >   return l;
> > }
> > 
> > void pass6c () {
> >   if (0 < optVerbose) {
> >     fprintf (stderr, "# Pass #6c (walking the differences)...\n");
> >     fflush (stderr);
> >   }
> > 
> >   nMatchedLines = 0;
> > 
> >   // Write the header.
> > 
> >   fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
> >   fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
> > 
> >   // Starting at the top of both files,...
> > 
> >   unsigned o = 0;
> >   unsigned n = 0;
> > 
> >   while (o < lines[0].size () || n < lines[1].size ()) {
> > 
> >     // Find the bounds of the current contextual 'window'.
> > 
> >     // If we aren't looking at a delete or an insert, we're not at the
> >     // start of a context window.
> > 
> >     if (lines[0][o].l != ~0 && lines[1][n].l != ~0) {
> >       o += 1;
> >       n += 1;
> >       continue;
> >     }
> > 
> >     // We're now looking at at least 1 delete or insert, so a window
507,510c2207
< 769,770c1191,1192
< <     int boOldWindow = max (0, int (o) - int (optCopyContext));
< <     int boNewWindow = max (0, int (n) - int (optCopyContext));
< ---
---
> >     
513,515c2210,2233
< 795c1217
< <       // This context will end optCopyContext matched lines past the
< ---
---
> > 
> >     if (1 < optVerbose) {
> >       fprintf (stderr, "boOldWindow = %d, boNewWindow = %d\n", boOldWindow, boNewWindow);
> >       fflush (stderr);
> >     }
> > 
> >     // Look for the end of the current window.
> > 
> >     int eoOldWindow;
> >     int eoNewWindow;
> > 
> >     bool widenWindow = true;
> >     while (widenWindow && o < lines[0].size () || n < lines[1].size ()) {
> > 
> >       // Skip over the delete(s) and/or insert(s) defining the current
> >       // context.
> > 
> >       while (o < lines[0].size () && lines[0][o].l == ~0) {
> >         o += 1;
> >       }
> >       while (n < lines[1].size () && lines[1][n].l == ~0) {
> >         n += 1;
> >       }
> > 
517,519c2235,2237
< 799c1221
< <       for (unsigned l = 0; !widenWindow && l < optCopyContext; l += 1) {
< ---
---
> >       // last set of deletes or inserts we find.
> > 
> >       widenWindow = false;
521,523c2239,2252
< 814c1236
< <       // optCopyContext ahead for another delete or insert.
< ---
---
> >         if (o < lines[0].size ()) {
> >           widenWindow |= lines[0][o].l == ~0;
> >           o += 1;
> >         }
> >         if (n < lines[1].size ()) {
> >           widenWindow |= lines[1][n].l == ~0;
> >           n += 1;
> >         }
> >       }
> > 
> >       eoOldWindow = o;
> >       eoNewWindow = n;
> > 
> >       // However, since another window could follow, we look
525,527c2254,2255
< 817c1239
< <         for (unsigned l = 0; l < (2 * optCopyContext + 1); l += 1) {
< ---
---
> > 
> >       if (!widenWindow) {
529,531c2257,2609
< 1171c1593
< <   int columnWidth = (optPageWidth - 7) / 2;
< ---
---
> >           if (o < lines[0].size ()) {
> >             widenWindow |= lines[0][o].l == ~0;
> >             o += 1;
> >           }
> >           if (n < lines[1].size ()) {
> >             widenWindow |= lines[1][n].l == ~0;
> >             n += 1;
> >           }
> >         }
> >       }
> >     }
> > 
> >     // We've found the end of the window.
> > 
> >     if (1 < optVerbose) {
> >       fprintf (stderr, "eoOldWindow = %d, eoNewWindow = %d\n", eoOldWindow, eoNewWindow);
> >       fflush (stderr);
> >     }
> > 
> >     // Now, reset ourselves to the start of the window, and walk it to
> >     // produce the output.  We'll walk it twice, first for the old
> >     // file part, then for the new file part.
> > 
> >     fprintf (stdout, "***************\n");
> >     fprintf (stdout, "*** %d,%d ****\n", boOldWindow + 1, eoOldWindow);
> > 
> >     o = boOldWindow;
> >     n = boNewWindow;
> > 
> >     while (o < eoOldWindow || n < eoNewWindow) {
> > 
> >       // Find any unmatched lines at this point in the old file.  These
> >       // are deletes.
> > 
> >       unsigned boDeletes = o;
> >       while (o < eoOldWindow && lines[0][o].l == ~0) {
> >         o += 1;
> >       }
> > 
> >       // Find any unmatched lines at this point in the new file.  These
> >       // are inserts.
> > 
> >       unsigned boInserts = n;
> >       while (n < eoNewWindow && lines[1][n].l == ~0) {
> >         n += 1;
> >       }
> > 
> >       // We've got deleted line(s) from boDeletes .. o.
> >       // We've got deleted line(s) from boInserts .. n.
> > 
> >       unsigned nDeletes = o - boDeletes;
> >       unsigned nInserts = n - boInserts;
> > 
> >       // We've got...
> > 
> >       if (nDeletes && nInserts) {
> > 
> >         // ... deletes and inserts.
> > 
> >         for (unsigned l = boDeletes; l < o; l += 1) {
> >           fprintf (stdout, "! %s\n", lines[0][l].line->c_str ());
> >         }
> >       } else if (nDeletes) {
> > 
> >         //  ... just deletes.
> > 
> >         for (unsigned l = boDeletes; l < o; l += 1) {
> >           fprintf (stdout, "- %s\n", lines[0][l].line->c_str ());
> >         }
> >       }
> > 
> >       // When we get here, we're dealing with matching lines.
> > 
> >       fprintf (stdout, "  %s\n", lines[0][o].line->c_str ());
> >       o += 1;
> >       n += 1;
> >     }
> > 
> >     fprintf (stdout, "--- %d,%d ----\n", boNewWindow + 1, eoNewWindow);
> > 
> >     o = boOldWindow;
> >     n = boNewWindow;
> > 
> >     while (o < eoOldWindow && n < eoNewWindow) {
> > 
> >       // Find any unmatched lines at this point in the old file.  These
> >       // are deletes.
> > 
> >       unsigned boDeletes = o;
> >       while (o < eoOldWindow && lines[0][o].l == ~0) {
> >         o += 1;
> >       }
> > 
> >       // Find any unmatched lines at this point in the new file.  These
> >       // are inserts.
> > 
> >       unsigned boInserts = n;
> >       while (n < eoNewWindow && lines[1][n].l == ~0) {
> >         n += 1;
> >       }
> > 
> >       // We've got deleted line(s) from boDeletes .. o.
> >       // We've got deleted line(s) from boInserts .. n.
> > 
> >       unsigned nDeletes = o - boDeletes;
> >       unsigned nInserts = n - boInserts;
> > 
> >       // We've got...
> > 
> >       if (nDeletes && nInserts) {
> > 
> >         // ... deletes and inserts.
> > 
> >         for (unsigned l = boInserts; l < n; l += 1) {
> >           fprintf (stdout, "! %s\n", lines[1][l].line->c_str ());
> >         }
> >       } else if (nInserts) {
> > 
> >         //  ... just inserts.
> > 
> >         for (unsigned l = boInserts; l < n; l += 1) {
> >           fprintf (stdout, "+ %s\n", lines[1][l].line->c_str ());
> >         }
> >       }
> > 
> >       // When we get here, we're dealing with matching lines.
> > 
> >       fprintf (stdout, "  %s\n", lines[1][n].line->c_str ());
> >       o += 1;
> >       n += 1;
> >     }
> > 
> >     // Reset to the end of the current window.
> > 
> >     o = eoOldWindow;
> >     n = eoNewWindow;
> >   }
> > }
> > 
> > void pass6e () {
> >   fprintf (stderr, "pass6e() is unimplemented!\n");
> >   fflush (stderr);
> > }
> > 
> > void pass6i () {
> >   fprintf (stderr, "pass6i() is unimplemented!\n");
> >   fflush (stderr);
> > }
> > 
> > void pass6n ()
> > {
> >   if (0 < optVerbose) {
> >     fprintf (stderr, "# Pass #6n (walking the differences)...\n");
> >     fflush (stderr);
> >   }
> > 
> >   nMatchedLines = 0;
> > 
> >   // Write the header.  (None for normal.)
> > 
> >   // Starting at the top of both files,...
> > 
> >   unsigned o = 0;
> >   unsigned n = 0;
> > 
> >   while (o < lines[0].size () || n < lines[1].size ()) {
> > 
> >     // Find any unmatched lines at this point in the old file.  These
> >     // are deletes.
> > 
> >     unsigned boDeletes;
> >     for (boDeletes = o;
> >          o < lines[0].size () && lines[0][o].l == ~0;
> >          o += 1
> >         )
> >     {}
> > 
> >     // Find any unmatched lines at this point in the new file.  These
> >     // are inserts.
> > 
> >     unsigned boInserts;
> >     for (boInserts = n;
> >          n < lines[1].size () && lines[1][n].l == ~0;
> >          n += 1
> >         )
> >     {}
> > 
> >     // We've got deleted line(s) from boDeletes .. o.
> >     // We've got deleted line(s) from boInserts .. n.
> > 
> >     unsigned nDeletes = o - boDeletes;
> >     unsigned nInserts = n - boInserts;
> > 
> >     // We've got...
> > 
> >     if (nDeletes && nInserts) {
> > 
> >       // ... deletes and inserts.
> > 
> >       if (1 < nDeletes && 1 < nInserts) {
> >         fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, boInserts + 1, n);
> >       } else if (1 < nDeletes) {
> >         fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boInserts + 1);
> >       } else if (1 < nInserts) {
> >         fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInserts + 1, n);
> >       } 
> >       for (unsigned l = boDeletes; l < o; l += 1) {
> >         fprintf (stdout, "< %s\n", lines[0][l].line->c_str ());
> >       }
> >       fprintf (stdout, "---\n");
> >       for (unsigned l = boInserts; l < n; l += 1) {
> >         fprintf (stdout, "> %s\n", lines[1][l].line->c_str ());
> >       }
> >     } else if (nDeletes) {
> > 
> >       //  ... just deletes.
> > 
> >       if (1 < nDeletes) {
> >         fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
> >       } else {
> >         fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
> >       }
> >       for (unsigned l = boDeletes; l < o; l += 1) {
> >         fprintf (stdout, "< %s\n", lines[0][l].line->c_str ());
> >       }
> >     } else if (nInserts) {
> > 
> >       //  ... just inserts.
> > 
> >       if (1 < nInserts) {
> >         fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
> >       } else {
> >         fprintf (stdout, "%da%d\n", o, boInserts + 1);
> >       }
> >       for (unsigned l = boInserts; l < n; l += 1) {
> >         fprintf (stdout, "> %s\n", lines[1][l].line->c_str ());
> >       }
> >     }
> > 
> >     // When we get here, we're dealing with matching lines.
> > 
> >     o += 1;
> >     n += 1;
> >   }
> > }
> > 
> > void pass6r () {
> >   fprintf (stderr, "pass6r() is unimplemented!\n");
> >   fflush (stderr);
> > }
> > 
> > void pass6s () {
> >   fprintf (stderr, "pass6s() is unimplemented!\n");
> >   fflush (stderr);
> > }
> > 
> > void pass6u ()
> > {
> >   if (0 < optVerbose) {
> >     fprintf (stderr, "# Pass #6u (walking the differences)...\n");
> >     fflush (stderr);
> >   }
> > 
> >   nMatchedLines = 0;
> > 
> >   // Write the header.
> > 
> >   fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
> >   fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
> >   fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), lines[1].size ());
> > 
> >   // Starting at the top of both files,...
> > 
> >   unsigned o = 0;
> >   unsigned n = 0;
> > 
> >   while (o < lines[0].size () || n < lines[1].size ()) {
> > 
> >     // Find any unmatched lines at this point in the old file.  These
> >     // are deletes.
> > 
> >     unsigned boDeletes;
> >     for (boDeletes = o;
> >          o < lines[0].size () && lines[0][o].l == ~0;
> >          o += 1
> >         )
> >     {}
> > 
> >     // Find any unmatched lines at this point in the new file.  These
> >     // are inserts.
> > 
> >     unsigned boInserts;
> >     for (boInserts = n;
> >          n < lines[1].size () && lines[1][n].l == ~0;
> >          n += 1
> >         )
> >     {}
> > 
> >     // We've got deleted line(s) from boDeletes .. o.
> >     // We've got deleted line(s) from boInserts .. n.
> > 
> >     unsigned nDeletes = o - boDeletes;
> >     unsigned nInserts = n - boInserts;
> > 
> >     // We've got...
> > 
> >     if (nDeletes && nInserts) {
> > 
> >       // ... deletes and inserts.
> > 
> >       for (unsigned l = boDeletes; l < o; l += 1) {
> >         fprintf (stdout, "-%s\n", lines[0][l].line->c_str ());
> >       }
> >       for (unsigned l = boInserts; l < n; l += 1) {
> >         fprintf (stdout, "+%s\n", lines[1][l].line->c_str ());
> >       }
> >     } else if (nDeletes) {
> > 
> >       //  ... just deletes.
> > 
> >       for (unsigned l = boDeletes; l < o; l += 1) {
> >         fprintf (stdout, "-%s\n", lines[0][l].line->c_str ());
> >       }
> >     } else if (nInserts) {
> > 
> >       //  ... just inserts.
> > 
> >       for (unsigned l = boInserts; l < n; l += 1) {
> >         fprintf (stdout, "+%s\n", lines[1][l].line->c_str ());
> >       }
> >     }
> > 
> >     // When we get here, we're dealing with matching lines.
> > 
> >     fprintf (stdout, " %s\n", lines[0][o].line->c_str ());
> >     o += 1;
> >     n += 1;
> >   }
> > }
> > 
> > void pass6y ()
> > {
> >   if (0 < optVerbose) {
> >     fprintf (stderr, "# Pass #6y (walking the differences)...\n");
> >     fflush (stderr);
> >   }
> > 
> >   // Write the header.
> > 
> >   // None for side-by-side.
> > 
> >   // Starting at the top of both files,...
> > 
# ../sdiff --normal dif.8.cpp dif.7.cpp >& dif.8.7.diff--normal.test
./test: line 46: 23288 Aborted                 (core dumped) ${DIFF} "${option}" "${oSrc}" "${nSrc}" 1>&"${dst}.test"
# dif.8.7.diff--normal ---------------------------------------------------------
0a1
> sdiff: sdiff.cpp:1637: void pass6n(): Assertion `lines[0][o].line == lines[1][n].line' failed.
3c4
< 15,22c14
---
> 15,24c14
12,14c13
< ---
< >   Default,
< 24c16,23
---
> < 
17,25c16,17
< >   Context,
< >   EdScript,
< >   IfThenElse,
< >   Normal,
< >   RCS,
< >   SideBySide,
< >   Unified
< > };
< 26,50c25
---
> >   Default,
> 26,50c16,25
51a44,52
> >   Context,
> >   EdScript,
> >   IfThenElse,
> >   Normal,
> >   RCS,
> >   SideBySide,
> >   Unified
> > };
> > 
56,471c57
< 117,118d93
< < void getopts (int argc, char const *const argv[]);
< < 
< 126c101
< < int main (int argc, char const *const argv[])
< ---
< > int main (int argc, char *argv[])
< 128,145d102
< <   getopts (argc, argv);
< < 
< <   if (opt_v_ShowVersionInfo) {
< <     fprintf
< <       (stderr,
< <        "diff () 0.0.1"
< <        "Copyright (C) 2008 Sidney R Maxwell III"
< <        ""
< <        "This program comes with NO WARRANTY, to the extent permitted by law."
< <        "You may redistribute copies of this program"
< <        "under the terms of the GNU General Public License."
< <        "For more information about these matters, see the file named COPYING."
< <        ""
< <        "Written by Sid Maxwell."
< <       );
< <     exit (0);
< <   }
< < 
< 148c105
< <   for (int a = optind, n = 0; a < argc && n < 2; a += 1, n += 1) {
< ---
< >   for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
< 211,591d167
< < // Usage: diff [OPTION]... FILES
< < // Compare files line by line.
< < // 
< < //   --GTYPE-group-format=GFMT  Similar, but format GTYPE input groups with GFMT.
< < //   --LTYPE-line-format=LFMT  Similar, but format LTYPE input lines with LFMT.
< < //     LTYPE is `old', `new', or `unchanged'.  GTYPE is LTYPE or `changed'.
< < //     GFMT may contain:
< < //       %<  lines from FILE1
< < //       %>  lines from FILE2
< < //       %=  lines common to FILE1 and FILE2
< < //       %[-][WIDTH][.[PREC]]{doxX}LETTER  printf-style spec for LETTER
< < //         LETTERs are as follows for new group, lower case for old group:
< < //           F  first line number
< < //           L  last line number
< < //           N  number of lines = L-F+1
< < //           E  F-1
< < //           M  L+1
< < //     LFMT may contain:
< < //       %L  contents of line
< < //       %l  contents of line, excluding any trailing newline
< < //       %[-][WIDTH][.[PREC]]{doxX}n  printf-style spec for input line number
< < //     Either GFMT or LFMT may contain:
< < //       %%  %
< < //       %c'C'  the single character C
< < //       %c'\OOO'  the character with octal code OOO
< < //
< < //   --brief  -q  Output only whether files differ.
< < //   --context[=NUM]  -c  -C NUM  Output NUM (default 3) lines of copied context.
< < //   --ed  -e  Output an ed script.
< < //   --exclude-from=FILE  -X FILE  Exclude files that match any pattern in FILE.
< < //   --exclude=PAT  -x PAT  Exclude files that match PAT.
< < //   --expand-tabs  -t  Expand tabs to spaces in output.
< < //   --from-file=FILE1  Compare FILE1 to all operands.  FILE1 can be a directory.
< < //   --help  Output this help.
< < //   --horizon-lines=NUM  Keep NUM lines of the common prefix and suffix.
< < //   --ifdef=NAME  -D NAME  Output merged file to show `#ifdef NAME' diffs.
< < //   --ignore-all-space  -w  Ignore all white space.
< < //   --ignore-blank-lines  -B  Ignore changes whose lines are all blank.
< < //   --ignore-case  -i  Ignore case differences in file contents.
< < //   --ignore-file-name-case  Ignore case when comparing file names.
< < //   --ignore-matching-lines=RE  -I RE  Ignore changes whose lines all match RE.
< < //   --ignore-space-change  -b  Ignore changes in the amount of white space.
< < //   --ignore-tab-expansion  -E  Ignore changes due to tab expansion.
< < //   --initial-tab  -T  Make tabs line up by prepending a tab.
< < //   --label LABEL  Use LABEL instead of file name.
< < //   --left-column  Output only the left column of common lines.
< < //   --line-format=LFMT  Similar, but format all input lines with LFMT.
< < //   --minimal  -d  Try hard to find a smaller set of changes.
< < //   --new-file  -N  Treat absent files as empty.
< < //   --no-ignore-file-name-case  Consider case when comparing file names.
< < //   --normal  Output a normal diff.
< < //   --paginate  -l  Pass the output through `pr' to paginate it.
< < //   --rcs  -n  Output an RCS format diff.
< < //   --recursive  -r  Recursively compare any subdirectories found.
< < //   --report-identical-files  -s  Report when two files are the same.
< < //   --show-c-function  -p  Show which C function each change is in.
< < //   --show-function-line=RE  -F RE  Show the most recent line matching RE.
< < //   --side-by-side  -y  Output in two columns.
< < //   --speed-large-files  Assume large files and many scattered small changes.
< < //   --starting-file=FILE  -S FILE  Start with FILE when comparing directories.
< < //   --strip-trailing-cr  Strip trailing carriage return on input.
< < //   --suppress-common-lines  Do not output common lines.
< < //   --text  -a  Treat all files as text.
< < //   --to-file=FILE2  Compare all operands to FILE2.  FILE2 can be a directory.
< < //   --unidirectional-new-file  Treat absent first files as empty.
< < //   --unified[=NUM]  -u  -U NUM  Output NUM (default 3) lines of unified context.
< < //   --version  -v  Output version info.
< < //   --width=NUM  -W NUM  Output at most NUM (default 130) print columns.
< < // 
< < // FILES are `FILE1 FILE2' or `DIR1 DIR2' or `DIR FILE...' or `FILE... DIR'.
< < // If --from-file or --to-file is given, there are no restrictions on FILES.
< < // If a FILE is `-', read standard input.
< < // 
< < // Report bugs to <bug-gnu-utils@gnu.org>.
< < 
< < void getopts (int argc, char const *const argv[])
< < {
< <   while (1) {
< <     int option_index = 0;
< <     static option long_options[] = {
< <       { "brief",                        0, 0, 'q' }, // Output only whether files differ.
< <       { "context",                      2, 0, 'c' }, // Output NUM (default 3) lines of copied context.
< <       { "ed",                           0, 0, 'e' }, // Output an ed script.
< <       { "exclude-from",                 1, 0, ' ' }, // Exclude files that match any pattern in FILE.
< <       { "exclude",                      1, 0, 'x' }, // Exclude files that match PAT.
< <       { "expand-tabs",                  0, 0, 't' }, // Expand tabs to spaces in output.
< <       { "from-file",                    1, 0, ' ' }, // Compare FILE1 to all operands. FILE1 can be a directory.
< <       { "help",                         0, 0, 'h' }, // Output this help.
< <       { "horizon-lines",                1, 0, ' ' }, // Keep NUM lines of the common prefix and suffix.
< <       { "ifdef",                        1, 0, 'D' }, // Output merged file to show `#ifdef NAME' diffs.
< <       { "ignore-all-space",             0, 0, 'w' }, // Ignore all white space.
< <       { "ignore-blank-lines",           0, 0, 'B' }, // Ignore changes whose lines are all blank.
< <       { "ignore-case",                  0, 0, 'i' }, // Ignore case differences in file contents.
< <       { "ignore-file-name-case",        0, 0, ' ' }, // Ignore case when comparing file names.
< <       { "ignore-matching-lines",        1, 0, 'I' }, // Ignore changes whose lines all match RE.
< <       { "ignore-space-change",          0, 0, 'b' }, // Ignore changes in the amount of white space.
< <       { "ignore-tab-expansion",         0, 0, 'E' }, // Ignore changes due to tab expansion.
< <       { "initial-tab",                  0, 0, 'T' }, // Make tabs line up by prepending a tab.
< <       { "label",                        1, 0, ' ' }, // Use LABEL instead of file name.
< <       { "left-column",                  0, 0, ' ' }, // Output only the left column of common lines.
< <       { "line-format",                  1, 0, ' ' }, // Similar, but format all input lines with LFMT.
< <       { "minimal",                      0, 0, 'd' }, // Try hard to find a smaller set of changes.
< <       { "new-file",                     0, 0, 'N' }, // Treat absent files as empty.
< <       { "no-ignore-file-name-case",     0, 0, ' ' }, // Consider case when comparing file names.
< <       { "normal",                       0, 0, ' ' }, // Output a normal diff.
< <       { "paginate",                     0, 0, 'l' }, // Pass the output through `pr' to paginate it.
< <       { "rcs",                          0, 0, 'n' }, // Output an RCS format diff.
< <       { "recursive",                    0, 0, 'r' }, // Recursively compare any subdirectories found.
< <       { "report-identical-files",       0, 0, 's' }, // Report when two files are the same.
< <       { "show-c-function",              0, 0, 'p' }, // Show which C function each change is in.
< <       { "show-function-line",           1, 0, 'F' }, // Show the most recent line matching RE.
< <       { "side-by-side",                 0, 0, 'y' }, // Output in two columns.
< <       { "speed-large-files",            0, 0, ' ' }, // Assume large files and many scattered small changes.
< <       { "starting-file",                1, 0, 'S' }, // Start with FILE when comparing directories.
< <       { "strip-trailing-cr",            0, 0, ' ' }, // Strip trailing carriage return on input.
< <       { "suppress-common-lines",        0, 0, ' ' }, // Do not output common lines.
< <       { "text",                         0, 0, 'a' }, // Treat all files as text.
< <       { "to-file",                      0, 0, ' ' }, // Compare all operands to FILE2.  FILE2 can be a directory.
< <       { "unidirectional-new-file",      0, 0, ' ' }, // Treat absent first files as empty.
< <       { "unified",                      2, 0, 'u' }, // Output NUM (default 3) lines of unified context.
< <       { "version",                      0, 0, 'v' }, // Output version info.
< <       { "width",                        1, 0, 'W' }, // Output at most NUM (default 130) print columns.
< <       { 0,				0, 0,   0 }
< <     };
< < 
< <     char const *short_options =
< <       "B"                       // Ignore changes whose lines are all blank.
< <       "C:"                      // Output NUM (default 3) lines of copied context.
< <       "D:"                      // Output merged file to show `#ifdef NAME' diffs.
< <       "E"                       // Ignore changes due to tab expansion.
< <       "F:"                      // Show the most recent line matching RE.
< <       "I:"                      // Ignore changes whose lines all match RE.
< <       "N"                       // Treat absent files as empty.
< <       "S:"                      // Start with FILE when comparing directories.
< <       "T"                       // Make tabs line up by prepending a tab.
< <       "U:"                      // Output NUM (default 3) lines of unified context.
< <       "W:"                      // Output at most NUM (default 130) print columns.
< <       "X:"                      // Exclude files that match any pattern in FILE.
< <       "a"                       // Treat all files as text.
< <       "b"                       // Ignore changes in the amount of white space.
< <       "c"                       // Output NUM (default 3) lines of copied context.
< <       "d"                       // Try hard to find a smaller set of changes.
< <       "e"                       // Output an ed script.
< <       "i"                       // Ignore case differences in file contents.
< <       "l"                       // Pass the output through `pr' to paginate it.
< <       "n"                       // Output an RCS format diff.
< <       "p"                       // Show which C function each change is in.
< <       "q"                       // Output only whether files differ.
< <       "r"                       // Recursively compare any subdirectories found.
< <       "s"                       // Report when two files are the same.
< <       "t"                       // Expand tabs to spaces in output.
< <       "u"                       // Output NUM (default 3) lines of unified context.
< <       "v"                       // Output version info.
< <       "w"                       // Ignore all white space.
< <       "x:"                      // Exclude files that match PAT.
< <       "y"                       // Output in two columns.
< <       ;
< < 
< <     int c =
< <       getopt_long
< <         (argc,
< <          const_cast<char *const *> (argv),
< <          short_options,
< <          long_options,
< <          &option_index
< <         );
< < 
< <     switch (c) {
< <     case -1:
< <       return;
< < 
< <     case 0:
< <       printf ("option %s", long_options[option_index].name);
< <       if (optarg)
< <         printf (" with arg %s", optarg);
< <       printf ("\n");
< <       break;
< <     case 'B':
< <       opt_B_IgnoreBlankLines = true;
< <       break;
< <     case 'C':
< <       {
< <         unsigned linesOfContext = 3;
< <         if (optarg) {
< <           if (sscanf (optarg, "%u", &linesOfContext) != 1) {
< <             fprintf (stderr, "-C <NUM> or --context[=<NUM>] (%d)\n", opt_C_LinesOfCopyContext);
< <             exit (1);
< <           }
< <         }
< <         opt_C_LinesOfCopyContext = linesOfContext;
< <       }
< <       break;
< <     case 'D':
< <       opt_D_IfdefName = optarg;
< <       break;
< <     case 'E':
< <       opt_E_IgnoreTabExpansionChanges = true;
< <       break;
< <     case 'F':
< <       opt_F_ShowMostRecentLineMatching = optarg;
< <       break;
< <     case 'I':
< <       opt_I_IgnoreLinesMatching = optarg;
< <       break;
< <     case 'N':
< <       opt_N_TreatAbsentFilesAsEmpty = true;
< <       break;
< <     case 'S':
< <       opt_S_StartWithFileMatching = optarg;
< <       break;
< <     case 'T':
< <       opt_T_PrependATab = true;
< <       break;
< <     case 'U':
< <       {
< <         unsigned linesOfContext = 3;
< <         if (optarg) {
< <           if (sscanf (optarg, "%u", &linesOfContext) != 1) {
< <             fprintf (stderr, "-U <NUM> or --unified[=<NUM>] (%d)\n", opt_U_LinesOfUnifiedContext);
< <             exit (1);
< <           }
< <         }
< <         opt_U_LinesOfUnifiedContext = linesOfContext;
< <       }
< <       break;
< <     case 'W':
< <       {
< <         unsigned maxPrintColumns = 130;
< <         if (optarg) {
< <           if (sscanf (optarg, "%u", &maxPrintColumns) != 1) {
< <             fprintf (stderr, "-W <NUM> or --width[=<NUM>] (%d)\n", opt_W_MaxPrintColumns);
< <             exit (1);
< <           }
< <         }
< <         opt_W_MaxPrintColumns = maxPrintColumns;
< <       }
< <       break;
< <     case 'X':
< <       opt_X_ExcludeFilesMatching = optarg;
< <       break;
< <     case 'a':
< <       opt_a_TreatAllFilesAsText = true;
< <       break;
< <     case 'b':
< <       opt_b_IgnoreWhitespaceChanges = true;
< <       break;
< <     case 'c':
< <       opt___OutputFormat = opt_c_Context;
< <       break;
< <     case 'd':
< <       opt_d_TryToFindMinimalChanges = true;
< <       break;
< <     case 'e':
< <       opt___OutputFormat = opt_e_EdScript;
< <       break;
< <     case 'i':
< <       opt_i_IgnoreCaseDifferences = true;
< <       break;
< <     case 'l':
< <       opt_l_PaginateWithPr = true;
< <       break;
< <     case 'n':
< <       opt___OutputFormat = opt_n_RCS;
< <       break;
< <     case 'p':
< <       opt_p_ShowChangedCFunction = true;
< <       break;
< <     case 'q':
< <       opt_q_OutputOnlyIfFilesDiffer = true;
< <       break;
< <     case 'r':
< <       opt_r_RecursivelyCompareSubdirectories = true;
< <       break;
< <     case 's':
< <       opt_s_ReportWhenFilesAreSame = true;
< <       break;
< <     case 't':
< <       opt_t_ExpandTabs = true;
< <       break;
< <     case 'u':
< <       opt___OutputFormat = opt_u_Unified;
< <       break;
< <     case 'v':
< <       opt_v_ShowVersionInfo = true;
< <       break;
< <     case 'w':
< <       opt_w_IgnoreAllWhitespace = true;
< <       break;
< <     case 'x':
< <       opt_x_IgnoreFilesMatching = optarg;
< <       break;
< <     case 'y':
< <       opt___OutputFormat = opt_y_SideBySide;
< <       break;
< <     case 'h':
< <     case '?':
< <       fprintf
< <         (stderr,
< <          "Usage: diff [OPTION]... FILES\n"
< <          "Compare files line by line.\n"
< <          "\n"
< <          "  --GTYPE-group-format=GFMT  Similar, but format GTYPE input groups with GFMT.\n"
< <          "  --LTYPE-line-format=LFMT  Similar, but format LTYPE input lines with LFMT.\n"
< <          "    LTYPE is `old', `new', or `unchanged'.  GTYPE is LTYPE or `changed'.\n"
< <          "    GFMT may contain:\n"
< <          "      %<  lines from FILE1\n"
< <          "      %>  lines from FILE2\n"
< <          "      %=  lines common to FILE1 and FILE2\n"
< <          "      %[-][WIDTH][.[PREC]]{doxX}LETTER  printf-style spec for LETTER\n"
< <          "        LETTERs are as follows for new group, lower case for old group:\n"
< <          "          F  first line number\n"
< <          "          L  last line number\n"
< <          "          N  number of lines = L-F+1\n"
< <          "          E  F-1\n"
< <          "          M  L+1\n"
< <          "    LFMT may contain:\n"
< <          "      %L  contents of line\n"
< <          "      %l  contents of line, excluding any trailing newline\n"
< <          "      %[-][WIDTH][.[PREC]]{doxX}n  printf-style spec for input line number\n"
< <          "    Either GFMT or LFMT may contain:\n"
< <          "      %%  %\n"
< <          "      %c'C'  the single character C\n"
< <          "      %c'\\OOO'  the character with octal code OOO\n"
< <          "\n"
< <          "  --brief  -q  Output only whether files differ.\n"
< <          "  --context[=NUM]  -c  -C NUM  Output NUM (default 3) lines of copied context.\n"
< <          "  --ed  -e  Output an ed script.\n"
< <          "  --exclude-from=FILE  -X FILE  Exclude files that match any pattern in FILE.\n"
< <          "  --exclude=PAT  -x PAT  Exclude files that match PAT.\n"
< <          "  --expand-tabs  -t  Expand tabs to spaces in output.\n"
< <          "  --from-file=FILE1  Compare FILE1 to all operands.  FILE1 can be a directory.\n"
< <          "  --help  Output this help.\n"
< <          "  --horizon-lines=NUM  Keep NUM lines of the common prefix and suffix.\n"
< <          "  --ifdef=NAME  -D NAME  Output merged file to show `#ifdef NAME' diffs.\n"
< <          "  --ignore-all-space  -w  Ignore all white space.\n"
< <          "  --ignore-blank-lines  -B  Ignore changes whose lines are all blank.\n"
< <          "  --ignore-case  -i  Ignore case differences in file contents.\n"
< <          "  --ignore-file-name-case  Ignore case when comparing file names.\n"
< <          "  --ignore-matching-lines=RE  -I RE  Ignore changes whose lines all match RE.\n"
< <          "  --ignore-space-change  -b  Ignore changes in the amount of white space.\n"
< <          "  --ignore-tab-expansion  -E  Ignore changes due to tab expansion.\n"
< <          "  --initial-tab  -T  Make tabs line up by prepending a tab.\n"
< <          "  --label LABEL  Use LABEL instead of file name.\n"
< <          "  --left-column  Output only the left column of common lines.\n"
< <          "  --line-format=LFMT  Similar, but format all input lines with LFMT.\n"
< <          "  --minimal  -d  Try hard to find a smaller set of changes.\n"
< <          "  --new-file  -N  Treat absent files as empty.\n"
< <          "  --no-ignore-file-name-case  Consider case when comparing file names.\n"
< <          "  --normal  Output a normal diff.\n"
< <          "  --paginate  -l  Pass the output through `pr' to paginate it.\n"
< <          "  --rcs  -n  Output an RCS format diff.\n"
< <          "  --recursive  -r  Recursively compare any subdirectories found.\n"
< <          "  --report-identical-files  -s  Report when two files are the same.\n"
< <          "  --show-c-function  -p  Show which C function each change is in.\n"
< <          "  --show-function-line=RE  -F RE  Show the most recent line matching RE.\n"
< <          "  --side-by-side  -y  Output in two columns.\n"
< <          "  --speed-large-files  Assume large files and many scattered small changes.\n"
< <          "  --starting-file=FILE  -S FILE  Start with FILE when comparing directories.\n"
< <          "  --strip-trailing-cr  Strip trailing carriage return on input.\n"
< <          "  --suppress-common-lines  Do not output common lines.\n"
< <          "  --text  -a  Treat all files as text.\n"
< <          "  --to-file=FILE2  Compare all operands to FILE2.  FILE2 can be a directory.\n"
< <          "  --unidirectional-new-file  Treat absent first files as empty.\n"
< <          "  --unified[=NUM]  -u  -U NUM  Output NUM (default 3) lines of unified context.\n"
< <          "  --version  -v  Output version info.\n"
< <          "  --width=NUM  -W NUM  Output at most NUM (default 130) print columns.\n"
< <          "\n"
< <          "FILES are `FILE1 FILE2' or `DIR1 DIR2' or `DIR FILE...' or `FILE... DIR'.\n"
< <          "If --from-file or --to-file is given, there are no restrictions on FILES.\n"
< <          "If a FILE is `-', read standard input.\n"
< <          "\n"
< <          "Report bugs to <bug-gnu-utils@gnu.org>.\n"
< <         );
< <       exit (1);
< <     default:
< <       fprintf (stderr, "Unhandled option (%c%s)!\n", c, optarg ? optarg : "");
< <       exit (1);
< <     }
< <   }
< < }
< < 
< 1108,1109c684,686
< <   switch (opt___OutputFormat) {
< <   case opt_c_Context:
< ---
---
> 115a93,101
473,534c59,66
< >   switch (diffFormat) {
< >   case Context:
< 1113c690
< <   case opt_e_EdScript:
< ---
< >   case EdScript:
< 1117c694
< <   case opt_D_IfThenElse:
< ---
< >   case IfThenElse:
< 1121c698
< <   case opt___Normal:
< ---
< >   case Normal:
< 1125c702
< <   case opt_n_RCS:
< ---
< >   case RCS:
< 1129c706
< <   case opt_y_SideBySide:
< ---
< >   case SideBySide:
< 1133c710
< <   case opt_u_Unified:
< ---
< >   case Unified:
< 1136a714
< >   case Default:
< 1138c716
< <     pass6n ();
< ---
< >     pass6c ();
< 1189c767
< <     // begins here (or, rather, opt_C_LinesOfCopyContext lines earlier).
< ---
< >     // begins here (or, rather, optCopyContext lines earlier).
< 1191,1192c769,770
< <     int boOldWindow = max (0, int (o) - int (opt_C_LinesOfCopyContext));
< <     int boNewWindow = max (0, int (n) - int (opt_C_LinesOfCopyContext));
< ---
< >     int boOldWindow = max (0, int (o) - int (optCopyContext));
< >     int boNewWindow = max (0, int (n) - int (optCopyContext));
< 1217c795
< <       // This context will end opt_C_LinesOfCopyContext matched lines past the
< ---
< >       // This context will end optCopyContext matched lines past the
< 1221c799
< <       for (unsigned l = 0; !widenWindow && l < opt_C_LinesOfCopyContext; l += 1) {
< ---
< >       for (unsigned l = 0; !widenWindow && l < optCopyContext; l += 1) {
< 1236c814
< <       // opt_C_LinesOfCopyContext ahead for another delete or insert.
< ---
< >       // optCopyContext ahead for another delete or insert.
< 1239c817
< <         for (unsigned l = 0; l < (2 * opt_C_LinesOfCopyContext + 1); l += 1) {
< ---
< >         for (unsigned l = 0; l < (2 * optCopyContext + 1); l += 1) {
< 1593c1171
< <   int columnWidth = (opt_W_MaxPrintColumns - 7) / 2;
< ---
< >   int columnWidth = (optPageWidth - 7) / 2;
---
> > void pass1 ();
> > void pass2 ();
> > void pass3 ();
> > void pass4 ();
> > void pass5 ();
> > void pass6 ();
> > 
> > int main (int argc, char *argv[])
# ../sdiff -c dif.0.cpp dif.1.cpp >& dif.0.1.diff-c.test
./test: line 46: 23298 Aborted                 (core dumped) ${DIFF} "${option}" "${oSrc}" "${nSrc}" 1>&"${dst}.test"
# dif.0.1.diff-c ---------------------------------------------------------------
1,83c1,3
< *** dif.0.cpp	2008-02-20 19:41:29.000000000 +0000
< --- dif.1.cpp	2008-02-20 19:55:12.000000000 +0000
< ***************
< *** 1,32 ****
< - #include <map>
< - using std::map;
<   #include <string>
<   using std::string;
<   #include <stdio.h>
<   
<   int main (int argc, char *argv[])
<   {
<     map<string, int> table;
<     for (int a = 1; a < argc; a += 1) {
<       if (FILE *f = fopen (argv[a], "r")) {
<         fprintf (stderr, "# Reading %s...", argv[a]);
<         char buffer[1024];
< -       unsigned n = 0;
<         while (fgets (buffer, sizeof (buffer), f)) {
< ! 	string l (buffer);
< ! 	table[l] += 1;
< ! 	n += 1;
<         }
< !       fprintf (stderr, " %u lines.\n", n);
<       } else {
<       }
<     }
< !   printf ("table.size () = %d\n", table.size ());
<     map<int, int> counts;
<     for (map<string, int>::iterator i = table.begin (); i != table.end (); i++) {
<       counts[i->second] += 1;
<     }
<     for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
< !     fprintf (stderr, "counts[%d] = %d\n", i->first, i->second);
<     }
<   }
< --- 1,46 ----
<   #include <string>
<   using std::string;
< + #include <map>
< + using std::map;
< + #include <vector>
< + using std::vector;
<   #include <stdio.h>
<   
<   int main (int argc, char *argv[])
<   {
<     map<string, int> table;
< +   vector<vector<int *> *> fileLines;
< + 
<     for (int a = 1; a < argc; a += 1) {
<       if (FILE *f = fopen (argv[a], "r")) {
<         fprintf (stderr, "# Reading %s...", argv[a]);
< +       vector<int *> *lines = new vector<int *> ();
< + 
<         char buffer[1024];
<         while (fgets (buffer, sizeof (buffer), f)) {
< !         int *line = &table[buffer];
< !         lines->push_back (line);
< !         *line += 1;
<         }
< !       fprintf (stderr, " %u lines.\n", lines->size ());
< !       fileLines.push_back (lines);
<       } else {
< +       fprintf (stderr, "%s: Unable to open %s!  Ignoring....\n", argv[a]);
<       }
<     }
< !   printf ("# table.size () = %d\n", table.size ());
<     map<int, int> counts;
<     for (map<string, int>::iterator i = table.begin (); i != table.end (); i++) {
<       counts[i->second] += 1;
<     }
<     for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
< !     fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
< !   }
< !   for (int f = 0; f < fileLines.size (); f += 1) {
< !     fprintf (stderr, "# file #%d\n", f);
< !     vector<int *> *lines = fileLines[f];
< !     for (int l = 0; l < lines->size (); l += 1) {
< !       fprintf (stderr, "#   [%d] = %d\n", l, *(*lines)[l]);
< !     }
<     }
<   }
---
> sdiff: sdiff.cpp:1363: void pass6c(): Assertion `widenWindow || lines[0][o].line == lines[1][n].line' failed.
> *** dif.0.cpp	0000-00-00 00:00:00.000000000 +0000
> --- dif.1.cpp	0000-00-00 00:00:00.000000000 +0000
# ../sdiff -c dif.1.cpp dif.0.cpp >& dif.1.0.diff-c.test
./test: line 46: 23301 Aborted                 (core dumped) ${DIFF} "${option}" "${oSrc}" "${nSrc}" 1>&"${dst}.test"
# dif.1.0.diff-c ---------------------------------------------------------------
1,83c1,3
< *** dif.1.cpp	2008-02-20 19:55:12.000000000 +0000
< --- dif.0.cpp	2008-02-20 19:41:29.000000000 +0000
< ***************
< *** 1,46 ****
< - #include <string>
< - using std::string;
<   #include <map>
<   using std::map;
< ! #include <vector>
< ! using std::vector;
<   #include <stdio.h>
<   
<   int main (int argc, char *argv[])
<   {
<     map<string, int> table;
< -   vector<vector<int *> *> fileLines;
< - 
<     for (int a = 1; a < argc; a += 1) {
<       if (FILE *f = fopen (argv[a], "r")) {
<         fprintf (stderr, "# Reading %s...", argv[a]);
< -       vector<int *> *lines = new vector<int *> ();
< - 
<         char buffer[1024];
<         while (fgets (buffer, sizeof (buffer), f)) {
< !         int *line = &table[buffer];
< !         lines->push_back (line);
< !         *line += 1;
<         }
< !       fprintf (stderr, " %u lines.\n", lines->size ());
< !       fileLines.push_back (lines);
<       } else {
< -       fprintf (stderr, "%s: Unable to open %s!  Ignoring....\n", argv[a]);
<       }
<     }
< !   printf ("# table.size () = %d\n", table.size ());
<     map<int, int> counts;
<     for (map<string, int>::iterator i = table.begin (); i != table.end (); i++) {
<       counts[i->second] += 1;
<     }
<     for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
< !     fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
< !   }
< !   for (int f = 0; f < fileLines.size (); f += 1) {
< !     fprintf (stderr, "# file #%d\n", f);
< !     vector<int *> *lines = fileLines[f];
< !     for (int l = 0; l < lines->size (); l += 1) {
< !       fprintf (stderr, "#   [%d] = %d\n", l, *(*lines)[l]);
< !     }
<     }
<   }
< --- 1,32 ----
<   #include <map>
<   using std::map;
< ! #include <string>
< ! using std::string;
<   #include <stdio.h>
<   
<   int main (int argc, char *argv[])
<   {
<     map<string, int> table;
<     for (int a = 1; a < argc; a += 1) {
<       if (FILE *f = fopen (argv[a], "r")) {
<         fprintf (stderr, "# Reading %s...", argv[a]);
<         char buffer[1024];
< +       unsigned n = 0;
<         while (fgets (buffer, sizeof (buffer), f)) {
< ! 	string l (buffer);
< ! 	table[l] += 1;
< ! 	n += 1;
<         }
< !       fprintf (stderr, " %u lines.\n", n);
<       } else {
<       }
<     }
< !   printf ("table.size () = %d\n", table.size ());
<     map<int, int> counts;
<     for (map<string, int>::iterator i = table.begin (); i != table.end (); i++) {
<       counts[i->second] += 1;
<     }
<     for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
< !     fprintf (stderr, "counts[%d] = %d\n", i->first, i->second);
<     }
<   }
---
> sdiff: sdiff.cpp:1363: void pass6c(): Assertion `widenWindow || lines[0][o].line == lines[1][n].line' failed.
> *** dif.1.cpp	0000-00-00 00:00:00.000000000 +0000
> --- dif.0.cpp	0000-00-00 00:00:00.000000000 +0000
# ../sdiff -c dif.1.cpp dif.2.cpp >& dif.1.2.diff-c.test
./test: line 46: 23311 Aborted                 (core dumped) ${DIFF} "${option}" "${oSrc}" "${nSrc}" 1>&"${dst}.test"
# dif.1.2.diff-c ---------------------------------------------------------------
1,117c1,3
< *** dif.1.cpp	2008-02-20 19:55:12.000000000 +0000
< --- dif.2.cpp	2008-02-20 22:17:26.000000000 +0000
< ***************
< *** 1,29 ****
<   #include <string>
<   using std::string;
<   #include <map>
<   using std::map;
<   #include <vector>
<   using std::vector;
<   #include <stdio.h>
<   
<   int main (int argc, char *argv[])
<   {
< !   map<string, int> table;
< !   vector<vector<int *> *> fileLines;
<   
< !   for (int a = 1; a < argc; a += 1) {
<       if (FILE *f = fopen (argv[a], "r")) {
<         fprintf (stderr, "# Reading %s...", argv[a]);
< -       vector<int *> *lines = new vector<int *> ();
<   
<         char buffer[1024];
<         while (fgets (buffer, sizeof (buffer), f)) {
< !         int *line = &table[buffer];
< !         lines->push_back (line);
< !         *line += 1;
<         }
< !       fprintf (stderr, " %u lines.\n", lines->size ());
< !       fileLines.push_back (lines);
<       } else {
<         fprintf (stderr, "%s: Unable to open %s!  Ignoring....\n", argv[a]);
<       }
< --- 1,48 ----
<   #include <string>
<   using std::string;
< + #include <list>
< + using std::list;
<   #include <map>
<   using std::map;
<   #include <vector>
<   using std::vector;
<   #include <stdio.h>
<   
< + struct Line : public string {
< +   Line (string _text) :
< +     text (_text)
< +   {
< +   }
< +   string text;
< +   list<unsigned> counts[2];
< + };
< + 
< + typedef map<string, Line *> MapStringToLinePtr;
< + typedef vector<Line *> VectorLinePtr;
< + 
<   int main (int argc, char *argv[])
<   {
< !   MapStringToLinePtr table;
< !   VectorLinePtr lines[2];
<   
< !   for (int a = 1; a < argc && a <= 2; a += 1) {
<       if (FILE *f = fopen (argv[a], "r")) {
<         fprintf (stderr, "# Reading %s...", argv[a]);
<   
< +       VectorLinePtr *lines = new VectorLinePtr ();
<         char buffer[1024];
<         while (fgets (buffer, sizeof (buffer), f)) {
< !         string text (buffer);
< ! 
< !         Line *line = table[text];
< ! 
< !         if (!line) {
< !           table[text] = line = new Line (text);
< !         }
< !         line->counts[a - 1].push_back (lines[a - 1].size ());
< !         lines[a - 1].push_back (line);
<         }
< !       fprintf (stderr, " %u lines.\n", lines[a - 1]->size ());
<       } else {
<         fprintf (stderr, "%s: Unable to open %s!  Ignoring....\n", argv[a]);
<       }
< ***************
< *** 31,46 ****
<     printf ("# table.size () = %d\n", table.size ());
<     map<int, int> counts;
<     for (map<string, int>::iterator i = table.begin (); i != table.end (); i++) {
< !     counts[i->second] += 1;
<     }
<     for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
<       fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
<     }
< !   for (int f = 0; f < fileLines.size (); f += 1) {
< !     fprintf (stderr, "# file #%d\n", f);
< !     vector<int *> *lines = fileLines[f];
< !     for (int l = 0; l < lines->size (); l += 1) {
< !       fprintf (stderr, "#   [%d] = %d\n", l, *(*lines)[l]);
<       }
<     }
<   }
< --- 50,65 ----
<     printf ("# table.size () = %d\n", table.size ());
<     map<int, int> counts;
<     for (map<string, int>::iterator i = table.begin (); i != table.end (); i++) {
< !     Line *l = i->second;
< !     counts[l->counts[0].size () + l->counts[1].size ()] += 1;
<     }
<     for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
<       fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
<     }
< !   for (int f = 0; f < 2; f += 1) {
< !     fprintf (stderr, "# file #%d\n", f + 1);
< !     for (int l = 0; l < lines[f].size (); l += 1) {
< !       fprintf (stderr, "#   [%d] = %d\n", l, lines[f][l]->counts[f].size ());
<       }
<     }
<   }
---
> sdiff: sdiff.cpp:1390: void pass6c(): Assertion `widenWindow || lines[0][o].line == lines[1][n].line' failed.
> *** dif.1.cpp	0000-00-00 00:00:00.000000000 +0000
> --- dif.2.cpp	0000-00-00 00:00:00.000000000 +0000
# ../sdiff -c dif.2.cpp dif.1.cpp >& dif.2.1.diff-c.test
./test: line 46: 23314 Aborted                 (core dumped) ${DIFF} "${option}" "${oSrc}" "${nSrc}" 1>&"${dst}.test"
# dif.2.1.diff-c ---------------------------------------------------------------
1,117c1,3
< *** dif.2.cpp	2008-02-20 22:17:26.000000000 +0000
< --- dif.1.cpp	2008-02-20 19:55:12.000000000 +0000
< ***************
< *** 1,48 ****
<   #include <string>
<   using std::string;
< - #include <list>
< - using std::list;
<   #include <map>
<   using std::map;
<   #include <vector>
<   using std::vector;
<   #include <stdio.h>
<   
< - struct Line : public string {
< -   Line (string _text) :
< -     text (_text)
< -   {
< -   }
< -   string text;
< -   list<unsigned> counts[2];
< - };
< - 
< - typedef map<string, Line *> MapStringToLinePtr;
< - typedef vector<Line *> VectorLinePtr;
< - 
<   int main (int argc, char *argv[])
<   {
< !   MapStringToLinePtr table;
< !   VectorLinePtr lines[2];
<   
< !   for (int a = 1; a < argc && a <= 2; a += 1) {
<       if (FILE *f = fopen (argv[a], "r")) {
<         fprintf (stderr, "# Reading %s...", argv[a]);
<   
< -       VectorLinePtr *lines = new VectorLinePtr ();
<         char buffer[1024];
<         while (fgets (buffer, sizeof (buffer), f)) {
< !         string text (buffer);
< ! 
< !         Line *line = table[text];
< ! 
< !         if (!line) {
< !           table[text] = line = new Line (text);
< !         }
< !         line->counts[a - 1].push_back (lines[a - 1].size ());
< !         lines[a - 1].push_back (line);
<         }
< !       fprintf (stderr, " %u lines.\n", lines[a - 1]->size ());
<       } else {
<         fprintf (stderr, "%s: Unable to open %s!  Ignoring....\n", argv[a]);
<       }
< --- 1,29 ----
<   #include <string>
<   using std::string;
<   #include <map>
<   using std::map;
<   #include <vector>
<   using std::vector;
<   #include <stdio.h>
<   
<   int main (int argc, char *argv[])
<   {
< !   map<string, int> table;
< !   vector<vector<int *> *> fileLines;
<   
< !   for (int a = 1; a < argc; a += 1) {
<       if (FILE *f = fopen (argv[a], "r")) {
<         fprintf (stderr, "# Reading %s...", argv[a]);
< +       vector<int *> *lines = new vector<int *> ();
<   
<         char buffer[1024];
<         while (fgets (buffer, sizeof (buffer), f)) {
< !         int *line = &table[buffer];
< !         lines->push_back (line);
< !         *line += 1;
<         }
< !       fprintf (stderr, " %u lines.\n", lines->size ());
< !       fileLines.push_back (lines);
<       } else {
<         fprintf (stderr, "%s: Unable to open %s!  Ignoring....\n", argv[a]);
<       }
< ***************
< *** 50,65 ****
<     printf ("# table.size () = %d\n", table.size ());
<     map<int, int> counts;
<     for (map<string, int>::iterator i = table.begin (); i != table.end (); i++) {
< !     Line *l = i->second;
< !     counts[l->counts[0].size () + l->counts[1].size ()] += 1;
<     }
<     for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
<       fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
<     }
< !   for (int f = 0; f < 2; f += 1) {
< !     fprintf (stderr, "# file #%d\n", f + 1);
< !     for (int l = 0; l < lines[f].size (); l += 1) {
< !       fprintf (stderr, "#   [%d] = %d\n", l, lines[f][l]->counts[f].size ());
<       }
<     }
<   }
< --- 31,46 ----
<     printf ("# table.size () = %d\n", table.size ());
<     map<int, int> counts;
<     for (map<string, int>::iterator i = table.begin (); i != table.end (); i++) {
< !     counts[i->second] += 1;
<     }
<     for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
<       fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
<     }
< !   for (int f = 0; f < fileLines.size (); f += 1) {
< !     fprintf (stderr, "# file #%d\n", f);
< !     vector<int *> *lines = fileLines[f];
< !     for (int l = 0; l < lines->size (); l += 1) {
< !       fprintf (stderr, "#   [%d] = %d\n", l, *(*lines)[l]);
<       }
<     }
<   }
---
> sdiff: sdiff.cpp:1363: void pass6c(): Assertion `widenWindow || lines[0][o].line == lines[1][n].line' failed.
> *** dif.2.cpp	0000-00-00 00:00:00.000000000 +0000
> --- dif.1.cpp	0000-00-00 00:00:00.000000000 +0000
# ../sdiff -c dif.2.cpp dif.3.cpp >& dif.2.3.diff-c.test
./test: line 46: 23324 Aborted                 (core dumped) ${DIFF} "${option}" "${oSrc}" "${nSrc}" 1>&"${dst}.test"
# dif.2.3.diff-c ---------------------------------------------------------------
1,810c1,3
< *** dif.2.cpp	2008-02-20 22:17:26.000000000 +0000
< --- dif.3.cpp	2008-02-22 21:42:10.000000000 +0000
< ***************
< *** 1,3 ****
< --- 1,5 ----
< + #include <algorithm>
< + using std::find;
<   #include <string>
<   using std::string;
<   #include <list>
< ***************
< *** 8,36 ****
<   using std::vector;
<   #include <stdio.h>
<   
<   struct Line : public string {
<     Line (string _text) :
< !     text (_text)
<     {
<     }
< !   string text;
< !   list<unsigned> counts[2];
<   };
<   
<   typedef map<string, Line *> MapStringToLinePtr;
< ! typedef vector<Line *> VectorLinePtr;
<   
<   int main (int argc, char *argv[])
<   {
<     MapStringToLinePtr table;
<     VectorLinePtr lines[2];
<   
< !   for (int a = 1; a < argc && a <= 2; a += 1) {
< !     if (FILE *f = fopen (argv[a], "r")) {
< !       fprintf (stderr, "# Reading %s...", argv[a]);
<   
< -       VectorLinePtr *lines = new VectorLinePtr ();
<         char buffer[1024];
<         while (fgets (buffer, sizeof (buffer), f)) {
<           string text (buffer);
<   
< --- 10,98 ----
<   using std::vector;
<   #include <stdio.h>
<   
< + enum DiffFormat {
< +   Default,
< + 
< +   Context,
< +   EdScript,
< +   IfThenElse,
< +   Normal,
< +   RCS,
< +   SideBySide,
< +   Unified
< + };
< + 
< + DiffFormat diffFormat = Unified;
< + 
< + int optVerbose = 1;
< + 
<   struct Line : public string {
<     Line (string _text) :
< !     string (_text)
<     {
<     }
< !   ~Line () {
< !     copies[0].erase (copies[0].begin (), copies[0].end ());
< !     copies[1].erase (copies[1].begin (), copies[1].end ());
< !   }
< !   void Dump (FILE *out) {
< !     fprintf (out, "{{ ");
< !     for (list<unsigned>::iterator i = copies[0].begin (); i != copies[0].end (); i++) {
< !       fprintf (out, "%u ", *i);
< !     }
< !     fprintf (out, "},{ ");
< !     for (list<unsigned>::iterator i = copies[1].begin (); i != copies[1].end (); i++) {
< !       fprintf (out, "%u ", *i);
< !     }
< !     fprintf (out, "}}\t%s", c_str ());
< !   }
< !   list<unsigned> copies[2];
< ! };
< ! 
< ! struct LinePtr {
< !   LinePtr (Line *_line) :
< !     line (_line),
< !     l (~0u)
< !   {
< !   }
< !   void Dump (FILE *out) {
< !     fprintf (out, "[%d] ", l);
< !     line->Dump (out);
< !   }
< !   Line *line;
< !   unsigned l;
<   };
<   
<   typedef map<string, Line *> MapStringToLinePtr;
< ! typedef vector<LinePtr> VectorLinePtr;
< ! 
< ! char *ARGV0 = "dif2";
<   
<   int main (int argc, char *argv[])
<   {
< +   char const *files[2] = { 0, 0 };
< + 
<     MapStringToLinePtr table;
<     VectorLinePtr lines[2];
<   
< !   unsigned nTotalMatchedBlocks = 0;
< !   unsigned nMatchedBlocks = 0;
< !   unsigned nTotalMatchedLines = 0;
< !   unsigned nMatchedLines = 0;
< ! 
< !   // Read the old [0] file, and the new [1] file.
< ! 
< !   for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
< !     files[n] = argv[a];
< ! 
< !     if (FILE *f = fopen (files[n], "r")) {
< !       if (0 < optVerbose) {
< !         fprintf (stderr, "# Reading %s...", files[n]);
< !       }
<   
<         char buffer[1024];
< +       unsigned nUniq = 0;
< + 
<         while (fgets (buffer, sizeof (buffer), f)) {
<           string text (buffer);
<   
< ***************
< *** 38,65 ****
<   
<           if (!line) {
<             table[text] = line = new Line (text);
<           }
< !         line->counts[a - 1].push_back (lines[a - 1].size ());
< !         lines[a - 1].push_back (line);
<         }
< -       fprintf (stderr, " %u lines.\n", lines[a - 1]->size ());
<       } else {
< !       fprintf (stderr, "%s: Unable to open %s!  Ignoring....\n", argv[a]);
<       }
<     }
< !   printf ("# table.size () = %d\n", table.size ());
< !   map<int, int> counts;
< !   for (map<string, int>::iterator i = table.begin (); i != table.end (); i++) {
<       Line *l = i->second;
< !     counts[l->counts[0].size () + l->counts[1].size ()] += 1;
<     }
< !   for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
< !     fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
<     }
< !   for (int f = 0; f < 2; f += 1) {
< !     fprintf (stderr, "# file #%d\n", f + 1);
< !     for (int l = 0; l < lines[f].size (); l += 1) {
< !       fprintf (stderr, "#   [%d] = %d\n", l, lines[f][l]->counts[f].size ());
<       }
<     }
<   }
< --- 100,747 ----
<   
<           if (!line) {
<             table[text] = line = new Line (text);
< +           nUniq += 1;
<           }
< !         line->copies[n].push_back (lines[n].size ());
< !         lines[n].push_back (line);
< !       }
< ! 
< !       if (0 < optVerbose) {
< !         fprintf (stderr, " %u lines, %u unique.\n", lines[n].size (), nUniq);
<         }
<       } else {
< !       fprintf (stderr, "%s: Unable to open %s!  Exiting....\n", ARGV0, files[n]);
< !       perror (ARGV0);
< !       exit (1);
<       }
<     }
< ! 
< !   if (0 < optVerbose) {
< !     printf ("# Total unique lines = %d\n", table.size ());
< !   }
< ! 
< !   // map<int, int> counts;
< !   // for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
< !   //   Line *l = i->second;
< !   //   counts[l->counts[0].size () + l->counts[1].size ()] += 1;
< !   // }
< !   // for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
< !   //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
< !   // }
< ! 
< !   // Perform pass #1, in which we find all explicit matches amongst
< !   // the unique lines.  For every unique line that appears the same
< !   // number of times in both files, we declare the lines to match.
< ! 
< !   if (0 < optVerbose) {
< !     fprintf (stderr, "# Pass 1 (finding matches amongst unique lines)...");
< !   }
< ! 
< !   nMatchedLines = 0;
< ! 
< !   for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
<       Line *l = i->second;
< ! 
< !     // If the number of old and new lines match, then we declare that
< !     // they are (all) the same line.  Note, it isn't possible for the
< !     // numbers of both files to be 0.
< ! 
< !     // (In the original algorithm, we only recognized a match, here,
< !     // if there was exactly 1 copy for each file.)
< ! 
< !     if (l->copies[0].size () == l->copies[1].size ()) {
< !       nMatchedLines += 1;
< ! 
< !       // For each matched line in the new file, mark it with the
< !       // corresponding line (number) in the old file.
< ! 
< !       while (!l->copies[0].empty ()) {
< !         unsigned o = l->copies[0].front ();
< !         unsigned n = l->copies[1].front ();
< ! 
< !         // Match up the pair.
< ! 
< !         lines[0][o].l = n;
< !         lines[1][n].l = o;
< ! 
< !         // Remove the matched line numbers from the lists.
< ! 
< !         l->copies[0].pop_front ();
< !         l->copies[1].pop_front ();
< !       }
< !     }
< !   }
< !   nTotalMatchedLines += nMatchedLines;
< ! 
< !   // Let's see the intermediate results.
< ! 
< !   if (0 < optVerbose) {
< !     fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
< ! 
< !     if (1 < optVerbose) {
< !       for (int f = 0; f < 2; f += 1) {
< !         fprintf (stderr, "# file #%d\n", f + 1);
< !         for (int l = 0; l < lines[f].size (); l += 1) {
< !           fprintf (stderr, "#   [%d] ", l);
< !           lines[f][l].Dump (stderr);
< !         }
< !       }
< !     }
< !   }
< ! 
< !   // Perform Pass #2, in which we attempt to 'widen' blocks of matched
< !   // lines, by appending lines which are the same in both files.
< ! 
< !   if (0 < optVerbose) {
< !     fprintf (stderr, "# Pass #2 (spreading matches down)...");
< !   }
< ! 
< !   nMatchedBlocks = 0;
< !   nMatchedLines = 0;
< ! 
< !   // Starting at the top of the old file,...
< ! 
< !   for (unsigned o = 0; o < lines[0].size (); o += 1) {
< ! 
< !     // ... skip any currently unmatched lines...
< ! 
< !     if (lines[0][o].l == ~0) {
< !       continue;
< !     }
< ! 
< !     // ... until we find an [already] matched line.  Then, skip over
< !     // the set of 1 or more matched lines, until we reach any
< !     // following, still-unmatched line.
< ! 
< !     unsigned n;
< !     do {
< !       n = lines[0][o].l + 1;
< !       o += 1;
< !     } while (o < lines[0].size () && lines[0][o].l != ~0);
< ! 
< !     // Now, o - 1 is the line number of the last matched old line, and
< !     // n - 1 is the line number of the last matched new line.  We want
< !     // to add new old and new lines, if they match.
< ! 
< !     // Finally, attempt to add unmatched lines to the preceeding
< !     // matched set.
< ! 
< !     for (; o < lines[0].size () && lines[0][o].l == ~0; o += 1, n += 1) {
< ! 
< !       // If the [next] pair of old and new lines aren't the same line, we're done.
< ! 
< !       if (lines[0][o].line != lines[1][n].line) {
< !         break;
< !       }
< ! 
< !       // Match up the pair.
< ! 
< !       lines[0][o].l = n;
< !       lines[1][n].l = o;
< ! 
< !       // Remove the matched line numbers form the lists.
< ! 
< !       Line *line = lines[0][o].line;
< !       list<unsigned> &oldCopies = line->copies[0];
< !       list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
< !       if (oL != oldCopies.end ()) {
< !         oldCopies.erase (oL);
< !       }
< !       list<unsigned> &newCopies = line->copies[0];
< !       list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
< !       if (nL != newCopies.end ()) {
< !         newCopies.erase (nL);
< !       }
< ! 
< !       nMatchedLines += 1;
< !     }
< !     nMatchedBlocks += 1;
< !   }
< !   nTotalMatchedLines += nMatchedLines;
< !   nTotalMatchedBlocks += nMatchedBlocks;
< ! 
< !   // Let's see the intermediate results.
< ! 
< !   if (0 < optVerbose) {
< !     fprintf (stderr,
< !              " found %u/%u matched lines/blocks (%u/%u totals).\n",
< !              nMatchedLines,
< !              nMatchedBlocks,
< !              nTotalMatchedLines,
< !              nTotalMatchedBlocks
< !             );
< !     if (1 < optVerbose) {
< !       for (int f = 0; f < 2; f += 1) {
< !         fprintf (stderr, "# file #%d\n", f + 1);
< !         for (int l = 0; l < lines[f].size (); l += 1) {
< !           fprintf (stderr, "#   [%d] ", l);
< !           lines[f][l].Dump (stderr);
< !         }
< !       }
< !     }
<     }
< ! 
< !   // Perform Pass #3, in which we attempt to 'widen' blocks of matched
< !   // lines, by prepending lines which are the same in both files.
< ! 
< !   if (0 < optVerbose) {
< !     fprintf (stderr, "# Pass #3 (spreading matches up)...");
<     }
< ! 
< !   nMatchedBlocks = 0;
< !   nMatchedLines = 0;
< ! 
< !   // Starting at the bottom of the old file,...
< ! 
< !   for (int o = lines[0].size (); 0 <= o; o -= 1) {
< ! 
< !     // ... skip any currently unmatched lines...
< ! 
< !     if (lines[0][o].l == ~0) {
< !       continue;
< !     }
< ! 
< !     // ... until we find an [already] matched line.  Then, skip over
< !     // the set of 1 or more matched lines, until we reach any
< !     // following, still-unmatched line.
< ! 
< !     unsigned n;
< !     do {
< !       n = lines[0][o].l - 1;
< !       o -= 1;
< !     } while (0 <= o && lines[0][o].l != ~0);
< ! 
< !     // Now, o + 1 is the line number of the last matched old line, and
< !     // n + 1 is the line number of the last matched new line.  We want
< !     // to add new old and new lines, if they match.
< ! 
< !     // Finally, attempt to add unmatched lines to the preceeding
< !     // matched set.
< ! 
< !     for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
< ! 
< !       // If the [next] pair of old and new lines aren't the same line, we're done.
< ! 
< !       if (lines[0][o].line != lines[1][n].line) {
< !         break;
< !       }
< ! 
< !       // Match up the pair.
< ! 
< !       lines[0][o].l = n;
< !       lines[1][n].l = o;
< ! 
< !       // Remove the matched line numbers form the lists.
< ! 
< !       Line *line = lines[0][o].line;
< !       list<unsigned> &oldCopies = line->copies[0];
< !       list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
< !       if (oL != oldCopies.end ()) {
< !         oldCopies.erase (oL);
< !       }
< !       list<unsigned> &newCopies = line->copies[0];
< !       list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
< !       if (nL != newCopies.end ()) {
< !         newCopies.erase (nL);
< !       }
< ! 
< !       nMatchedLines += 1;
< !     }
< !     nMatchedBlocks += 1;
< !   }
< !   nTotalMatchedLines += nMatchedLines;
< ! 
< !   // Let's see the intermediate results.
< ! 
< !   if (0 < optVerbose) {
< !     fprintf (stderr,
< !              " found %u/%u matched lines/blocks (%u/%u totals).\n",
< !              nMatchedLines,
< !              nMatchedBlocks,
< !              nTotalMatchedLines,
< !              nTotalMatchedBlocks
< !             );
< ! 
< !     if (1 < optVerbose) {
< !       for (int f = 0; f < 2; f += 1) {
< !         fprintf (stderr, "# file #%d\n", f + 1);
< !         for (int l = 0; l < lines[f].size (); l += 1) {
< !           fprintf (stderr, "#   [%d] ", l);
< !           lines[f][l].Dump (stderr);
< !         }
< !       }
< !     }
< !   }
< ! 
< !   // Perform pass #4, in which we find any remaining matches amongst
< !   // the unique lines.  For every unique line that has more than 1
< !   // copy in both files, we declare the copies to match.
< ! 
< !   if (0 < optVerbose) {
< !     fprintf (stderr, "# Pass 4 (finding remaining matches amongst unique lines)...");
< !   }
< ! 
< !   nMatchedLines = 0;
< ! 
< !   for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
< !     Line *l = i->second;
< ! 
< !     // If there's more than 1 matching old and new lines, then we
< !     // declare that each pair are (all) the same line.
< ! 
< !     // (In the original algorithm, we only recognized a match, here,
< !     // if there was exactly 1 copy for each file.)
< ! 
< !     while (0 < l->copies[0].size () && 0 < l->copies[1].size ()) {
< !       nMatchedLines += 1;
< ! 
< !       // For each matched line in the new file, mark it with the
< !       // corresponding line (number) in the old file.
< ! 
< !       unsigned o = l->copies[0].front ();
< !       unsigned n = l->copies[1].front ();
< ! 
< !       // Match up the pair.
< ! 
< !       lines[0][o].l = n;
< !       lines[1][n].l = o;
< ! 
< !       // Remove the matched line numbers from the lists.
< ! 
< !       l->copies[0].pop_front ();
< !       l->copies[1].pop_front ();
< !     }
< !   }
< !   nTotalMatchedLines += nMatchedLines;
< ! 
< !   // Let's see the intermediate results.
< ! 
< !   if (0 < optVerbose) {
< !     fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
< ! 
< !     if (1 < optVerbose) {
< !       for (int f = 0; f < 2; f += 1) {
< !         fprintf (stderr, "# file #%d\n", f + 1);
< !         for (int l = 0; l < lines[f].size (); l += 1) {
< !           fprintf (stderr, "#   [%d] ", l);
< !           lines[f][l].Dump (stderr);
< !         }
< !       }
< !     }
< !   }
< ! 
< !   // Perform Pass #5, in which we look for blocks which match, but are
< !   // the result of a move (their not in their original position).  For
< !   // these, we'll unmatch the blocks, turning them into a delete and
< !   // an insert.
< ! 
< !   if (0 < optVerbose) {
< !     fprintf (stderr, "# Pass #5 (unmatching block moves)...\n");
< !   }
< ! 
< !   nMatchedBlocks = 0;
< !   nMatchedLines = 0;
< ! 
< !   // Starting at the top of both files,...
< ! 
< !   unsigned o = 0;
< !   unsigned n = 0;
< ! 
< !   while (o < lines[0].size () || n < lines[1].size ()) {
< ! 
< !     // Skip any unmatched lines at this point in the old file.  These
< !     // are deletes.
< ! 
< !     //    Old     New
< !     //   +---+
< !     // 0 | a |
< !     //   +---+   +---+
< !     //         0 | b |
< !     //   +---+   +---+
< !     // 1 | c | 1 | c |
< !     //   +---+   +---+
< !     //         2 | z |
< !     //   +---+   +---+
< !     // 2 | d | 3 | d |
< !     //   +---+   +---+
< ! 
< !     while (o < lines[0].size () && lines[0][o].l == ~0) {
< !       o += 1;
< !     }
< ! 
< !     // Skip any unmatched lines at this point in the new file.  These
< !     // are inserts.
< ! 
< !     while (n < lines[1].size () && lines[1][n].l == ~0) {
< !       n += 1;
< !     }
< ! 
< !     // When we get here, we know that we're dealing with matching
< !     // lines (or the end of one or both files).  We're done with this
< !     // pass, if we've reached the end of either file.
< ! 
< !     if (lines[0].size () <= o || lines[1].size () <= n) {
< !       break;
< !     }
< ! 
< !     // We now know that we've got a pair of matching lines, the start
< !     // of a matching block.  If the new file's line number is what we
< !     // expect, then the matched pair is unmoved, and we can skip over
< !     // the pair.  (If this is really the start of a block of more than
< !     // 1 lines, we'll handle it one pair at a time.)
< ! 
< !     if (lines[0][o].l == n) {
< !       o += 1;
< !       n += 1;
< !       continue;
< !     }
< ! 
< !     // If, on the other hand, we don't expect this [new] line number,
< !     // then this matching block has been moved.  We need to turn the
< !     // matched pair into an *unmatched* pair, one of deletes, and one
< !     // of inserts.  First, though, we need to know how big this block
< !     // is, and how far it was moved....
< ! 
< !     // Remember where we were when we started.
< ! 
< !     unsigned oOld = o;
< !     unsigned nOld = n;
< ! 
< !     // Remember where the block came from.
< ! 
< !     unsigned nNew = lines[0][o].l;
< ! 
< !     // Find the end of this matched pair.
< ! 
< !     for (n = nNew; o < lines[0].size () && n < lines[1].size (); o += 1, n += 1) {
< !       if (lines[0][o].l != n) {
< !         break;
< !       }
< !     }
< ! 
< !     // When we get here:
< !     // * oOld..o is the old file's block,
< !     // * nNew..n is the new file's *moved* block, and
< !     // * nOld is where we originally expected the new block from.
< !  
< !     // We can now calculate the length of the block...
< !     
< !     unsigned bSize = o - oOld;  // (or n - nNew)
< ! 
< !     // ... and we can calculate how far the block moved:
< ! 
< !     unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
< ! 
< !     // The larger of the two will become our delete, and the smaller
< !     // will become our insert.
< ! 
< !     //    Old     New
< !     //   +---+   +---+
< !     // 0 | a | 0 | b |
< !     //   +---+ 1 | b |
< !     // 1 | b |   +---+
< !     // 2 | b | 2 | a |
< !     //   +---+   +---+
< !     // 3 | c | 3 | c |
< !     //   +---+   +---+
< ! 
< !     // (1) Delete a@0, insert a@2, or
< !     // (2) insert bb@0, delete bb@1?
< ! 
< !     // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and bMove
< !     // (of a) is 2-0 or 2, the size of b@0.  We choose to delete a@0,
< !     // and reinsert a@2.
< ! 
< !     // if (bSize <= bMove) {
< !       for (unsigned a = oOld; a < o; a += 1) {
< !         lines[0][a].l = ~0;
< !       }
< !       for (unsigned d = nNew; d < n; d += 1) {
< !         lines[1][d].l = ~0;
< !       }
< !     // } else {
< !       // for (unsigned a = oOld; a < o; a += 1) {
< !       //   lines[0][a].l = ~0;
< !       // }
< !       // for (unsigned d = nNew; d < n; d += 1) {
< !       //   lines[1][d].l = ~0;
< !       // }
< !     // }
< ! 
< !     // Continue from where we left off.
< ! 
< !     n = nOld;
< !   }
< !   nTotalMatchedLines -= nMatchedLines;
< !   nTotalMatchedBlocks -= nMatchedBlocks;
< ! 
< !   // Let's see the intermediate results.
< ! 
< !   if (0 < optVerbose) {
< !     fprintf (stderr,
< !              " found %u/%u matched lines/blocks (%u/%u totals).\n",
< !              nMatchedLines,
< !              nMatchedBlocks,
< !              nTotalMatchedLines,
< !              nTotalMatchedBlocks
< !             );
< ! 
< !     if (1 < optVerbose) {
< !       for (int f = 0; f < 2; f += 1) {
< !         fprintf (stderr, "# file #%d\n", f + 1);
< !         for (int l = 0; l < lines[f].size (); l += 1) {
< !           fprintf (stderr, "#   [%d] ", l);
< !           lines[f][l].Dump (stderr);
< !         }
< !       }
< !     }
< !   }
< ! 
< !   // Perform Pass #6, in which we create the desired output.
< ! 
< !   if (0 < optVerbose) {
< !     fprintf (stderr, "# Pass #6 (walking the differences)...\n");
< !   }
< ! 
< !   nMatchedLines = 0;
< ! 
< !   // Write the header.
< ! 
< !   switch (diffFormat) {
< !   case Default:
< !   case Normal:
< !     break;
< !   case Unified:
< !     fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
< !     fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
< !     fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), lines[1].size ());
< !     break;
< !   }
< ! 
< !   // Starting at the top of both files,...
< ! 
< !   o = 0;
< !   n = 0;
< ! 
< !   while (o < lines[0].size () || n < lines[1].size ()) {
< ! 
< !     // Find any unmatched lines at this point in the old file.  These
< !     // are deletes.
< ! 
< !     unsigned boDeletes;
< !     for (boDeletes = o;
< !          o < lines[0].size () && lines[0][o].l == ~0;
< !          o += 1
< !         )
< !     {}
< ! 
< !     // Find any unmatched lines at this point in the new file.  These
< !     // are inserts.
< ! 
< !     unsigned boInserts;
< !     for (boInserts = n;
< !          n < lines[1].size () && lines[1][n].l == ~0;
< !          n += 1
< !         )
< !     {}
< ! 
< !     // We've got deleted line(s) from boDeletes .. o.
< !     // We've got deleted line(s) from boInserts .. n.
< ! 
< !     unsigned nDeletes = o - boDeletes;
< !     unsigned nInserts = n - boInserts;
< ! 
< !     // We've got...
< ! 
< !     if (nDeletes && nInserts) {
< ! 
< !       // ... deletes and inserts.
< ! 
< !       switch (diffFormat) {
< !       case Default:
< !       case Normal:
< !         if (1 < nDeletes && 1 < nInserts) {
< !           fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, boInserts + 1, n);
< !         } else if (1 < nDeletes) {
< !           fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boInserts + 1);
< !         } else if (1 < nInserts) {
< !           fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInserts + 1, n);
< !         } 
< !         for (unsigned l = boDeletes; l < o; l += 1) {
< !           fprintf (stdout, "< %s", lines[0][l].line->c_str ());
< !         }
< !         fprintf (stderr, "---\n");
< !         for (unsigned l = boInserts; l < n; l += 1) {
< !           fprintf (stdout, "> %s", lines[1][l].line->c_str ());
< !         }
< !         break;
< ! 
< !       case Unified:
< !         for (unsigned l = boDeletes; l < o; l += 1) {
< !           fprintf (stdout, "-%s", lines[0][l].line->c_str ());
< !         }
< !         for (unsigned l = boInserts; l < n; l += 1) {
< !           fprintf (stdout, "+%s", lines[1][l].line->c_str ());
< !         }
< !         break;
< !       }
< !     } else if (nDeletes) {
< ! 
< !       //  ... just deletes.
< ! 
< !       switch (diffFormat) {
< !       case Default:
< !       case Normal:
< !         if (1 < nDeletes) {
< !           fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
< !         } else {
< !           fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
< !         }
< !         for (unsigned l = boDeletes; l < o; l += 1) {
< !           fprintf (stdout, "< %s", lines[0][l].line->c_str ());
< !         }
< !         break;
< !       case Unified:
< !         for (unsigned l = boDeletes; l < o; l += 1) {
< !           fprintf (stdout, "-%s", lines[0][l].line->c_str ());
< !         }
< !         break;
< !       }
< !     } else if (nInserts) {
< ! 
< !       //  ... just inserts.
< ! 
< !       switch (diffFormat) {
< !       case Default:
< !       case Normal:
< !         if (1 < nInserts) {
< !           fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
< !         } else {
< !           fprintf (stdout, "%da%d\n", o, boInserts + 1);
< !         }
< !         for (unsigned l = boInserts; l < n; l += 1) {
< !           fprintf (stdout, "> %s", lines[1][l].line->c_str ());
< !         }
< !         break;
< !       case Unified:
< !         for (unsigned l = boInserts; l < n; l += 1) {
< !           fprintf (stdout, "+%s", lines[1][l].line->c_str ());
< !         }
< !         break;
< !       }
< !     }
< ! 
< !     // When we get here, we're dealing with matching lines.
< ! 
< !     switch (diffFormat) {
< !     case Default:
< !     case Normal:
< !       break;
< !     case Unified:
< !       fprintf (stdout, " %s", lines[0][o].line->c_str ());
< !       break;
<       }
< +     o += 1;
< +     n += 1;
<     }
<   }
---
> sdiff: sdiff.cpp:1390: void pass6c(): Assertion `widenWindow || lines[0][o].line == lines[1][n].line' failed.
> *** dif.2.cpp	0000-00-00 00:00:00.000000000 +0000
> --- dif.3.cpp	0000-00-00 00:00:00.000000000 +0000
# ../sdiff -c dif.3.cpp dif.2.cpp >& dif.3.2.diff-c.test
./test: line 46: 23327 Aborted                 (core dumped) ${DIFF} "${option}" "${oSrc}" "${nSrc}" 1>&"${dst}.test"
# dif.3.2.diff-c ---------------------------------------------------------------
1,810c1,3
< *** dif.3.cpp	2008-02-22 21:42:10.000000000 +0000
< --- dif.2.cpp	2008-02-20 22:17:26.000000000 +0000
< ***************
< *** 1,5 ****
< - #include <algorithm>
< - using std::find;
<   #include <string>
<   using std::string;
<   #include <list>
< --- 1,3 ----
< ***************
< *** 10,98 ****
<   using std::vector;
<   #include <stdio.h>
<   
< - enum DiffFormat {
< -   Default,
< - 
< -   Context,
< -   EdScript,
< -   IfThenElse,
< -   Normal,
< -   RCS,
< -   SideBySide,
< -   Unified
< - };
< - 
< - DiffFormat diffFormat = Unified;
< - 
< - int optVerbose = 1;
< - 
<   struct Line : public string {
<     Line (string _text) :
< !     string (_text)
<     {
<     }
< !   ~Line () {
< !     copies[0].erase (copies[0].begin (), copies[0].end ());
< !     copies[1].erase (copies[1].begin (), copies[1].end ());
< !   }
< !   void Dump (FILE *out) {
< !     fprintf (out, "{{ ");
< !     for (list<unsigned>::iterator i = copies[0].begin (); i != copies[0].end (); i++) {
< !       fprintf (out, "%u ", *i);
< !     }
< !     fprintf (out, "},{ ");
< !     for (list<unsigned>::iterator i = copies[1].begin (); i != copies[1].end (); i++) {
< !       fprintf (out, "%u ", *i);
< !     }
< !     fprintf (out, "}}\t%s", c_str ());
< !   }
< !   list<unsigned> copies[2];
< ! };
< ! 
< ! struct LinePtr {
< !   LinePtr (Line *_line) :
< !     line (_line),
< !     l (~0u)
< !   {
< !   }
< !   void Dump (FILE *out) {
< !     fprintf (out, "[%d] ", l);
< !     line->Dump (out);
< !   }
< !   Line *line;
< !   unsigned l;
<   };
<   
<   typedef map<string, Line *> MapStringToLinePtr;
< ! typedef vector<LinePtr> VectorLinePtr;
< ! 
< ! char *ARGV0 = "dif2";
<   
<   int main (int argc, char *argv[])
<   {
< -   char const *files[2] = { 0, 0 };
< - 
<     MapStringToLinePtr table;
<     VectorLinePtr lines[2];
<   
< !   unsigned nTotalMatchedBlocks = 0;
< !   unsigned nMatchedBlocks = 0;
< !   unsigned nTotalMatchedLines = 0;
< !   unsigned nMatchedLines = 0;
< ! 
< !   // Read the old [0] file, and the new [1] file.
< ! 
< !   for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
< !     files[n] = argv[a];
< ! 
< !     if (FILE *f = fopen (files[n], "r")) {
< !       if (0 < optVerbose) {
< !         fprintf (stderr, "# Reading %s...", files[n]);
< !       }
<   
<         char buffer[1024];
< -       unsigned nUniq = 0;
< - 
<         while (fgets (buffer, sizeof (buffer), f)) {
<           string text (buffer);
<   
< --- 8,36 ----
<   using std::vector;
<   #include <stdio.h>
<   
<   struct Line : public string {
<     Line (string _text) :
< !     text (_text)
<     {
<     }
< !   string text;
< !   list<unsigned> counts[2];
<   };
<   
<   typedef map<string, Line *> MapStringToLinePtr;
< ! typedef vector<Line *> VectorLinePtr;
<   
<   int main (int argc, char *argv[])
<   {
<     MapStringToLinePtr table;
<     VectorLinePtr lines[2];
<   
< !   for (int a = 1; a < argc && a <= 2; a += 1) {
< !     if (FILE *f = fopen (argv[a], "r")) {
< !       fprintf (stderr, "# Reading %s...", argv[a]);
<   
< +       VectorLinePtr *lines = new VectorLinePtr ();
<         char buffer[1024];
<         while (fgets (buffer, sizeof (buffer), f)) {
<           string text (buffer);
<   
< ***************
< *** 100,747 ****
<   
<           if (!line) {
<             table[text] = line = new Line (text);
< -           nUniq += 1;
<           }
< !         line->copies[n].push_back (lines[n].size ());
< !         lines[n].push_back (line);
< !       }
< ! 
< !       if (0 < optVerbose) {
< !         fprintf (stderr, " %u lines, %u unique.\n", lines[n].size (), nUniq);
<         }
<       } else {
< !       fprintf (stderr, "%s: Unable to open %s!  Exiting....\n", ARGV0, files[n]);
< !       perror (ARGV0);
< !       exit (1);
<       }
<     }
< ! 
< !   if (0 < optVerbose) {
< !     printf ("# Total unique lines = %d\n", table.size ());
< !   }
< ! 
< !   // map<int, int> counts;
< !   // for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
< !   //   Line *l = i->second;
< !   //   counts[l->counts[0].size () + l->counts[1].size ()] += 1;
< !   // }
< !   // for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
< !   //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
< !   // }
< ! 
< !   // Perform pass #1, in which we find all explicit matches amongst
< !   // the unique lines.  For every unique line that appears the same
< !   // number of times in both files, we declare the lines to match.
< ! 
< !   if (0 < optVerbose) {
< !     fprintf (stderr, "# Pass 1 (finding matches amongst unique lines)...");
< !   }
< ! 
< !   nMatchedLines = 0;
< ! 
< !   for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
<       Line *l = i->second;
< ! 
< !     // If the number of old and new lines match, then we declare that
< !     // they are (all) the same line.  Note, it isn't possible for the
< !     // numbers of both files to be 0.
< ! 
< !     // (In the original algorithm, we only recognized a match, here,
< !     // if there was exactly 1 copy for each file.)
< ! 
< !     if (l->copies[0].size () == l->copies[1].size ()) {
< !       nMatchedLines += 1;
< ! 
< !       // For each matched line in the new file, mark it with the
< !       // corresponding line (number) in the old file.
< ! 
< !       while (!l->copies[0].empty ()) {
< !         unsigned o = l->copies[0].front ();
< !         unsigned n = l->copies[1].front ();
< ! 
< !         // Match up the pair.
< ! 
< !         lines[0][o].l = n;
< !         lines[1][n].l = o;
< ! 
< !         // Remove the matched line numbers from the lists.
< ! 
< !         l->copies[0].pop_front ();
< !         l->copies[1].pop_front ();
< !       }
< !     }
< !   }
< !   nTotalMatchedLines += nMatchedLines;
< ! 
< !   // Let's see the intermediate results.
< ! 
< !   if (0 < optVerbose) {
< !     fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
< ! 
< !     if (1 < optVerbose) {
< !       for (int f = 0; f < 2; f += 1) {
< !         fprintf (stderr, "# file #%d\n", f + 1);
< !         for (int l = 0; l < lines[f].size (); l += 1) {
< !           fprintf (stderr, "#   [%d] ", l);
< !           lines[f][l].Dump (stderr);
< !         }
< !       }
< !     }
< !   }
< ! 
< !   // Perform Pass #2, in which we attempt to 'widen' blocks of matched
< !   // lines, by appending lines which are the same in both files.
< ! 
< !   if (0 < optVerbose) {
< !     fprintf (stderr, "# Pass #2 (spreading matches down)...");
< !   }
< ! 
< !   nMatchedBlocks = 0;
< !   nMatchedLines = 0;
< ! 
< !   // Starting at the top of the old file,...
< ! 
< !   for (unsigned o = 0; o < lines[0].size (); o += 1) {
< ! 
< !     // ... skip any currently unmatched lines...
< ! 
< !     if (lines[0][o].l == ~0) {
< !       continue;
< !     }
< ! 
< !     // ... until we find an [already] matched line.  Then, skip over
< !     // the set of 1 or more matched lines, until we reach any
< !     // following, still-unmatched line.
< ! 
< !     unsigned n;
< !     do {
< !       n = lines[0][o].l + 1;
< !       o += 1;
< !     } while (o < lines[0].size () && lines[0][o].l != ~0);
< ! 
< !     // Now, o - 1 is the line number of the last matched old line, and
< !     // n - 1 is the line number of the last matched new line.  We want
< !     // to add new old and new lines, if they match.
< ! 
< !     // Finally, attempt to add unmatched lines to the preceeding
< !     // matched set.
< ! 
< !     for (; o < lines[0].size () && lines[0][o].l == ~0; o += 1, n += 1) {
< ! 
< !       // If the [next] pair of old and new lines aren't the same line, we're done.
< ! 
< !       if (lines[0][o].line != lines[1][n].line) {
< !         break;
< !       }
< ! 
< !       // Match up the pair.
< ! 
< !       lines[0][o].l = n;
< !       lines[1][n].l = o;
< ! 
< !       // Remove the matched line numbers form the lists.
< ! 
< !       Line *line = lines[0][o].line;
< !       list<unsigned> &oldCopies = line->copies[0];
< !       list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
< !       if (oL != oldCopies.end ()) {
< !         oldCopies.erase (oL);
< !       }
< !       list<unsigned> &newCopies = line->copies[0];
< !       list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
< !       if (nL != newCopies.end ()) {
< !         newCopies.erase (nL);
< !       }
< ! 
< !       nMatchedLines += 1;
< !     }
< !     nMatchedBlocks += 1;
< !   }
< !   nTotalMatchedLines += nMatchedLines;
< !   nTotalMatchedBlocks += nMatchedBlocks;
< ! 
< !   // Let's see the intermediate results.
< ! 
< !   if (0 < optVerbose) {
< !     fprintf (stderr,
< !              " found %u/%u matched lines/blocks (%u/%u totals).\n",
< !              nMatchedLines,
< !              nMatchedBlocks,
< !              nTotalMatchedLines,
< !              nTotalMatchedBlocks
< !             );
< !     if (1 < optVerbose) {
< !       for (int f = 0; f < 2; f += 1) {
< !         fprintf (stderr, "# file #%d\n", f + 1);
< !         for (int l = 0; l < lines[f].size (); l += 1) {
< !           fprintf (stderr, "#   [%d] ", l);
< !           lines[f][l].Dump (stderr);
< !         }
< !       }
< !     }
<     }
< ! 
< !   // Perform Pass #3, in which we attempt to 'widen' blocks of matched
< !   // lines, by prepending lines which are the same in both files.
< ! 
< !   if (0 < optVerbose) {
< !     fprintf (stderr, "# Pass #3 (spreading matches up)...");
<     }
< ! 
< !   nMatchedBlocks = 0;
< !   nMatchedLines = 0;
< ! 
< !   // Starting at the bottom of the old file,...
< ! 
< !   for (int o = lines[0].size (); 0 <= o; o -= 1) {
< ! 
< !     // ... skip any currently unmatched lines...
< ! 
< !     if (lines[0][o].l == ~0) {
< !       continue;
< !     }
< ! 
< !     // ... until we find an [already] matched line.  Then, skip over
< !     // the set of 1 or more matched lines, until we reach any
< !     // following, still-unmatched line.
< ! 
< !     unsigned n;
< !     do {
< !       n = lines[0][o].l - 1;
< !       o -= 1;
< !     } while (0 <= o && lines[0][o].l != ~0);
< ! 
< !     // Now, o + 1 is the line number of the last matched old line, and
< !     // n + 1 is the line number of the last matched new line.  We want
< !     // to add new old and new lines, if they match.
< ! 
< !     // Finally, attempt to add unmatched lines to the preceeding
< !     // matched set.
< ! 
< !     for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
< ! 
< !       // If the [next] pair of old and new lines aren't the same line, we're done.
< ! 
< !       if (lines[0][o].line != lines[1][n].line) {
< !         break;
< !       }
< ! 
< !       // Match up the pair.
< ! 
< !       lines[0][o].l = n;
< !       lines[1][n].l = o;
< ! 
< !       // Remove the matched line numbers form the lists.
< ! 
< !       Line *line = lines[0][o].line;
< !       list<unsigned> &oldCopies = line->copies[0];
< !       list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
< !       if (oL != oldCopies.end ()) {
< !         oldCopies.erase (oL);
< !       }
< !       list<unsigned> &newCopies = line->copies[0];
< !       list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
< !       if (nL != newCopies.end ()) {
< !         newCopies.erase (nL);
< !       }
< ! 
< !       nMatchedLines += 1;
< !     }
< !     nMatchedBlocks += 1;
< !   }
< !   nTotalMatchedLines += nMatchedLines;
< ! 
< !   // Let's see the intermediate results.
< ! 
< !   if (0 < optVerbose) {
< !     fprintf (stderr,
< !              " found %u/%u matched lines/blocks (%u/%u totals).\n",
< !              nMatchedLines,
< !              nMatchedBlocks,
< !              nTotalMatchedLines,
< !              nTotalMatchedBlocks
< !             );
< ! 
< !     if (1 < optVerbose) {
< !       for (int f = 0; f < 2; f += 1) {
< !         fprintf (stderr, "# file #%d\n", f + 1);
< !         for (int l = 0; l < lines[f].size (); l += 1) {
< !           fprintf (stderr, "#   [%d] ", l);
< !           lines[f][l].Dump (stderr);
< !         }
< !       }
< !     }
< !   }
< ! 
< !   // Perform pass #4, in which we find any remaining matches amongst
< !   // the unique lines.  For every unique line that has more than 1
< !   // copy in both files, we declare the copies to match.
< ! 
< !   if (0 < optVerbose) {
< !     fprintf (stderr, "# Pass 4 (finding remaining matches amongst unique lines)...");
< !   }
< ! 
< !   nMatchedLines = 0;
< ! 
< !   for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
< !     Line *l = i->second;
< ! 
< !     // If there's more than 1 matching old and new lines, then we
< !     // declare that each pair are (all) the same line.
< ! 
< !     // (In the original algorithm, we only recognized a match, here,
< !     // if there was exactly 1 copy for each file.)
< ! 
< !     while (0 < l->copies[0].size () && 0 < l->copies[1].size ()) {
< !       nMatchedLines += 1;
< ! 
< !       // For each matched line in the new file, mark it with the
< !       // corresponding line (number) in the old file.
< ! 
< !       unsigned o = l->copies[0].front ();
< !       unsigned n = l->copies[1].front ();
< ! 
< !       // Match up the pair.
< ! 
< !       lines[0][o].l = n;
< !       lines[1][n].l = o;
< ! 
< !       // Remove the matched line numbers from the lists.
< ! 
< !       l->copies[0].pop_front ();
< !       l->copies[1].pop_front ();
< !     }
< !   }
< !   nTotalMatchedLines += nMatchedLines;
< ! 
< !   // Let's see the intermediate results.
< ! 
< !   if (0 < optVerbose) {
< !     fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
< ! 
< !     if (1 < optVerbose) {
< !       for (int f = 0; f < 2; f += 1) {
< !         fprintf (stderr, "# file #%d\n", f + 1);
< !         for (int l = 0; l < lines[f].size (); l += 1) {
< !           fprintf (stderr, "#   [%d] ", l);
< !           lines[f][l].Dump (stderr);
< !         }
< !       }
< !     }
< !   }
< ! 
< !   // Perform Pass #5, in which we look for blocks which match, but are
< !   // the result of a move (their not in their original position).  For
< !   // these, we'll unmatch the blocks, turning them into a delete and
< !   // an insert.
< ! 
< !   if (0 < optVerbose) {
< !     fprintf (stderr, "# Pass #5 (unmatching block moves)...\n");
< !   }
< ! 
< !   nMatchedBlocks = 0;
< !   nMatchedLines = 0;
< ! 
< !   // Starting at the top of both files,...
< ! 
< !   unsigned o = 0;
< !   unsigned n = 0;
< ! 
< !   while (o < lines[0].size () || n < lines[1].size ()) {
< ! 
< !     // Skip any unmatched lines at this point in the old file.  These
< !     // are deletes.
< ! 
< !     //    Old     New
< !     //   +---+
< !     // 0 | a |
< !     //   +---+   +---+
< !     //         0 | b |
< !     //   +---+   +---+
< !     // 1 | c | 1 | c |
< !     //   +---+   +---+
< !     //         2 | z |
< !     //   +---+   +---+
< !     // 2 | d | 3 | d |
< !     //   +---+   +---+
< ! 
< !     while (o < lines[0].size () && lines[0][o].l == ~0) {
< !       o += 1;
< !     }
< ! 
< !     // Skip any unmatched lines at this point in the new file.  These
< !     // are inserts.
< ! 
< !     while (n < lines[1].size () && lines[1][n].l == ~0) {
< !       n += 1;
< !     }
< ! 
< !     // When we get here, we know that we're dealing with matching
< !     // lines (or the end of one or both files).  We're done with this
< !     // pass, if we've reached the end of either file.
< ! 
< !     if (lines[0].size () <= o || lines[1].size () <= n) {
< !       break;
< !     }
< ! 
< !     // We now know that we've got a pair of matching lines, the start
< !     // of a matching block.  If the new file's line number is what we
< !     // expect, then the matched pair is unmoved, and we can skip over
< !     // the pair.  (If this is really the start of a block of more than
< !     // 1 lines, we'll handle it one pair at a time.)
< ! 
< !     if (lines[0][o].l == n) {
< !       o += 1;
< !       n += 1;
< !       continue;
< !     }
< ! 
< !     // If, on the other hand, we don't expect this [new] line number,
< !     // then this matching block has been moved.  We need to turn the
< !     // matched pair into an *unmatched* pair, one of deletes, and one
< !     // of inserts.  First, though, we need to know how big this block
< !     // is, and how far it was moved....
< ! 
< !     // Remember where we were when we started.
< ! 
< !     unsigned oOld = o;
< !     unsigned nOld = n;
< ! 
< !     // Remember where the block came from.
< ! 
< !     unsigned nNew = lines[0][o].l;
< ! 
< !     // Find the end of this matched pair.
< ! 
< !     for (n = nNew; o < lines[0].size () && n < lines[1].size (); o += 1, n += 1) {
< !       if (lines[0][o].l != n) {
< !         break;
< !       }
< !     }
< ! 
< !     // When we get here:
< !     // * oOld..o is the old file's block,
< !     // * nNew..n is the new file's *moved* block, and
< !     // * nOld is where we originally expected the new block from.
< !  
< !     // We can now calculate the length of the block...
< !     
< !     unsigned bSize = o - oOld;  // (or n - nNew)
< ! 
< !     // ... and we can calculate how far the block moved:
< ! 
< !     unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
< ! 
< !     // The larger of the two will become our delete, and the smaller
< !     // will become our insert.
< ! 
< !     //    Old     New
< !     //   +---+   +---+
< !     // 0 | a | 0 | b |
< !     //   +---+ 1 | b |
< !     // 1 | b |   +---+
< !     // 2 | b | 2 | a |
< !     //   +---+   +---+
< !     // 3 | c | 3 | c |
< !     //   +---+   +---+
< ! 
< !     // (1) Delete a@0, insert a@2, or
< !     // (2) insert bb@0, delete bb@1?
< ! 
< !     // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and bMove
< !     // (of a) is 2-0 or 2, the size of b@0.  We choose to delete a@0,
< !     // and reinsert a@2.
< ! 
< !     // if (bSize <= bMove) {
< !       for (unsigned a = oOld; a < o; a += 1) {
< !         lines[0][a].l = ~0;
< !       }
< !       for (unsigned d = nNew; d < n; d += 1) {
< !         lines[1][d].l = ~0;
< !       }
< !     // } else {
< !       // for (unsigned a = oOld; a < o; a += 1) {
< !       //   lines[0][a].l = ~0;
< !       // }
< !       // for (unsigned d = nNew; d < n; d += 1) {
< !       //   lines[1][d].l = ~0;
< !       // }
< !     // }
< ! 
< !     // Continue from where we left off.
< ! 
< !     n = nOld;
< !   }
< !   nTotalMatchedLines -= nMatchedLines;
< !   nTotalMatchedBlocks -= nMatchedBlocks;
< ! 
< !   // Let's see the intermediate results.
< ! 
< !   if (0 < optVerbose) {
< !     fprintf (stderr,
< !              " found %u/%u matched lines/blocks (%u/%u totals).\n",
< !              nMatchedLines,
< !              nMatchedBlocks,
< !              nTotalMatchedLines,
< !              nTotalMatchedBlocks
< !             );
< ! 
< !     if (1 < optVerbose) {
< !       for (int f = 0; f < 2; f += 1) {
< !         fprintf (stderr, "# file #%d\n", f + 1);
< !         for (int l = 0; l < lines[f].size (); l += 1) {
< !           fprintf (stderr, "#   [%d] ", l);
< !           lines[f][l].Dump (stderr);
< !         }
< !       }
< !     }
< !   }
< ! 
< !   // Perform Pass #6, in which we create the desired output.
< ! 
< !   if (0 < optVerbose) {
< !     fprintf (stderr, "# Pass #6 (walking the differences)...\n");
< !   }
< ! 
< !   nMatchedLines = 0;
< ! 
< !   // Write the header.
< ! 
< !   switch (diffFormat) {
< !   case Default:
< !   case Normal:
< !     break;
< !   case Unified:
< !     fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
< !     fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
< !     fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), lines[1].size ());
< !     break;
< !   }
< ! 
< !   // Starting at the top of both files,...
< ! 
< !   o = 0;
< !   n = 0;
< ! 
< !   while (o < lines[0].size () || n < lines[1].size ()) {
< ! 
< !     // Find any unmatched lines at this point in the old file.  These
< !     // are deletes.
< ! 
< !     unsigned boDeletes;
< !     for (boDeletes = o;
< !          o < lines[0].size () && lines[0][o].l == ~0;
< !          o += 1
< !         )
< !     {}
< ! 
< !     // Find any unmatched lines at this point in the new file.  These
< !     // are inserts.
< ! 
< !     unsigned boInserts;
< !     for (boInserts = n;
< !          n < lines[1].size () && lines[1][n].l == ~0;
< !          n += 1
< !         )
< !     {}
< ! 
< !     // We've got deleted line(s) from boDeletes .. o.
< !     // We've got deleted line(s) from boInserts .. n.
< ! 
< !     unsigned nDeletes = o - boDeletes;
< !     unsigned nInserts = n - boInserts;
< ! 
< !     // We've got...
< ! 
< !     if (nDeletes && nInserts) {
< ! 
< !       // ... deletes and inserts.
< ! 
< !       switch (diffFormat) {
< !       case Default:
< !       case Normal:
< !         if (1 < nDeletes && 1 < nInserts) {
< !           fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, boInserts + 1, n);
< !         } else if (1 < nDeletes) {
< !           fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boInserts + 1);
< !         } else if (1 < nInserts) {
< !           fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInserts + 1, n);
< !         } 
< !         for (unsigned l = boDeletes; l < o; l += 1) {
< !           fprintf (stdout, "< %s", lines[0][l].line->c_str ());
< !         }
< !         fprintf (stderr, "---\n");
< !         for (unsigned l = boInserts; l < n; l += 1) {
< !           fprintf (stdout, "> %s", lines[1][l].line->c_str ());
< !         }
< !         break;
< ! 
< !       case Unified:
< !         for (unsigned l = boDeletes; l < o; l += 1) {
< !           fprintf (stdout, "-%s", lines[0][l].line->c_str ());
< !         }
< !         for (unsigned l = boInserts; l < n; l += 1) {
< !           fprintf (stdout, "+%s", lines[1][l].line->c_str ());
< !         }
< !         break;
< !       }
< !     } else if (nDeletes) {
< ! 
< !       //  ... just deletes.
< ! 
< !       switch (diffFormat) {
< !       case Default:
< !       case Normal:
< !         if (1 < nDeletes) {
< !           fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
< !         } else {
< !           fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
< !         }
< !         for (unsigned l = boDeletes; l < o; l += 1) {
< !           fprintf (stdout, "< %s", lines[0][l].line->c_str ());
< !         }
< !         break;
< !       case Unified:
< !         for (unsigned l = boDeletes; l < o; l += 1) {
< !           fprintf (stdout, "-%s", lines[0][l].line->c_str ());
< !         }
< !         break;
< !       }
< !     } else if (nInserts) {
< ! 
< !       //  ... just inserts.
< ! 
< !       switch (diffFormat) {
< !       case Default:
< !       case Normal:
< !         if (1 < nInserts) {
< !           fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
< !         } else {
< !           fprintf (stdout, "%da%d\n", o, boInserts + 1);
< !         }
< !         for (unsigned l = boInserts; l < n; l += 1) {
< !           fprintf (stdout, "> %s", lines[1][l].line->c_str ());
< !         }
< !         break;
< !       case Unified:
< !         for (unsigned l = boInserts; l < n; l += 1) {
< !           fprintf (stdout, "+%s", lines[1][l].line->c_str ());
< !         }
< !         break;
< !       }
< !     }
< ! 
< !     // When we get here, we're dealing with matching lines.
< ! 
< !     switch (diffFormat) {
< !     case Default:
< !     case Normal:
< !       break;
< !     case Unified:
< !       fprintf (stdout, " %s", lines[0][o].line->c_str ());
< !       break;
<       }
< -     o += 1;
< -     n += 1;
<     }
<   }
< --- 38,65 ----
<   
<           if (!line) {
<             table[text] = line = new Line (text);
<           }
< !         line->counts[a - 1].push_back (lines[a - 1].size ());
< !         lines[a - 1].push_back (line);
<         }
< +       fprintf (stderr, " %u lines.\n", lines[a - 1]->size ());
<       } else {
< !       fprintf (stderr, "%s: Unable to open %s!  Ignoring....\n", argv[a]);
<       }
<     }
< !   printf ("# table.size () = %d\n", table.size ());
< !   map<int, int> counts;
< !   for (map<string, int>::iterator i = table.begin (); i != table.end (); i++) {
<       Line *l = i->second;
< !     counts[l->counts[0].size () + l->counts[1].size ()] += 1;
<     }
< !   for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
< !     fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
<     }
< !   for (int f = 0; f < 2; f += 1) {
< !     fprintf (stderr, "# file #%d\n", f + 1);
< !     for (int l = 0; l < lines[f].size (); l += 1) {
< !       fprintf (stderr, "#   [%d] = %d\n", l, lines[f][l]->counts[f].size ());
<       }
<     }
<   }
---
> sdiff: sdiff.cpp:1363: void pass6c(): Assertion `widenWindow || lines[0][o].line == lines[1][n].line' failed.
> *** dif.3.cpp	0000-00-00 00:00:00.000000000 +0000
> --- dif.2.cpp	0000-00-00 00:00:00.000000000 +0000
# ../sdiff -c dif.3.cpp dif.4.cpp >& dif.3.4.diff-c.test
# dif.3.4.diff-c ---------------------------------------------------------------
0a1,2
> *** dif.3.cpp	0000-00-00 00:00:00.000000000 +0000
> --- dif.4.cpp	0000-00-00 00:00:00.000000000 +0000
# ../sdiff -c dif.4.cpp dif.3.cpp >& dif.4.3.diff-c.test
# dif.4.3.diff-c ---------------------------------------------------------------
0a1,2
> *** dif.4.cpp	0000-00-00 00:00:00.000000000 +0000
> --- dif.3.cpp	0000-00-00 00:00:00.000000000 +0000
# ../sdiff -c dif.4.cpp dif.5.cpp >& dif.4.5.diff-c.test
./test: line 46: 23350 Aborted                 (core dumped) ${DIFF} "${option}" "${oSrc}" "${nSrc}" 1>&"${dst}.test"
# dif.4.5.diff-c ---------------------------------------------------------------
1,726c1,3
< *** dif.4.cpp	2008-02-25 18:06:37.000000000 +0000
< --- dif.5.cpp	2008-02-25 19:19:42.000000000 +0000
< ***************
< *** 22,28 ****
<     Unified
<   };
<   
< ! DiffFormat diffFormat = Unified;
<   
<   int optVerbose = 1;
<   
< --- 22,29 ----
<     Unified
<   };
<   
< ! DiffFormat diffFormat = Context;
< ! unsigned optCopyContext = 3;
<   
<   int optVerbose = 1;
<   
< ***************
< *** 66,85 ****
<   typedef map<string, Line *> MapStringToLinePtr;
<   typedef vector<LinePtr> VectorLinePtr;
<   
< ! char *ARGV0 = "dif2";
<   
< ! int main (int argc, char *argv[])
< ! {
< !   char const *files[2] = { 0, 0 };
<   
< !   MapStringToLinePtr table;
< !   VectorLinePtr lines[2];
<   
< !   unsigned nTotalMatchedBlocks = 0;
< !   unsigned nMatchedBlocks = 0;
< !   unsigned nTotalMatchedLines = 0;
< !   unsigned nMatchedLines = 0;
<   
<     // Read the old [0] file, and the new [1] file.
<   
<     for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
< --- 67,104 ----
<   typedef map<string, Line *> MapStringToLinePtr;
<   typedef vector<LinePtr> VectorLinePtr;
<   
< ! // Our name.
<   
< ! char *ARGV0 = "dif3";
< ! 
< ! // The 'symbol' (line) table.
< ! 
< ! MapStringToLinePtr table;
< ! 
< ! // The names of the 2 files to be diff'd.
< ! 
< ! char const *files[2] = { 0, 0 };
< ! 
< ! // The lines of the 2 files to be diff'd.
< ! 
< ! VectorLinePtr lines[2];
<   
< ! // Miscellaneous metrics.
<   
< ! unsigned nTotalMatchedBlocks = 0;
< ! unsigned nMatchedBlocks = 0;
< ! unsigned nTotalMatchedLines = 0;
< ! unsigned nMatchedLines = 0;
<   
< + void pass1 ();
< + void pass2 ();
< + void pass3 ();
< + void pass4 ();
< + void pass5 ();
< + void pass6 ();
< + 
< + int main (int argc, char *argv[])
< + {
<     // Read the old [0] file, and the new [1] file.
<   
<     for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
< ***************
< *** 117,123 ****
<     }
<   
<     if (0 < optVerbose) {
< !     printf ("# Total unique lines = %d\n", table.size ());
<     }
<   
<     // map<int, int> counts;
< --- 136,142 ----
<     }
<   
<     if (0 < optVerbose) {
< !     fprintf (stderr, "# Total unique lines = %d\n", table.size ());
<     }
<   
<     // map<int, int> counts;
< ***************
< *** 129,138 ****
<     //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
<     // }
<   
< !   // Perform pass #1, in which we find all explicit matches amongst
< !   // the unique lines.  For every unique line that appears the same
< !   // number of times in both files, we declare the lines to match.
<   
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass 1 (finding matches amongst unique lines)...");
<     }
< --- 148,169 ----
<     //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
<     // }
<   
< !   pass1 ();
< !   pass2 ();
< !   pass3 ();
< !   pass4 ();
< !   pass5 ();
< !   pass6 ();
<   
< +   return 0;
< + }
< + 
< + // Perform pass #1, in which we find all explicit matches amongst the
< + // unique lines.  For every unique line that appears the same number
< + // of times in both files, we declare the lines to match.
< + 
< + void pass1 ()
< + {
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass 1 (finding matches amongst unique lines)...");
<     }
< ***************
< *** 188,197 ****
<         }
<       }
<     }
<   
< !   // Perform Pass #2, in which we attempt to 'widen' blocks of matched
< !   // lines, by appending lines which are the same in both files.
<   
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass #2 (spreading matches down)...");
<     }
< --- 219,231 ----
<         }
<       }
<     }
< + }
<   
< ! // Perform Pass #2, in which we attempt to 'widen' blocks of matched
< ! // lines, by appending lines which are the same in both files.
<   
< + void pass2 ()
< + {
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass #2 (spreading matches down)...");
<     }
< ***************
< *** 280,289 ****
<         }
<       }
<     }
<   
< !   // Perform Pass #3, in which we attempt to 'widen' blocks of matched
< !   // lines, by prepending lines which are the same in both files.
<   
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass #3 (spreading matches up)...");
<     }
< --- 314,326 ----
<         }
<       }
<     }
< + }
<   
< ! // Perform Pass #3, in which we attempt to 'widen' blocks of matched
< ! // lines, by prepending lines which are the same in both files.
<   
< + void pass3 ()
< + {
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass #3 (spreading matches up)...");
<     }
< ***************
< *** 372,382 ****
<         }
<       }
<     }
<   
< !   // Perform pass #4, in which we find any remaining matches amongst
< !   // the unique lines.  For every unique line that has more than 1
< !   // copy in both files, we declare the copies to match.
<   
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass 4 (finding remaining matches amongst unique lines)...");
<     }
< --- 409,422 ----
<         }
<       }
<     }
< + }
<   
< ! // Perform pass #4, in which we find any remaining matches amongst the
< ! // unique lines.  For every unique line that has more than 1 copy in
< ! // both files, we declare the copies to match.
<   
< + void pass4 ()
< + {
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass 4 (finding remaining matches amongst unique lines)...");
<     }
< ***************
< *** 429,440 ****
<         }
<       }
<     }
<   
< !   // Perform Pass #5, in which we look for blocks which match, but are
< !   // the result of a move (their not in their original position).  For
< !   // these, we'll unmatch the blocks, turning them into a delete and
< !   // an insert.
<   
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass #5 (unmatching block moves)...\n");
<     }
< --- 469,483 ----
<         }
<       }
<     }
< + }
<   
< ! // Perform Pass #5, in which we look for blocks which match, but are
< ! // the result of a move (their not in their original position).  For
< ! // these, we'll unmatch the blocks, turning them into a delete and an
< ! // insert.
<   
< + void pass5 ()
< + {
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass #5 (unmatching block moves)...\n");
<     }
< ***************
< *** 596,627 ****
<         }
<       }
<     }
<   
< !   // Perform Pass #6, in which we create the desired output.
<   
< !   if (0 < optVerbose) {
< !     fprintf (stderr, "# Pass #6 (walking the differences)...\n");
< !   }
<   
< !   nMatchedLines = 0;
< ! 
< !   // Write the header.
<   
<     switch (diffFormat) {
< !   case Default:
<     case Normal:
<       break;
<     case Unified:
< !     fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
< !     fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
< !     fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), lines[1].size ());
<       break;
<     }
<   
<     // Starting at the top of both files,...
<   
< !   o = 0;
< !   n = 0;
<   
<     while (o < lines[0].size () || n < lines[1].size ()) {
<   
< --- 639,725 ----
<         }
<       }
<     }
< + }
<   
< ! // Perform Pass #6, in which we create the desired output.
<   
< ! void pass6c ();
< ! void pass6e ();
< ! void pass6i ();
< ! void pass6n ();
< ! void pass6r ();
< ! void pass6s ();
< ! void pass6u ();
<   
< ! void pass6 ()
< ! {
<   
<     switch (diffFormat) {
< !   case Context:
< !     pass6c ();
< !     break;
< ! 
< !   case EdScript:
< !     pass6e ();
< !     break;
< ! 
< !   case IfThenElse:
< !     pass6i ();
< !     break;
< ! 
<     case Normal:
< +     pass6n ();
<       break;
< + 
< +   case RCS:
< +     pass6r ();
< +     break;
< + 
< +   case SideBySide:
< +     pass6s ();
< +     break;
< + 
<     case Unified:
< !     pass6u ();
< !     break;
< ! 
< !   case Default:
< !   default:
< !     pass6c ();
<       break;
<     }
< + }
< + 
< + template<typename T> T min (T l, T r) {
< +   if (l < r) {
< +     return l;
< +   }
< +   return r;
< + }
< + 
< + template<typename T> T max (T l, T r) {
< +   if (l < r) {
< +     return r;
< +   }
< +   return l;
< + }
< + 
< + void pass6c () {
< +   if (0 < optVerbose) {
< +     fprintf (stderr, "# Pass #6u (walking the differences)...\n");
< +   }
< + 
< +   nMatchedLines = 0;
< + 
< +   // Write the header.
< + 
< +   fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
< +   fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
<   
<     // Starting at the top of both files,...
<   
< !   unsigned o = 0;
< !   unsigned n = 0;
<   
<     while (o < lines[0].size () || n < lines[1].size ()) {
<   
< ***************
< *** 651,746 ****
<       unsigned nDeletes = o - boDeletes;
<       unsigned nInserts = n - boInserts;
<   
< !     // We've got...
<   
< !     if (nDeletes && nInserts) {
<   
< !       // ... deletes and inserts.
<   
< -       switch (diffFormat) {
< -       case Default:
< -       case Normal:
< -         if (1 < nDeletes && 1 < nInserts) {
< -           fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, boInserts + 1, n);
< -         } else if (1 < nDeletes) {
< -           fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boInserts + 1);
< -         } else if (1 < nInserts) {
< -           fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInserts + 1, n);
< -         } 
<           for (unsigned l = boDeletes; l < o; l += 1) {
< !           fprintf (stdout, "< %s", lines[0][l].line->c_str ());
< !         }
< !         fprintf (stderr, "---\n");
< !         for (unsigned l = boInserts; l < n; l += 1) {
< !           fprintf (stdout, "> %s", lines[1][l].line->c_str ());
<           }
< !         break;
<   
< -       case Unified:
<           for (unsigned l = boDeletes; l < o; l += 1) {
< !           fprintf (stdout, "-%s", lines[0][l].line->c_str ());
<           }
<           for (unsigned l = boInserts; l < n; l += 1) {
< !           fprintf (stdout, "+%s", lines[1][l].line->c_str ());
<           }
< !         break;
<         }
<       } else if (nDeletes) {
<   
<         //  ... just deletes.
<   
< !       switch (diffFormat) {
< !       case Default:
< !       case Normal:
< !         if (1 < nDeletes) {
< !           fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
< !         } else {
< !           fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
< !         }
< !         for (unsigned l = boDeletes; l < o; l += 1) {
< !           fprintf (stdout, "< %s", lines[0][l].line->c_str ());
< !         }
< !         break;
< !       case Unified:
< !         for (unsigned l = boDeletes; l < o; l += 1) {
< !           fprintf (stdout, "-%s", lines[0][l].line->c_str ());
< !         }
< !         break;
<         }
<       } else if (nInserts) {
<   
<         //  ... just inserts.
<   
< !       switch (diffFormat) {
< !       case Default:
< !       case Normal:
< !         if (1 < nInserts) {
< !           fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
< !         } else {
< !           fprintf (stdout, "%da%d\n", o, boInserts + 1);
< !         }
< !         for (unsigned l = boInserts; l < n; l += 1) {
< !           fprintf (stdout, "> %s", lines[1][l].line->c_str ());
< !         }
< !         break;
< !       case Unified:
< !         for (unsigned l = boInserts; l < n; l += 1) {
< !           fprintf (stdout, "+%s", lines[1][l].line->c_str ());
< !         }
< !         break;
<         }
<       }
<   
<       // When we get here, we're dealing with matching lines.
<   
< !     switch (diffFormat) {
< !     case Default:
< !     case Normal:
< !       break;
< !     case Unified:
< !       fprintf (stdout, " %s", lines[0][o].line->c_str ());
< !       break;
<       }
<       o += 1;
<       n += 1;
<     }
< --- 749,1010 ----
<       unsigned nDeletes = o - boDeletes;
<       unsigned nInserts = n - boInserts;
<   
< !     // Have we got anything?
<   
< !     if (nDeletes || nInserts) {
< !       int boOldWindow = max (0, int (boDeletes) - int(optCopyContext));
< !       int eoOldWindow = min (int (lines[0].size ()), int(o) + int(optCopyContext));
<   
< !       int boNewWindow = max (0, int (boInserts) - int (optCopyContext));
< !       int eoNewWindow = min (int (lines[1].size ()), int(n) + int (optCopyContext));
< ! 
< !       fprintf (stdout, "***************\n*** %d,%d ****", boOldWindow, eoOldWindow);
< !       for (unsigned l = boOldWindow; l < boDeletes; l += 1) {
< !         fprintf (stdout, "  %s", lines[0][l].line->c_str ());
< !       }
< ! 
< !       // We've got...
< ! 
< !       if (nDeletes && nInserts) {
< ! 
< !         // ... deletes and inserts.
<   
<           for (unsigned l = boDeletes; l < o; l += 1) {
< !           fprintf (stdout, "! %s", lines[0][l].line->c_str ());
<           }
< !       } else if (nDeletes) {
< ! 
< !         //  ... just deletes.
<   
<           for (unsigned l = boDeletes; l < o; l += 1) {
< !           fprintf (stdout, "- %s", lines[0][l].line->c_str ());
< !         }
< !       }
< ! 
< !       for (unsigned l = o; l < eoOldWindow; l += 1) {
< !         fprintf (stdout, "  %s", lines[0][l].line->c_str ());
< !       }
< !       fprintf (stdout, "--- %d,%d ----", boNewWindow, eoNewWindow);
< !       for (unsigned l = boNewWindow; l < boInserts; l += 1) {
< !         fprintf (stdout, "  %s", lines[1][l].line->c_str ());
< !       }
< ! 
< !       // We've got...
< ! 
< !       if (nDeletes && nInserts) {
< ! 
< !         // ... deletes and inserts.
< ! 
< !         for (unsigned l = boInserts; l < n; l += 1) {
< !           fprintf (stdout, "! %s", lines[1][l].line->c_str ());
<           }
< +       } else if (nInserts) {
< + 
< +         //  ... just inserts.
< + 
<           for (unsigned l = boInserts; l < n; l += 1) {
< !           fprintf (stdout, "+ %s", lines[1][l].line->c_str ());
<           }
< !       }
< ! 
< !       for (unsigned l = n; l < eoNewWindow; l += 1) {
< !         fprintf (stdout, "  %s", lines[1][l].line->c_str ());
< !       }
< !     }
< ! 
< !     // When we get here, we're dealing with matching lines.
< ! 
< !     o += 1;
< !     n += 1;
< !   }
< ! }
< ! 
< ! void pass6e () {
< ! }
< ! 
< ! void pass6i () {
< ! }
< ! 
< ! void pass6n ()
< ! {
< !   if (0 < optVerbose) {
< !     fprintf (stderr, "# Pass #6n (walking the differences)...\n");
< !   }
< ! 
< !   nMatchedLines = 0;
< ! 
< !   // Write the header.  (None for normal.)
< ! 
< !   // Starting at the top of both files,...
< ! 
< !   unsigned o = 0;
< !   unsigned n = 0;
< ! 
< !   while (o < lines[0].size () || n < lines[1].size ()) {
< ! 
< !     // Find any unmatched lines at this point in the old file.  These
< !     // are deletes.
< ! 
< !     unsigned boDeletes;
< !     for (boDeletes = o;
< !          o < lines[0].size () && lines[0][o].l == ~0;
< !          o += 1
< !         )
< !     {}
< ! 
< !     // Find any unmatched lines at this point in the new file.  These
< !     // are inserts.
< ! 
< !     unsigned boInserts;
< !     for (boInserts = n;
< !          n < lines[1].size () && lines[1][n].l == ~0;
< !          n += 1
< !         )
< !     {}
< ! 
< !     // We've got deleted line(s) from boDeletes .. o.
< !     // We've got deleted line(s) from boInserts .. n.
< ! 
< !     unsigned nDeletes = o - boDeletes;
< !     unsigned nInserts = n - boInserts;
< ! 
< !     // We've got...
< ! 
< !     if (nDeletes && nInserts) {
< ! 
< !       // ... deletes and inserts.
< ! 
< !       if (1 < nDeletes && 1 < nInserts) {
< !         fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, boInserts + 1, n);
< !       } else if (1 < nDeletes) {
< !         fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boInserts + 1);
< !       } else if (1 < nInserts) {
< !         fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInserts + 1, n);
< !       } 
< !       for (unsigned l = boDeletes; l < o; l += 1) {
< !         fprintf (stdout, "< %s", lines[0][l].line->c_str ());
< !       }
< !       fprintf (stderr, "---\n");
< !       for (unsigned l = boInserts; l < n; l += 1) {
< !         fprintf (stdout, "> %s", lines[1][l].line->c_str ());
<         }
<       } else if (nDeletes) {
<   
<         //  ... just deletes.
<   
< !       if (1 < nDeletes) {
< !         fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
< !       } else {
< !         fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
< !       }
< !       for (unsigned l = boDeletes; l < o; l += 1) {
< !         fprintf (stdout, "< %s", lines[0][l].line->c_str ());
<         }
<       } else if (nInserts) {
<   
<         //  ... just inserts.
<   
< !       if (1 < nInserts) {
< !         fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
< !       } else {
< !         fprintf (stdout, "%da%d\n", o, boInserts + 1);
< !       }
< !       for (unsigned l = boInserts; l < n; l += 1) {
< !         fprintf (stdout, "> %s", lines[1][l].line->c_str ());
<         }
<       }
<   
<       // When we get here, we're dealing with matching lines.
<   
< !     o += 1;
< !     n += 1;
< !   }
< ! }
< ! 
< ! void pass6r () {
< ! }
< ! 
< ! void pass6s () {
< ! }
< ! 
< ! void pass6u ()
< ! {
< !   if (0 < optVerbose) {
< !     fprintf (stderr, "# Pass #6u (walking the differences)...\n");
< !   }
< ! 
< !   nMatchedLines = 0;
< ! 
< !   // Write the header.
< ! 
< !   fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
< !   fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
< !   fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), lines[1].size ());
< ! 
< !   // Starting at the top of both files,...
< ! 
< !   unsigned o = 0;
< !   unsigned n = 0;
< ! 
< !   while (o < lines[0].size () || n < lines[1].size ()) {
< ! 
< !     // Find any unmatched lines at this point in the old file.  These
< !     // are deletes.
< ! 
< !     unsigned boDeletes;
< !     for (boDeletes = o;
< !          o < lines[0].size () && lines[0][o].l == ~0;
< !          o += 1
< !         )
< !     {}
< ! 
< !     // Find any unmatched lines at this point in the new file.  These
< !     // are inserts.
< ! 
< !     unsigned boInserts;
< !     for (boInserts = n;
< !          n < lines[1].size () && lines[1][n].l == ~0;
< !          n += 1
< !         )
< !     {}
< ! 
< !     // We've got deleted line(s) from boDeletes .. o.
< !     // We've got deleted line(s) from boInserts .. n.
< ! 
< !     unsigned nDeletes = o - boDeletes;
< !     unsigned nInserts = n - boInserts;
< ! 
< !     // We've got...
< ! 
< !     if (nDeletes && nInserts) {
< ! 
< !       // ... deletes and inserts.
< ! 
< !       for (unsigned l = boDeletes; l < o; l += 1) {
< !         fprintf (stdout, "-%s", lines[0][l].line->c_str ());
< !       }
< !       for (unsigned l = boInserts; l < n; l += 1) {
< !         fprintf (stdout, "+%s", lines[1][l].line->c_str ());
< !       }
< !     } else if (nDeletes) {
< ! 
< !       //  ... just deletes.
< ! 
< !       for (unsigned l = boDeletes; l < o; l += 1) {
< !         fprintf (stdout, "-%s", lines[0][l].line->c_str ());
< !       }
< !     } else if (nInserts) {
< ! 
< !       //  ... just inserts.
< ! 
< !       for (unsigned l = boInserts; l < n; l += 1) {
< !         fprintf (stdout, "+%s", lines[1][l].line->c_str ());
< !       }
<       }
< + 
< +     // When we get here, we're dealing with matching lines.
< + 
< +     fprintf (stdout, " %s", lines[0][o].line->c_str ());
<       o += 1;
<       n += 1;
<     }
---
> sdiff: sdiff.cpp:1363: void pass6c(): Assertion `widenWindow || lines[0][o].line == lines[1][n].line' failed.
> *** dif.4.cpp	0000-00-00 00:00:00.000000000 +0000
> --- dif.5.cpp	0000-00-00 00:00:00.000000000 +0000
# ../sdiff -c dif.5.cpp dif.4.cpp >& dif.5.4.diff-c.test
./test: line 46: 23353 Aborted                 (core dumped) ${DIFF} "${option}" "${oSrc}" "${nSrc}" 1>&"${dst}.test"
# dif.5.4.diff-c ---------------------------------------------------------------
1,726c1,3
< *** dif.5.cpp	2008-02-25 19:19:42.000000000 +0000
< --- dif.4.cpp	2008-02-25 18:06:37.000000000 +0000
< ***************
< *** 22,29 ****
<     Unified
<   };
<   
< ! DiffFormat diffFormat = Context;
< ! unsigned optCopyContext = 3;
<   
<   int optVerbose = 1;
<   
< --- 22,28 ----
<     Unified
<   };
<   
< ! DiffFormat diffFormat = Unified;
<   
<   int optVerbose = 1;
<   
< ***************
< *** 67,104 ****
<   typedef map<string, Line *> MapStringToLinePtr;
<   typedef vector<LinePtr> VectorLinePtr;
<   
< ! // Our name.
<   
< ! char *ARGV0 = "dif3";
< ! 
< ! // The 'symbol' (line) table.
< ! 
< ! MapStringToLinePtr table;
< ! 
< ! // The names of the 2 files to be diff'd.
< ! 
< ! char const *files[2] = { 0, 0 };
< ! 
< ! // The lines of the 2 files to be diff'd.
< ! 
< ! VectorLinePtr lines[2];
< ! 
< ! // Miscellaneous metrics.
<   
< ! unsigned nTotalMatchedBlocks = 0;
< ! unsigned nMatchedBlocks = 0;
< ! unsigned nTotalMatchedLines = 0;
< ! unsigned nMatchedLines = 0;
<   
< ! void pass1 ();
< ! void pass2 ();
< ! void pass3 ();
< ! void pass4 ();
< ! void pass5 ();
< ! void pass6 ();
<   
< - int main (int argc, char *argv[])
< - {
<     // Read the old [0] file, and the new [1] file.
<   
<     for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
< --- 66,85 ----
<   typedef map<string, Line *> MapStringToLinePtr;
<   typedef vector<LinePtr> VectorLinePtr;
<   
< ! char *ARGV0 = "dif2";
<   
< ! int main (int argc, char *argv[])
< ! {
< !   char const *files[2] = { 0, 0 };
<   
< !   MapStringToLinePtr table;
< !   VectorLinePtr lines[2];
<   
< !   unsigned nTotalMatchedBlocks = 0;
< !   unsigned nMatchedBlocks = 0;
< !   unsigned nTotalMatchedLines = 0;
< !   unsigned nMatchedLines = 0;
<   
<     // Read the old [0] file, and the new [1] file.
<   
<     for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
< ***************
< *** 136,142 ****
<     }
<   
<     if (0 < optVerbose) {
< !     fprintf (stderr, "# Total unique lines = %d\n", table.size ());
<     }
<   
<     // map<int, int> counts;
< --- 117,123 ----
<     }
<   
<     if (0 < optVerbose) {
< !     printf ("# Total unique lines = %d\n", table.size ());
<     }
<   
<     // map<int, int> counts;
< ***************
< *** 148,169 ****
<     //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
<     // }
<   
< !   pass1 ();
< !   pass2 ();
< !   pass3 ();
< !   pass4 ();
< !   pass5 ();
< !   pass6 ();
<   
< -   return 0;
< - }
< - 
< - // Perform pass #1, in which we find all explicit matches amongst the
< - // unique lines.  For every unique line that appears the same number
< - // of times in both files, we declare the lines to match.
< - 
< - void pass1 ()
< - {
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass 1 (finding matches amongst unique lines)...");
<     }
< --- 129,138 ----
<     //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
<     // }
<   
< !   // Perform pass #1, in which we find all explicit matches amongst
< !   // the unique lines.  For every unique line that appears the same
< !   // number of times in both files, we declare the lines to match.
<   
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass 1 (finding matches amongst unique lines)...");
<     }
< ***************
< *** 219,231 ****
<         }
<       }
<     }
< - }
<   
< ! // Perform Pass #2, in which we attempt to 'widen' blocks of matched
< ! // lines, by appending lines which are the same in both files.
<   
< - void pass2 ()
< - {
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass #2 (spreading matches down)...");
<     }
< --- 188,197 ----
<         }
<       }
<     }
<   
< !   // Perform Pass #2, in which we attempt to 'widen' blocks of matched
< !   // lines, by appending lines which are the same in both files.
<   
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass #2 (spreading matches down)...");
<     }
< ***************
< *** 314,326 ****
<         }
<       }
<     }
< - }
<   
< ! // Perform Pass #3, in which we attempt to 'widen' blocks of matched
< ! // lines, by prepending lines which are the same in both files.
<   
< - void pass3 ()
< - {
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass #3 (spreading matches up)...");
<     }
< --- 280,289 ----
<         }
<       }
<     }
<   
< !   // Perform Pass #3, in which we attempt to 'widen' blocks of matched
< !   // lines, by prepending lines which are the same in both files.
<   
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass #3 (spreading matches up)...");
<     }
< ***************
< *** 409,422 ****
<         }
<       }
<     }
< - }
<   
< ! // Perform pass #4, in which we find any remaining matches amongst the
< ! // unique lines.  For every unique line that has more than 1 copy in
< ! // both files, we declare the copies to match.
<   
< - void pass4 ()
< - {
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass 4 (finding remaining matches amongst unique lines)...");
<     }
< --- 372,382 ----
<         }
<       }
<     }
<   
< !   // Perform pass #4, in which we find any remaining matches amongst
< !   // the unique lines.  For every unique line that has more than 1
< !   // copy in both files, we declare the copies to match.
<   
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass 4 (finding remaining matches amongst unique lines)...");
<     }
< ***************
< *** 469,483 ****
<         }
<       }
<     }
< - }
<   
< ! // Perform Pass #5, in which we look for blocks which match, but are
< ! // the result of a move (their not in their original position).  For
< ! // these, we'll unmatch the blocks, turning them into a delete and an
< ! // insert.
<   
< - void pass5 ()
< - {
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass #5 (unmatching block moves)...\n");
<     }
< --- 429,440 ----
<         }
<       }
<     }
<   
< !   // Perform Pass #5, in which we look for blocks which match, but are
< !   // the result of a move (their not in their original position).  For
< !   // these, we'll unmatch the blocks, turning them into a delete and
< !   // an insert.
<   
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass #5 (unmatching block moves)...\n");
<     }
< ***************
< *** 639,725 ****
<         }
<       }
<     }
< - }
< - 
< - // Perform Pass #6, in which we create the desired output.
<   
< ! void pass6c ();
< ! void pass6e ();
< ! void pass6i ();
< ! void pass6n ();
< ! void pass6r ();
< ! void pass6s ();
< ! void pass6u ();
< ! 
< ! void pass6 ()
< ! {
<   
< !   switch (diffFormat) {
< !   case Context:
< !     pass6c ();
< !     break;
<   
< !   case EdScript:
< !     pass6e ();
< !     break;
<   
< !   case IfThenElse:
< !     pass6i ();
< !     break;
<   
<     case Normal:
< -     pass6n ();
<       break;
< - 
< -   case RCS:
< -     pass6r ();
< -     break;
< - 
< -   case SideBySide:
< -     pass6s ();
< -     break;
< - 
<     case Unified:
< !     pass6u ();
< !     break;
< ! 
< !   case Default:
< !   default:
< !     pass6c ();
<       break;
<     }
< - }
< - 
< - template<typename T> T min (T l, T r) {
< -   if (l < r) {
< -     return l;
< -   }
< -   return r;
< - }
< - 
< - template<typename T> T max (T l, T r) {
< -   if (l < r) {
< -     return r;
< -   }
< -   return l;
< - }
< - 
< - void pass6c () {
< -   if (0 < optVerbose) {
< -     fprintf (stderr, "# Pass #6u (walking the differences)...\n");
< -   }
< - 
< -   nMatchedLines = 0;
< - 
< -   // Write the header.
< - 
< -   fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
< -   fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
<   
<     // Starting at the top of both files,...
<   
< !   unsigned o = 0;
< !   unsigned n = 0;
<   
<     while (o < lines[0].size () || n < lines[1].size ()) {
<   
< --- 596,627 ----
<         }
<       }
<     }
<   
< !   // Perform Pass #6, in which we create the desired output.
<   
< !   if (0 < optVerbose) {
< !     fprintf (stderr, "# Pass #6 (walking the differences)...\n");
< !   }
<   
< !   nMatchedLines = 0;
<   
< !   // Write the header.
<   
< +   switch (diffFormat) {
< +   case Default:
<     case Normal:
<       break;
<     case Unified:
< !     fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
< !     fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
< !     fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), lines[1].size ());
<       break;
<     }
<   
<     // Starting at the top of both files,...
<   
< !   o = 0;
< !   n = 0;
<   
<     while (o < lines[0].size () || n < lines[1].size ()) {
<   
< ***************
< *** 749,1010 ****
<       unsigned nDeletes = o - boDeletes;
<       unsigned nInserts = n - boInserts;
<   
< !     // Have we got anything?
< ! 
< !     if (nDeletes || nInserts) {
< !       int boOldWindow = max (0, int (boDeletes) - int(optCopyContext));
< !       int eoOldWindow = min (int (lines[0].size ()), int(o) + int(optCopyContext));
< ! 
< !       int boNewWindow = max (0, int (boInserts) - int (optCopyContext));
< !       int eoNewWindow = min (int (lines[1].size ()), int(n) + int (optCopyContext));
< ! 
< !       fprintf (stdout, "***************\n*** %d,%d ****", boOldWindow, eoOldWindow);
< !       for (unsigned l = boOldWindow; l < boDeletes; l += 1) {
< !         fprintf (stdout, "  %s", lines[0][l].line->c_str ());
< !       }
< ! 
< !       // We've got...
< ! 
< !       if (nDeletes && nInserts) {
< ! 
< !         // ... deletes and inserts.
<   
< !         for (unsigned l = boDeletes; l < o; l += 1) {
< !           fprintf (stdout, "! %s", lines[0][l].line->c_str ());
< !         }
< !       } else if (nDeletes) {
<   
< !         //  ... just deletes.
<   
<           for (unsigned l = boDeletes; l < o; l += 1) {
< !           fprintf (stdout, "- %s", lines[0][l].line->c_str ());
<           }
< !       }
< ! 
< !       for (unsigned l = o; l < eoOldWindow; l += 1) {
< !         fprintf (stdout, "  %s", lines[0][l].line->c_str ());
< !       }
< !       fprintf (stdout, "--- %d,%d ----", boNewWindow, eoNewWindow);
< !       for (unsigned l = boNewWindow; l < boInserts; l += 1) {
< !         fprintf (stdout, "  %s", lines[1][l].line->c_str ());
< !       }
< ! 
< !       // We've got...
< ! 
< !       if (nDeletes && nInserts) {
< ! 
< !         // ... deletes and inserts.
< ! 
<           for (unsigned l = boInserts; l < n; l += 1) {
< !           fprintf (stdout, "! %s", lines[1][l].line->c_str ());
<           }
< !       } else if (nInserts) {
< ! 
< !         //  ... just inserts.
<   
<           for (unsigned l = boInserts; l < n; l += 1) {
< !           fprintf (stdout, "+ %s", lines[1][l].line->c_str ());
<           }
< !       }
< ! 
< !       for (unsigned l = n; l < eoNewWindow; l += 1) {
< !         fprintf (stdout, "  %s", lines[1][l].line->c_str ());
< !       }
< !     }
< ! 
< !     // When we get here, we're dealing with matching lines.
< ! 
< !     o += 1;
< !     n += 1;
< !   }
< ! }
< ! 
< ! void pass6e () {
< ! }
< ! 
< ! void pass6i () {
< ! }
< ! 
< ! void pass6n ()
< ! {
< !   if (0 < optVerbose) {
< !     fprintf (stderr, "# Pass #6n (walking the differences)...\n");
< !   }
< ! 
< !   nMatchedLines = 0;
< ! 
< !   // Write the header.  (None for normal.)
< ! 
< !   // Starting at the top of both files,...
< ! 
< !   unsigned o = 0;
< !   unsigned n = 0;
< ! 
< !   while (o < lines[0].size () || n < lines[1].size ()) {
< ! 
< !     // Find any unmatched lines at this point in the old file.  These
< !     // are deletes.
< ! 
< !     unsigned boDeletes;
< !     for (boDeletes = o;
< !          o < lines[0].size () && lines[0][o].l == ~0;
< !          o += 1
< !         )
< !     {}
< ! 
< !     // Find any unmatched lines at this point in the new file.  These
< !     // are inserts.
< ! 
< !     unsigned boInserts;
< !     for (boInserts = n;
< !          n < lines[1].size () && lines[1][n].l == ~0;
< !          n += 1
< !         )
< !     {}
< ! 
< !     // We've got deleted line(s) from boDeletes .. o.
< !     // We've got deleted line(s) from boInserts .. n.
< ! 
< !     unsigned nDeletes = o - boDeletes;
< !     unsigned nInserts = n - boInserts;
< ! 
< !     // We've got...
< ! 
< !     if (nDeletes && nInserts) {
< ! 
< !       // ... deletes and inserts.
< ! 
< !       if (1 < nDeletes && 1 < nInserts) {
< !         fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, boInserts + 1, n);
< !       } else if (1 < nDeletes) {
< !         fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boInserts + 1);
< !       } else if (1 < nInserts) {
< !         fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInserts + 1, n);
< !       } 
< !       for (unsigned l = boDeletes; l < o; l += 1) {
< !         fprintf (stdout, "< %s", lines[0][l].line->c_str ());
< !       }
< !       fprintf (stderr, "---\n");
< !       for (unsigned l = boInserts; l < n; l += 1) {
< !         fprintf (stdout, "> %s", lines[1][l].line->c_str ());
<         }
<       } else if (nDeletes) {
<   
<         //  ... just deletes.
<   
< !       if (1 < nDeletes) {
< !         fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
< !       } else {
< !         fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
< !       }
< !       for (unsigned l = boDeletes; l < o; l += 1) {
< !         fprintf (stdout, "< %s", lines[0][l].line->c_str ());
<         }
<       } else if (nInserts) {
<   
<         //  ... just inserts.
<   
< !       if (1 < nInserts) {
< !         fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
< !       } else {
< !         fprintf (stdout, "%da%d\n", o, boInserts + 1);
< !       }
< !       for (unsigned l = boInserts; l < n; l += 1) {
< !         fprintf (stdout, "> %s", lines[1][l].line->c_str ());
<         }
<       }
<   
<       // When we get here, we're dealing with matching lines.
<   
< !     o += 1;
< !     n += 1;
< !   }
< ! }
< ! 
< ! void pass6r () {
< ! }
< ! 
< ! void pass6s () {
< ! }
< ! 
< ! void pass6u ()
< ! {
< !   if (0 < optVerbose) {
< !     fprintf (stderr, "# Pass #6u (walking the differences)...\n");
< !   }
< ! 
< !   nMatchedLines = 0;
< ! 
< !   // Write the header.
< ! 
< !   fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
< !   fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
< !   fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), lines[1].size ());
< ! 
< !   // Starting at the top of both files,...
< ! 
< !   unsigned o = 0;
< !   unsigned n = 0;
< ! 
< !   while (o < lines[0].size () || n < lines[1].size ()) {
< ! 
< !     // Find any unmatched lines at this point in the old file.  These
< !     // are deletes.
< ! 
< !     unsigned boDeletes;
< !     for (boDeletes = o;
< !          o < lines[0].size () && lines[0][o].l == ~0;
< !          o += 1
< !         )
< !     {}
< ! 
< !     // Find any unmatched lines at this point in the new file.  These
< !     // are inserts.
< ! 
< !     unsigned boInserts;
< !     for (boInserts = n;
< !          n < lines[1].size () && lines[1][n].l == ~0;
< !          n += 1
< !         )
< !     {}
< ! 
< !     // We've got deleted line(s) from boDeletes .. o.
< !     // We've got deleted line(s) from boInserts .. n.
< ! 
< !     unsigned nDeletes = o - boDeletes;
< !     unsigned nInserts = n - boInserts;
< ! 
< !     // We've got...
< ! 
< !     if (nDeletes && nInserts) {
< ! 
< !       // ... deletes and inserts.
< ! 
< !       for (unsigned l = boDeletes; l < o; l += 1) {
< !         fprintf (stdout, "-%s", lines[0][l].line->c_str ());
< !       }
< !       for (unsigned l = boInserts; l < n; l += 1) {
< !         fprintf (stdout, "+%s", lines[1][l].line->c_str ());
< !       }
< !     } else if (nDeletes) {
< ! 
< !       //  ... just deletes.
< ! 
< !       for (unsigned l = boDeletes; l < o; l += 1) {
< !         fprintf (stdout, "-%s", lines[0][l].line->c_str ());
< !       }
< !     } else if (nInserts) {
< ! 
< !       //  ... just inserts.
< ! 
< !       for (unsigned l = boInserts; l < n; l += 1) {
< !         fprintf (stdout, "+%s", lines[1][l].line->c_str ());
< !       }
<       }
< - 
< -     // When we get here, we're dealing with matching lines.
< - 
< -     fprintf (stdout, " %s", lines[0][o].line->c_str ());
<       o += 1;
<       n += 1;
<     }
< --- 651,746 ----
<       unsigned nDeletes = o - boDeletes;
<       unsigned nInserts = n - boInserts;
<   
< !     // We've got...
<   
< !     if (nDeletes && nInserts) {
<   
< !       // ... deletes and inserts.
<   
< +       switch (diffFormat) {
< +       case Default:
< +       case Normal:
< +         if (1 < nDeletes && 1 < nInserts) {
< +           fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, boInserts + 1, n);
< +         } else if (1 < nDeletes) {
< +           fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boInserts + 1);
< +         } else if (1 < nInserts) {
< +           fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInserts + 1, n);
< +         } 
<           for (unsigned l = boDeletes; l < o; l += 1) {
< !           fprintf (stdout, "< %s", lines[0][l].line->c_str ());
<           }
< !         fprintf (stderr, "---\n");
<           for (unsigned l = boInserts; l < n; l += 1) {
< !           fprintf (stdout, "> %s", lines[1][l].line->c_str ());
<           }
< !         break;
<   
< +       case Unified:
< +         for (unsigned l = boDeletes; l < o; l += 1) {
< +           fprintf (stdout, "-%s", lines[0][l].line->c_str ());
< +         }
<           for (unsigned l = boInserts; l < n; l += 1) {
< !           fprintf (stdout, "+%s", lines[1][l].line->c_str ());
<           }
< !         break;
<         }
<       } else if (nDeletes) {
<   
<         //  ... just deletes.
<   
< !       switch (diffFormat) {
< !       case Default:
< !       case Normal:
< !         if (1 < nDeletes) {
< !           fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
< !         } else {
< !           fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
< !         }
< !         for (unsigned l = boDeletes; l < o; l += 1) {
< !           fprintf (stdout, "< %s", lines[0][l].line->c_str ());
< !         }
< !         break;
< !       case Unified:
< !         for (unsigned l = boDeletes; l < o; l += 1) {
< !           fprintf (stdout, "-%s", lines[0][l].line->c_str ());
< !         }
< !         break;
<         }
<       } else if (nInserts) {
<   
<         //  ... just inserts.
<   
< !       switch (diffFormat) {
< !       case Default:
< !       case Normal:
< !         if (1 < nInserts) {
< !           fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
< !         } else {
< !           fprintf (stdout, "%da%d\n", o, boInserts + 1);
< !         }
< !         for (unsigned l = boInserts; l < n; l += 1) {
< !           fprintf (stdout, "> %s", lines[1][l].line->c_str ());
< !         }
< !         break;
< !       case Unified:
< !         for (unsigned l = boInserts; l < n; l += 1) {
< !           fprintf (stdout, "+%s", lines[1][l].line->c_str ());
< !         }
< !         break;
<         }
<       }
<   
<       // When we get here, we're dealing with matching lines.
<   
< !     switch (diffFormat) {
< !     case Default:
< !     case Normal:
< !       break;
< !     case Unified:
< !       fprintf (stdout, " %s", lines[0][o].line->c_str ());
< !       break;
<       }
<       o += 1;
<       n += 1;
<     }
---
> sdiff: sdiff.cpp:1363: void pass6c(): Assertion `widenWindow || lines[0][o].line == lines[1][n].line' failed.
> *** dif.5.cpp	0000-00-00 00:00:00.000000000 +0000
> --- dif.4.cpp	0000-00-00 00:00:00.000000000 +0000
# ../sdiff -c dif.5.cpp dif.6.cpp >& dif.5.6.diff-c.test
./test: line 46: 23363 Aborted                 (core dumped) ${DIFF} "${option}" "${oSrc}" "${nSrc}" 1>&"${dst}.test"
# dif.5.6.diff-c ---------------------------------------------------------------
1,238c1,3
< *** dif.5.cpp	2008-02-25 19:19:42.000000000 +0000
< --- dif.6.cpp	2008-02-25 19:54:55.000000000 +0000
< ***************
< *** 723,768 ****
<   
<     while (o < lines[0].size () || n < lines[1].size ()) {
<   
< !     // Find any unmatched lines at this point in the old file.  These
< !     // are deletes.
<   
< !     unsigned boDeletes;
< !     for (boDeletes = o;
< !          o < lines[0].size () && lines[0][o].l == ~0;
< !          o += 1
< !         )
< !     {}
<   
< !     // Find any unmatched lines at this point in the new file.  These
< !     // are inserts.
<   
< !     unsigned boInserts;
< !     for (boInserts = n;
< !          n < lines[1].size () && lines[1][n].l == ~0;
< !          n += 1
< !         )
< !     {}
<   
< !     // We've got deleted line(s) from boDeletes .. o.
< !     // We've got deleted line(s) from boInserts .. n.
<   
< !     unsigned nDeletes = o - boDeletes;
< !     unsigned nInserts = n - boInserts;
<   
< !     // Have we got anything?
<   
< !     if (nDeletes || nInserts) {
< !       int boOldWindow = max (0, int (boDeletes) - int(optCopyContext));
< !       int eoOldWindow = min (int (lines[0].size ()), int(o) + int(optCopyContext));
< ! 
< !       int boNewWindow = max (0, int (boInserts) - int (optCopyContext));
< !       int eoNewWindow = min (int (lines[1].size ()), int(n) + int (optCopyContext));
< ! 
< !       fprintf (stdout, "***************\n*** %d,%d ****", boOldWindow, eoOldWindow);
< !       for (unsigned l = boOldWindow; l < boDeletes; l += 1) {
< !         fprintf (stdout, "  %s", lines[0][l].line->c_str ());
<         }
<   
<         // We've got...
<   
<         if (nDeletes && nInserts) {
< --- 723,820 ----
<   
<     while (o < lines[0].size () || n < lines[1].size ()) {
<   
< !     // Find the bounds of the current contextual 'window'.
<   
< !     // If we aren't looking at a delete or an insert, we're not at the
< !     // start of a context window.
<   
< !     if (lines[0][o].l != ~0 && lines[1][n].l != ~0) {
< !       o += 1;
< !       n += 1;
< !       continue;
< !     }
<   
< !     // We're looking at at least 1 delete or insert, so a window
< !     // begins here (or, rather, optCopyContext lines earlier).
< !     
< !     int boOldWindow = max (0, int (boDeletes) - int(optCopyContext));
< !     int eoOldWindow = min (int (lines[0].size ()), int(o) + int(optCopyContext));
< ! 
< !     // Look for the end of the window.
< ! 
< !     bool widenWindow = false;
< !     do {
< ! 
< !       // Skip over the delete(s) and/or insert(s) defining the current
< !       // context.
< ! 
< !       while (o < lines[0].size () && lines[0][o].l == ~0) {
< !         o += 1;
< !       }
< !       while (n < lines[1].size () && lines[1][n].l == ~0) {
< !         n += 1;
< !       }
< ! 
< !       // ...  This context will end optCopyContext lines past the last
< !       // set of deletes or inserts we find.  However, since another
< !       // window could follow, we look 2 * optCopyContext ahead for
< !       // another delete or insert.
< ! 
< !       for (unsigned l = 0; l < (2 * optCopyContext); i += 1) {
< !         if (o < lines[0].size ()) {
< !           if (widenWindow |= lines[0][o].l == ~0) {
< !             break;
< !           }
< !           o += 1;
< !         }
< !         if (n < lines[1].size ()) {
< !           if (widenWindow |= lines[1][o].l == ~0) {
< !             break;
< !           }
< !           n += 1;
< !         }
< !       }
< !     } while (widenWindow);
<   
< !     // We've found the end of the window.
<   
< !     int boNewWindow = max (0, int (boInserts) - int (optCopyContext));
< !     int eoNewWindow = min (int (lines[1].size ()), int(n) + int (optCopyContext));
< ! 
< !     // Now, reset ourselves to the start of the window, and walk it to
< !     // produce the output.  We'll walk it twice, first for the old
< !     // file part, then for the new file part.
< ! 
< !     fprintf (stdout, "***************\n");
< !     fprintf (stdout, "*** %d,%d ****\n", boOldWindow + 1, eoOldWindow + 1);
<   
< !     o = boOldWindow;
< !     n = boNewWindow;
<   
< !     while (o < eoOldWindow && n < eoNewWindow) {
< ! 
< !       // Find any unmatched lines at this point in the old file.  These
< !       // are deletes.
< ! 
< !       unsigned boDeletes = o;
< !       while (o < eoOldWindow && lines[0][o].l == ~0) {
< !         o += 1;
<         }
<   
< +       // Find any unmatched lines at this point in the new file.  These
< +       // are inserts.
< + 
< +       unsigned boInserts = n;
< +       while (n < eoNewWindow && lines[1][n].l == ~0) {
< +         n += 1;
< +       }
< + 
< +       // We've got deleted line(s) from boDeletes .. o.
< +       // We've got deleted line(s) from boInserts .. n.
< + 
< +       unsigned nDeletes = o - boDeletes;
< +       unsigned nInserts = n - boInserts;
< + 
<         // We've got...
<   
<         if (nDeletes && nInserts) {
< ***************
< *** 781,794 ****
<           }
<         }
<   
< !       for (unsigned l = o; l < eoOldWindow; l += 1) {
< !         fprintf (stdout, "  %s", lines[0][l].line->c_str ());
<         }
< !       fprintf (stdout, "--- %d,%d ----", boNewWindow, eoNewWindow);
< !       for (unsigned l = boNewWindow; l < boInserts; l += 1) {
< !         fprintf (stdout, "  %s", lines[1][l].line->c_str ());
<         }
<   
<         // We've got...
<   
<         if (nDeletes && nInserts) {
< --- 833,874 ----
<           }
<         }
<   
< !       // When we get here, we're dealing with matching lines.
< ! 
< !       fprintf (stdout, "  %s", lines[0][l].line->c_str ());
< !       o += 1;
< !       n += 1;
< !     }
< ! 
< !     fprintf (stdout, "--- %d,%d ----\n", boNewWindow + 1, eoNewWindow + 1);
< ! 
< !     o = boOldWindow;
< !     n = boNewWindow;
< ! 
< !     while (o < eoOldWindow && n < eoNewWindow) {
< ! 
< !       // Find any unmatched lines at this point in the old file.  These
< !       // are deletes.
< ! 
< !       unsigned boDeletes = o;
< !       while (o < eoOldWindow && lines[0][o].l == ~0) {
< !         o += 1;
<         }
< ! 
< !       // Find any unmatched lines at this point in the new file.  These
< !       // are inserts.
< ! 
< !       unsigned boInserts = n;
< !       while (n < eoNewWindow && lines[1][n].l == ~0) {
< !         n += 1;
<         }
<   
< +       // We've got deleted line(s) from boDeletes .. o.
< +       // We've got deleted line(s) from boInserts .. n.
< + 
< +       unsigned nDeletes = o - boDeletes;
< +       unsigned nInserts = n - boInserts;
< + 
<         // We've got...
<   
<         if (nDeletes && nInserts) {
< ***************
< *** 807,821 ****
<           }
<         }
<   
< !       for (unsigned l = n; l < eoNewWindow; l += 1) {
< !         fprintf (stdout, "  %s", lines[1][l].line->c_str ());
< !       }
< !     }
< ! 
< !     // When we get here, we're dealing with matching lines.
<   
< !     o += 1;
< !     n += 1;
<     }
<   }
<   
< --- 887,898 ----
<           }
<         }
<   
< !       // When we get here, we're dealing with matching lines.
<   
< !       fprintf (stdout, "  %s", lines[1][l].line->c_str ());
< !       o += 1;
< !       n += 1;
< !     }
<     }
<   }
<   
---
> sdiff: sdiff.cpp:1363: void pass6c(): Assertion `widenWindow || lines[0][o].line == lines[1][n].line' failed.
> *** dif.5.cpp	0000-00-00 00:00:00.000000000 +0000
> --- dif.6.cpp	0000-00-00 00:00:00.000000000 +0000
# ../sdiff -c dif.6.cpp dif.5.cpp >& dif.6.5.diff-c.test
./test: line 46: 23366 Aborted                 (core dumped) ${DIFF} "${option}" "${oSrc}" "${nSrc}" 1>&"${dst}.test"
# dif.6.5.diff-c ---------------------------------------------------------------
1,238c1,3
< *** dif.6.cpp	2008-02-25 19:54:55.000000000 +0000
< --- dif.5.cpp	2008-02-25 19:19:42.000000000 +0000
< ***************
< *** 723,820 ****
<   
<     while (o < lines[0].size () || n < lines[1].size ()) {
<   
< !     // Find the bounds of the current contextual 'window'.
< ! 
< !     // If we aren't looking at a delete or an insert, we're not at the
< !     // start of a context window.
< ! 
< !     if (lines[0][o].l != ~0 && lines[1][n].l != ~0) {
< !       o += 1;
< !       n += 1;
< !       continue;
< !     }
< ! 
< !     // We're looking at at least 1 delete or insert, so a window
< !     // begins here (or, rather, optCopyContext lines earlier).
< !     
< !     int boOldWindow = max (0, int (boDeletes) - int(optCopyContext));
< !     int eoOldWindow = min (int (lines[0].size ()), int(o) + int(optCopyContext));
< ! 
< !     // Look for the end of the window.
< ! 
< !     bool widenWindow = false;
< !     do {
< ! 
< !       // Skip over the delete(s) and/or insert(s) defining the current
< !       // context.
< ! 
< !       while (o < lines[0].size () && lines[0][o].l == ~0) {
< !         o += 1;
< !       }
< !       while (n < lines[1].size () && lines[1][n].l == ~0) {
< !         n += 1;
< !       }
< ! 
< !       // ...  This context will end optCopyContext lines past the last
< !       // set of deletes or inserts we find.  However, since another
< !       // window could follow, we look 2 * optCopyContext ahead for
< !       // another delete or insert.
< ! 
< !       for (unsigned l = 0; l < (2 * optCopyContext); i += 1) {
< !         if (o < lines[0].size ()) {
< !           if (widenWindow |= lines[0][o].l == ~0) {
< !             break;
< !           }
< !           o += 1;
< !         }
< !         if (n < lines[1].size ()) {
< !           if (widenWindow |= lines[1][o].l == ~0) {
< !             break;
< !           }
< !           n += 1;
< !         }
< !       }
< !     } while (widenWindow);
< ! 
< !     // We've found the end of the window.
< ! 
< !     int boNewWindow = max (0, int (boInserts) - int (optCopyContext));
< !     int eoNewWindow = min (int (lines[1].size ()), int(n) + int (optCopyContext));
< ! 
< !     // Now, reset ourselves to the start of the window, and walk it to
< !     // produce the output.  We'll walk it twice, first for the old
< !     // file part, then for the new file part.
<   
< !     fprintf (stdout, "***************\n");
< !     fprintf (stdout, "*** %d,%d ****\n", boOldWindow + 1, eoOldWindow + 1);
<   
< !     o = boOldWindow;
< !     n = boNewWindow;
<   
< !     while (o < eoOldWindow && n < eoNewWindow) {
<   
< !       // Find any unmatched lines at this point in the old file.  These
< !       // are deletes.
<   
< !       unsigned boDeletes = o;
< !       while (o < eoOldWindow && lines[0][o].l == ~0) {
< !         o += 1;
< !       }
<   
< !       // Find any unmatched lines at this point in the new file.  These
< !       // are inserts.
<   
< !       unsigned boInserts = n;
< !       while (n < eoNewWindow && lines[1][n].l == ~0) {
< !         n += 1;
<         }
<   
< -       // We've got deleted line(s) from boDeletes .. o.
< -       // We've got deleted line(s) from boInserts .. n.
< - 
< -       unsigned nDeletes = o - boDeletes;
< -       unsigned nInserts = n - boInserts;
< - 
<         // We've got...
<   
<         if (nDeletes && nInserts) {
< --- 723,768 ----
<   
<     while (o < lines[0].size () || n < lines[1].size ()) {
<   
< !     // Find any unmatched lines at this point in the old file.  These
< !     // are deletes.
<   
< !     unsigned boDeletes;
< !     for (boDeletes = o;
< !          o < lines[0].size () && lines[0][o].l == ~0;
< !          o += 1
< !         )
< !     {}
<   
< !     // Find any unmatched lines at this point in the new file.  These
< !     // are inserts.
<   
< !     unsigned boInserts;
< !     for (boInserts = n;
< !          n < lines[1].size () && lines[1][n].l == ~0;
< !          n += 1
< !         )
< !     {}
<   
< !     // We've got deleted line(s) from boDeletes .. o.
< !     // We've got deleted line(s) from boInserts .. n.
<   
< !     unsigned nDeletes = o - boDeletes;
< !     unsigned nInserts = n - boInserts;
<   
< !     // Have we got anything?
<   
< !     if (nDeletes || nInserts) {
< !       int boOldWindow = max (0, int (boDeletes) - int(optCopyContext));
< !       int eoOldWindow = min (int (lines[0].size ()), int(o) + int(optCopyContext));
< ! 
< !       int boNewWindow = max (0, int (boInserts) - int (optCopyContext));
< !       int eoNewWindow = min (int (lines[1].size ()), int(n) + int (optCopyContext));
< ! 
< !       fprintf (stdout, "***************\n*** %d,%d ****", boOldWindow, eoOldWindow);
< !       for (unsigned l = boOldWindow; l < boDeletes; l += 1) {
< !         fprintf (stdout, "  %s", lines[0][l].line->c_str ());
<         }
<   
<         // We've got...
<   
<         if (nDeletes && nInserts) {
< ***************
< *** 833,874 ****
<           }
<         }
<   
< !       // When we get here, we're dealing with matching lines.
< ! 
< !       fprintf (stdout, "  %s", lines[0][l].line->c_str ());
< !       o += 1;
< !       n += 1;
< !     }
< ! 
< !     fprintf (stdout, "--- %d,%d ----\n", boNewWindow + 1, eoNewWindow + 1);
< ! 
< !     o = boOldWindow;
< !     n = boNewWindow;
< ! 
< !     while (o < eoOldWindow && n < eoNewWindow) {
< ! 
< !       // Find any unmatched lines at this point in the old file.  These
< !       // are deletes.
< ! 
< !       unsigned boDeletes = o;
< !       while (o < eoOldWindow && lines[0][o].l == ~0) {
< !         o += 1;
<         }
< ! 
< !       // Find any unmatched lines at this point in the new file.  These
< !       // are inserts.
< ! 
< !       unsigned boInserts = n;
< !       while (n < eoNewWindow && lines[1][n].l == ~0) {
< !         n += 1;
<         }
<   
< -       // We've got deleted line(s) from boDeletes .. o.
< -       // We've got deleted line(s) from boInserts .. n.
< - 
< -       unsigned nDeletes = o - boDeletes;
< -       unsigned nInserts = n - boInserts;
< - 
<         // We've got...
<   
<         if (nDeletes && nInserts) {
< --- 781,794 ----
<           }
<         }
<   
< !       for (unsigned l = o; l < eoOldWindow; l += 1) {
< !         fprintf (stdout, "  %s", lines[0][l].line->c_str ());
<         }
< !       fprintf (stdout, "--- %d,%d ----", boNewWindow, eoNewWindow);
< !       for (unsigned l = boNewWindow; l < boInserts; l += 1) {
< !         fprintf (stdout, "  %s", lines[1][l].line->c_str ());
<         }
<   
<         // We've got...
<   
<         if (nDeletes && nInserts) {
< ***************
< *** 887,898 ****
<           }
<         }
<   
< !       // When we get here, we're dealing with matching lines.
< ! 
< !       fprintf (stdout, "  %s", lines[1][l].line->c_str ());
< !       o += 1;
< !       n += 1;
<       }
<     }
<   }
<   
< --- 807,821 ----
<           }
<         }
<   
< !       for (unsigned l = n; l < eoNewWindow; l += 1) {
< !         fprintf (stdout, "  %s", lines[1][l].line->c_str ());
< !       }
<       }
< + 
< +     // When we get here, we're dealing with matching lines.
< + 
< +     o += 1;
< +     n += 1;
<     }
<   }
<   
---
> sdiff: sdiff.cpp:1363: void pass6c(): Assertion `widenWindow || lines[0][o].line == lines[1][n].line' failed.
> *** dif.6.cpp	0000-00-00 00:00:00.000000000 +0000
> --- dif.5.cpp	0000-00-00 00:00:00.000000000 +0000
# ../sdiff -c dif.6.cpp dif.7.cpp >& dif.6.7.diff-c.test
./test: line 46: 23376 Aborted                 (core dumped) ${DIFF} "${option}" "${oSrc}" "${nSrc}" 1>&"${dst}.test"
# dif.6.7.diff-c ---------------------------------------------------------------
1,858c1,3
< *** dif.6.cpp	2008-02-25 19:54:55.000000000 +0000
< --- dif.7.cpp	2008-02-25 22:43:43.000000000 +0000
< ***************
< *** 22,31 ****
<     Unified
<   };
<   
< ! DiffFormat diffFormat = Context;
< ! unsigned optCopyContext = 3;
<   
< ! int optVerbose = 1;
<   
<   struct Line : public string {
<     Line (string _text) :
< --- 22,32 ----
<     Unified
<   };
<   
< ! DiffFormat diffFormat = SideBySide;
<   
< ! unsigned optCopyContext = 3;
< ! unsigned optPageWidth = 130;
< ! unsigned optVerbose = 2;
<   
<   struct Line : public string {
<     Line (string _text) :
< ***************
< *** 45,51 ****
<       for (list<unsigned>::iterator i = copies[1].begin (); i != copies[1].end (); i++) {
<         fprintf (out, "%u ", *i);
<       }
< !     fprintf (out, "}}\t%s", c_str ());
<     }
<     list<unsigned> copies[2];
<   };
< --- 46,52 ----
<       for (list<unsigned>::iterator i = copies[1].begin (); i != copies[1].end (); i++) {
<         fprintf (out, "%u ", *i);
<       }
< !     fprintf (out, "}}\t%s\n", c_str ());
<     }
<     list<unsigned> copies[2];
<   };
< ***************
< *** 107,112 ****
< --- 108,114 ----
<       if (FILE *f = fopen (files[n], "r")) {
<         if (0 < optVerbose) {
<           fprintf (stderr, "# Reading %s...", files[n]);
< +         fflush (stderr);
<         }
<   
<         char buffer[1024];
< ***************
< *** 115,120 ****
< --- 117,124 ----
<         while (fgets (buffer, sizeof (buffer), f)) {
<           string text (buffer);
<   
< +         text.erase (text.end () - 1);
< + 
<           Line *line = table[text];
<   
<           if (!line) {
< ***************
< *** 127,135 ****
< --- 131,141 ----
<   
<         if (0 < optVerbose) {
<           fprintf (stderr, " %u lines, %u unique.\n", lines[n].size (), nUniq);
< +         fflush (stderr);
<         }
<       } else {
<         fprintf (stderr, "%s: Unable to open %s!  Exiting....\n", ARGV0, files[n]);
< +       fflush (stderr);
<         perror (ARGV0);
<         exit (1);
<       }
< ***************
< *** 137,142 ****
< --- 143,149 ----
<   
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Total unique lines = %d\n", table.size ());
< +     fflush (stderr);
<     }
<   
<     // map<int, int> counts;
< ***************
< *** 166,171 ****
< --- 173,179 ----
<   {
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass 1 (finding matches amongst unique lines)...");
< +     fflush (stderr);
<     }
<   
<     nMatchedLines = 0;
< ***************
< *** 208,219 ****
<   
<     if (0 < optVerbose) {
<       fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
<   
< !     if (1 < optVerbose) {
<         for (int f = 0; f < 2; f += 1) {
<           fprintf (stderr, "# file #%d\n", f + 1);
<           for (int l = 0; l < lines[f].size (); l += 1) {
<             fprintf (stderr, "#   [%d] ", l);
<             lines[f][l].Dump (stderr);
<           }
<         }
< --- 216,230 ----
<   
<     if (0 < optVerbose) {
<       fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
< +     fflush (stderr);
<   
< !     if (2 < optVerbose) {
<         for (int f = 0; f < 2; f += 1) {
<           fprintf (stderr, "# file #%d\n", f + 1);
< +         fflush (stderr);
<           for (int l = 0; l < lines[f].size (); l += 1) {
<             fprintf (stderr, "#   [%d] ", l);
< +           fflush (stderr);
<             lines[f][l].Dump (stderr);
<           }
<         }
< ***************
< *** 228,233 ****
< --- 239,245 ----
<   {
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass #2 (spreading matches down)...");
< +     fflush (stderr);
<     }
<   
<     nMatchedBlocks = 0;
< ***************
< *** 304,314 ****
<                nTotalMatchedLines,
<                nTotalMatchedBlocks
<               );
< !     if (1 < optVerbose) {
<         for (int f = 0; f < 2; f += 1) {
<           fprintf (stderr, "# file #%d\n", f + 1);
<           for (int l = 0; l < lines[f].size (); l += 1) {
<             fprintf (stderr, "#   [%d] ", l);
<             lines[f][l].Dump (stderr);
<           }
<         }
< --- 316,329 ----
<                nTotalMatchedLines,
<                nTotalMatchedBlocks
<               );
< !     fflush (stderr);
< !     if (2 < optVerbose) {
<         for (int f = 0; f < 2; f += 1) {
<           fprintf (stderr, "# file #%d\n", f + 1);
< +         fflush (stderr);
<           for (int l = 0; l < lines[f].size (); l += 1) {
<             fprintf (stderr, "#   [%d] ", l);
< +           fflush (stderr);
<             lines[f][l].Dump (stderr);
<           }
<         }
< ***************
< *** 323,328 ****
< --- 338,344 ----
<   {
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass #3 (spreading matches up)...");
< +     fflush (stderr);
<     }
<   
<     nMatchedBlocks = 0;
< ***************
< *** 398,409 ****
<                nTotalMatchedLines,
<                nTotalMatchedBlocks
<               );
<   
< !     if (1 < optVerbose) {
<         for (int f = 0; f < 2; f += 1) {
<           fprintf (stderr, "# file #%d\n", f + 1);
<           for (int l = 0; l < lines[f].size (); l += 1) {
<             fprintf (stderr, "#   [%d] ", l);
<             lines[f][l].Dump (stderr);
<           }
<         }
< --- 414,428 ----
<                nTotalMatchedLines,
<                nTotalMatchedBlocks
<               );
< +     fflush (stderr);
<   
< !     if (2 < optVerbose) {
<         for (int f = 0; f < 2; f += 1) {
<           fprintf (stderr, "# file #%d\n", f + 1);
< +         fflush (stderr);
<           for (int l = 0; l < lines[f].size (); l += 1) {
<             fprintf (stderr, "#   [%d] ", l);
< +           fflush (stderr);
<             lines[f][l].Dump (stderr);
<           }
<         }
< ***************
< *** 419,424 ****
< --- 438,444 ----
<   {
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass 4 (finding remaining matches amongst unique lines)...");
< +     fflush (stderr);
<     }
<   
<     nMatchedLines = 0;
< ***************
< *** 458,469 ****
<   
<     if (0 < optVerbose) {
<       fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
<   
< !     if (1 < optVerbose) {
<         for (int f = 0; f < 2; f += 1) {
<           fprintf (stderr, "# file #%d\n", f + 1);
<           for (int l = 0; l < lines[f].size (); l += 1) {
<             fprintf (stderr, "#   [%d] ", l);
<             lines[f][l].Dump (stderr);
<           }
<         }
< --- 478,492 ----
<   
<     if (0 < optVerbose) {
<       fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
< +     fflush (stderr);
<   
< !     if (2 < optVerbose) {
<         for (int f = 0; f < 2; f += 1) {
<           fprintf (stderr, "# file #%d\n", f + 1);
< +         fflush (stderr);
<           for (int l = 0; l < lines[f].size (); l += 1) {
<             fprintf (stderr, "#   [%d] ", l);
< +           fflush (stderr);
<             lines[f][l].Dump (stderr);
<           }
<         }
< ***************
< *** 480,485 ****
< --- 503,509 ----
<   {
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass #5 (unmatching block moves)...\n");
< +     fflush (stderr);
<     }
<   
<     nMatchedBlocks = 0;
< ***************
< *** 628,639 ****
<                nTotalMatchedLines,
<                nTotalMatchedBlocks
<               );
<   
< !     if (1 < optVerbose) {
<         for (int f = 0; f < 2; f += 1) {
<           fprintf (stderr, "# file #%d\n", f + 1);
<           for (int l = 0; l < lines[f].size (); l += 1) {
<             fprintf (stderr, "#   [%d] ", l);
<             lines[f][l].Dump (stderr);
<           }
<         }
< --- 652,666 ----
<                nTotalMatchedLines,
<                nTotalMatchedBlocks
<               );
< +     fflush (stderr);
<   
< !     if (2 < optVerbose) {
<         for (int f = 0; f < 2; f += 1) {
<           fprintf (stderr, "# file #%d\n", f + 1);
< +         fflush (stderr);
<           for (int l = 0; l < lines[f].size (); l += 1) {
<             fprintf (stderr, "#   [%d] ", l);
< +           fflush (stderr);
<             lines[f][l].Dump (stderr);
<           }
<         }
< ***************
< *** 650,655 ****
< --- 677,683 ----
<   void pass6r ();
<   void pass6s ();
<   void pass6u ();
< + void pass6y ();
<   
<   void pass6 ()
<   {
< ***************
< *** 676,682 ****
<       break;
<   
<     case SideBySide:
< !     pass6s ();
<       break;
<   
<     case Unified:
< --- 704,710 ----
<       break;
<   
<     case SideBySide:
< !     pass6y ();
<       break;
<   
<     case Unified:
< ***************
< *** 706,712 ****
<   
<   void pass6c () {
<     if (0 < optVerbose) {
< !     fprintf (stderr, "# Pass #6u (walking the differences)...\n");
<     }
<   
<     nMatchedLines = 0;
< --- 734,741 ----
<   
<   void pass6c () {
<     if (0 < optVerbose) {
< !     fprintf (stderr, "# Pass #6c (walking the differences)...\n");
< !     fflush (stderr);
<     }
<   
<     nMatchedLines = 0;
< ***************
< *** 734,749 ****
<         continue;
<       }
<   
< !     // We're looking at at least 1 delete or insert, so a window
<       // begins here (or, rather, optCopyContext lines earlier).
<       
< !     int boOldWindow = max (0, int (boDeletes) - int(optCopyContext));
< !     int eoOldWindow = min (int (lines[0].size ()), int(o) + int(optCopyContext));
<   
< !     // Look for the end of the window.
<   
< !     bool widenWindow = false;
< !     do {
<   
<         // Skip over the delete(s) and/or insert(s) defining the current
<         // context.
< --- 763,786 ----
<         continue;
<       }
<   
< !     // We're now looking at at least 1 delete or insert, so a window
<       // begins here (or, rather, optCopyContext lines earlier).
<       
< !     int boOldWindow = max (0, int (o) - int (optCopyContext));
< !     int boNewWindow = max (0, int (n) - int (optCopyContext));
<   
< !     if (1 < optVerbose) {
< !       fprintf (stderr, "boOldWindow = %d, boNewWindow = %d\n", boOldWindow, boNewWindow);
< !       fflush (stderr);
< !     }
<   
< !     // Look for the end of the current window.
< ! 
< !     int eoOldWindow;
< !     int eoNewWindow;
< ! 
< !     bool widenWindow = true;
< !     while (widenWindow && o < lines[0].size () || n < lines[1].size ()) {
<   
<         // Skip over the delete(s) and/or insert(s) defining the current
<         // context.
< ***************
< *** 755,797 ****
<           n += 1;
<         }
<   
< !       // ...  This context will end optCopyContext lines past the last
< !       // set of deletes or inserts we find.  However, since another
< !       // window could follow, we look 2 * optCopyContext ahead for
< !       // another delete or insert.
<   
< !       for (unsigned l = 0; l < (2 * optCopyContext); i += 1) {
<           if (o < lines[0].size ()) {
< !           if (widenWindow |= lines[0][o].l == ~0) {
< !             break;
< !           }
<             o += 1;
<           }
<           if (n < lines[1].size ()) {
< !           if (widenWindow |= lines[1][o].l == ~0) {
< !             break;
< !           }
<             n += 1;
<           }
<         }
< !     } while (widenWindow);
<   
<       // We've found the end of the window.
<   
< !     int boNewWindow = max (0, int (boInserts) - int (optCopyContext));
< !     int eoNewWindow = min (int (lines[1].size ()), int(n) + int (optCopyContext));
<   
<       // Now, reset ourselves to the start of the window, and walk it to
<       // produce the output.  We'll walk it twice, first for the old
<       // file part, then for the new file part.
<   
<       fprintf (stdout, "***************\n");
< !     fprintf (stdout, "*** %d,%d ****\n", boOldWindow + 1, eoOldWindow + 1);
<   
<       o = boOldWindow;
<       n = boNewWindow;
<   
< !     while (o < eoOldWindow && n < eoNewWindow) {
<   
<         // Find any unmatched lines at this point in the old file.  These
<         // are deletes.
< --- 792,850 ----
<           n += 1;
<         }
<   
< !       // This context will end optCopyContext matched lines past the
< !       // last set of deletes or inserts we find.
<   
< !       widenWindow = false;
< !       for (unsigned l = 0; !widenWindow && l < optCopyContext; l += 1) {
<           if (o < lines[0].size ()) {
< !           widenWindow |= lines[0][o].l == ~0;
<             o += 1;
<           }
<           if (n < lines[1].size ()) {
< !           widenWindow |= lines[1][n].l == ~0;
<             n += 1;
<           }
<         }
< ! 
< !       eoOldWindow = o;
< !       eoNewWindow = n;
< ! 
< !       // However, since another window could follow, we look
< !       // optCopyContext ahead for another delete or insert.
< ! 
< !       if (!widenWindow) {
< !         for (unsigned l = 0; l < (2 * optCopyContext + 1); l += 1) {
< !           if (o < lines[0].size ()) {
< !             widenWindow |= lines[0][o].l == ~0;
< !             o += 1;
< !           }
< !           if (n < lines[1].size ()) {
< !             widenWindow |= lines[1][n].l == ~0;
< !             n += 1;
< !           }
< !         }
< !       }
< !     }
<   
<       // We've found the end of the window.
<   
< !     if (1 < optVerbose) {
< !       fprintf (stderr, "eoOldWindow = %d, eoNewWindow = %d\n", eoOldWindow, eoNewWindow);
< !       fflush (stderr);
< !     }
<   
<       // Now, reset ourselves to the start of the window, and walk it to
<       // produce the output.  We'll walk it twice, first for the old
<       // file part, then for the new file part.
<   
<       fprintf (stdout, "***************\n");
< !     fprintf (stdout, "*** %d,%d ****\n", boOldWindow + 1, eoOldWindow);
<   
<       o = boOldWindow;
<       n = boNewWindow;
<   
< !     while (o < eoOldWindow || n < eoNewWindow) {
<   
<         // Find any unmatched lines at this point in the old file.  These
<         // are deletes.
< ***************
< *** 822,846 ****
<           // ... deletes and inserts.
<   
<           for (unsigned l = boDeletes; l < o; l += 1) {
< !           fprintf (stdout, "! %s", lines[0][l].line->c_str ());
<           }
<         } else if (nDeletes) {
<   
<           //  ... just deletes.
<   
<           for (unsigned l = boDeletes; l < o; l += 1) {
< !           fprintf (stdout, "- %s", lines[0][l].line->c_str ());
<           }
<         }
<   
<         // When we get here, we're dealing with matching lines.
<   
< !       fprintf (stdout, "  %s", lines[0][l].line->c_str ());
<         o += 1;
<         n += 1;
<       }
<   
< !     fprintf (stdout, "--- %d,%d ----\n", boNewWindow + 1, eoNewWindow + 1);
<   
<       o = boOldWindow;
<       n = boNewWindow;
< --- 875,899 ----
<           // ... deletes and inserts.
<   
<           for (unsigned l = boDeletes; l < o; l += 1) {
< !           fprintf (stdout, "! %s\n", lines[0][l].line->c_str ());
<           }
<         } else if (nDeletes) {
<   
<           //  ... just deletes.
<   
<           for (unsigned l = boDeletes; l < o; l += 1) {
< !           fprintf (stdout, "- %s\n", lines[0][l].line->c_str ());
<           }
<         }
<   
<         // When we get here, we're dealing with matching lines.
<   
< !       fprintf (stdout, "  %s\n", lines[0][o].line->c_str ());
<         o += 1;
<         n += 1;
<       }
<   
< !     fprintf (stdout, "--- %d,%d ----\n", boNewWindow + 1, eoNewWindow);
<   
<       o = boOldWindow;
<       n = boNewWindow;
< ***************
< *** 876,911 ****
<           // ... deletes and inserts.
<   
<           for (unsigned l = boInserts; l < n; l += 1) {
< !           fprintf (stdout, "! %s", lines[1][l].line->c_str ());
<           }
<         } else if (nInserts) {
<   
<           //  ... just inserts.
<   
<           for (unsigned l = boInserts; l < n; l += 1) {
< !           fprintf (stdout, "+ %s", lines[1][l].line->c_str ());
<           }
<         }
<   
<         // When we get here, we're dealing with matching lines.
<   
< !       fprintf (stdout, "  %s", lines[1][l].line->c_str ());
<         o += 1;
<         n += 1;
<       }
<     }
<   }
<   
<   void pass6e () {
<   }
<   
<   void pass6i () {
<   }
<   
<   void pass6n ()
<   {
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass #6n (walking the differences)...\n");
<     }
<   
<     nMatchedLines = 0;
< --- 929,974 ----
<           // ... deletes and inserts.
<   
<           for (unsigned l = boInserts; l < n; l += 1) {
< !           fprintf (stdout, "! %s\n", lines[1][l].line->c_str ());
<           }
<         } else if (nInserts) {
<   
<           //  ... just inserts.
<   
<           for (unsigned l = boInserts; l < n; l += 1) {
< !           fprintf (stdout, "+ %s\n", lines[1][l].line->c_str ());
<           }
<         }
<   
<         // When we get here, we're dealing with matching lines.
<   
< !       fprintf (stdout, "  %s\n", lines[1][n].line->c_str ());
<         o += 1;
<         n += 1;
<       }
< + 
< +     // Reset to the end of the current window.
< + 
< +     o = eoOldWindow;
< +     n = eoNewWindow;
<     }
<   }
<   
<   void pass6e () {
< +   fprintf (stderr, "pass6e() is unimplemented!\n");
< +   fflush (stderr);
<   }
<   
<   void pass6i () {
< +   fprintf (stderr, "pass6i() is unimplemented!\n");
< +   fflush (stderr);
<   }
<   
<   void pass6n ()
<   {
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass #6n (walking the differences)...\n");
< +     fflush (stderr);
<     }
<   
<     nMatchedLines = 0;
< ***************
< *** 959,969 ****
<           fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInserts + 1, n);
<         } 
<         for (unsigned l = boDeletes; l < o; l += 1) {
< !         fprintf (stdout, "< %s", lines[0][l].line->c_str ());
<         }
< !       fprintf (stderr, "---\n");
<         for (unsigned l = boInserts; l < n; l += 1) {
< !         fprintf (stdout, "> %s", lines[1][l].line->c_str ());
<         }
<       } else if (nDeletes) {
<   
< --- 1022,1032 ----
<           fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInserts + 1, n);
<         } 
<         for (unsigned l = boDeletes; l < o; l += 1) {
< !         fprintf (stdout, "< %s\n", lines[0][l].line->c_str ());
<         }
< !       fprintf (stdout, "---\n");
<         for (unsigned l = boInserts; l < n; l += 1) {
< !         fprintf (stdout, "> %s\n", lines[1][l].line->c_str ());
<         }
<       } else if (nDeletes) {
<   
< ***************
< *** 975,981 ****
<           fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
<         }
<         for (unsigned l = boDeletes; l < o; l += 1) {
< !         fprintf (stdout, "< %s", lines[0][l].line->c_str ());
<         }
<       } else if (nInserts) {
<   
< --- 1038,1044 ----
<           fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
<         }
<         for (unsigned l = boDeletes; l < o; l += 1) {
< !         fprintf (stdout, "< %s\n", lines[0][l].line->c_str ());
<         }
<       } else if (nInserts) {
<   
< ***************
< *** 987,993 ****
<           fprintf (stdout, "%da%d\n", o, boInserts + 1);
<         }
<         for (unsigned l = boInserts; l < n; l += 1) {
< !         fprintf (stdout, "> %s", lines[1][l].line->c_str ());
<         }
<       }
<   
< --- 1050,1056 ----
<           fprintf (stdout, "%da%d\n", o, boInserts + 1);
<         }
<         for (unsigned l = boInserts; l < n; l += 1) {
< !         fprintf (stdout, "> %s\n", lines[1][l].line->c_str ());
<         }
<       }
<   
< ***************
< *** 999,1013 ****
< --- 1062,1081 ----
<   }
<   
<   void pass6r () {
< +   fprintf (stderr, "pass6r() is unimplemented!\n");
< +   fflush (stderr);
<   }
<   
<   void pass6s () {
< +   fprintf (stderr, "pass6s() is unimplemented!\n");
< +   fflush (stderr);
<   }
<   
<   void pass6u ()
<   {
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass #6u (walking the differences)...\n");
< +     fflush (stderr);
<     }
<   
<     nMatchedLines = 0;
< ***************
< *** 1058,1087 ****
<         // ... deletes and inserts.
<   
<         for (unsigned l = boDeletes; l < o; l += 1) {
< !         fprintf (stdout, "-%s", lines[0][l].line->c_str ());
<         }
<         for (unsigned l = boInserts; l < n; l += 1) {
< !         fprintf (stdout, "+%s", lines[1][l].line->c_str ());
<         }
<       } else if (nDeletes) {
<   
<         //  ... just deletes.
<   
<         for (unsigned l = boDeletes; l < o; l += 1) {
< !         fprintf (stdout, "-%s", lines[0][l].line->c_str ());
<         }
<       } else if (nInserts) {
<   
<         //  ... just inserts.
<   
<         for (unsigned l = boInserts; l < n; l += 1) {
< !         fprintf (stdout, "+%s", lines[1][l].line->c_str ());
<         }
<       }
<   
<       // When we get here, we're dealing with matching lines.
<   
< !     fprintf (stdout, " %s", lines[0][o].line->c_str ());
<       o += 1;
<       n += 1;
<     }
< --- 1126,1251 ----
<         // ... deletes and inserts.
<   
<         for (unsigned l = boDeletes; l < o; l += 1) {
< !         fprintf (stdout, "-%s\n", lines[0][l].line->c_str ());
<         }
<         for (unsigned l = boInserts; l < n; l += 1) {
< !         fprintf (stdout, "+%s\n", lines[1][l].line->c_str ());
<         }
<       } else if (nDeletes) {
<   
<         //  ... just deletes.
<   
<         for (unsigned l = boDeletes; l < o; l += 1) {
< !         fprintf (stdout, "-%s\n", lines[0][l].line->c_str ());
<         }
<       } else if (nInserts) {
<   
<         //  ... just inserts.
<   
<         for (unsigned l = boInserts; l < n; l += 1) {
< !         fprintf (stdout, "+%s\n", lines[1][l].line->c_str ());
<         }
<       }
<   
<       // When we get here, we're dealing with matching lines.
<   
< !     fprintf (stdout, " %s\n", lines[0][o].line->c_str ());
< !     o += 1;
< !     n += 1;
< !   }
< ! }
< ! 
< ! void pass6y ()
< ! {
< !   if (0 < optVerbose) {
< !     fprintf (stderr, "# Pass #6y (walking the differences)...\n");
< !     fflush (stderr);
< !   }
< ! 
< !   // Write the header.
< ! 
< !   // None for side-by-side.
< ! 
< !   // Starting at the top of both files,...
< ! 
< !   int columnWidth = (optPageWidth - 7) / 2;
< ! 
< !   unsigned o = 0;
< !   unsigned n = 0;
< ! 
< !   while (o < lines[0].size () || n < lines[1].size ()) {
< ! 
< !     // Find any unmatched lines at this point in the old file.  These
< !     // are deletes.
< ! 
< !     unsigned boDeletes = o;
< !     while (o < lines[0].size () && lines[0][o].l == ~0) {
< !       o += 1;
< !     }
< ! 
< !     // Find any unmatched lines at this point in the new file.  These
< !     // are inserts.
< ! 
< !     unsigned boInserts = n;
< !     while (n < lines[1].size () && lines[1][n].l == ~0) {
< !       n += 1;
< !     }
< ! 
< !     // We've got deleted line(s) from boDeletes .. o.
< !     // We've got deleted line(s) from boInserts .. n.
< ! 
< !     unsigned nDeletes = o - boDeletes;
< !     unsigned nInserts = n - boInserts;
< ! 
< !     // We've got...
< ! 
< !     while (boDeletes < o && boInserts < n) {
< ! 
< !       // ... deletes and inserts.
< ! 
< !       fprintf (stdout,
< !                "%-*s | %s\n",
< !                columnWidth,
< !                lines[0][boDeletes].line->substr (0, columnWidth).c_str (),
< !                lines[1][boInserts].line->substr (0, columnWidth).c_str ()
< !               );
< !       boDeletes += 1;
< !       boInserts += 1;
< !     }
< ! 
< !     while (boDeletes < o) {
< ! 
< !       //  ... just deletes.
< ! 
< !       fprintf (stdout,
< !                "%-*s <\n",
< !                columnWidth,
< !                lines[0][boDeletes].line->substr (0, columnWidth).c_str ()
< !               );
< !       boDeletes += 1;
< !     }
< ! 
< !     while (boInserts < n) {
< ! 
< !       //  ... just inserts.
< ! 
< !       fprintf (stdout,
< !                "%-*s > %s\n",
< !                columnWidth,
< !                "",
< !                lines[1][boInserts].line->substr (0, columnWidth).c_str ()
< !               );
< !       boInserts += 1;
< !     }
< ! 
< !     // When we get here, we're dealing with matching lines.
< ! 
< !     fprintf (stdout,
< !              "%-*s   %s\n",
< !              columnWidth,
< !              lines[0][o].line->substr (0, columnWidth).c_str (),
< !              lines[1][n].line->substr (0, columnWidth).c_str ()
< !             );
<       o += 1;
<       n += 1;
<     }
---
> sdiff: sdiff.cpp:1363: void pass6c(): Assertion `widenWindow || lines[0][o].line == lines[1][n].line' failed.
> *** dif.6.cpp	0000-00-00 00:00:00.000000000 +0000
> --- dif.7.cpp	0000-00-00 00:00:00.000000000 +0000
# ../sdiff -c dif.7.cpp dif.6.cpp >& dif.7.6.diff-c.test
./test: line 46: 23379 Aborted                 (core dumped) ${DIFF} "${option}" "${oSrc}" "${nSrc}" 1>&"${dst}.test"
# dif.7.6.diff-c ---------------------------------------------------------------
1,858c1,3
< *** dif.7.cpp	2008-02-25 22:43:43.000000000 +0000
< --- dif.6.cpp	2008-02-25 19:54:55.000000000 +0000
< ***************
< *** 22,32 ****
<     Unified
<   };
<   
< ! DiffFormat diffFormat = SideBySide;
< ! 
<   unsigned optCopyContext = 3;
< ! unsigned optPageWidth = 130;
< ! unsigned optVerbose = 2;
<   
<   struct Line : public string {
<     Line (string _text) :
< --- 22,31 ----
<     Unified
<   };
<   
< ! DiffFormat diffFormat = Context;
<   unsigned optCopyContext = 3;
< ! 
< ! int optVerbose = 1;
<   
<   struct Line : public string {
<     Line (string _text) :
< ***************
< *** 46,52 ****
<       for (list<unsigned>::iterator i = copies[1].begin (); i != copies[1].end (); i++) {
<         fprintf (out, "%u ", *i);
<       }
< !     fprintf (out, "}}\t%s\n", c_str ());
<     }
<     list<unsigned> copies[2];
<   };
< --- 45,51 ----
<       for (list<unsigned>::iterator i = copies[1].begin (); i != copies[1].end (); i++) {
<         fprintf (out, "%u ", *i);
<       }
< !     fprintf (out, "}}\t%s", c_str ());
<     }
<     list<unsigned> copies[2];
<   };
< ***************
< *** 108,114 ****
<       if (FILE *f = fopen (files[n], "r")) {
<         if (0 < optVerbose) {
<           fprintf (stderr, "# Reading %s...", files[n]);
< -         fflush (stderr);
<         }
<   
<         char buffer[1024];
< --- 107,112 ----
< ***************
< *** 117,124 ****
<         while (fgets (buffer, sizeof (buffer), f)) {
<           string text (buffer);
<   
< -         text.erase (text.end () - 1);
< - 
<           Line *line = table[text];
<   
<           if (!line) {
< --- 115,120 ----
< ***************
< *** 131,141 ****
<   
<         if (0 < optVerbose) {
<           fprintf (stderr, " %u lines, %u unique.\n", lines[n].size (), nUniq);
< -         fflush (stderr);
<         }
<       } else {
<         fprintf (stderr, "%s: Unable to open %s!  Exiting....\n", ARGV0, files[n]);
< -       fflush (stderr);
<         perror (ARGV0);
<         exit (1);
<       }
< --- 127,135 ----
< ***************
< *** 143,149 ****
<   
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Total unique lines = %d\n", table.size ());
< -     fflush (stderr);
<     }
<   
<     // map<int, int> counts;
< --- 137,142 ----
< ***************
< *** 173,179 ****
<   {
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass 1 (finding matches amongst unique lines)...");
< -     fflush (stderr);
<     }
<   
<     nMatchedLines = 0;
< --- 166,171 ----
< ***************
< *** 216,230 ****
<   
<     if (0 < optVerbose) {
<       fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
< -     fflush (stderr);
<   
< !     if (2 < optVerbose) {
<         for (int f = 0; f < 2; f += 1) {
<           fprintf (stderr, "# file #%d\n", f + 1);
< -         fflush (stderr);
<           for (int l = 0; l < lines[f].size (); l += 1) {
<             fprintf (stderr, "#   [%d] ", l);
< -           fflush (stderr);
<             lines[f][l].Dump (stderr);
<           }
<         }
< --- 208,219 ----
<   
<     if (0 < optVerbose) {
<       fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
<   
< !     if (1 < optVerbose) {
<         for (int f = 0; f < 2; f += 1) {
<           fprintf (stderr, "# file #%d\n", f + 1);
<           for (int l = 0; l < lines[f].size (); l += 1) {
<             fprintf (stderr, "#   [%d] ", l);
<             lines[f][l].Dump (stderr);
<           }
<         }
< ***************
< *** 239,245 ****
<   {
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass #2 (spreading matches down)...");
< -     fflush (stderr);
<     }
<   
<     nMatchedBlocks = 0;
< --- 228,233 ----
< ***************
< *** 316,329 ****
<                nTotalMatchedLines,
<                nTotalMatchedBlocks
<               );
< !     fflush (stderr);
< !     if (2 < optVerbose) {
<         for (int f = 0; f < 2; f += 1) {
<           fprintf (stderr, "# file #%d\n", f + 1);
< -         fflush (stderr);
<           for (int l = 0; l < lines[f].size (); l += 1) {
<             fprintf (stderr, "#   [%d] ", l);
< -           fflush (stderr);
<             lines[f][l].Dump (stderr);
<           }
<         }
< --- 304,314 ----
<                nTotalMatchedLines,
<                nTotalMatchedBlocks
<               );
< !     if (1 < optVerbose) {
<         for (int f = 0; f < 2; f += 1) {
<           fprintf (stderr, "# file #%d\n", f + 1);
<           for (int l = 0; l < lines[f].size (); l += 1) {
<             fprintf (stderr, "#   [%d] ", l);
<             lines[f][l].Dump (stderr);
<           }
<         }
< ***************
< *** 338,344 ****
<   {
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass #3 (spreading matches up)...");
< -     fflush (stderr);
<     }
<   
<     nMatchedBlocks = 0;
< --- 323,328 ----
< ***************
< *** 414,428 ****
<                nTotalMatchedLines,
<                nTotalMatchedBlocks
<               );
< -     fflush (stderr);
<   
< !     if (2 < optVerbose) {
<         for (int f = 0; f < 2; f += 1) {
<           fprintf (stderr, "# file #%d\n", f + 1);
< -         fflush (stderr);
<           for (int l = 0; l < lines[f].size (); l += 1) {
<             fprintf (stderr, "#   [%d] ", l);
< -           fflush (stderr);
<             lines[f][l].Dump (stderr);
<           }
<         }
< --- 398,409 ----
<                nTotalMatchedLines,
<                nTotalMatchedBlocks
<               );
<   
< !     if (1 < optVerbose) {
<         for (int f = 0; f < 2; f += 1) {
<           fprintf (stderr, "# file #%d\n", f + 1);
<           for (int l = 0; l < lines[f].size (); l += 1) {
<             fprintf (stderr, "#   [%d] ", l);
<             lines[f][l].Dump (stderr);
<           }
<         }
< ***************
< *** 438,444 ****
<   {
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass 4 (finding remaining matches amongst unique lines)...");
< -     fflush (stderr);
<     }
<   
<     nMatchedLines = 0;
< --- 419,424 ----
< ***************
< *** 478,492 ****
<   
<     if (0 < optVerbose) {
<       fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
< -     fflush (stderr);
<   
< !     if (2 < optVerbose) {
<         for (int f = 0; f < 2; f += 1) {
<           fprintf (stderr, "# file #%d\n", f + 1);
< -         fflush (stderr);
<           for (int l = 0; l < lines[f].size (); l += 1) {
<             fprintf (stderr, "#   [%d] ", l);
< -           fflush (stderr);
<             lines[f][l].Dump (stderr);
<           }
<         }
< --- 458,469 ----
<   
<     if (0 < optVerbose) {
<       fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
<   
< !     if (1 < optVerbose) {
<         for (int f = 0; f < 2; f += 1) {
<           fprintf (stderr, "# file #%d\n", f + 1);
<           for (int l = 0; l < lines[f].size (); l += 1) {
<             fprintf (stderr, "#   [%d] ", l);
<             lines[f][l].Dump (stderr);
<           }
<         }
< ***************
< *** 503,509 ****
<   {
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass #5 (unmatching block moves)...\n");
< -     fflush (stderr);
<     }
<   
<     nMatchedBlocks = 0;
< --- 480,485 ----
< ***************
< *** 652,666 ****
<                nTotalMatchedLines,
<                nTotalMatchedBlocks
<               );
< -     fflush (stderr);
<   
< !     if (2 < optVerbose) {
<         for (int f = 0; f < 2; f += 1) {
<           fprintf (stderr, "# file #%d\n", f + 1);
< -         fflush (stderr);
<           for (int l = 0; l < lines[f].size (); l += 1) {
<             fprintf (stderr, "#   [%d] ", l);
< -           fflush (stderr);
<             lines[f][l].Dump (stderr);
<           }
<         }
< --- 628,639 ----
<                nTotalMatchedLines,
<                nTotalMatchedBlocks
<               );
<   
< !     if (1 < optVerbose) {
<         for (int f = 0; f < 2; f += 1) {
<           fprintf (stderr, "# file #%d\n", f + 1);
<           for (int l = 0; l < lines[f].size (); l += 1) {
<             fprintf (stderr, "#   [%d] ", l);
<             lines[f][l].Dump (stderr);
<           }
<         }
< ***************
< *** 677,683 ****
<   void pass6r ();
<   void pass6s ();
<   void pass6u ();
< - void pass6y ();
<   
<   void pass6 ()
<   {
< --- 650,655 ----
< ***************
< *** 704,710 ****
<       break;
<   
<     case SideBySide:
< !     pass6y ();
<       break;
<   
<     case Unified:
< --- 676,682 ----
<       break;
<   
<     case SideBySide:
< !     pass6s ();
<       break;
<   
<     case Unified:
< ***************
< *** 734,741 ****
<   
<   void pass6c () {
<     if (0 < optVerbose) {
< !     fprintf (stderr, "# Pass #6c (walking the differences)...\n");
< !     fflush (stderr);
<     }
<   
<     nMatchedLines = 0;
< --- 706,712 ----
<   
<   void pass6c () {
<     if (0 < optVerbose) {
< !     fprintf (stderr, "# Pass #6u (walking the differences)...\n");
<     }
<   
<     nMatchedLines = 0;
< ***************
< *** 763,786 ****
<         continue;
<       }
<   
< !     // We're now looking at at least 1 delete or insert, so a window
<       // begins here (or, rather, optCopyContext lines earlier).
<       
< !     int boOldWindow = max (0, int (o) - int (optCopyContext));
< !     int boNewWindow = max (0, int (n) - int (optCopyContext));
< ! 
< !     if (1 < optVerbose) {
< !       fprintf (stderr, "boOldWindow = %d, boNewWindow = %d\n", boOldWindow, boNewWindow);
< !       fflush (stderr);
< !     }
<   
< !     // Look for the end of the current window.
<   
< !     int eoOldWindow;
< !     int eoNewWindow;
< ! 
< !     bool widenWindow = true;
< !     while (widenWindow && o < lines[0].size () || n < lines[1].size ()) {
<   
<         // Skip over the delete(s) and/or insert(s) defining the current
<         // context.
< --- 734,749 ----
<         continue;
<       }
<   
< !     // We're looking at at least 1 delete or insert, so a window
<       // begins here (or, rather, optCopyContext lines earlier).
<       
< !     int boOldWindow = max (0, int (boDeletes) - int(optCopyContext));
< !     int eoOldWindow = min (int (lines[0].size ()), int(o) + int(optCopyContext));
<   
< !     // Look for the end of the window.
<   
< !     bool widenWindow = false;
< !     do {
<   
<         // Skip over the delete(s) and/or insert(s) defining the current
<         // context.
< ***************
< *** 792,850 ****
<           n += 1;
<         }
<   
< !       // This context will end optCopyContext matched lines past the
< !       // last set of deletes or inserts we find.
<   
< !       widenWindow = false;
< !       for (unsigned l = 0; !widenWindow && l < optCopyContext; l += 1) {
<           if (o < lines[0].size ()) {
< !           widenWindow |= lines[0][o].l == ~0;
<             o += 1;
<           }
<           if (n < lines[1].size ()) {
< !           widenWindow |= lines[1][n].l == ~0;
<             n += 1;
<           }
<         }
< ! 
< !       eoOldWindow = o;
< !       eoNewWindow = n;
< ! 
< !       // However, since another window could follow, we look
< !       // optCopyContext ahead for another delete or insert.
< ! 
< !       if (!widenWindow) {
< !         for (unsigned l = 0; l < (2 * optCopyContext + 1); l += 1) {
< !           if (o < lines[0].size ()) {
< !             widenWindow |= lines[0][o].l == ~0;
< !             o += 1;
< !           }
< !           if (n < lines[1].size ()) {
< !             widenWindow |= lines[1][n].l == ~0;
< !             n += 1;
< !           }
< !         }
< !       }
< !     }
<   
<       // We've found the end of the window.
<   
< !     if (1 < optVerbose) {
< !       fprintf (stderr, "eoOldWindow = %d, eoNewWindow = %d\n", eoOldWindow, eoNewWindow);
< !       fflush (stderr);
< !     }
<   
<       // Now, reset ourselves to the start of the window, and walk it to
<       // produce the output.  We'll walk it twice, first for the old
<       // file part, then for the new file part.
<   
<       fprintf (stdout, "***************\n");
< !     fprintf (stdout, "*** %d,%d ****\n", boOldWindow + 1, eoOldWindow);
<   
<       o = boOldWindow;
<       n = boNewWindow;
<   
< !     while (o < eoOldWindow || n < eoNewWindow) {
<   
<         // Find any unmatched lines at this point in the old file.  These
<         // are deletes.
< --- 755,797 ----
<           n += 1;
<         }
<   
< !       // ...  This context will end optCopyContext lines past the last
< !       // set of deletes or inserts we find.  However, since another
< !       // window could follow, we look 2 * optCopyContext ahead for
< !       // another delete or insert.
<   
< !       for (unsigned l = 0; l < (2 * optCopyContext); i += 1) {
<           if (o < lines[0].size ()) {
< !           if (widenWindow |= lines[0][o].l == ~0) {
< !             break;
< !           }
<             o += 1;
<           }
<           if (n < lines[1].size ()) {
< !           if (widenWindow |= lines[1][o].l == ~0) {
< !             break;
< !           }
<             n += 1;
<           }
<         }
< !     } while (widenWindow);
<   
<       // We've found the end of the window.
<   
< !     int boNewWindow = max (0, int (boInserts) - int (optCopyContext));
< !     int eoNewWindow = min (int (lines[1].size ()), int(n) + int (optCopyContext));
<   
<       // Now, reset ourselves to the start of the window, and walk it to
<       // produce the output.  We'll walk it twice, first for the old
<       // file part, then for the new file part.
<   
<       fprintf (stdout, "***************\n");
< !     fprintf (stdout, "*** %d,%d ****\n", boOldWindow + 1, eoOldWindow + 1);
<   
<       o = boOldWindow;
<       n = boNewWindow;
<   
< !     while (o < eoOldWindow && n < eoNewWindow) {
<   
<         // Find any unmatched lines at this point in the old file.  These
<         // are deletes.
< ***************
< *** 875,899 ****
<           // ... deletes and inserts.
<   
<           for (unsigned l = boDeletes; l < o; l += 1) {
< !           fprintf (stdout, "! %s\n", lines[0][l].line->c_str ());
<           }
<         } else if (nDeletes) {
<   
<           //  ... just deletes.
<   
<           for (unsigned l = boDeletes; l < o; l += 1) {
< !           fprintf (stdout, "- %s\n", lines[0][l].line->c_str ());
<           }
<         }
<   
<         // When we get here, we're dealing with matching lines.
<   
< !       fprintf (stdout, "  %s\n", lines[0][o].line->c_str ());
<         o += 1;
<         n += 1;
<       }
<   
< !     fprintf (stdout, "--- %d,%d ----\n", boNewWindow + 1, eoNewWindow);
<   
<       o = boOldWindow;
<       n = boNewWindow;
< --- 822,846 ----
<           // ... deletes and inserts.
<   
<           for (unsigned l = boDeletes; l < o; l += 1) {
< !           fprintf (stdout, "! %s", lines[0][l].line->c_str ());
<           }
<         } else if (nDeletes) {
<   
<           //  ... just deletes.
<   
<           for (unsigned l = boDeletes; l < o; l += 1) {
< !           fprintf (stdout, "- %s", lines[0][l].line->c_str ());
<           }
<         }
<   
<         // When we get here, we're dealing with matching lines.
<   
< !       fprintf (stdout, "  %s", lines[0][l].line->c_str ());
<         o += 1;
<         n += 1;
<       }
<   
< !     fprintf (stdout, "--- %d,%d ----\n", boNewWindow + 1, eoNewWindow + 1);
<   
<       o = boOldWindow;
<       n = boNewWindow;
< ***************
< *** 929,974 ****
<           // ... deletes and inserts.
<   
<           for (unsigned l = boInserts; l < n; l += 1) {
< !           fprintf (stdout, "! %s\n", lines[1][l].line->c_str ());
<           }
<         } else if (nInserts) {
<   
<           //  ... just inserts.
<   
<           for (unsigned l = boInserts; l < n; l += 1) {
< !           fprintf (stdout, "+ %s\n", lines[1][l].line->c_str ());
<           }
<         }
<   
<         // When we get here, we're dealing with matching lines.
<   
< !       fprintf (stdout, "  %s\n", lines[1][n].line->c_str ());
<         o += 1;
<         n += 1;
<       }
< - 
< -     // Reset to the end of the current window.
< - 
< -     o = eoOldWindow;
< -     n = eoNewWindow;
<     }
<   }
<   
<   void pass6e () {
< -   fprintf (stderr, "pass6e() is unimplemented!\n");
< -   fflush (stderr);
<   }
<   
<   void pass6i () {
< -   fprintf (stderr, "pass6i() is unimplemented!\n");
< -   fflush (stderr);
<   }
<   
<   void pass6n ()
<   {
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass #6n (walking the differences)...\n");
< -     fflush (stderr);
<     }
<   
<     nMatchedLines = 0;
< --- 876,911 ----
<           // ... deletes and inserts.
<   
<           for (unsigned l = boInserts; l < n; l += 1) {
< !           fprintf (stdout, "! %s", lines[1][l].line->c_str ());
<           }
<         } else if (nInserts) {
<   
<           //  ... just inserts.
<   
<           for (unsigned l = boInserts; l < n; l += 1) {
< !           fprintf (stdout, "+ %s", lines[1][l].line->c_str ());
<           }
<         }
<   
<         // When we get here, we're dealing with matching lines.
<   
< !       fprintf (stdout, "  %s", lines[1][l].line->c_str ());
<         o += 1;
<         n += 1;
<       }
<     }
<   }
<   
<   void pass6e () {
<   }
<   
<   void pass6i () {
<   }
<   
<   void pass6n ()
<   {
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass #6n (walking the differences)...\n");
<     }
<   
<     nMatchedLines = 0;
< ***************
< *** 1022,1032 ****
<           fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInserts + 1, n);
<         } 
<         for (unsigned l = boDeletes; l < o; l += 1) {
< !         fprintf (stdout, "< %s\n", lines[0][l].line->c_str ());
<         }
< !       fprintf (stdout, "---\n");
<         for (unsigned l = boInserts; l < n; l += 1) {
< !         fprintf (stdout, "> %s\n", lines[1][l].line->c_str ());
<         }
<       } else if (nDeletes) {
<   
< --- 959,969 ----
<           fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInserts + 1, n);
<         } 
<         for (unsigned l = boDeletes; l < o; l += 1) {
< !         fprintf (stdout, "< %s", lines[0][l].line->c_str ());
<         }
< !       fprintf (stderr, "---\n");
<         for (unsigned l = boInserts; l < n; l += 1) {
< !         fprintf (stdout, "> %s", lines[1][l].line->c_str ());
<         }
<       } else if (nDeletes) {
<   
< ***************
< *** 1038,1044 ****
<           fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
<         }
<         for (unsigned l = boDeletes; l < o; l += 1) {
< !         fprintf (stdout, "< %s\n", lines[0][l].line->c_str ());
<         }
<       } else if (nInserts) {
<   
< --- 975,981 ----
<           fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
<         }
<         for (unsigned l = boDeletes; l < o; l += 1) {
< !         fprintf (stdout, "< %s", lines[0][l].line->c_str ());
<         }
<       } else if (nInserts) {
<   
< ***************
< *** 1050,1056 ****
<           fprintf (stdout, "%da%d\n", o, boInserts + 1);
<         }
<         for (unsigned l = boInserts; l < n; l += 1) {
< !         fprintf (stdout, "> %s\n", lines[1][l].line->c_str ());
<         }
<       }
<   
< --- 987,993 ----
<           fprintf (stdout, "%da%d\n", o, boInserts + 1);
<         }
<         for (unsigned l = boInserts; l < n; l += 1) {
< !         fprintf (stdout, "> %s", lines[1][l].line->c_str ());
<         }
<       }
<   
< ***************
< *** 1062,1081 ****
<   }
<   
<   void pass6r () {
< -   fprintf (stderr, "pass6r() is unimplemented!\n");
< -   fflush (stderr);
<   }
<   
<   void pass6s () {
< -   fprintf (stderr, "pass6s() is unimplemented!\n");
< -   fflush (stderr);
<   }
<   
<   void pass6u ()
<   {
<     if (0 < optVerbose) {
<       fprintf (stderr, "# Pass #6u (walking the differences)...\n");
< -     fflush (stderr);
<     }
<   
<     nMatchedLines = 0;
< --- 999,1013 ----
< ***************
< *** 1126,1251 ****
<         // ... deletes and inserts.
<   
<         for (unsigned l = boDeletes; l < o; l += 1) {
< !         fprintf (stdout, "-%s\n", lines[0][l].line->c_str ());
<         }
<         for (unsigned l = boInserts; l < n; l += 1) {
< !         fprintf (stdout, "+%s\n", lines[1][l].line->c_str ());
<         }
<       } else if (nDeletes) {
<   
<         //  ... just deletes.
<   
<         for (unsigned l = boDeletes; l < o; l += 1) {
< !         fprintf (stdout, "-%s\n", lines[0][l].line->c_str ());
<         }
<       } else if (nInserts) {
<   
<         //  ... just inserts.
<   
<         for (unsigned l = boInserts; l < n; l += 1) {
< !         fprintf (stdout, "+%s\n", lines[1][l].line->c_str ());
<         }
<       }
<   
<       // When we get here, we're dealing with matching lines.
<   
< !     fprintf (stdout, " %s\n", lines[0][o].line->c_str ());
< !     o += 1;
< !     n += 1;
< !   }
< ! }
< ! 
< ! void pass6y ()
< ! {
< !   if (0 < optVerbose) {
< !     fprintf (stderr, "# Pass #6y (walking the differences)...\n");
< !     fflush (stderr);
< !   }
< ! 
< !   // Write the header.
< ! 
< !   // None for side-by-side.
< ! 
< !   // Starting at the top of both files,...
< ! 
< !   int columnWidth = (optPageWidth - 7) / 2;
< ! 
< !   unsigned o = 0;
< !   unsigned n = 0;
< ! 
< !   while (o < lines[0].size () || n < lines[1].size ()) {
< ! 
< !     // Find any unmatched lines at this point in the old file.  These
< !     // are deletes.
< ! 
< !     unsigned boDeletes = o;
< !     while (o < lines[0].size () && lines[0][o].l == ~0) {
< !       o += 1;
< !     }
< ! 
< !     // Find any unmatched lines at this point in the new file.  These
< !     // are inserts.
< ! 
< !     unsigned boInserts = n;
< !     while (n < lines[1].size () && lines[1][n].l == ~0) {
< !       n += 1;
< !     }
< ! 
< !     // We've got deleted line(s) from boDeletes .. o.
< !     // We've got deleted line(s) from boInserts .. n.
< ! 
< !     unsigned nDeletes = o - boDeletes;
< !     unsigned nInserts = n - boInserts;
< ! 
< !     // We've got...
< ! 
< !     while (boDeletes < o && boInserts < n) {
< ! 
< !       // ... deletes and inserts.
< ! 
< !       fprintf (stdout,
< !                "%-*s | %s\n",
< !                columnWidth,
< !                lines[0][boDeletes].line->substr (0, columnWidth).c_str (),
< !                lines[1][boInserts].line->substr (0, columnWidth).c_str ()
< !               );
< !       boDeletes += 1;
< !       boInserts += 1;
< !     }
< ! 
< !     while (boDeletes < o) {
< ! 
< !       //  ... just deletes.
< ! 
< !       fprintf (stdout,
< !                "%-*s <\n",
< !                columnWidth,
< !                lines[0][boDeletes].line->substr (0, columnWidth).c_str ()
< !               );
< !       boDeletes += 1;
< !     }
< ! 
< !     while (boInserts < n) {
< ! 
< !       //  ... just inserts.
< ! 
< !       fprintf (stdout,
< !                "%-*s > %s\n",
< !                columnWidth,
< !                "",
< !                lines[1][boInserts].line->substr (0, columnWidth).c_str ()
< !               );
< !       boInserts += 1;
< !     }
< ! 
< !     // When we get here, we're dealing with matching lines.
< ! 
< !     fprintf (stdout,
< !              "%-*s   %s\n",
< !              columnWidth,
< !              lines[0][o].line->substr (0, columnWidth).c_str (),
< !              lines[1][n].line->substr (0, columnWidth).c_str ()
< !             );
<       o += 1;
<       n += 1;
<     }
< --- 1058,1087 ----
<         // ... deletes and inserts.
<   
<         for (unsigned l = boDeletes; l < o; l += 1) {
< !         fprintf (stdout, "-%s", lines[0][l].line->c_str ());
<         }
<         for (unsigned l = boInserts; l < n; l += 1) {
< !         fprintf (stdout, "+%s", lines[1][l].line->c_str ());
<         }
<       } else if (nDeletes) {
<   
<         //  ... just deletes.
<   
<         for (unsigned l = boDeletes; l < o; l += 1) {
< !         fprintf (stdout, "-%s", lines[0][l].line->c_str ());
<         }
<       } else if (nInserts) {
<   
<         //  ... just inserts.
<   
<         for (unsigned l = boInserts; l < n; l += 1) {
< !         fprintf (stdout, "+%s", lines[1][l].line->c_str ());
<         }
<       }
<   
<       // When we get here, we're dealing with matching lines.
<   
< !     fprintf (stdout, " %s", lines[0][o].line->c_str ());
<       o += 1;
<       n += 1;
<     }
---
> sdiff: sdiff.cpp:1363: void pass6c(): Assertion `widenWindow || lines[0][o].line == lines[1][n].line' failed.
> *** dif.7.cpp	0000-00-00 00:00:00.000000000 +0000
> --- dif.6.cpp	0000-00-00 00:00:00.000000000 +0000
# ../sdiff -c dif.7.cpp dif.8.cpp >& dif.7.8.diff-c.test
./test: line 46: 23389 Aborted                 (core dumped) ${DIFF} "${option}" "${oSrc}" "${nSrc}" 1>&"${dst}.test"
# dif.7.8.diff-c ---------------------------------------------------------------
1,685c1,3
< *** dif.7.cpp	2008-02-25 22:43:43.000000000 +0000
< --- dif.8.cpp	2008-02-26 01:32:31.000000000 +0000
< ***************
< *** 9,31 ****
<   #include <vector>
<   using std::vector;
<   #include <stdio.h>
<   
<   enum DiffFormat {
< !   Default,
< ! 
< !   Context,
< !   EdScript,
< !   IfThenElse,
< !   Normal,
< !   RCS,
< !   SideBySide,
< !   Unified
<   };
<   
< ! DiffFormat diffFormat = SideBySide;
<   
< - unsigned optCopyContext = 3;
< - unsigned optPageWidth = 130;
<   unsigned optVerbose = 2;
<   
<   struct Line : public string {
< --- 9,54 ----
<   #include <vector>
<   using std::vector;
<   #include <stdio.h>
< + #include <getopt.h>
<   
<   enum DiffFormat {
< !   opt_D_IfThenElse,
< !   opt___Normal,
< !   opt_c_Context,
< !   opt_e_EdScript,
< !   opt_n_RCS,
< !   opt_u_Unified,
< !   opt_y_SideBySide
<   };
<   
< ! DiffFormat opt___OutputFormat = opt___Normal;
< ! 
< ! bool       opt_B_IgnoreBlankLines = false;
< ! unsigned   opt_C_LinesOfCopyContext = 3;
< ! string     opt_D_IfdefName;
< ! bool       opt_E_IgnoreTabExpansionChanges = false;
< ! string     opt_F_ShowMostRecentLineMatching;
< ! string     opt_I_IgnoreLinesMatching;
< ! bool       opt_N_TreatAbsentFilesAsEmpty = false;
< ! string     opt_S_StartWithFileMatching;
< ! bool       opt_T_PrependATab = false;
< ! unsigned   opt_U_LinesOfUnifiedContext = 3;
< ! unsigned   opt_W_MaxPrintColumns = 130;
< ! string     opt_X_ExcludeFilesMatching;
< ! bool       opt_a_TreatAllFilesAsText = false;
< ! bool       opt_b_IgnoreWhitespaceChanges = false;
< ! bool       opt_d_TryToFindMinimalChanges = false;
< ! bool       opt_i_IgnoreCaseDifferences = false;
< ! bool       opt_l_PaginateWithPr = false;
< ! bool       opt_p_ShowChangedCFunction = false;
< ! bool       opt_q_OutputOnlyIfFilesDiffer = false;
< ! bool       opt_r_RecursivelyCompareSubdirectories = false;
< ! bool       opt_s_ReportWhenFilesAreSame = false;
< ! bool       opt_t_ExpandTabs = false;
< ! bool       opt_v_ShowVersionInfo = false;
< ! bool       opt_w_IgnoreAllWhitespace = false;
< ! string     opt_x_IgnoreFilesMatching;
<   
<   unsigned optVerbose = 2;
<   
<   struct Line : public string {
< ***************
< *** 91,96 ****
< --- 114,121 ----
<   unsigned nTotalMatchedLines = 0;
<   unsigned nMatchedLines = 0;
<   
< + void getopts (int argc, char const *const argv[]);
< + 
<   void pass1 ();
<   void pass2 ();
<   void pass3 ();
< ***************
< *** 98,108 ****
<   void pass5 ();
<   void pass6 ();
<   
< ! int main (int argc, char *argv[])
<   {
<     // Read the old [0] file, and the new [1] file.
<   
< !   for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
<       files[n] = argv[a];
<   
<       if (FILE *f = fopen (files[n], "r")) {
< --- 123,151 ----
<   void pass5 ();
<   void pass6 ();
<   
< ! int main (int argc, char const *const argv[])
<   {
< +   getopts (argc, argv);
< + 
< +   if (opt_v_ShowVersionInfo) {
< +     fprintf
< +       (stderr,
< +        "diff () 0.0.1"
< +        "Copyright (C) 2008 Sidney R Maxwell III"
< +        ""
< +        "This program comes with NO WARRANTY, to the extent permitted by law."
< +        "You may redistribute copies of this program"
< +        "under the terms of the GNU General Public License."
< +        "For more information about these matters, see the file named COPYING."
< +        ""
< +        "Written by Sid Maxwell."
< +       );
< +     exit (0);
< +   }
< + 
<     // Read the old [0] file, and the new [1] file.
<   
< !   for (int a = optind, n = 0; a < argc && n < 2; a += 1, n += 1) {
<       files[n] = argv[a];
<   
<       if (FILE *f = fopen (files[n], "r")) {
< ***************
< *** 165,170 ****
< --- 208,594 ----
<     return 0;
<   }
<   
< + // Usage: diff [OPTION]... FILES
< + // Compare files line by line.
< + // 
< + //   --GTYPE-group-format=GFMT  Similar, but format GTYPE input groups with GFMT.
< + //   --LTYPE-line-format=LFMT  Similar, but format LTYPE input lines with LFMT.
< + //     LTYPE is `old', `new', or `unchanged'.  GTYPE is LTYPE or `changed'.
< + //     GFMT may contain:
< + //       %<  lines from FILE1
< + //       %>  lines from FILE2
< + //       %=  lines common to FILE1 and FILE2
< + //       %[-][WIDTH][.[PREC]]{doxX}LETTER  printf-style spec for LETTER
< + //         LETTERs are as follows for new group, lower case for old group:
< + //           F  first line number
< + //           L  last line number
< + //           N  number of lines = L-F+1
< + //           E  F-1
< + //           M  L+1
< + //     LFMT may contain:
< + //       %L  contents of line
< + //       %l  contents of line, excluding any trailing newline
< + //       %[-][WIDTH][.[PREC]]{doxX}n  printf-style spec for input line number
< + //     Either GFMT or LFMT may contain:
< + //       %%  %
< + //       %c'C'  the single character C
< + //       %c'\OOO'  the character with octal code OOO
< + //
< + //   --brief  -q  Output only whether files differ.
< + //   --context[=NUM]  -c  -C NUM  Output NUM (default 3) lines of copied context.
< + //   --ed  -e  Output an ed script.
< + //   --exclude-from=FILE  -X FILE  Exclude files that match any pattern in FILE.
< + //   --exclude=PAT  -x PAT  Exclude files that match PAT.
< + //   --expand-tabs  -t  Expand tabs to spaces in output.
< + //   --from-file=FILE1  Compare FILE1 to all operands.  FILE1 can be a directory.
< + //   --help  Output this help.
< + //   --horizon-lines=NUM  Keep NUM lines of the common prefix and suffix.
< + //   --ifdef=NAME  -D NAME  Output merged file to show `#ifdef NAME' diffs.
< + //   --ignore-all-space  -w  Ignore all white space.
< + //   --ignore-blank-lines  -B  Ignore changes whose lines are all blank.
< + //   --ignore-case  -i  Ignore case differences in file contents.
< + //   --ignore-file-name-case  Ignore case when comparing file names.
< + //   --ignore-matching-lines=RE  -I RE  Ignore changes whose lines all match RE.
< + //   --ignore-space-change  -b  Ignore changes in the amount of white space.
< + //   --ignore-tab-expansion  -E  Ignore changes due to tab expansion.
< + //   --initial-tab  -T  Make tabs line up by prepending a tab.
< + //   --label LABEL  Use LABEL instead of file name.
< + //   --left-column  Output only the left column of common lines.
< + //   --line-format=LFMT  Similar, but format all input lines with LFMT.
< + //   --minimal  -d  Try hard to find a smaller set of changes.
< + //   --new-file  -N  Treat absent files as empty.
< + //   --no-ignore-file-name-case  Consider case when comparing file names.
< + //   --normal  Output a normal diff.
< + //   --paginate  -l  Pass the output through `pr' to paginate it.
< + //   --rcs  -n  Output an RCS format diff.
< + //   --recursive  -r  Recursively compare any subdirectories found.
< + //   --report-identical-files  -s  Report when two files are the same.
< + //   --show-c-function  -p  Show which C function each change is in.
< + //   --show-function-line=RE  -F RE  Show the most recent line matching RE.
< + //   --side-by-side  -y  Output in two columns.
< + //   --speed-large-files  Assume large files and many scattered small changes.
< + //   --starting-file=FILE  -S FILE  Start with FILE when comparing directories.
< + //   --strip-trailing-cr  Strip trailing carriage return on input.
< + //   --suppress-common-lines  Do not output common lines.
< + //   --text  -a  Treat all files as text.
< + //   --to-file=FILE2  Compare all operands to FILE2.  FILE2 can be a directory.
< + //   --unidirectional-new-file  Treat absent first files as empty.
< + //   --unified[=NUM]  -u  -U NUM  Output NUM (default 3) lines of unified context.
< + //   --version  -v  Output version info.
< + //   --width=NUM  -W NUM  Output at most NUM (default 130) print columns.
< + // 
< + // FILES are `FILE1 FILE2' or `DIR1 DIR2' or `DIR FILE...' or `FILE... DIR'.
< + // If --from-file or --to-file is given, there are no restrictions on FILES.
< + // If a FILE is `-', read standard input.
< + // 
< + // Report bugs to <bug-gnu-utils@gnu.org>.
< + 
< + void getopts (int argc, char const *const argv[])
< + {
< +   while (1) {
< +     int option_index = 0;
< +     static option long_options[] = {
< +       { "brief",                        0, 0, 'q' }, // Output only whether files differ.
< +       { "context",                      2, 0, 'c' }, // Output NUM (default 3) lines of copied context.
< +       { "ed",                           0, 0, 'e' }, // Output an ed script.
< +       { "exclude-from",                 1, 0, ' ' }, // Exclude files that match any pattern in FILE.
< +       { "exclude",                      1, 0, 'x' }, // Exclude files that match PAT.
< +       { "expand-tabs",                  0, 0, 't' }, // Expand tabs to spaces in output.
< +       { "from-file",                    1, 0, ' ' }, // Compare FILE1 to all operands. FILE1 can be a directory.
< +       { "help",                         0, 0, 'h' }, // Output this help.
< +       { "horizon-lines",                1, 0, ' ' }, // Keep NUM lines of the common prefix and suffix.
< +       { "ifdef",                        1, 0, 'D' }, // Output merged file to show `#ifdef NAME' diffs.
< +       { "ignore-all-space",             0, 0, 'w' }, // Ignore all white space.
< +       { "ignore-blank-lines",           0, 0, 'B' }, // Ignore changes whose lines are all blank.
< +       { "ignore-case",                  0, 0, 'i' }, // Ignore case differences in file contents.
< +       { "ignore-file-name-case",        0, 0, ' ' }, // Ignore case when comparing file names.
< +       { "ignore-matching-lines",        1, 0, 'I' }, // Ignore changes whose lines all match RE.
< +       { "ignore-space-change",          0, 0, 'b' }, // Ignore changes in the amount of white space.
< +       { "ignore-tab-expansion",         0, 0, 'E' }, // Ignore changes due to tab expansion.
< +       { "initial-tab",                  0, 0, 'T' }, // Make tabs line up by prepending a tab.
< +       { "label",                        1, 0, ' ' }, // Use LABEL instead of file name.
< +       { "left-column",                  0, 0, ' ' }, // Output only the left column of common lines.
< +       { "line-format",                  1, 0, ' ' }, // Similar, but format all input lines with LFMT.
< +       { "minimal",                      0, 0, 'd' }, // Try hard to find a smaller set of changes.
< +       { "new-file",                     0, 0, 'N' }, // Treat absent files as empty.
< +       { "no-ignore-file-name-case",     0, 0, ' ' }, // Consider case when comparing file names.
< +       { "normal",                       0, 0, ' ' }, // Output a normal diff.
< +       { "paginate",                     0, 0, 'l' }, // Pass the output through `pr' to paginate it.
< +       { "rcs",                          0, 0, 'n' }, // Output an RCS format diff.
< +       { "recursive",                    0, 0, 'r' }, // Recursively compare any subdirectories found.
< +       { "report-identical-files",       0, 0, 's' }, // Report when two files are the same.
< +       { "show-c-function",              0, 0, 'p' }, // Show which C function each change is in.
< +       { "show-function-line",           1, 0, 'F' }, // Show the most recent line matching RE.
< +       { "side-by-side",                 0, 0, 'y' }, // Output in two columns.
< +       { "speed-large-files",            0, 0, ' ' }, // Assume large files and many scattered small changes.
< +       { "starting-file",                1, 0, 'S' }, // Start with FILE when comparing directories.
< +       { "strip-trailing-cr",            0, 0, ' ' }, // Strip trailing carriage return on input.
< +       { "suppress-common-lines",        0, 0, ' ' }, // Do not output common lines.
< +       { "text",                         0, 0, 'a' }, // Treat all files as text.
< +       { "to-file",                      0, 0, ' ' }, // Compare all operands to FILE2.  FILE2 can be a directory.
< +       { "unidirectional-new-file",      0, 0, ' ' }, // Treat absent first files as empty.
< +       { "unified",                      2, 0, 'u' }, // Output NUM (default 3) lines of unified context.
< +       { "version",                      0, 0, 'v' }, // Output version info.
< +       { "width",                        1, 0, 'W' }, // Output at most NUM (default 130) print columns.
< +       { 0,				0, 0,   0 }
< +     };
< + 
< +     char const *short_options =
< +       "B"                       // Ignore changes whose lines are all blank.
< +       "C:"                      // Output NUM (default 3) lines of copied context.
< +       "D:"                      // Output merged file to show `#ifdef NAME' diffs.
< +       "E"                       // Ignore changes due to tab expansion.
< +       "F:"                      // Show the most recent line matching RE.
< +       "I:"                      // Ignore changes whose lines all match RE.
< +       "N"                       // Treat absent files as empty.
< +       "S:"                      // Start with FILE when comparing directories.
< +       "T"                       // Make tabs line up by prepending a tab.
< +       "U:"                      // Output NUM (default 3) lines of unified context.
< +       "W:"                      // Output at most NUM (default 130) print columns.
< +       "X:"                      // Exclude files that match any pattern in FILE.
< +       "a"                       // Treat all files as text.
< +       "b"                       // Ignore changes in the amount of white space.
< +       "c"                       // Output NUM (default 3) lines of copied context.
< +       "d"                       // Try hard to find a smaller set of changes.
< +       "e"                       // Output an ed script.
< +       "i"                       // Ignore case differences in file contents.
< +       "l"                       // Pass the output through `pr' to paginate it.
< +       "n"                       // Output an RCS format diff.
< +       "p"                       // Show which C function each change is in.
< +       "q"                       // Output only whether files differ.
< +       "r"                       // Recursively compare any subdirectories found.
< +       "s"                       // Report when two files are the same.
< +       "t"                       // Expand tabs to spaces in output.
< +       "u"                       // Output NUM (default 3) lines of unified context.
< +       "v"                       // Output version info.
< +       "w"                       // Ignore all white space.
< +       "x:"                      // Exclude files that match PAT.
< +       "y"                       // Output in two columns.
< +       ;
< + 
< +     int c =
< +       getopt_long
< +         (argc,
< +          const_cast<char *const *> (argv),
< +          short_options,
< +          long_options,
< +          &option_index
< +         );
< + 
< +     switch (c) {
< +     case -1:
< +       return;
< + 
< +     case 0:
< +       printf ("option %s", long_options[option_index].name);
< +       if (optarg)
< +         printf (" with arg %s", optarg);
< +       printf ("\n");
< +       break;
< +     case 'B':
< +       opt_B_IgnoreBlankLines = true;
< +       break;
< +     case 'C':
< +       {
< +         unsigned linesOfContext = 3;
< +         if (optarg) {
< +           if (sscanf (optarg, "%u", &linesOfContext) != 1) {
< +             fprintf (stderr, "-C <NUM> or --context[=<NUM>] (%d)\n", opt_C_LinesOfCopyContext);
< +             exit (1);
< +           }
< +         }
< +         opt_C_LinesOfCopyContext = linesOfContext;
< +       }
< +       break;
< +     case 'D':
< +       opt_D_IfdefName = optarg;
< +       break;
< +     case 'E':
< +       opt_E_IgnoreTabExpansionChanges = true;
< +       break;
< +     case 'F':
< +       opt_F_ShowMostRecentLineMatching = optarg;
< +       break;
< +     case 'I':
< +       opt_I_IgnoreLinesMatching = optarg;
< +       break;
< +     case 'N':
< +       opt_N_TreatAbsentFilesAsEmpty = true;
< +       break;
< +     case 'S':
< +       opt_S_StartWithFileMatching = optarg;
< +       break;
< +     case 'T':
< +       opt_T_PrependATab = true;
< +       break;
< +     case 'U':
< +       {
< +         unsigned linesOfContext = 3;
< +         if (optarg) {
< +           if (sscanf (optarg, "%u", &linesOfContext) != 1) {
< +             fprintf (stderr, "-U <NUM> or --unified[=<NUM>] (%d)\n", opt_U_LinesOfUnifiedContext);
< +             exit (1);
< +           }
< +         }
< +         opt_U_LinesOfUnifiedContext = linesOfContext;
< +       }
< +       break;
< +     case 'W':
< +       {
< +         unsigned maxPrintColumns = 130;
< +         if (optarg) {
< +           if (sscanf (optarg, "%u", &maxPrintColumns) != 1) {
< +             fprintf (stderr, "-W <NUM> or --width[=<NUM>] (%d)\n", opt_W_MaxPrintColumns);
< +             exit (1);
< +           }
< +         }
< +         opt_W_MaxPrintColumns = maxPrintColumns;
< +       }
< +       break;
< +     case 'X':
< +       opt_X_ExcludeFilesMatching = optarg;
< +       break;
< +     case 'a':
< +       opt_a_TreatAllFilesAsText = true;
< +       break;
< +     case 'b':
< +       opt_b_IgnoreWhitespaceChanges = true;
< +       break;
< +     case 'c':
< +       opt___OutputFormat = opt_c_Context;
< +       break;
< +     case 'd':
< +       opt_d_TryToFindMinimalChanges = true;
< +       break;
< +     case 'e':
< +       opt___OutputFormat = opt_e_EdScript;
< +       break;
< +     case 'i':
< +       opt_i_IgnoreCaseDifferences = true;
< +       break;
< +     case 'l':
< +       opt_l_PaginateWithPr = true;
< +       break;
< +     case 'n':
< +       opt___OutputFormat = opt_n_RCS;
< +       break;
< +     case 'p':
< +       opt_p_ShowChangedCFunction = true;
< +       break;
< +     case 'q':
< +       opt_q_OutputOnlyIfFilesDiffer = true;
< +       break;
< +     case 'r':
< +       opt_r_RecursivelyCompareSubdirectories = true;
< +       break;
< +     case 's':
< +       opt_s_ReportWhenFilesAreSame = true;
< +       break;
< +     case 't':
< +       opt_t_ExpandTabs = true;
< +       break;
< +     case 'u':
< +       opt___OutputFormat = opt_u_Unified;
< +       break;
< +     case 'v':
< +       opt_v_ShowVersionInfo = true;
< +       break;
< +     case 'w':
< +       opt_w_IgnoreAllWhitespace = true;
< +       break;
< +     case 'x':
< +       opt_x_IgnoreFilesMatching = optarg;
< +       break;
< +     case 'y':
< +       opt___OutputFormat = opt_y_SideBySide;
< +       break;
< +     case 'h':
< +     case '?':
< +       fprintf
< +         (stderr,
< +          "Usage: diff [OPTION]... FILES\n"
< +          "Compare files line by line.\n"
< +          "\n"
< +          "  --GTYPE-group-format=GFMT  Similar, but format GTYPE input groups with GFMT.\n"
< +          "  --LTYPE-line-format=LFMT  Similar, but format LTYPE input lines with LFMT.\n"
< +          "    LTYPE is `old', `new', or `unchanged'.  GTYPE is LTYPE or `changed'.\n"
< +          "    GFMT may contain:\n"
< +          "      %<  lines from FILE1\n"
< +          "      %>  lines from FILE2\n"
< +          "      %=  lines common to FILE1 and FILE2\n"
< +          "      %[-][WIDTH][.[PREC]]{doxX}LETTER  printf-style spec for LETTER\n"
< +          "        LETTERs are as follows for new group, lower case for old group:\n"
< +          "          F  first line number\n"
< +          "          L  last line number\n"
< +          "          N  number of lines = L-F+1\n"
< +          "          E  F-1\n"
< +          "          M  L+1\n"
< +          "    LFMT may contain:\n"
< +          "      %L  contents of line\n"
< +          "      %l  contents of line, excluding any trailing newline\n"
< +          "      %[-][WIDTH][.[PREC]]{doxX}n  printf-style spec for input line number\n"
< +          "    Either GFMT or LFMT may contain:\n"
< +          "      %%  %\n"
< +          "      %c'C'  the single character C\n"
< +          "      %c'\\OOO'  the character with octal code OOO\n"
< +          "\n"
< +          "  --brief  -q  Output only whether files differ.\n"
< +          "  --context[=NUM]  -c  -C NUM  Output NUM (default 3) lines of copied context.\n"
< +          "  --ed  -e  Output an ed script.\n"
< +          "  --exclude-from=FILE  -X FILE  Exclude files that match any pattern in FILE.\n"
< +          "  --exclude=PAT  -x PAT  Exclude files that match PAT.\n"
< +          "  --expand-tabs  -t  Expand tabs to spaces in output.\n"
< +          "  --from-file=FILE1  Compare FILE1 to all operands.  FILE1 can be a directory.\n"
< +          "  --help  Output this help.\n"
< +          "  --horizon-lines=NUM  Keep NUM lines of the common prefix and suffix.\n"
< +          "  --ifdef=NAME  -D NAME  Output merged file to show `#ifdef NAME' diffs.\n"
< +          "  --ignore-all-space  -w  Ignore all white space.\n"
< +          "  --ignore-blank-lines  -B  Ignore changes whose lines are all blank.\n"
< +          "  --ignore-case  -i  Ignore case differences in file contents.\n"
< +          "  --ignore-file-name-case  Ignore case when comparing file names.\n"
< +          "  --ignore-matching-lines=RE  -I RE  Ignore changes whose lines all match RE.\n"
< +          "  --ignore-space-change  -b  Ignore changes in the amount of white space.\n"
< +          "  --ignore-tab-expansion  -E  Ignore changes due to tab expansion.\n"
< +          "  --initial-tab  -T  Make tabs line up by prepending a tab.\n"
< +          "  --label LABEL  Use LABEL instead of file name.\n"
< +          "  --left-column  Output only the left column of common lines.\n"
< +          "  --line-format=LFMT  Similar, but format all input lines with LFMT.\n"
< +          "  --minimal  -d  Try hard to find a smaller set of changes.\n"
< +          "  --new-file  -N  Treat absent files as empty.\n"
< +          "  --no-ignore-file-name-case  Consider case when comparing file names.\n"
< +          "  --normal  Output a normal diff.\n"
< +          "  --paginate  -l  Pass the output through `pr' to paginate it.\n"
< +          "  --rcs  -n  Output an RCS format diff.\n"
< +          "  --recursive  -r  Recursively compare any subdirectories found.\n"
< +          "  --report-identical-files  -s  Report when two files are the same.\n"
< +          "  --show-c-function  -p  Show which C function each change is in.\n"
< +          "  --show-function-line=RE  -F RE  Show the most recent line matching RE.\n"
< +          "  --side-by-side  -y  Output in two columns.\n"
< +          "  --speed-large-files  Assume large files and many scattered small changes.\n"
< +          "  --starting-file=FILE  -S FILE  Start with FILE when comparing directories.\n"
< +          "  --strip-trailing-cr  Strip trailing carriage return on input.\n"
< +          "  --suppress-common-lines  Do not output common lines.\n"
< +          "  --text  -a  Treat all files as text.\n"
< +          "  --to-file=FILE2  Compare all operands to FILE2.  FILE2 can be a directory.\n"
< +          "  --unidirectional-new-file  Treat absent first files as empty.\n"
< +          "  --unified[=NUM]  -u  -U NUM  Output NUM (default 3) lines of unified context.\n"
< +          "  --version  -v  Output version info.\n"
< +          "  --width=NUM  -W NUM  Output at most NUM (default 130) print columns.\n"
< +          "\n"
< +          "FILES are `FILE1 FILE2' or `DIR1 DIR2' or `DIR FILE...' or `FILE... DIR'.\n"
< +          "If --from-file or --to-file is given, there are no restrictions on FILES.\n"
< +          "If a FILE is `-', read standard input.\n"
< +          "\n"
< +          "Report bugs to <bug-gnu-utils@gnu.org>.\n"
< +         );
< +       exit (1);
< +     default:
< +       fprintf (stderr, "Unhandled option (%c%s)!\n", c, optarg ? optarg : "");
< +       exit (1);
< +     }
< +   }
< + }
< + 
<   // Perform pass #1, in which we find all explicit matches amongst the
<   // unique lines.  For every unique line that appears the same number
<   // of times in both files, we declare the lines to match.
< ***************
< *** 681,719 ****
<   
<   void pass6 ()
<   {
< ! 
< !   switch (diffFormat) {
< !   case Context:
<       pass6c ();
<       break;
<   
< !   case EdScript:
<       pass6e ();
<       break;
<   
< !   case IfThenElse:
<       pass6i ();
<       break;
<   
< !   case Normal:
<       pass6n ();
<       break;
<   
< !   case RCS:
<       pass6r ();
<       break;
<   
< !   case SideBySide:
<       pass6y ();
<       break;
<   
< !   case Unified:
<       pass6u ();
<       break;
<   
< -   case Default:
<     default:
< !     pass6c ();
<       break;
<     }
<   }
< --- 1105,1141 ----
<   
<   void pass6 ()
<   {
< !   switch (opt___OutputFormat) {
< !   case opt_c_Context:
<       pass6c ();
<       break;
<   
< !   case opt_e_EdScript:
<       pass6e ();
<       break;
<   
< !   case opt_D_IfThenElse:
<       pass6i ();
<       break;
<   
< !   case opt___Normal:
<       pass6n ();
<       break;
<   
< !   case opt_n_RCS:
<       pass6r ();
<       break;
<   
< !   case opt_y_SideBySide:
<       pass6y ();
<       break;
<   
< !   case opt_u_Unified:
<       pass6u ();
<       break;
<   
<     default:
< !     pass6n ();
<       break;
<     }
<   }
< ***************
< *** 764,773 ****
<       }
<   
<       // We're now looking at at least 1 delete or insert, so a window
< !     // begins here (or, rather, optCopyContext lines earlier).
<       
< !     int boOldWindow = max (0, int (o) - int (optCopyContext));
< !     int boNewWindow = max (0, int (n) - int (optCopyContext));
<   
<       if (1 < optVerbose) {
<         fprintf (stderr, "boOldWindow = %d, boNewWindow = %d\n", boOldWindow, boNewWindow);
< --- 1186,1195 ----
<       }
<   
<       // We're now looking at at least 1 delete or insert, so a window
< !     // begins here (or, rather, opt_C_LinesOfCopyContext lines earlier).
<       
< !     int boOldWindow = max (0, int (o) - int (opt_C_LinesOfCopyContext));
< !     int boNewWindow = max (0, int (n) - int (opt_C_LinesOfCopyContext));
<   
<       if (1 < optVerbose) {
<         fprintf (stderr, "boOldWindow = %d, boNewWindow = %d\n", boOldWindow, boNewWindow);
< ***************
< *** 792,802 ****
<           n += 1;
<         }
<   
< !       // This context will end optCopyContext matched lines past the
<         // last set of deletes or inserts we find.
<   
<         widenWindow = false;
< !       for (unsigned l = 0; !widenWindow && l < optCopyContext; l += 1) {
<           if (o < lines[0].size ()) {
<             widenWindow |= lines[0][o].l == ~0;
<             o += 1;
< --- 1214,1224 ----
<           n += 1;
<         }
<   
< !       // This context will end opt_C_LinesOfCopyContext matched lines past the
<         // last set of deletes or inserts we find.
<   
<         widenWindow = false;
< !       for (unsigned l = 0; !widenWindow && l < opt_C_LinesOfCopyContext; l += 1) {
<           if (o < lines[0].size ()) {
<             widenWindow |= lines[0][o].l == ~0;
<             o += 1;
< ***************
< *** 811,820 ****
<         eoNewWindow = n;
<   
<         // However, since another window could follow, we look
< !       // optCopyContext ahead for another delete or insert.
<   
<         if (!widenWindow) {
< !         for (unsigned l = 0; l < (2 * optCopyContext + 1); l += 1) {
<             if (o < lines[0].size ()) {
<               widenWindow |= lines[0][o].l == ~0;
<               o += 1;
< --- 1233,1242 ----
<         eoNewWindow = n;
<   
<         // However, since another window could follow, we look
< !       // opt_C_LinesOfCopyContext ahead for another delete or insert.
<   
<         if (!widenWindow) {
< !         for (unsigned l = 0; l < (2 * opt_C_LinesOfCopyContext + 1); l += 1) {
<             if (o < lines[0].size ()) {
<               widenWindow |= lines[0][o].l == ~0;
<               o += 1;
< ***************
< *** 1168,1174 ****
<   
<     // Starting at the top of both files,...
<   
< !   int columnWidth = (optPageWidth - 7) / 2;
<   
<     unsigned o = 0;
<     unsigned n = 0;
< --- 1590,1596 ----
<   
<     // Starting at the top of both files,...
<   
< !   int columnWidth = (opt_W_MaxPrintColumns - 7) / 2;
<   
<     unsigned o = 0;
<     unsigned n = 0;
---
> sdiff: sdiff.cpp:1363: void pass6c(): Assertion `widenWindow || lines[0][o].line == lines[1][n].line' failed.
> *** dif.7.cpp	0000-00-00 00:00:00.000000000 +0000
> --- dif.8.cpp	0000-00-00 00:00:00.000000000 +0000
# ../sdiff -c dif.8.cpp dif.7.cpp >& dif.8.7.diff-c.test
./test: line 46: 23392 Aborted                 (core dumped) ${DIFF} "${option}" "${oSrc}" "${nSrc}" 1>&"${dst}.test"
# dif.8.7.diff-c ---------------------------------------------------------------
1,685c1,3
< *** dif.8.cpp	2008-02-26 01:32:31.000000000 +0000
< --- dif.7.cpp	2008-02-25 22:43:43.000000000 +0000
< ***************
< *** 9,54 ****
<   #include <vector>
<   using std::vector;
<   #include <stdio.h>
< - #include <getopt.h>
<   
<   enum DiffFormat {
< !   opt_D_IfThenElse,
< !   opt___Normal,
< !   opt_c_Context,
< !   opt_e_EdScript,
< !   opt_n_RCS,
< !   opt_u_Unified,
< !   opt_y_SideBySide
< ! };
<   
< ! DiffFormat opt___OutputFormat = opt___Normal;
<   
< ! bool       opt_B_IgnoreBlankLines = false;
< ! unsigned   opt_C_LinesOfCopyContext = 3;
< ! string     opt_D_IfdefName;
< ! bool       opt_E_IgnoreTabExpansionChanges = false;
< ! string     opt_F_ShowMostRecentLineMatching;
< ! string     opt_I_IgnoreLinesMatching;
< ! bool       opt_N_TreatAbsentFilesAsEmpty = false;
< ! string     opt_S_StartWithFileMatching;
< ! bool       opt_T_PrependATab = false;
< ! unsigned   opt_U_LinesOfUnifiedContext = 3;
< ! unsigned   opt_W_MaxPrintColumns = 130;
< ! string     opt_X_ExcludeFilesMatching;
< ! bool       opt_a_TreatAllFilesAsText = false;
< ! bool       opt_b_IgnoreWhitespaceChanges = false;
< ! bool       opt_d_TryToFindMinimalChanges = false;
< ! bool       opt_i_IgnoreCaseDifferences = false;
< ! bool       opt_l_PaginateWithPr = false;
< ! bool       opt_p_ShowChangedCFunction = false;
< ! bool       opt_q_OutputOnlyIfFilesDiffer = false;
< ! bool       opt_r_RecursivelyCompareSubdirectories = false;
< ! bool       opt_s_ReportWhenFilesAreSame = false;
< ! bool       opt_t_ExpandTabs = false;
< ! bool       opt_v_ShowVersionInfo = false;
< ! bool       opt_w_IgnoreAllWhitespace = false;
< ! string     opt_x_IgnoreFilesMatching;
<   
<   unsigned optVerbose = 2;
<   
<   struct Line : public string {
< --- 9,31 ----
<   #include <vector>
<   using std::vector;
<   #include <stdio.h>
<   
<   enum DiffFormat {
< !   Default,
<   
< !   Context,
< !   EdScript,
< !   IfThenElse,
< !   Normal,
< !   RCS,
< !   SideBySide,
< !   Unified
< ! };
<   
< ! DiffFormat diffFormat = SideBySide;
<   
< + unsigned optCopyContext = 3;
< + unsigned optPageWidth = 130;
<   unsigned optVerbose = 2;
<   
<   struct Line : public string {
< ***************
< *** 114,121 ****
<   unsigned nTotalMatchedLines = 0;
<   unsigned nMatchedLines = 0;
<   
< - void getopts (int argc, char const *const argv[]);
< - 
<   void pass1 ();
<   void pass2 ();
<   void pass3 ();
< --- 91,96 ----
< ***************
< *** 123,151 ****
<   void pass5 ();
<   void pass6 ();
<   
< ! int main (int argc, char const *const argv[])
<   {
< -   getopts (argc, argv);
< - 
< -   if (opt_v_ShowVersionInfo) {
< -     fprintf
< -       (stderr,
< -        "diff () 0.0.1"
< -        "Copyright (C) 2008 Sidney R Maxwell III"
< -        ""
< -        "This program comes with NO WARRANTY, to the extent permitted by law."
< -        "You may redistribute copies of this program"
< -        "under the terms of the GNU General Public License."
< -        "For more information about these matters, see the file named COPYING."
< -        ""
< -        "Written by Sid Maxwell."
< -       );
< -     exit (0);
< -   }
< - 
<     // Read the old [0] file, and the new [1] file.
<   
< !   for (int a = optind, n = 0; a < argc && n < 2; a += 1, n += 1) {
<       files[n] = argv[a];
<   
<       if (FILE *f = fopen (files[n], "r")) {
< --- 98,108 ----
<   void pass5 ();
<   void pass6 ();
<   
< ! int main (int argc, char *argv[])
<   {
<     // Read the old [0] file, and the new [1] file.
<   
< !   for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
<       files[n] = argv[a];
<   
<       if (FILE *f = fopen (files[n], "r")) {
< ***************
< *** 208,594 ****
<     return 0;
<   }
<   
< - // Usage: diff [OPTION]... FILES
< - // Compare files line by line.
< - // 
< - //   --GTYPE-group-format=GFMT  Similar, but format GTYPE input groups with GFMT.
< - //   --LTYPE-line-format=LFMT  Similar, but format LTYPE input lines with LFMT.
< - //     LTYPE is `old', `new', or `unchanged'.  GTYPE is LTYPE or `changed'.
< - //     GFMT may contain:
< - //       %<  lines from FILE1
< - //       %>  lines from FILE2
< - //       %=  lines common to FILE1 and FILE2
< - //       %[-][WIDTH][.[PREC]]{doxX}LETTER  printf-style spec for LETTER
< - //         LETTERs are as follows for new group, lower case for old group:
< - //           F  first line number
< - //           L  last line number
< - //           N  number of lines = L-F+1
< - //           E  F-1
< - //           M  L+1
< - //     LFMT may contain:
< - //       %L  contents of line
< - //       %l  contents of line, excluding any trailing newline
< - //       %[-][WIDTH][.[PREC]]{doxX}n  printf-style spec for input line number
< - //     Either GFMT or LFMT may contain:
< - //       %%  %
< - //       %c'C'  the single character C
< - //       %c'\OOO'  the character with octal code OOO
< - //
< - //   --brief  -q  Output only whether files differ.
< - //   --context[=NUM]  -c  -C NUM  Output NUM (default 3) lines of copied context.
< - //   --ed  -e  Output an ed script.
< - //   --exclude-from=FILE  -X FILE  Exclude files that match any pattern in FILE.
< - //   --exclude=PAT  -x PAT  Exclude files that match PAT.
< - //   --expand-tabs  -t  Expand tabs to spaces in output.
< - //   --from-file=FILE1  Compare FILE1 to all operands.  FILE1 can be a directory.
< - //   --help  Output this help.
< - //   --horizon-lines=NUM  Keep NUM lines of the common prefix and suffix.
< - //   --ifdef=NAME  -D NAME  Output merged file to show `#ifdef NAME' diffs.
< - //   --ignore-all-space  -w  Ignore all white space.
< - //   --ignore-blank-lines  -B  Ignore changes whose lines are all blank.
< - //   --ignore-case  -i  Ignore case differences in file contents.
< - //   --ignore-file-name-case  Ignore case when comparing file names.
< - //   --ignore-matching-lines=RE  -I RE  Ignore changes whose lines all match RE.
< - //   --ignore-space-change  -b  Ignore changes in the amount of white space.
< - //   --ignore-tab-expansion  -E  Ignore changes due to tab expansion.
< - //   --initial-tab  -T  Make tabs line up by prepending a tab.
< - //   --label LABEL  Use LABEL instead of file name.
< - //   --left-column  Output only the left column of common lines.
< - //   --line-format=LFMT  Similar, but format all input lines with LFMT.
< - //   --minimal  -d  Try hard to find a smaller set of changes.
< - //   --new-file  -N  Treat absent files as empty.
< - //   --no-ignore-file-name-case  Consider case when comparing file names.
< - //   --normal  Output a normal diff.
< - //   --paginate  -l  Pass the output through `pr' to paginate it.
< - //   --rcs  -n  Output an RCS format diff.
< - //   --recursive  -r  Recursively compare any subdirectories found.
< - //   --report-identical-files  -s  Report when two files are the same.
< - //   --show-c-function  -p  Show which C function each change is in.
< - //   --show-function-line=RE  -F RE  Show the most recent line matching RE.
< - //   --side-by-side  -y  Output in two columns.
< - //   --speed-large-files  Assume large files and many scattered small changes.
< - //   --starting-file=FILE  -S FILE  Start with FILE when comparing directories.
< - //   --strip-trailing-cr  Strip trailing carriage return on input.
< - //   --suppress-common-lines  Do not output common lines.
< - //   --text  -a  Treat all files as text.
< - //   --to-file=FILE2  Compare all operands to FILE2.  FILE2 can be a directory.
< - //   --unidirectional-new-file  Treat absent first files as empty.
< - //   --unified[=NUM]  -u  -U NUM  Output NUM (default 3) lines of unified context.
< - //   --version  -v  Output version info.
< - //   --width=NUM  -W NUM  Output at most NUM (default 130) print columns.
< - // 
< - // FILES are `FILE1 FILE2' or `DIR1 DIR2' or `DIR FILE...' or `FILE... DIR'.
< - // If --from-file or --to-file is given, there are no restrictions on FILES.
< - // If a FILE is `-', read standard input.
< - // 
< - // Report bugs to <bug-gnu-utils@gnu.org>.
< - 
< - void getopts (int argc, char const *const argv[])
< - {
< -   while (1) {
< -     int option_index = 0;
< -     static option long_options[] = {
< -       { "brief",                        0, 0, 'q' }, // Output only whether files differ.
< -       { "context",                      2, 0, 'c' }, // Output NUM (default 3) lines of copied context.
< -       { "ed",                           0, 0, 'e' }, // Output an ed script.
< -       { "exclude-from",                 1, 0, ' ' }, // Exclude files that match any pattern in FILE.
< -       { "exclude",                      1, 0, 'x' }, // Exclude files that match PAT.
< -       { "expand-tabs",                  0, 0, 't' }, // Expand tabs to spaces in output.
< -       { "from-file",                    1, 0, ' ' }, // Compare FILE1 to all operands. FILE1 can be a directory.
< -       { "help",                         0, 0, 'h' }, // Output this help.
< -       { "horizon-lines",                1, 0, ' ' }, // Keep NUM lines of the common prefix and suffix.
< -       { "ifdef",                        1, 0, 'D' }, // Output merged file to show `#ifdef NAME' diffs.
< -       { "ignore-all-space",             0, 0, 'w' }, // Ignore all white space.
< -       { "ignore-blank-lines",           0, 0, 'B' }, // Ignore changes whose lines are all blank.
< -       { "ignore-case",                  0, 0, 'i' }, // Ignore case differences in file contents.
< -       { "ignore-file-name-case",        0, 0, ' ' }, // Ignore case when comparing file names.
< -       { "ignore-matching-lines",        1, 0, 'I' }, // Ignore changes whose lines all match RE.
< -       { "ignore-space-change",          0, 0, 'b' }, // Ignore changes in the amount of white space.
< -       { "ignore-tab-expansion",         0, 0, 'E' }, // Ignore changes due to tab expansion.
< -       { "initial-tab",                  0, 0, 'T' }, // Make tabs line up by prepending a tab.
< -       { "label",                        1, 0, ' ' }, // Use LABEL instead of file name.
< -       { "left-column",                  0, 0, ' ' }, // Output only the left column of common lines.
< -       { "line-format",                  1, 0, ' ' }, // Similar, but format all input lines with LFMT.
< -       { "minimal",                      0, 0, 'd' }, // Try hard to find a smaller set of changes.
< -       { "new-file",                     0, 0, 'N' }, // Treat absent files as empty.
< -       { "no-ignore-file-name-case",     0, 0, ' ' }, // Consider case when comparing file names.
< -       { "normal",                       0, 0, ' ' }, // Output a normal diff.
< -       { "paginate",                     0, 0, 'l' }, // Pass the output through `pr' to paginate it.
< -       { "rcs",                          0, 0, 'n' }, // Output an RCS format diff.
< -       { "recursive",                    0, 0, 'r' }, // Recursively compare any subdirectories found.
< -       { "report-identical-files",       0, 0, 's' }, // Report when two files are the same.
< -       { "show-c-function",              0, 0, 'p' }, // Show which C function each change is in.
< -       { "show-function-line",           1, 0, 'F' }, // Show the most recent line matching RE.
< -       { "side-by-side",                 0, 0, 'y' }, // Output in two columns.
< -       { "speed-large-files",            0, 0, ' ' }, // Assume large files and many scattered small changes.
< -       { "starting-file",                1, 0, 'S' }, // Start with FILE when comparing directories.
< -       { "strip-trailing-cr",            0, 0, ' ' }, // Strip trailing carriage return on input.
< -       { "suppress-common-lines",        0, 0, ' ' }, // Do not output common lines.
< -       { "text",                         0, 0, 'a' }, // Treat all files as text.
< -       { "to-file",                      0, 0, ' ' }, // Compare all operands to FILE2.  FILE2 can be a directory.
< -       { "unidirectional-new-file",      0, 0, ' ' }, // Treat absent first files as empty.
< -       { "unified",                      2, 0, 'u' }, // Output NUM (default 3) lines of unified context.
< -       { "version",                      0, 0, 'v' }, // Output version info.
< -       { "width",                        1, 0, 'W' }, // Output at most NUM (default 130) print columns.
< -       { 0,				0, 0,   0 }
< -     };
< - 
< -     char const *short_options =
< -       "B"                       // Ignore changes whose lines are all blank.
< -       "C:"                      // Output NUM (default 3) lines of copied context.
< -       "D:"                      // Output merged file to show `#ifdef NAME' diffs.
< -       "E"                       // Ignore changes due to tab expansion.
< -       "F:"                      // Show the most recent line matching RE.
< -       "I:"                      // Ignore changes whose lines all match RE.
< -       "N"                       // Treat absent files as empty.
< -       "S:"                      // Start with FILE when comparing directories.
< -       "T"                       // Make tabs line up by prepending a tab.
< -       "U:"                      // Output NUM (default 3) lines of unified context.
< -       "W:"                      // Output at most NUM (default 130) print columns.
< -       "X:"                      // Exclude files that match any pattern in FILE.
< -       "a"                       // Treat all files as text.
< -       "b"                       // Ignore changes in the amount of white space.
< -       "c"                       // Output NUM (default 3) lines of copied context.
< -       "d"                       // Try hard to find a smaller set of changes.
< -       "e"                       // Output an ed script.
< -       "i"                       // Ignore case differences in file contents.
< -       "l"                       // Pass the output through `pr' to paginate it.
< -       "n"                       // Output an RCS format diff.
< -       "p"                       // Show which C function each change is in.
< -       "q"                       // Output only whether files differ.
< -       "r"                       // Recursively compare any subdirectories found.
< -       "s"                       // Report when two files are the same.
< -       "t"                       // Expand tabs to spaces in output.
< -       "u"                       // Output NUM (default 3) lines of unified context.
< -       "v"                       // Output version info.
< -       "w"                       // Ignore all white space.
< -       "x:"                      // Exclude files that match PAT.
< -       "y"                       // Output in two columns.
< -       ;
< - 
< -     int c =
< -       getopt_long
< -         (argc,
< -          const_cast<char *const *> (argv),
< -          short_options,
< -          long_options,
< -          &option_index
< -         );
< - 
< -     switch (c) {
< -     case -1:
< -       return;
< - 
< -     case 0:
< -       printf ("option %s", long_options[option_index].name);
< -       if (optarg)
< -         printf (" with arg %s", optarg);
< -       printf ("\n");
< -       break;
< -     case 'B':
< -       opt_B_IgnoreBlankLines = true;
< -       break;
< -     case 'C':
< -       {
< -         unsigned linesOfContext = 3;
< -         if (optarg) {
< -           if (sscanf (optarg, "%u", &linesOfContext) != 1) {
< -             fprintf (stderr, "-C <NUM> or --context[=<NUM>] (%d)\n", opt_C_LinesOfCopyContext);
< -             exit (1);
< -           }
< -         }
< -         opt_C_LinesOfCopyContext = linesOfContext;
< -       }
< -       break;
< -     case 'D':
< -       opt_D_IfdefName = optarg;
< -       break;
< -     case 'E':
< -       opt_E_IgnoreTabExpansionChanges = true;
< -       break;
< -     case 'F':
< -       opt_F_ShowMostRecentLineMatching = optarg;
< -       break;
< -     case 'I':
< -       opt_I_IgnoreLinesMatching = optarg;
< -       break;
< -     case 'N':
< -       opt_N_TreatAbsentFilesAsEmpty = true;
< -       break;
< -     case 'S':
< -       opt_S_StartWithFileMatching = optarg;
< -       break;
< -     case 'T':
< -       opt_T_PrependATab = true;
< -       break;
< -     case 'U':
< -       {
< -         unsigned linesOfContext = 3;
< -         if (optarg) {
< -           if (sscanf (optarg, "%u", &linesOfContext) != 1) {
< -             fprintf (stderr, "-U <NUM> or --unified[=<NUM>] (%d)\n", opt_U_LinesOfUnifiedContext);
< -             exit (1);
< -           }
< -         }
< -         opt_U_LinesOfUnifiedContext = linesOfContext;
< -       }
< -       break;
< -     case 'W':
< -       {
< -         unsigned maxPrintColumns = 130;
< -         if (optarg) {
< -           if (sscanf (optarg, "%u", &maxPrintColumns) != 1) {
< -             fprintf (stderr, "-W <NUM> or --width[=<NUM>] (%d)\n", opt_W_MaxPrintColumns);
< -             exit (1);
< -           }
< -         }
< -         opt_W_MaxPrintColumns = maxPrintColumns;
< -       }
< -       break;
< -     case 'X':
< -       opt_X_ExcludeFilesMatching = optarg;
< -       break;
< -     case 'a':
< -       opt_a_TreatAllFilesAsText = true;
< -       break;
< -     case 'b':
< -       opt_b_IgnoreWhitespaceChanges = true;
< -       break;
< -     case 'c':
< -       opt___OutputFormat = opt_c_Context;
< -       break;
< -     case 'd':
< -       opt_d_TryToFindMinimalChanges = true;
< -       break;
< -     case 'e':
< -       opt___OutputFormat = opt_e_EdScript;
< -       break;
< -     case 'i':
< -       opt_i_IgnoreCaseDifferences = true;
< -       break;
< -     case 'l':
< -       opt_l_PaginateWithPr = true;
< -       break;
< -     case 'n':
< -       opt___OutputFormat = opt_n_RCS;
< -       break;
< -     case 'p':
< -       opt_p_ShowChangedCFunction = true;
< -       break;
< -     case 'q':
< -       opt_q_OutputOnlyIfFilesDiffer = true;
< -       break;
< -     case 'r':
< -       opt_r_RecursivelyCompareSubdirectories = true;
< -       break;
< -     case 's':
< -       opt_s_ReportWhenFilesAreSame = true;
< -       break;
< -     case 't':
< -       opt_t_ExpandTabs = true;
< -       break;
< -     case 'u':
< -       opt___OutputFormat = opt_u_Unified;
< -       break;
< -     case 'v':
< -       opt_v_ShowVersionInfo = true;
< -       break;
< -     case 'w':
< -       opt_w_IgnoreAllWhitespace = true;
< -       break;
< -     case 'x':
< -       opt_x_IgnoreFilesMatching = optarg;
< -       break;
< -     case 'y':
< -       opt___OutputFormat = opt_y_SideBySide;
< -       break;
< -     case 'h':
< -     case '?':
< -       fprintf
< -         (stderr,
< -          "Usage: diff [OPTION]... FILES\n"
< -          "Compare files line by line.\n"
< -          "\n"
< -          "  --GTYPE-group-format=GFMT  Similar, but format GTYPE input groups with GFMT.\n"
< -          "  --LTYPE-line-format=LFMT  Similar, but format LTYPE input lines with LFMT.\n"
< -          "    LTYPE is `old', `new', or `unchanged'.  GTYPE is LTYPE or `changed'.\n"
< -          "    GFMT may contain:\n"
< -          "      %<  lines from FILE1\n"
< -          "      %>  lines from FILE2\n"
< -          "      %=  lines common to FILE1 and FILE2\n"
< -          "      %[-][WIDTH][.[PREC]]{doxX}LETTER  printf-style spec for LETTER\n"
< -          "        LETTERs are as follows for new group, lower case for old group:\n"
< -          "          F  first line number\n"
< -          "          L  last line number\n"
< -          "          N  number of lines = L-F+1\n"
< -          "          E  F-1\n"
< -          "          M  L+1\n"
< -          "    LFMT may contain:\n"
< -          "      %L  contents of line\n"
< -          "      %l  contents of line, excluding any trailing newline\n"
< -          "      %[-][WIDTH][.[PREC]]{doxX}n  printf-style spec for input line number\n"
< -          "    Either GFMT or LFMT may contain:\n"
< -          "      %%  %\n"
< -          "      %c'C'  the single character C\n"
< -          "      %c'\\OOO'  the character with octal code OOO\n"
< -          "\n"
< -          "  --brief  -q  Output only whether files differ.\n"
< -          "  --context[=NUM]  -c  -C NUM  Output NUM (default 3) lines of copied context.\n"
< -          "  --ed  -e  Output an ed script.\n"
< -          "  --exclude-from=FILE  -X FILE  Exclude files that match any pattern in FILE.\n"
< -          "  --exclude=PAT  -x PAT  Exclude files that match PAT.\n"
< -          "  --expand-tabs  -t  Expand tabs to spaces in output.\n"
< -          "  --from-file=FILE1  Compare FILE1 to all operands.  FILE1 can be a directory.\n"
< -          "  --help  Output this help.\n"
< -          "  --horizon-lines=NUM  Keep NUM lines of the common prefix and suffix.\n"
< -          "  --ifdef=NAME  -D NAME  Output merged file to show `#ifdef NAME' diffs.\n"
< -          "  --ignore-all-space  -w  Ignore all white space.\n"
< -          "  --ignore-blank-lines  -B  Ignore changes whose lines are all blank.\n"
< -          "  --ignore-case  -i  Ignore case differences in file contents.\n"
< -          "  --ignore-file-name-case  Ignore case when comparing file names.\n"
< -          "  --ignore-matching-lines=RE  -I RE  Ignore changes whose lines all match RE.\n"
< -          "  --ignore-space-change  -b  Ignore changes in the amount of white space.\n"
< -          "  --ignore-tab-expansion  -E  Ignore changes due to tab expansion.\n"
< -          "  --initial-tab  -T  Make tabs line up by prepending a tab.\n"
< -          "  --label LABEL  Use LABEL instead of file name.\n"
< -          "  --left-column  Output only the left column of common lines.\n"
< -          "  --line-format=LFMT  Similar, but format all input lines with LFMT.\n"
< -          "  --minimal  -d  Try hard to find a smaller set of changes.\n"
< -          "  --new-file  -N  Treat absent files as empty.\n"
< -          "  --no-ignore-file-name-case  Consider case when comparing file names.\n"
< -          "  --normal  Output a normal diff.\n"
< -          "  --paginate  -l  Pass the output through `pr' to paginate it.\n"
< -          "  --rcs  -n  Output an RCS format diff.\n"
< -          "  --recursive  -r  Recursively compare any subdirectories found.\n"
< -          "  --report-identical-files  -s  Report when two files are the same.\n"
< -          "  --show-c-function  -p  Show which C function each change is in.\n"
< -          "  --show-function-line=RE  -F RE  Show the most recent line matching RE.\n"
< -          "  --side-by-side  -y  Output in two columns.\n"
< -          "  --speed-large-files  Assume large files and many scattered small changes.\n"
< -          "  --starting-file=FILE  -S FILE  Start with FILE when comparing directories.\n"
< -          "  --strip-trailing-cr  Strip trailing carriage return on input.\n"
< -          "  --suppress-common-lines  Do not output common lines.\n"
< -          "  --text  -a  Treat all files as text.\n"
< -          "  --to-file=FILE2  Compare all operands to FILE2.  FILE2 can be a directory.\n"
< -          "  --unidirectional-new-file  Treat absent first files as empty.\n"
< -          "  --unified[=NUM]  -u  -U NUM  Output NUM (default 3) lines of unified context.\n"
< -          "  --version  -v  Output version info.\n"
< -          "  --width=NUM  -W NUM  Output at most NUM (default 130) print columns.\n"
< -          "\n"
< -          "FILES are `FILE1 FILE2' or `DIR1 DIR2' or `DIR FILE...' or `FILE... DIR'.\n"
< -          "If --from-file or --to-file is given, there are no restrictions on FILES.\n"
< -          "If a FILE is `-', read standard input.\n"
< -          "\n"
< -          "Report bugs to <bug-gnu-utils@gnu.org>.\n"
< -         );
< -       exit (1);
< -     default:
< -       fprintf (stderr, "Unhandled option (%c%s)!\n", c, optarg ? optarg : "");
< -       exit (1);
< -     }
< -   }
< - }
< - 
<   // Perform pass #1, in which we find all explicit matches amongst the
<   // unique lines.  For every unique line that appears the same number
<   // of times in both files, we declare the lines to match.
< --- 165,170 ----
< ***************
< *** 1105,1141 ****
<   
<   void pass6 ()
<   {
< !   switch (opt___OutputFormat) {
< !   case opt_c_Context:
<       pass6c ();
<       break;
<   
< !   case opt_e_EdScript:
<       pass6e ();
<       break;
<   
< !   case opt_D_IfThenElse:
<       pass6i ();
<       break;
<   
< !   case opt___Normal:
<       pass6n ();
<       break;
<   
< !   case opt_n_RCS:
<       pass6r ();
<       break;
<   
< !   case opt_y_SideBySide:
<       pass6y ();
<       break;
<   
< !   case opt_u_Unified:
<       pass6u ();
<       break;
<   
<     default:
< !     pass6n ();
<       break;
<     }
<   }
< --- 681,719 ----
<   
<   void pass6 ()
<   {
< ! 
< !   switch (diffFormat) {
< !   case Context:
<       pass6c ();
<       break;
<   
< !   case EdScript:
<       pass6e ();
<       break;
<   
< !   case IfThenElse:
<       pass6i ();
<       break;
<   
< !   case Normal:
<       pass6n ();
<       break;
<   
< !   case RCS:
<       pass6r ();
<       break;
<   
< !   case SideBySide:
<       pass6y ();
<       break;
<   
< !   case Unified:
<       pass6u ();
<       break;
<   
< +   case Default:
<     default:
< !     pass6c ();
<       break;
<     }
<   }
< ***************
< *** 1186,1195 ****
<       }
<   
<       // We're now looking at at least 1 delete or insert, so a window
< !     // begins here (or, rather, opt_C_LinesOfCopyContext lines earlier).
<       
< !     int boOldWindow = max (0, int (o) - int (opt_C_LinesOfCopyContext));
< !     int boNewWindow = max (0, int (n) - int (opt_C_LinesOfCopyContext));
<   
<       if (1 < optVerbose) {
<         fprintf (stderr, "boOldWindow = %d, boNewWindow = %d\n", boOldWindow, boNewWindow);
< --- 764,773 ----
<       }
<   
<       // We're now looking at at least 1 delete or insert, so a window
< !     // begins here (or, rather, optCopyContext lines earlier).
<       
< !     int boOldWindow = max (0, int (o) - int (optCopyContext));
< !     int boNewWindow = max (0, int (n) - int (optCopyContext));
<   
<       if (1 < optVerbose) {
<         fprintf (stderr, "boOldWindow = %d, boNewWindow = %d\n", boOldWindow, boNewWindow);
< ***************
< *** 1214,1224 ****
<           n += 1;
<         }
<   
< !       // This context will end opt_C_LinesOfCopyContext matched lines past the
<         // last set of deletes or inserts we find.
<   
<         widenWindow = false;
< !       for (unsigned l = 0; !widenWindow && l < opt_C_LinesOfCopyContext; l += 1) {
<           if (o < lines[0].size ()) {
<             widenWindow |= lines[0][o].l == ~0;
<             o += 1;
< --- 792,802 ----
<           n += 1;
<         }
<   
< !       // This context will end optCopyContext matched lines past the
<         // last set of deletes or inserts we find.
<   
<         widenWindow = false;
< !       for (unsigned l = 0; !widenWindow && l < optCopyContext; l += 1) {
<           if (o < lines[0].size ()) {
<             widenWindow |= lines[0][o].l == ~0;
<             o += 1;
< ***************
< *** 1233,1242 ****
<         eoNewWindow = n;
<   
<         // However, since another window could follow, we look
< !       // opt_C_LinesOfCopyContext ahead for another delete or insert.
<   
<         if (!widenWindow) {
< !         for (unsigned l = 0; l < (2 * opt_C_LinesOfCopyContext + 1); l += 1) {
<             if (o < lines[0].size ()) {
<               widenWindow |= lines[0][o].l == ~0;
<               o += 1;
< --- 811,820 ----
<         eoNewWindow = n;
<   
<         // However, since another window could follow, we look
< !       // optCopyContext ahead for another delete or insert.
<   
<         if (!widenWindow) {
< !         for (unsigned l = 0; l < (2 * optCopyContext + 1); l += 1) {
<             if (o < lines[0].size ()) {
<               widenWindow |= lines[0][o].l == ~0;
<               o += 1;
< ***************
< *** 1590,1596 ****
<   
<     // Starting at the top of both files,...
<   
< !   int columnWidth = (opt_W_MaxPrintColumns - 7) / 2;
<   
<     unsigned o = 0;
<     unsigned n = 0;
< --- 1168,1174 ----
<   
<     // Starting at the top of both files,...
<   
< !   int columnWidth = (optPageWidth - 7) / 2;
<   
<     unsigned o = 0;
<     unsigned n = 0;
---
> sdiff: sdiff.cpp:1363: void pass6c(): Assertion `widenWindow || lines[0][o].line == lines[1][n].line' failed.
> *** dif.8.cpp	0000-00-00 00:00:00.000000000 +0000
> --- dif.7.cpp	0000-00-00 00:00:00.000000000 +0000
# ../sdiff -u dif.0.cpp dif.1.cpp >& dif.0.1.diff-u.test
# dif.0.1.diff-u ---------------------------------------------------------------
1,2c1,2
< --- dif.0.cpp	2008-02-20 19:41:29.000000000 +0000
< +++ dif.1.cpp	2008-02-20 19:55:12.000000000 +0000
---
> --- dif.0.cpp	0000-00-00 00:00:00.000000000 +0000
> +++ dif.1.cpp	0000-00-00 00:00:00.000000000 +0000
# ../sdiff -u dif.1.cpp dif.0.cpp >& dif.1.0.diff-u.test
# dif.1.0.diff-u ---------------------------------------------------------------
1,2c1,2
< --- dif.1.cpp	2008-02-20 19:55:12.000000000 +0000
< +++ dif.0.cpp	2008-02-20 19:41:29.000000000 +0000
---
> --- dif.1.cpp	0000-00-00 00:00:00.000000000 +0000
> +++ dif.0.cpp	0000-00-00 00:00:00.000000000 +0000
# ../sdiff -u dif.1.cpp dif.2.cpp >& dif.1.2.diff-u.test
# dif.1.2.diff-u ---------------------------------------------------------------
1,3c1,3
< --- dif.1.cpp	2008-02-20 19:55:12.000000000 +0000
< +++ dif.2.cpp	2008-02-20 22:17:26.000000000 +0000
< @@ -1,29 +1,48 @@
---
> --- dif.1.cpp	0000-00-00 00:00:00.000000000 +0000
> +++ dif.2.cpp	0000-00-00 00:00:00.000000000 +0000
> @@ -1,46 +1,65 @@
13a14,17
> -int main (int argc, char *argv[])
> -{
> -  map<string, int> table;
> -  vector<vector<int *> *> fileLines;
22c26,30
< +
---
>  
> -  for (int a = 1; a < argc; a += 1) {
> -    if (FILE *f = fopen (argv[a], "r")) {
> -      fprintf (stderr, "# Reading %s...", argv[a]);
> -      vector<int *> *lines = new vector<int *> ();
25,29c33,35
< +
<  int main (int argc, char *argv[])
<  {
< -  map<string, int> table;
< -  vector<vector<int *> *> fileLines;
---
>  
> +int main (int argc, char *argv[])
> +{
32,33c38
<  
< -  for (int a = 1; a < argc; a += 1) {
---
> +
35,38c40,42
<      if (FILE *f = fopen (argv[a], "r")) {
<        fprintf (stderr, "# Reading %s...", argv[a]);
< -      vector<int *> *lines = new vector<int *> ();
<  
---
> +    if (FILE *f = fopen (argv[a], "r")) {
> +      fprintf (stderr, "# Reading %s...", argv[a]);
> +
61c65
< @@ -31,16 +50,16 @@
---
>    }
# ../sdiff -u dif.2.cpp dif.1.cpp >& dif.2.1.diff-u.test
./test: line 46: 23418 Aborted                 (core dumped) ${DIFF} "${option}" "${oSrc}" "${nSrc}" 1>&"${dst}.test"
# dif.2.1.diff-u ---------------------------------------------------------------
1,3c1,4
< --- dif.2.cpp	2008-02-20 22:17:26.000000000 +0000
< +++ dif.1.cpp	2008-02-20 19:55:12.000000000 +0000
< @@ -1,48 +1,29 @@
---
> sdiff: sdiff.cpp:1745: void pass6u(): Assertion `lines[0][o].line == lines[1][n].line' failed.
> --- dif.2.cpp	0000-00-00 00:00:00.000000000 +0000
> +++ dif.1.cpp	0000-00-00 00:00:00.000000000 +0000
> @@ -1,65 +1,46 @@
13,29c14,16
<  
< -struct Line : public string {
< -  Line (string _text) :
< -    text (_text)
< -  {
< -  }
< -  string text;
< -  list<unsigned> counts[2];
< -};
< -
< -typedef map<string, Line *> MapStringToLinePtr;
< -typedef vector<Line *> VectorLinePtr;
< -
<  int main (int argc, char *argv[])
<  {
< -  MapStringToLinePtr table;
< -  VectorLinePtr lines[2];
---
> +
> +int main (int argc, char *argv[])
> +{
32,33c19
<  
< -  for (int a = 1; a < argc && a <= 2; a += 1) {
---
> +
35,83d20
<      if (FILE *f = fopen (argv[a], "r")) {
<        fprintf (stderr, "# Reading %s...", argv[a]);
< +      vector<int *> *lines = new vector<int *> ();
<  
< -      VectorLinePtr *lines = new VectorLinePtr ();
<        char buffer[1024];
<        while (fgets (buffer, sizeof (buffer), f)) {
< -        string text (buffer);
< -
< -        Line *line = table[text];
< -
< -        if (!line) {
< -          table[text] = line = new Line (text);
< -        }
< -        line->counts[a - 1].push_back (lines[a - 1].size ());
< -        lines[a - 1].push_back (line);
< +        int *line = &table[buffer];
< +        lines->push_back (line);
< +        *line += 1;
<        }
< -      fprintf (stderr, " %u lines.\n", lines[a - 1]->size ());
< +      fprintf (stderr, " %u lines.\n", lines->size ());
< +      fileLines.push_back (lines);
<      } else {
<        fprintf (stderr, "%s: Unable to open %s!  Ignoring....\n", argv[a]);
<      }
< @@ -50,16 +31,16 @@
<    printf ("# table.size () = %d\n", table.size ());
<    map<int, int> counts;
<    for (map<string, int>::iterator i = table.begin (); i != table.end (); i++) {
< -    Line *l = i->second;
< -    counts[l->counts[0].size () + l->counts[1].size ()] += 1;
< +    counts[i->second] += 1;
<    }
<    for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
<      fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
<    }
< -  for (int f = 0; f < 2; f += 1) {
< -    fprintf (stderr, "# file #%d\n", f + 1);
< -    for (int l = 0; l < lines[f].size (); l += 1) {
< -      fprintf (stderr, "#   [%d] = %d\n", l, lines[f][l]->counts[f].size ());
< +  for (int f = 0; f < fileLines.size (); f += 1) {
< +    fprintf (stderr, "# file #%d\n", f);
< +    vector<int *> *lines = fileLines[f];
< +    for (int l = 0; l < lines->size (); l += 1) {
< +      fprintf (stderr, "#   [%d] = %d\n", l, *(*lines)[l]);
<      }
<    }
<  }
# ../sdiff -u dif.2.cpp dif.3.cpp >& dif.2.3.diff-u.test
# dif.2.3.diff-u ---------------------------------------------------------------
1,3c1,3
< --- dif.2.cpp	2008-02-20 22:17:26.000000000 +0000
< +++ dif.3.cpp	2008-02-22 21:42:10.000000000 +0000
< @@ -1,3 +1,5 @@
---
> --- dif.2.cpp	0000-00-00 00:00:00.000000000 +0000
> +++ dif.3.cpp	0000-00-00 00:00:00.000000000 +0000
> @@ -1,65 +1,747 @@
9c9,12
< @@ -8,29 +10,89 @@
---
>  using std::list;
>  #include <map>
>  using std::map;
>  #include <vector>
12a16,35
> -struct Line : public string {
> -  Line (string _text) :
> -    text (_text)
> -  {
> -  }
> -  string text;
> -  list<unsigned> counts[2];
> -};
> -
> -typedef map<string, Line *> MapStringToLinePtr;
> -typedef vector<Line *> VectorLinePtr;
> -
> -int main (int argc, char *argv[])
> -{
> -  MapStringToLinePtr table;
> -  VectorLinePtr lines[2];
> -
> -  for (int a = 1; a < argc && a <= 2; a += 1) {
> -    if (FILE *f = fopen (argv[a], "r")) {
> -      fprintf (stderr, "# Reading %s...", argv[a]);
15c38,55
< +
---
>  
> -      VectorLinePtr *lines = new VectorLinePtr ();
> -      char buffer[1024];
> -      while (fgets (buffer, sizeof (buffer), f)) {
> -        string text (buffer);
> -
> -        Line *line = table[text];
> -
> -        if (!line) {
> -          table[text] = line = new Line (text);
> -        }
> -        line->counts[a - 1].push_back (lines[a - 1].size ());
> -        lines[a - 1].push_back (line);
> -      }
> -      fprintf (stderr, " %u lines.\n", lines[a - 1]->size ());
> -    } else {
> -      fprintf (stderr, "%s: Unable to open %s!  Ignoring....\n", argv[a]);
> -    }
29,31c69,70
<  struct Line : public string {
<    Line (string _text) :
< -    text (_text)
---
> +struct Line : public string {
> +  Line (string _text) :
33,36c72,73
<    {
<    }
< -  string text;
< -  list<unsigned> counts[2];
---
> +  {
> +  }
40c77,90
< +  }
---
>    }
> -  printf ("# table.size () = %d\n", table.size ());
> -  map<int, int> counts;
> -  for (map<string, int>::iterator i = table.begin (); i != table.end (); i++) {
> -    Line *l = i->second;
> -    counts[l->counts[0].size () + l->counts[1].size ()] += 1;
> -  }
> -  for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
> -    fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
> -  }
> -  for (int f = 0; f < 2; f += 1) {
> -    fprintf (stderr, "# file #%d\n", f + 1);
> -    for (int l = 0; l < lines[f].size (); l += 1) {
> -      fprintf (stderr, "#   [%d] = %d\n", l, lines[f][l]->counts[f].size ());
49c99
< +    }
---
>      }
67,70c117,119
<  };
<  
<  typedef map<string, Line *> MapStringToLinePtr;
< -typedef vector<Line *> VectorLinePtr;
---
> +};
> +
> +typedef map<string, Line *> MapStringToLinePtr;
74,76c123,125
<  
<  int main (int argc, char *argv[])
<  {
---
> +
> +int main (int argc, char *argv[])
> +{
79,84c128,130
<    MapStringToLinePtr table;
<    VectorLinePtr lines[2];
<  
< -  for (int a = 1; a < argc && a <= 2; a += 1) {
< -    if (FILE *f = fopen (argv[a], "r")) {
< -      fprintf (stderr, "# Reading %s...", argv[a]);
---
> +  MapStringToLinePtr table;
> +  VectorLinePtr lines[2];
> +
99,101c145,146
<  
< -      VectorLinePtr *lines = new VectorLinePtr ();
<        char buffer[1024];
---
> +
> +      char buffer[1024];
104,110c149,155
<        while (fgets (buffer, sizeof (buffer), f)) {
<          string text (buffer);
<  
< @@ -38,28 +100,648 @@
<  
<          if (!line) {
<            table[text] = line = new Line (text);
---
> +      while (fgets (buffer, sizeof (buffer), f)) {
> +        string text (buffer);
> +
> +        Line *line = table[text];
> +
> +        if (!line) {
> +          table[text] = line = new Line (text);
112,114c157
<          }
< -        line->counts[a - 1].push_back (lines[a - 1].size ());
< -        lines[a - 1].push_back (line);
---
> +        }
121,124c164,165
<        }
< -      fprintf (stderr, " %u lines.\n", lines[a - 1]->size ());
<      } else {
< -      fprintf (stderr, "%s: Unable to open %s!  Ignoring....\n", argv[a]);
---
> +      }
> +    } else {
128,132c169,170
<      }
<    }
< -  printf ("# table.size () = %d\n", table.size ());
< -  map<int, int> counts;
< -  for (map<string, int>::iterator i = table.begin (); i != table.end (); i++) {
---
> +    }
> +  }
158,159c196
<      Line *l = i->second;
< -    counts[l->counts[0].size () + l->counts[1].size ()] += 1;
---
> +    Line *l = i->second;
298,300c335
<    }
< -  for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
< -    fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
---
> +  }
307,311c342
<    }
< -  for (int f = 0; f < 2; f += 1) {
< -    fprintf (stderr, "# file #%d\n", f + 1);
< -    for (int l = 0; l < lines[f].size (); l += 1) {
< -      fprintf (stderr, "#   [%d] = %d\n", l, lines[f][l]->counts[f].size ());
---
> +  }
765c796
<      }
---
> +    }
# ../sdiff -u dif.3.cpp dif.2.cpp >& dif.3.2.diff-u.test
./test: line 46: 23431 Aborted                 (core dumped) ${DIFF} "${option}" "${oSrc}" "${nSrc}" 1>&"${dst}.test"
# dif.3.2.diff-u ---------------------------------------------------------------
1,3c1,4
< --- dif.3.cpp	2008-02-22 21:42:10.000000000 +0000
< +++ dif.2.cpp	2008-02-20 22:17:26.000000000 +0000
< @@ -1,5 +1,3 @@
---
> sdiff: sdiff.cpp:1745: void pass6u(): Assertion `lines[0][o].line == lines[1][n].line' failed.
> --- dif.3.cpp	0000-00-00 00:00:00.000000000 +0000
> +++ dif.2.cpp	0000-00-00 00:00:00.000000000 +0000
> @@ -1,747 +1,65 @@
9c10,13
< @@ -10,89 +8,29 @@
---
>  using std::list;
>  #include <map>
>  using std::map;
>  #include <vector>
12,31c16,18
<  
< -enum DiffFormat {
< -  Default,
< -
< -  Context,
< -  EdScript,
< -  IfThenElse,
< -  Normal,
< -  RCS,
< -  SideBySide,
< -  Unified
< -};
< -
< -DiffFormat diffFormat = Unified;
< -
< -int optVerbose = 1;
< -
<  struct Line : public string {
<    Line (string _text) :
< -    string (_text)
---
> +
> +struct Line : public string {
> +  Line (string _text) :
33,769d19
<    {
<    }
< -  ~Line () {
< -    copies[0].erase (copies[0].begin (), copies[0].end ());
< -    copies[1].erase (copies[1].begin (), copies[1].end ());
< -  }
< -  void Dump (FILE *out) {
< -    fprintf (out, "{{ ");
< -    for (list<unsigned>::iterator i = copies[0].begin (); i != copies[0].end (); i++) {
< -      fprintf (out, "%u ", *i);
< -    }
< -    fprintf (out, "},{ ");
< -    for (list<unsigned>::iterator i = copies[1].begin (); i != copies[1].end (); i++) {
< -      fprintf (out, "%u ", *i);
< -    }
< -    fprintf (out, "}}\t%s", c_str ());
< -  }
< -  list<unsigned> copies[2];
< -};
< -
< -struct LinePtr {
< -  LinePtr (Line *_line) :
< -    line (_line),
< -    l (~0u)
< -  {
< -  }
< -  void Dump (FILE *out) {
< -    fprintf (out, "[%d] ", l);
< -    line->Dump (out);
< -  }
< -  Line *line;
< -  unsigned l;
< +  string text;
< +  list<unsigned> counts[2];
<  };
<  
<  typedef map<string, Line *> MapStringToLinePtr;
< -typedef vector<LinePtr> VectorLinePtr;
< -
< -char *ARGV0 = "dif2";
< +typedef vector<Line *> VectorLinePtr;
<  
<  int main (int argc, char *argv[])
<  {
< -  char const *files[2] = { 0, 0 };
< -
<    MapStringToLinePtr table;
<    VectorLinePtr lines[2];
<  
< -  unsigned nTotalMatchedBlocks = 0;
< -  unsigned nMatchedBlocks = 0;
< -  unsigned nTotalMatchedLines = 0;
< -  unsigned nMatchedLines = 0;
< -
< -  // Read the old [0] file, and the new [1] file.
< -
< -  for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
< -    files[n] = argv[a];
< -
< -    if (FILE *f = fopen (files[n], "r")) {
< -      if (0 < optVerbose) {
< -        fprintf (stderr, "# Reading %s...", files[n]);
< -      }
< +  for (int a = 1; a < argc && a <= 2; a += 1) {
< +    if (FILE *f = fopen (argv[a], "r")) {
< +      fprintf (stderr, "# Reading %s...", argv[a]);
<  
< +      VectorLinePtr *lines = new VectorLinePtr ();
<        char buffer[1024];
< -      unsigned nUniq = 0;
< -
<        while (fgets (buffer, sizeof (buffer), f)) {
<          string text (buffer);
<  
< @@ -100,648 +38,28 @@
<  
<          if (!line) {
<            table[text] = line = new Line (text);
< -          nUniq += 1;
<          }
< -        line->copies[n].push_back (lines[n].size ());
< -        lines[n].push_back (line);
< -      }
< -
< -      if (0 < optVerbose) {
< -        fprintf (stderr, " %u lines, %u unique.\n", lines[n].size (), nUniq);
< +        line->counts[a - 1].push_back (lines[a - 1].size ());
< +        lines[a - 1].push_back (line);
<        }
< +      fprintf (stderr, " %u lines.\n", lines[a - 1]->size ());
<      } else {
< -      fprintf (stderr, "%s: Unable to open %s!  Exiting....\n", ARGV0, files[n]);
< -      perror (ARGV0);
< -      exit (1);
< +      fprintf (stderr, "%s: Unable to open %s!  Ignoring....\n", argv[a]);
<      }
<    }
< -
< -  if (0 < optVerbose) {
< -    printf ("# Total unique lines = %d\n", table.size ());
< -  }
< -
< -  // map<int, int> counts;
< -  // for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
< -  //   Line *l = i->second;
< -  //   counts[l->counts[0].size () + l->counts[1].size ()] += 1;
< -  // }
< -  // for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
< -  //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
< -  // }
< -
< -  // Perform pass #1, in which we find all explicit matches amongst
< -  // the unique lines.  For every unique line that appears the same
< -  // number of times in both files, we declare the lines to match.
< -
< -  if (0 < optVerbose) {
< -    fprintf (stderr, "# Pass 1 (finding matches amongst unique lines)...");
< -  }
< -
< -  nMatchedLines = 0;
< -
< -  for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
< +  printf ("# table.size () = %d\n", table.size ());
< +  map<int, int> counts;
< +  for (map<string, int>::iterator i = table.begin (); i != table.end (); i++) {
<      Line *l = i->second;
< -
< -    // If the number of old and new lines match, then we declare that
< -    // they are (all) the same line.  Note, it isn't possible for the
< -    // numbers of both files to be 0.
< -
< -    // (In the original algorithm, we only recognized a match, here,
< -    // if there was exactly 1 copy for each file.)
< -
< -    if (l->copies[0].size () == l->copies[1].size ()) {
< -      nMatchedLines += 1;
< -
< -      // For each matched line in the new file, mark it with the
< -      // corresponding line (number) in the old file.
< -
< -      while (!l->copies[0].empty ()) {
< -        unsigned o = l->copies[0].front ();
< -        unsigned n = l->copies[1].front ();
< -
< -        // Match up the pair.
< -
< -        lines[0][o].l = n;
< -        lines[1][n].l = o;
< -
< -        // Remove the matched line numbers from the lists.
< -
< -        l->copies[0].pop_front ();
< -        l->copies[1].pop_front ();
< -      }
< -    }
< -  }
< -  nTotalMatchedLines += nMatchedLines;
< -
< -  // Let's see the intermediate results.
< -
< -  if (0 < optVerbose) {
< -    fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
< -
< -    if (1 < optVerbose) {
< -      for (int f = 0; f < 2; f += 1) {
< -        fprintf (stderr, "# file #%d\n", f + 1);
< -        for (int l = 0; l < lines[f].size (); l += 1) {
< -          fprintf (stderr, "#   [%d] ", l);
< -          lines[f][l].Dump (stderr);
< -        }
< -      }
< -    }
< -  }
< -
< -  // Perform Pass #2, in which we attempt to 'widen' blocks of matched
< -  // lines, by appending lines which are the same in both files.
< -
< -  if (0 < optVerbose) {
< -    fprintf (stderr, "# Pass #2 (spreading matches down)...");
< -  }
< -
< -  nMatchedBlocks = 0;
< -  nMatchedLines = 0;
< -
< -  // Starting at the top of the old file,...
< -
< -  for (unsigned o = 0; o < lines[0].size (); o += 1) {
< -
< -    // ... skip any currently unmatched lines...
< -
< -    if (lines[0][o].l == ~0) {
< -      continue;
< -    }
< -
< -    // ... until we find an [already] matched line.  Then, skip over
< -    // the set of 1 or more matched lines, until we reach any
< -    // following, still-unmatched line.
< -
< -    unsigned n;
< -    do {
< -      n = lines[0][o].l + 1;
< -      o += 1;
< -    } while (o < lines[0].size () && lines[0][o].l != ~0);
< -
< -    // Now, o - 1 is the line number of the last matched old line, and
< -    // n - 1 is the line number of the last matched new line.  We want
< -    // to add new old and new lines, if they match.
< -
< -    // Finally, attempt to add unmatched lines to the preceeding
< -    // matched set.
< -
< -    for (; o < lines[0].size () && lines[0][o].l == ~0; o += 1, n += 1) {
< -
< -      // If the [next] pair of old and new lines aren't the same line, we're done.
< -
< -      if (lines[0][o].line != lines[1][n].line) {
< -        break;
< -      }
< -
< -      // Match up the pair.
< -
< -      lines[0][o].l = n;
< -      lines[1][n].l = o;
< -
< -      // Remove the matched line numbers form the lists.
< -
< -      Line *line = lines[0][o].line;
< -      list<unsigned> &oldCopies = line->copies[0];
< -      list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
< -      if (oL != oldCopies.end ()) {
< -        oldCopies.erase (oL);
< -      }
< -      list<unsigned> &newCopies = line->copies[0];
< -      list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
< -      if (nL != newCopies.end ()) {
< -        newCopies.erase (nL);
< -      }
< -
< -      nMatchedLines += 1;
< -    }
< -    nMatchedBlocks += 1;
< -  }
< -  nTotalMatchedLines += nMatchedLines;
< -  nTotalMatchedBlocks += nMatchedBlocks;
< -
< -  // Let's see the intermediate results.
< -
< -  if (0 < optVerbose) {
< -    fprintf (stderr,
< -             " found %u/%u matched lines/blocks (%u/%u totals).\n",
< -             nMatchedLines,
< -             nMatchedBlocks,
< -             nTotalMatchedLines,
< -             nTotalMatchedBlocks
< -            );
< -    if (1 < optVerbose) {
< -      for (int f = 0; f < 2; f += 1) {
< -        fprintf (stderr, "# file #%d\n", f + 1);
< -        for (int l = 0; l < lines[f].size (); l += 1) {
< -          fprintf (stderr, "#   [%d] ", l);
< -          lines[f][l].Dump (stderr);
< -        }
< -      }
< -    }
< +    counts[l->counts[0].size () + l->counts[1].size ()] += 1;
<    }
< -
< -  // Perform Pass #3, in which we attempt to 'widen' blocks of matched
< -  // lines, by prepending lines which are the same in both files.
< -
< -  if (0 < optVerbose) {
< -    fprintf (stderr, "# Pass #3 (spreading matches up)...");
< +  for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
< +    fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
<    }
< -
< -  nMatchedBlocks = 0;
< -  nMatchedLines = 0;
< -
< -  // Starting at the bottom of the old file,...
< -
< -  for (int o = lines[0].size (); 0 <= o; o -= 1) {
< -
< -    // ... skip any currently unmatched lines...
< -
< -    if (lines[0][o].l == ~0) {
< -      continue;
< -    }
< -
< -    // ... until we find an [already] matched line.  Then, skip over
< -    // the set of 1 or more matched lines, until we reach any
< -    // following, still-unmatched line.
< -
< -    unsigned n;
< -    do {
< -      n = lines[0][o].l - 1;
< -      o -= 1;
< -    } while (0 <= o && lines[0][o].l != ~0);
< -
< -    // Now, o + 1 is the line number of the last matched old line, and
< -    // n + 1 is the line number of the last matched new line.  We want
< -    // to add new old and new lines, if they match.
< -
< -    // Finally, attempt to add unmatched lines to the preceeding
< -    // matched set.
< -
< -    for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
< -
< -      // If the [next] pair of old and new lines aren't the same line, we're done.
< -
< -      if (lines[0][o].line != lines[1][n].line) {
< -        break;
< -      }
< -
< -      // Match up the pair.
< -
< -      lines[0][o].l = n;
< -      lines[1][n].l = o;
< -
< -      // Remove the matched line numbers form the lists.
< -
< -      Line *line = lines[0][o].line;
< -      list<unsigned> &oldCopies = line->copies[0];
< -      list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
< -      if (oL != oldCopies.end ()) {
< -        oldCopies.erase (oL);
< -      }
< -      list<unsigned> &newCopies = line->copies[0];
< -      list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
< -      if (nL != newCopies.end ()) {
< -        newCopies.erase (nL);
< -      }
< -
< -      nMatchedLines += 1;
< -    }
< -    nMatchedBlocks += 1;
< -  }
< -  nTotalMatchedLines += nMatchedLines;
< -
< -  // Let's see the intermediate results.
< -
< -  if (0 < optVerbose) {
< -    fprintf (stderr,
< -             " found %u/%u matched lines/blocks (%u/%u totals).\n",
< -             nMatchedLines,
< -             nMatchedBlocks,
< -             nTotalMatchedLines,
< -             nTotalMatchedBlocks
< -            );
< -
< -    if (1 < optVerbose) {
< -      for (int f = 0; f < 2; f += 1) {
< -        fprintf (stderr, "# file #%d\n", f + 1);
< -        for (int l = 0; l < lines[f].size (); l += 1) {
< -          fprintf (stderr, "#   [%d] ", l);
< -          lines[f][l].Dump (stderr);
< -        }
< -      }
< -    }
< -  }
< -
< -  // Perform pass #4, in which we find any remaining matches amongst
< -  // the unique lines.  For every unique line that has more than 1
< -  // copy in both files, we declare the copies to match.
< -
< -  if (0 < optVerbose) {
< -    fprintf (stderr, "# Pass 4 (finding remaining matches amongst unique lines)...");
< -  }
< -
< -  nMatchedLines = 0;
< -
< -  for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
< -    Line *l = i->second;
< -
< -    // If there's more than 1 matching old and new lines, then we
< -    // declare that each pair are (all) the same line.
< -
< -    // (In the original algorithm, we only recognized a match, here,
< -    // if there was exactly 1 copy for each file.)
< -
< -    while (0 < l->copies[0].size () && 0 < l->copies[1].size ()) {
< -      nMatchedLines += 1;
< -
< -      // For each matched line in the new file, mark it with the
< -      // corresponding line (number) in the old file.
< -
< -      unsigned o = l->copies[0].front ();
< -      unsigned n = l->copies[1].front ();
< -
< -      // Match up the pair.
< -
< -      lines[0][o].l = n;
< -      lines[1][n].l = o;
< -
< -      // Remove the matched line numbers from the lists.
< -
< -      l->copies[0].pop_front ();
< -      l->copies[1].pop_front ();
< -    }
< -  }
< -  nTotalMatchedLines += nMatchedLines;
< -
< -  // Let's see the intermediate results.
< -
< -  if (0 < optVerbose) {
< -    fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
< -
< -    if (1 < optVerbose) {
< -      for (int f = 0; f < 2; f += 1) {
< -        fprintf (stderr, "# file #%d\n", f + 1);
< -        for (int l = 0; l < lines[f].size (); l += 1) {
< -          fprintf (stderr, "#   [%d] ", l);
< -          lines[f][l].Dump (stderr);
< -        }
< -      }
< -    }
< -  }
< -
< -  // Perform Pass #5, in which we look for blocks which match, but are
< -  // the result of a move (their not in their original position).  For
< -  // these, we'll unmatch the blocks, turning them into a delete and
< -  // an insert.
< -
< -  if (0 < optVerbose) {
< -    fprintf (stderr, "# Pass #5 (unmatching block moves)...\n");
< -  }
< -
< -  nMatchedBlocks = 0;
< -  nMatchedLines = 0;
< -
< -  // Starting at the top of both files,...
< -
< -  unsigned o = 0;
< -  unsigned n = 0;
< -
< -  while (o < lines[0].size () || n < lines[1].size ()) {
< -
< -    // Skip any unmatched lines at this point in the old file.  These
< -    // are deletes.
< -
< -    //    Old     New
< -    //   +---+
< -    // 0 | a |
< -    //   +---+   +---+
< -    //         0 | b |
< -    //   +---+   +---+
< -    // 1 | c | 1 | c |
< -    //   +---+   +---+
< -    //         2 | z |
< -    //   +---+   +---+
< -    // 2 | d | 3 | d |
< -    //   +---+   +---+
< -
< -    while (o < lines[0].size () && lines[0][o].l == ~0) {
< -      o += 1;
< -    }
< -
< -    // Skip any unmatched lines at this point in the new file.  These
< -    // are inserts.
< -
< -    while (n < lines[1].size () && lines[1][n].l == ~0) {
< -      n += 1;
< -    }
< -
< -    // When we get here, we know that we're dealing with matching
< -    // lines (or the end of one or both files).  We're done with this
< -    // pass, if we've reached the end of either file.
< -
< -    if (lines[0].size () <= o || lines[1].size () <= n) {
< -      break;
< -    }
< -
< -    // We now know that we've got a pair of matching lines, the start
< -    // of a matching block.  If the new file's line number is what we
< -    // expect, then the matched pair is unmoved, and we can skip over
< -    // the pair.  (If this is really the start of a block of more than
< -    // 1 lines, we'll handle it one pair at a time.)
< -
< -    if (lines[0][o].l == n) {
< -      o += 1;
< -      n += 1;
< -      continue;
< -    }
< -
< -    // If, on the other hand, we don't expect this [new] line number,
< -    // then this matching block has been moved.  We need to turn the
< -    // matched pair into an *unmatched* pair, one of deletes, and one
< -    // of inserts.  First, though, we need to know how big this block
< -    // is, and how far it was moved....
< -
< -    // Remember where we were when we started.
< -
< -    unsigned oOld = o;
< -    unsigned nOld = n;
< -
< -    // Remember where the block came from.
< -
< -    unsigned nNew = lines[0][o].l;
< -
< -    // Find the end of this matched pair.
< -
< -    for (n = nNew; o < lines[0].size () && n < lines[1].size (); o += 1, n += 1) {
< -      if (lines[0][o].l != n) {
< -        break;
< -      }
< -    }
< -
< -    // When we get here:
< -    // * oOld..o is the old file's block,
< -    // * nNew..n is the new file's *moved* block, and
< -    // * nOld is where we originally expected the new block from.
< - 
< -    // We can now calculate the length of the block...
< -    
< -    unsigned bSize = o - oOld;  // (or n - nNew)
< -
< -    // ... and we can calculate how far the block moved:
< -
< -    unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
< -
< -    // The larger of the two will become our delete, and the smaller
< -    // will become our insert.
< -
< -    //    Old     New
< -    //   +---+   +---+
< -    // 0 | a | 0 | b |
< -    //   +---+ 1 | b |
< -    // 1 | b |   +---+
< -    // 2 | b | 2 | a |
< -    //   +---+   +---+
< -    // 3 | c | 3 | c |
< -    //   +---+   +---+
< -
< -    // (1) Delete a@0, insert a@2, or
< -    // (2) insert bb@0, delete bb@1?
< -
< -    // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and bMove
< -    // (of a) is 2-0 or 2, the size of b@0.  We choose to delete a@0,
< -    // and reinsert a@2.
< -
< -    // if (bSize <= bMove) {
< -      for (unsigned a = oOld; a < o; a += 1) {
< -        lines[0][a].l = ~0;
< -      }
< -      for (unsigned d = nNew; d < n; d += 1) {
< -        lines[1][d].l = ~0;
< -      }
< -    // } else {
< -      // for (unsigned a = oOld; a < o; a += 1) {
< -      //   lines[0][a].l = ~0;
< -      // }
< -      // for (unsigned d = nNew; d < n; d += 1) {
< -      //   lines[1][d].l = ~0;
< -      // }
< -    // }
< -
< -    // Continue from where we left off.
< -
< -    n = nOld;
< -  }
< -  nTotalMatchedLines -= nMatchedLines;
< -  nTotalMatchedBlocks -= nMatchedBlocks;
< -
< -  // Let's see the intermediate results.
< -
< -  if (0 < optVerbose) {
< -    fprintf (stderr,
< -             " found %u/%u matched lines/blocks (%u/%u totals).\n",
< -             nMatchedLines,
< -             nMatchedBlocks,
< -             nTotalMatchedLines,
< -             nTotalMatchedBlocks
< -            );
< -
< -    if (1 < optVerbose) {
< -      for (int f = 0; f < 2; f += 1) {
< -        fprintf (stderr, "# file #%d\n", f + 1);
< -        for (int l = 0; l < lines[f].size (); l += 1) {
< -          fprintf (stderr, "#   [%d] ", l);
< -          lines[f][l].Dump (stderr);
< -        }
< -      }
< -    }
< -  }
< -
< -  // Perform Pass #6, in which we create the desired output.
< -
< -  if (0 < optVerbose) {
< -    fprintf (stderr, "# Pass #6 (walking the differences)...\n");
< -  }
< -
< -  nMatchedLines = 0;
< -
< -  // Write the header.
< -
< -  switch (diffFormat) {
< -  case Default:
< -  case Normal:
< -    break;
< -  case Unified:
< -    fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
< -    fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
< -    fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), lines[1].size ());
< -    break;
< -  }
< -
< -  // Starting at the top of both files,...
< -
< -  o = 0;
< -  n = 0;
< -
< -  while (o < lines[0].size () || n < lines[1].size ()) {
< -
< -    // Find any unmatched lines at this point in the old file.  These
< -    // are deletes.
< -
< -    unsigned boDeletes;
< -    for (boDeletes = o;
< -         o < lines[0].size () && lines[0][o].l == ~0;
< -         o += 1
< -        )
< -    {}
< -
< -    // Find any unmatched lines at this point in the new file.  These
< -    // are inserts.
< -
< -    unsigned boInserts;
< -    for (boInserts = n;
< -         n < lines[1].size () && lines[1][n].l == ~0;
< -         n += 1
< -        )
< -    {}
< -
< -    // We've got deleted line(s) from boDeletes .. o.
< -    // We've got deleted line(s) from boInserts .. n.
< -
< -    unsigned nDeletes = o - boDeletes;
< -    unsigned nInserts = n - boInserts;
< -
< -    // We've got...
< -
< -    if (nDeletes && nInserts) {
< -
< -      // ... deletes and inserts.
< -
< -      switch (diffFormat) {
< -      case Default:
< -      case Normal:
< -        if (1 < nDeletes && 1 < nInserts) {
< -          fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, boInserts + 1, n);
< -        } else if (1 < nDeletes) {
< -          fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boInserts + 1);
< -        } else if (1 < nInserts) {
< -          fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInserts + 1, n);
< -        } 
< -        for (unsigned l = boDeletes; l < o; l += 1) {
< -          fprintf (stdout, "< %s", lines[0][l].line->c_str ());
< -        }
< -        fprintf (stderr, "---\n");
< -        for (unsigned l = boInserts; l < n; l += 1) {
< -          fprintf (stdout, "> %s", lines[1][l].line->c_str ());
< -        }
< -        break;
< -
< -      case Unified:
< -        for (unsigned l = boDeletes; l < o; l += 1) {
< -          fprintf (stdout, "-%s", lines[0][l].line->c_str ());
< -        }
< -        for (unsigned l = boInserts; l < n; l += 1) {
< -          fprintf (stdout, "+%s", lines[1][l].line->c_str ());
< -        }
< -        break;
< -      }
< -    } else if (nDeletes) {
< -
< -      //  ... just deletes.
< -
< -      switch (diffFormat) {
< -      case Default:
< -      case Normal:
< -        if (1 < nDeletes) {
< -          fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
< -        } else {
< -          fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
< -        }
< -        for (unsigned l = boDeletes; l < o; l += 1) {
< -          fprintf (stdout, "< %s", lines[0][l].line->c_str ());
< -        }
< -        break;
< -      case Unified:
< -        for (unsigned l = boDeletes; l < o; l += 1) {
< -          fprintf (stdout, "-%s", lines[0][l].line->c_str ());
< -        }
< -        break;
< -      }
< -    } else if (nInserts) {
< -
< -      //  ... just inserts.
< -
< -      switch (diffFormat) {
< -      case Default:
< -      case Normal:
< -        if (1 < nInserts) {
< -          fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
< -        } else {
< -          fprintf (stdout, "%da%d\n", o, boInserts + 1);
< -        }
< -        for (unsigned l = boInserts; l < n; l += 1) {
< -          fprintf (stdout, "> %s", lines[1][l].line->c_str ());
< -        }
< -        break;
< -      case Unified:
< -        for (unsigned l = boInserts; l < n; l += 1) {
< -          fprintf (stdout, "+%s", lines[1][l].line->c_str ());
< -        }
< -        break;
< -      }
< -    }
< -
< -    // When we get here, we're dealing with matching lines.
< -
< -    switch (diffFormat) {
< -    case Default:
< -    case Normal:
< -      break;
< -    case Unified:
< -      fprintf (stdout, " %s", lines[0][o].line->c_str ());
< -      break;
< +  for (int f = 0; f < 2; f += 1) {
< +    fprintf (stderr, "# file #%d\n", f + 1);
< +    for (int l = 0; l < lines[f].size (); l += 1) {
< +      fprintf (stderr, "#   [%d] = %d\n", l, lines[f][l]->counts[f].size ());
<      }
< -    o += 1;
< -    n += 1;
<    }
<  }
# ../sdiff -u dif.3.cpp dif.4.cpp >& dif.3.4.diff-u.test
# dif.3.4.diff-u ---------------------------------------------------------------
0a1,750
> --- dif.3.cpp	0000-00-00 00:00:00.000000000 +0000
> +++ dif.4.cpp	0000-00-00 00:00:00.000000000 +0000
> @@ -1,747 +1,747 @@
>  #include <algorithm>
>  using std::find;
>  #include <string>
>  using std::string;
>  #include <list>
>  using std::list;
>  #include <map>
>  using std::map;
>  #include <vector>
>  using std::vector;
>  #include <stdio.h>
>  
>  enum DiffFormat {
>    Default,
>  
>    Context,
>    EdScript,
>    IfThenElse,
>    Normal,
>    RCS,
>    SideBySide,
>    Unified
>  };
>  
>  DiffFormat diffFormat = Unified;
>  
>  int optVerbose = 1;
>  
>  struct Line : public string {
>    Line (string _text) :
>      string (_text)
>    {
>    }
>    ~Line () {
>      copies[0].erase (copies[0].begin (), copies[0].end ());
>      copies[1].erase (copies[1].begin (), copies[1].end ());
>    }
>    void Dump (FILE *out) {
>      fprintf (out, "{{ ");
>      for (list<unsigned>::iterator i = copies[0].begin (); i != copies[0].end (); i++) {
>        fprintf (out, "%u ", *i);
>      }
>      fprintf (out, "},{ ");
>      for (list<unsigned>::iterator i = copies[1].begin (); i != copies[1].end (); i++) {
>        fprintf (out, "%u ", *i);
>      }
>      fprintf (out, "}}\t%s", c_str ());
>    }
>    list<unsigned> copies[2];
>  };
>  
>  struct LinePtr {
>    LinePtr (Line *_line) :
>      line (_line),
>      l (~0u)
>    {
>    }
>    void Dump (FILE *out) {
>      fprintf (out, "[%d] ", l);
>      line->Dump (out);
>    }
>    Line *line;
>    unsigned l;
>  };
>  
>  typedef map<string, Line *> MapStringToLinePtr;
>  typedef vector<LinePtr> VectorLinePtr;
>  
>  char *ARGV0 = "dif2";
>  
>  int main (int argc, char *argv[])
>  {
>    char const *files[2] = { 0, 0 };
>  
>    MapStringToLinePtr table;
>    VectorLinePtr lines[2];
>  
>    unsigned nTotalMatchedBlocks = 0;
>    unsigned nMatchedBlocks = 0;
>    unsigned nTotalMatchedLines = 0;
>    unsigned nMatchedLines = 0;
>  
>    // Read the old [0] file, and the new [1] file.
>  
>    for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
>      files[n] = argv[a];
>  
>      if (FILE *f = fopen (files[n], "r")) {
>        if (0 < optVerbose) {
>          fprintf (stderr, "# Reading %s...", files[n]);
>        }
>  
>        char buffer[1024];
>        unsigned nUniq = 0;
>  
>        while (fgets (buffer, sizeof (buffer), f)) {
>          string text (buffer);
>  
>          Line *line = table[text];
>  
>          if (!line) {
>            table[text] = line = new Line (text);
>            nUniq += 1;
>          }
>          line->copies[n].push_back (lines[n].size ());
>          lines[n].push_back (line);
>        }
>  
>        if (0 < optVerbose) {
>          fprintf (stderr, " %u lines, %u unique.\n", lines[n].size (), nUniq);
>        }
>      } else {
>        fprintf (stderr, "%s: Unable to open %s!  Exiting....\n", ARGV0, files[n]);
>        perror (ARGV0);
>        exit (1);
>      }
>    }
>  
>    if (0 < optVerbose) {
>      printf ("# Total unique lines = %d\n", table.size ());
>    }
>  
>    // map<int, int> counts;
>    // for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
>    //   Line *l = i->second;
>    //   counts[l->counts[0].size () + l->counts[1].size ()] += 1;
>    // }
>    // for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
>    //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
>    // }
>  
>    // Perform pass #1, in which we find all explicit matches amongst
>    // the unique lines.  For every unique line that appears the same
>    // number of times in both files, we declare the lines to match.
>  
>    if (0 < optVerbose) {
>      fprintf (stderr, "# Pass 1 (finding matches amongst unique lines)...");
>    }
>  
>    nMatchedLines = 0;
>  
>    for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
>      Line *l = i->second;
>  
>      // If the number of old and new lines match, then we declare that
>      // they are (all) the same line.  Note, it isn't possible for the
>      // numbers of both files to be 0.
>  
>      // (In the original algorithm, we only recognized a match, here,
>      // if there was exactly 1 copy for each file.)
>  
>      if (l->copies[0].size () == l->copies[1].size ()) {
>        nMatchedLines += 1;
>  
>        // For each matched line in the new file, mark it with the
>        // corresponding line (number) in the old file.
>  
>        while (!l->copies[0].empty ()) {
>          unsigned o = l->copies[0].front ();
>          unsigned n = l->copies[1].front ();
>  
>          // Match up the pair.
>  
>          lines[0][o].l = n;
>          lines[1][n].l = o;
>  
>          // Remove the matched line numbers from the lists.
>  
>          l->copies[0].pop_front ();
>          l->copies[1].pop_front ();
>        }
>      }
>    }
>    nTotalMatchedLines += nMatchedLines;
>  
>    // Let's see the intermediate results.
>  
>    if (0 < optVerbose) {
>      fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
>  
>      if (1 < optVerbose) {
>        for (int f = 0; f < 2; f += 1) {
>          fprintf (stderr, "# file #%d\n", f + 1);
>          for (int l = 0; l < lines[f].size (); l += 1) {
>            fprintf (stderr, "#   [%d] ", l);
>            lines[f][l].Dump (stderr);
>          }
>        }
>      }
>    }
>  
>    // Perform Pass #2, in which we attempt to 'widen' blocks of matched
>    // lines, by appending lines which are the same in both files.
>  
>    if (0 < optVerbose) {
>      fprintf (stderr, "# Pass #2 (spreading matches down)...");
>    }
>  
>    nMatchedBlocks = 0;
>    nMatchedLines = 0;
>  
>    // Starting at the top of the old file,...
>  
>    for (unsigned o = 0; o < lines[0].size (); o += 1) {
>  
>      // ... skip any currently unmatched lines...
>  
>      if (lines[0][o].l == ~0) {
>        continue;
>      }
>  
>      // ... until we find an [already] matched line.  Then, skip over
>      // the set of 1 or more matched lines, until we reach any
>      // following, still-unmatched line.
>  
>      unsigned n;
>      do {
>        n = lines[0][o].l + 1;
>        o += 1;
>      } while (o < lines[0].size () && lines[0][o].l != ~0);
>  
>      // Now, o - 1 is the line number of the last matched old line, and
>      // n - 1 is the line number of the last matched new line.  We want
>      // to add new old and new lines, if they match.
>  
>      // Finally, attempt to add unmatched lines to the preceeding
>      // matched set.
>  
>      for (; o < lines[0].size () && lines[0][o].l == ~0; o += 1, n += 1) {
>  
>        // If the [next] pair of old and new lines aren't the same line, we're done.
>  
>        if (lines[0][o].line != lines[1][n].line) {
>          break;
>        }
>  
>        // Match up the pair.
>  
>        lines[0][o].l = n;
>        lines[1][n].l = o;
>  
>        // Remove the matched line numbers form the lists.
>  
>        Line *line = lines[0][o].line;
>        list<unsigned> &oldCopies = line->copies[0];
>        list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
>        if (oL != oldCopies.end ()) {
>          oldCopies.erase (oL);
>        }
>        list<unsigned> &newCopies = line->copies[0];
>        list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
>        if (nL != newCopies.end ()) {
>          newCopies.erase (nL);
>        }
>  
>        nMatchedLines += 1;
>      }
>      nMatchedBlocks += 1;
>    }
>    nTotalMatchedLines += nMatchedLines;
>    nTotalMatchedBlocks += nMatchedBlocks;
>  
>    // Let's see the intermediate results.
>  
>    if (0 < optVerbose) {
>      fprintf (stderr,
>               " found %u/%u matched lines/blocks (%u/%u totals).\n",
>               nMatchedLines,
>               nMatchedBlocks,
>               nTotalMatchedLines,
>               nTotalMatchedBlocks
>              );
>      if (1 < optVerbose) {
>        for (int f = 0; f < 2; f += 1) {
>          fprintf (stderr, "# file #%d\n", f + 1);
>          for (int l = 0; l < lines[f].size (); l += 1) {
>            fprintf (stderr, "#   [%d] ", l);
>            lines[f][l].Dump (stderr);
>          }
>        }
>      }
>    }
>  
>    // Perform Pass #3, in which we attempt to 'widen' blocks of matched
>    // lines, by prepending lines which are the same in both files.
>  
>    if (0 < optVerbose) {
>      fprintf (stderr, "# Pass #3 (spreading matches up)...");
>    }
>  
>    nMatchedBlocks = 0;
>    nMatchedLines = 0;
>  
>    // Starting at the bottom of the old file,...
>  
>    for (int o = lines[0].size (); 0 <= o; o -= 1) {
>  
>      // ... skip any currently unmatched lines...
>  
>      if (lines[0][o].l == ~0) {
>        continue;
>      }
>  
>      // ... until we find an [already] matched line.  Then, skip over
>      // the set of 1 or more matched lines, until we reach any
>      // following, still-unmatched line.
>  
>      unsigned n;
>      do {
>        n = lines[0][o].l - 1;
>        o -= 1;
>      } while (0 <= o && lines[0][o].l != ~0);
>  
>      // Now, o + 1 is the line number of the last matched old line, and
>      // n + 1 is the line number of the last matched new line.  We want
>      // to add new old and new lines, if they match.
>  
>      // Finally, attempt to add unmatched lines to the preceeding
>      // matched set.
>  
>      for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
>  
>        // If the [next] pair of old and new lines aren't the same line, we're done.
>  
>        if (lines[0][o].line != lines[1][n].line) {
>          break;
>        }
>  
>        // Match up the pair.
>  
>        lines[0][o].l = n;
>        lines[1][n].l = o;
>  
>        // Remove the matched line numbers form the lists.
>  
>        Line *line = lines[0][o].line;
>        list<unsigned> &oldCopies = line->copies[0];
>        list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
>        if (oL != oldCopies.end ()) {
>          oldCopies.erase (oL);
>        }
>        list<unsigned> &newCopies = line->copies[0];
>        list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
>        if (nL != newCopies.end ()) {
>          newCopies.erase (nL);
>        }
>  
>        nMatchedLines += 1;
>      }
>      nMatchedBlocks += 1;
>    }
>    nTotalMatchedLines += nMatchedLines;
>  
>    // Let's see the intermediate results.
>  
>    if (0 < optVerbose) {
>      fprintf (stderr,
>               " found %u/%u matched lines/blocks (%u/%u totals).\n",
>               nMatchedLines,
>               nMatchedBlocks,
>               nTotalMatchedLines,
>               nTotalMatchedBlocks
>              );
>  
>      if (1 < optVerbose) {
>        for (int f = 0; f < 2; f += 1) {
>          fprintf (stderr, "# file #%d\n", f + 1);
>          for (int l = 0; l < lines[f].size (); l += 1) {
>            fprintf (stderr, "#   [%d] ", l);
>            lines[f][l].Dump (stderr);
>          }
>        }
>      }
>    }
>  
>    // Perform pass #4, in which we find any remaining matches amongst
>    // the unique lines.  For every unique line that has more than 1
>    // copy in both files, we declare the copies to match.
>  
>    if (0 < optVerbose) {
>      fprintf (stderr, "# Pass 4 (finding remaining matches amongst unique lines)...");
>    }
>  
>    nMatchedLines = 0;
>  
>    for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
>      Line *l = i->second;
>  
>      // If there's more than 1 matching old and new lines, then we
>      // declare that each pair are (all) the same line.
>  
>      // (In the original algorithm, we only recognized a match, here,
>      // if there was exactly 1 copy for each file.)
>  
>      while (0 < l->copies[0].size () && 0 < l->copies[1].size ()) {
>        nMatchedLines += 1;
>  
>        // For each matched line in the new file, mark it with the
>        // corresponding line (number) in the old file.
>  
>        unsigned o = l->copies[0].front ();
>        unsigned n = l->copies[1].front ();
>  
>        // Match up the pair.
>  
>        lines[0][o].l = n;
>        lines[1][n].l = o;
>  
>        // Remove the matched line numbers from the lists.
>  
>        l->copies[0].pop_front ();
>        l->copies[1].pop_front ();
>      }
>    }
>    nTotalMatchedLines += nMatchedLines;
>  
>    // Let's see the intermediate results.
>  
>    if (0 < optVerbose) {
>      fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
>  
>      if (1 < optVerbose) {
>        for (int f = 0; f < 2; f += 1) {
>          fprintf (stderr, "# file #%d\n", f + 1);
>          for (int l = 0; l < lines[f].size (); l += 1) {
>            fprintf (stderr, "#   [%d] ", l);
>            lines[f][l].Dump (stderr);
>          }
>        }
>      }
>    }
>  
>    // Perform Pass #5, in which we look for blocks which match, but are
>    // the result of a move (their not in their original position).  For
>    // these, we'll unmatch the blocks, turning them into a delete and
>    // an insert.
>  
>    if (0 < optVerbose) {
>      fprintf (stderr, "# Pass #5 (unmatching block moves)...\n");
>    }
>  
>    nMatchedBlocks = 0;
>    nMatchedLines = 0;
>  
>    // Starting at the top of both files,...
>  
>    unsigned o = 0;
>    unsigned n = 0;
>  
>    while (o < lines[0].size () || n < lines[1].size ()) {
>  
>      // Skip any unmatched lines at this point in the old file.  These
>      // are deletes.
>  
>      //    Old     New
>      //   +---+
>      // 0 | a |
>      //   +---+   +---+
>      //         0 | b |
>      //   +---+   +---+
>      // 1 | c | 1 | c |
>      //   +---+   +---+
>      //         2 | z |
>      //   +---+   +---+
>      // 2 | d | 3 | d |
>      //   +---+   +---+
>  
>      while (o < lines[0].size () && lines[0][o].l == ~0) {
>        o += 1;
>      }
>  
>      // Skip any unmatched lines at this point in the new file.  These
>      // are inserts.
>  
>      while (n < lines[1].size () && lines[1][n].l == ~0) {
>        n += 1;
>      }
>  
>      // When we get here, we know that we're dealing with matching
>      // lines (or the end of one or both files).  We're done with this
>      // pass, if we've reached the end of either file.
>  
>      if (lines[0].size () <= o || lines[1].size () <= n) {
>        break;
>      }
>  
>      // We now know that we've got a pair of matching lines, the start
>      // of a matching block.  If the new file's line number is what we
>      // expect, then the matched pair is unmoved, and we can skip over
>      // the pair.  (If this is really the start of a block of more than
>      // 1 lines, we'll handle it one pair at a time.)
>  
>      if (lines[0][o].l == n) {
>        o += 1;
>        n += 1;
>        continue;
>      }
>  
>      // If, on the other hand, we don't expect this [new] line number,
>      // then this matching block has been moved.  We need to turn the
>      // matched pair into an *unmatched* pair, one of deletes, and one
>      // of inserts.  First, though, we need to know how big this block
>      // is, and how far it was moved....
>  
>      // Remember where we were when we started.
>  
>      unsigned oOld = o;
>      unsigned nOld = n;
>  
>      // Remember where the block came from.
>  
>      unsigned nNew = lines[0][o].l;
>  
>      // Find the end of this matched pair.
>  
>      for (n = nNew; o < lines[0].size () && n < lines[1].size (); o += 1, n += 1) {
>        if (lines[0][o].l != n) {
>          break;
>        }
>      }
>  
>      // When we get here:
>      // * oOld..o is the old file's block,
>      // * nNew..n is the new file's *moved* block, and
>      // * nOld is where we originally expected the new block from.
>   
>      // We can now calculate the length of the block...
>      
>      unsigned bSize = o - oOld;  // (or n - nNew)
>  
>      // ... and we can calculate how far the block moved:
>  
>      unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
>  
>      // The larger of the two will become our delete, and the smaller
>      // will become our insert.
>  
>      //    Old     New
>      //   +---+   +---+
>      // 0 | a | 0 | b |
>      //   +---+ 1 | b |
>      // 1 | b |   +---+
>      // 2 | b | 2 | a |
>      //   +---+   +---+
>      // 3 | c | 3 | c |
>      //   +---+   +---+
>  
>      // (1) Delete a@0, insert a@2, or
>      // (2) insert bb@0, delete bb@1?
>  
>      // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and bMove
>      // (of a) is 2-0 or 2, the size of b@0.  We choose to delete a@0,
>      // and reinsert a@2.
>  
>      // if (bSize <= bMove) {
>        for (unsigned a = oOld; a < o; a += 1) {
>          lines[0][a].l = ~0;
>        }
>        for (unsigned d = nNew; d < n; d += 1) {
>          lines[1][d].l = ~0;
>        }
>      // } else {
>        // for (unsigned a = oOld; a < o; a += 1) {
>        //   lines[0][a].l = ~0;
>        // }
>        // for (unsigned d = nNew; d < n; d += 1) {
>        //   lines[1][d].l = ~0;
>        // }
>      // }
>  
>      // Continue from where we left off.
>  
>      n = nOld;
>    }
>    nTotalMatchedLines -= nMatchedLines;
>    nTotalMatchedBlocks -= nMatchedBlocks;
>  
>    // Let's see the intermediate results.
>  
>    if (0 < optVerbose) {
>      fprintf (stderr,
>               " found %u/%u matched lines/blocks (%u/%u totals).\n",
>               nMatchedLines,
>               nMatchedBlocks,
>               nTotalMatchedLines,
>               nTotalMatchedBlocks
>              );
>  
>      if (1 < optVerbose) {
>        for (int f = 0; f < 2; f += 1) {
>          fprintf (stderr, "# file #%d\n", f + 1);
>          for (int l = 0; l < lines[f].size (); l += 1) {
>            fprintf (stderr, "#   [%d] ", l);
>            lines[f][l].Dump (stderr);
>          }
>        }
>      }
>    }
>  
>    // Perform Pass #6, in which we create the desired output.
>  
>    if (0 < optVerbose) {
>      fprintf (stderr, "# Pass #6 (walking the differences)...\n");
>    }
>  
>    nMatchedLines = 0;
>  
>    // Write the header.
>  
>    switch (diffFormat) {
>    case Default:
>    case Normal:
>      break;
>    case Unified:
>      fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
>      fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
>      fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), lines[1].size ());
>      break;
>    }
>  
>    // Starting at the top of both files,...
>  
>    o = 0;
>    n = 0;
>  
>    while (o < lines[0].size () || n < lines[1].size ()) {
>  
>      // Find any unmatched lines at this point in the old file.  These
>      // are deletes.
>  
>      unsigned boDeletes;
>      for (boDeletes = o;
>           o < lines[0].size () && lines[0][o].l == ~0;
>           o += 1
>          )
>      {}
>  
>      // Find any unmatched lines at this point in the new file.  These
>      // are inserts.
>  
>      unsigned boInserts;
>      for (boInserts = n;
>           n < lines[1].size () && lines[1][n].l == ~0;
>           n += 1
>          )
>      {}
>  
>      // We've got deleted line(s) from boDeletes .. o.
>      // We've got deleted line(s) from boInserts .. n.
>  
>      unsigned nDeletes = o - boDeletes;
>      unsigned nInserts = n - boInserts;
>  
>      // We've got...
>  
>      if (nDeletes && nInserts) {
>  
>        // ... deletes and inserts.
>  
>        switch (diffFormat) {
>        case Default:
>        case Normal:
>          if (1 < nDeletes && 1 < nInserts) {
>            fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, boInserts + 1, n);
>          } else if (1 < nDeletes) {
>            fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boInserts + 1);
>          } else if (1 < nInserts) {
>            fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInserts + 1, n);
>          } 
>          for (unsigned l = boDeletes; l < o; l += 1) {
>            fprintf (stdout, "< %s", lines[0][l].line->c_str ());
>          }
>          fprintf (stderr, "---\n");
>          for (unsigned l = boInserts; l < n; l += 1) {
>            fprintf (stdout, "> %s", lines[1][l].line->c_str ());
>          }
>          break;
>  
>        case Unified:
>          for (unsigned l = boDeletes; l < o; l += 1) {
>            fprintf (stdout, "-%s", lines[0][l].line->c_str ());
>          }
>          for (unsigned l = boInserts; l < n; l += 1) {
>            fprintf (stdout, "+%s", lines[1][l].line->c_str ());
>          }
>          break;
>        }
>      } else if (nDeletes) {
>  
>        //  ... just deletes.
>  
>        switch (diffFormat) {
>        case Default:
>        case Normal:
>          if (1 < nDeletes) {
>            fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
>          } else {
>            fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
>          }
>          for (unsigned l = boDeletes; l < o; l += 1) {
>            fprintf (stdout, "< %s", lines[0][l].line->c_str ());
>          }
>          break;
>        case Unified:
>          for (unsigned l = boDeletes; l < o; l += 1) {
>            fprintf (stdout, "-%s", lines[0][l].line->c_str ());
>          }
>          break;
>        }
>      } else if (nInserts) {
>  
>        //  ... just inserts.
>  
>        switch (diffFormat) {
>        case Default:
>        case Normal:
>          if (1 < nInserts) {
>            fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
>          } else {
>            fprintf (stdout, "%da%d\n", o, boInserts + 1);
>          }
>          for (unsigned l = boInserts; l < n; l += 1) {
>            fprintf (stdout, "> %s", lines[1][l].line->c_str ());
>          }
>          break;
>        case Unified:
>          for (unsigned l = boInserts; l < n; l += 1) {
>            fprintf (stdout, "+%s", lines[1][l].line->c_str ());
>          }
>          break;
>        }
>      }
>  
>      // When we get here, we're dealing with matching lines.
>  
>      switch (diffFormat) {
>      case Default:
>      case Normal:
>        break;
>      case Unified:
>        fprintf (stdout, " %s", lines[0][o].line->c_str ());
>        break;
>      }
>      o += 1;
>      n += 1;
>    }
>  }
# ../sdiff -u dif.4.cpp dif.3.cpp >& dif.4.3.diff-u.test
# dif.4.3.diff-u ---------------------------------------------------------------
0a1,750
> --- dif.4.cpp	0000-00-00 00:00:00.000000000 +0000
> +++ dif.3.cpp	0000-00-00 00:00:00.000000000 +0000
> @@ -1,747 +1,747 @@
>  #include <algorithm>
>  using std::find;
>  #include <string>
>  using std::string;
>  #include <list>
>  using std::list;
>  #include <map>
>  using std::map;
>  #include <vector>
>  using std::vector;
>  #include <stdio.h>
>  
>  enum DiffFormat {
>    Default,
>  
>    Context,
>    EdScript,
>    IfThenElse,
>    Normal,
>    RCS,
>    SideBySide,
>    Unified
>  };
>  
>  DiffFormat diffFormat = Unified;
>  
>  int optVerbose = 1;
>  
>  struct Line : public string {
>    Line (string _text) :
>      string (_text)
>    {
>    }
>    ~Line () {
>      copies[0].erase (copies[0].begin (), copies[0].end ());
>      copies[1].erase (copies[1].begin (), copies[1].end ());
>    }
>    void Dump (FILE *out) {
>      fprintf (out, "{{ ");
>      for (list<unsigned>::iterator i = copies[0].begin (); i != copies[0].end (); i++) {
>        fprintf (out, "%u ", *i);
>      }
>      fprintf (out, "},{ ");
>      for (list<unsigned>::iterator i = copies[1].begin (); i != copies[1].end (); i++) {
>        fprintf (out, "%u ", *i);
>      }
>      fprintf (out, "}}\t%s", c_str ());
>    }
>    list<unsigned> copies[2];
>  };
>  
>  struct LinePtr {
>    LinePtr (Line *_line) :
>      line (_line),
>      l (~0u)
>    {
>    }
>    void Dump (FILE *out) {
>      fprintf (out, "[%d] ", l);
>      line->Dump (out);
>    }
>    Line *line;
>    unsigned l;
>  };
>  
>  typedef map<string, Line *> MapStringToLinePtr;
>  typedef vector<LinePtr> VectorLinePtr;
>  
>  char *ARGV0 = "dif2";
>  
>  int main (int argc, char *argv[])
>  {
>    char const *files[2] = { 0, 0 };
>  
>    MapStringToLinePtr table;
>    VectorLinePtr lines[2];
>  
>    unsigned nTotalMatchedBlocks = 0;
>    unsigned nMatchedBlocks = 0;
>    unsigned nTotalMatchedLines = 0;
>    unsigned nMatchedLines = 0;
>  
>    // Read the old [0] file, and the new [1] file.
>  
>    for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
>      files[n] = argv[a];
>  
>      if (FILE *f = fopen (files[n], "r")) {
>        if (0 < optVerbose) {
>          fprintf (stderr, "# Reading %s...", files[n]);
>        }
>  
>        char buffer[1024];
>        unsigned nUniq = 0;
>  
>        while (fgets (buffer, sizeof (buffer), f)) {
>          string text (buffer);
>  
>          Line *line = table[text];
>  
>          if (!line) {
>            table[text] = line = new Line (text);
>            nUniq += 1;
>          }
>          line->copies[n].push_back (lines[n].size ());
>          lines[n].push_back (line);
>        }
>  
>        if (0 < optVerbose) {
>          fprintf (stderr, " %u lines, %u unique.\n", lines[n].size (), nUniq);
>        }
>      } else {
>        fprintf (stderr, "%s: Unable to open %s!  Exiting....\n", ARGV0, files[n]);
>        perror (ARGV0);
>        exit (1);
>      }
>    }
>  
>    if (0 < optVerbose) {
>      printf ("# Total unique lines = %d\n", table.size ());
>    }
>  
>    // map<int, int> counts;
>    // for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
>    //   Line *l = i->second;
>    //   counts[l->counts[0].size () + l->counts[1].size ()] += 1;
>    // }
>    // for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
>    //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
>    // }
>  
>    // Perform pass #1, in which we find all explicit matches amongst
>    // the unique lines.  For every unique line that appears the same
>    // number of times in both files, we declare the lines to match.
>  
>    if (0 < optVerbose) {
>      fprintf (stderr, "# Pass 1 (finding matches amongst unique lines)...");
>    }
>  
>    nMatchedLines = 0;
>  
>    for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
>      Line *l = i->second;
>  
>      // If the number of old and new lines match, then we declare that
>      // they are (all) the same line.  Note, it isn't possible for the
>      // numbers of both files to be 0.
>  
>      // (In the original algorithm, we only recognized a match, here,
>      // if there was exactly 1 copy for each file.)
>  
>      if (l->copies[0].size () == l->copies[1].size ()) {
>        nMatchedLines += 1;
>  
>        // For each matched line in the new file, mark it with the
>        // corresponding line (number) in the old file.
>  
>        while (!l->copies[0].empty ()) {
>          unsigned o = l->copies[0].front ();
>          unsigned n = l->copies[1].front ();
>  
>          // Match up the pair.
>  
>          lines[0][o].l = n;
>          lines[1][n].l = o;
>  
>          // Remove the matched line numbers from the lists.
>  
>          l->copies[0].pop_front ();
>          l->copies[1].pop_front ();
>        }
>      }
>    }
>    nTotalMatchedLines += nMatchedLines;
>  
>    // Let's see the intermediate results.
>  
>    if (0 < optVerbose) {
>      fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
>  
>      if (1 < optVerbose) {
>        for (int f = 0; f < 2; f += 1) {
>          fprintf (stderr, "# file #%d\n", f + 1);
>          for (int l = 0; l < lines[f].size (); l += 1) {
>            fprintf (stderr, "#   [%d] ", l);
>            lines[f][l].Dump (stderr);
>          }
>        }
>      }
>    }
>  
>    // Perform Pass #2, in which we attempt to 'widen' blocks of matched
>    // lines, by appending lines which are the same in both files.
>  
>    if (0 < optVerbose) {
>      fprintf (stderr, "# Pass #2 (spreading matches down)...");
>    }
>  
>    nMatchedBlocks = 0;
>    nMatchedLines = 0;
>  
>    // Starting at the top of the old file,...
>  
>    for (unsigned o = 0; o < lines[0].size (); o += 1) {
>  
>      // ... skip any currently unmatched lines...
>  
>      if (lines[0][o].l == ~0) {
>        continue;
>      }
>  
>      // ... until we find an [already] matched line.  Then, skip over
>      // the set of 1 or more matched lines, until we reach any
>      // following, still-unmatched line.
>  
>      unsigned n;
>      do {
>        n = lines[0][o].l + 1;
>        o += 1;
>      } while (o < lines[0].size () && lines[0][o].l != ~0);
>  
>      // Now, o - 1 is the line number of the last matched old line, and
>      // n - 1 is the line number of the last matched new line.  We want
>      // to add new old and new lines, if they match.
>  
>      // Finally, attempt to add unmatched lines to the preceeding
>      // matched set.
>  
>      for (; o < lines[0].size () && lines[0][o].l == ~0; o += 1, n += 1) {
>  
>        // If the [next] pair of old and new lines aren't the same line, we're done.
>  
>        if (lines[0][o].line != lines[1][n].line) {
>          break;
>        }
>  
>        // Match up the pair.
>  
>        lines[0][o].l = n;
>        lines[1][n].l = o;
>  
>        // Remove the matched line numbers form the lists.
>  
>        Line *line = lines[0][o].line;
>        list<unsigned> &oldCopies = line->copies[0];
>        list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
>        if (oL != oldCopies.end ()) {
>          oldCopies.erase (oL);
>        }
>        list<unsigned> &newCopies = line->copies[0];
>        list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
>        if (nL != newCopies.end ()) {
>          newCopies.erase (nL);
>        }
>  
>        nMatchedLines += 1;
>      }
>      nMatchedBlocks += 1;
>    }
>    nTotalMatchedLines += nMatchedLines;
>    nTotalMatchedBlocks += nMatchedBlocks;
>  
>    // Let's see the intermediate results.
>  
>    if (0 < optVerbose) {
>      fprintf (stderr,
>               " found %u/%u matched lines/blocks (%u/%u totals).\n",
>               nMatchedLines,
>               nMatchedBlocks,
>               nTotalMatchedLines,
>               nTotalMatchedBlocks
>              );
>      if (1 < optVerbose) {
>        for (int f = 0; f < 2; f += 1) {
>          fprintf (stderr, "# file #%d\n", f + 1);
>          for (int l = 0; l < lines[f].size (); l += 1) {
>            fprintf (stderr, "#   [%d] ", l);
>            lines[f][l].Dump (stderr);
>          }
>        }
>      }
>    }
>  
>    // Perform Pass #3, in which we attempt to 'widen' blocks of matched
>    // lines, by prepending lines which are the same in both files.
>  
>    if (0 < optVerbose) {
>      fprintf (stderr, "# Pass #3 (spreading matches up)...");
>    }
>  
>    nMatchedBlocks = 0;
>    nMatchedLines = 0;
>  
>    // Starting at the bottom of the old file,...
>  
>    for (int o = lines[0].size (); 0 <= o; o -= 1) {
>  
>      // ... skip any currently unmatched lines...
>  
>      if (lines[0][o].l == ~0) {
>        continue;
>      }
>  
>      // ... until we find an [already] matched line.  Then, skip over
>      // the set of 1 or more matched lines, until we reach any
>      // following, still-unmatched line.
>  
>      unsigned n;
>      do {
>        n = lines[0][o].l - 1;
>        o -= 1;
>      } while (0 <= o && lines[0][o].l != ~0);
>  
>      // Now, o + 1 is the line number of the last matched old line, and
>      // n + 1 is the line number of the last matched new line.  We want
>      // to add new old and new lines, if they match.
>  
>      // Finally, attempt to add unmatched lines to the preceeding
>      // matched set.
>  
>      for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
>  
>        // If the [next] pair of old and new lines aren't the same line, we're done.
>  
>        if (lines[0][o].line != lines[1][n].line) {
>          break;
>        }
>  
>        // Match up the pair.
>  
>        lines[0][o].l = n;
>        lines[1][n].l = o;
>  
>        // Remove the matched line numbers form the lists.
>  
>        Line *line = lines[0][o].line;
>        list<unsigned> &oldCopies = line->copies[0];
>        list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
>        if (oL != oldCopies.end ()) {
>          oldCopies.erase (oL);
>        }
>        list<unsigned> &newCopies = line->copies[0];
>        list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
>        if (nL != newCopies.end ()) {
>          newCopies.erase (nL);
>        }
>  
>        nMatchedLines += 1;
>      }
>      nMatchedBlocks += 1;
>    }
>    nTotalMatchedLines += nMatchedLines;
>  
>    // Let's see the intermediate results.
>  
>    if (0 < optVerbose) {
>      fprintf (stderr,
>               " found %u/%u matched lines/blocks (%u/%u totals).\n",
>               nMatchedLines,
>               nMatchedBlocks,
>               nTotalMatchedLines,
>               nTotalMatchedBlocks
>              );
>  
>      if (1 < optVerbose) {
>        for (int f = 0; f < 2; f += 1) {
>          fprintf (stderr, "# file #%d\n", f + 1);
>          for (int l = 0; l < lines[f].size (); l += 1) {
>            fprintf (stderr, "#   [%d] ", l);
>            lines[f][l].Dump (stderr);
>          }
>        }
>      }
>    }
>  
>    // Perform pass #4, in which we find any remaining matches amongst
>    // the unique lines.  For every unique line that has more than 1
>    // copy in both files, we declare the copies to match.
>  
>    if (0 < optVerbose) {
>      fprintf (stderr, "# Pass 4 (finding remaining matches amongst unique lines)...");
>    }
>  
>    nMatchedLines = 0;
>  
>    for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
>      Line *l = i->second;
>  
>      // If there's more than 1 matching old and new lines, then we
>      // declare that each pair are (all) the same line.
>  
>      // (In the original algorithm, we only recognized a match, here,
>      // if there was exactly 1 copy for each file.)
>  
>      while (0 < l->copies[0].size () && 0 < l->copies[1].size ()) {
>        nMatchedLines += 1;
>  
>        // For each matched line in the new file, mark it with the
>        // corresponding line (number) in the old file.
>  
>        unsigned o = l->copies[0].front ();
>        unsigned n = l->copies[1].front ();
>  
>        // Match up the pair.
>  
>        lines[0][o].l = n;
>        lines[1][n].l = o;
>  
>        // Remove the matched line numbers from the lists.
>  
>        l->copies[0].pop_front ();
>        l->copies[1].pop_front ();
>      }
>    }
>    nTotalMatchedLines += nMatchedLines;
>  
>    // Let's see the intermediate results.
>  
>    if (0 < optVerbose) {
>      fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
>  
>      if (1 < optVerbose) {
>        for (int f = 0; f < 2; f += 1) {
>          fprintf (stderr, "# file #%d\n", f + 1);
>          for (int l = 0; l < lines[f].size (); l += 1) {
>            fprintf (stderr, "#   [%d] ", l);
>            lines[f][l].Dump (stderr);
>          }
>        }
>      }
>    }
>  
>    // Perform Pass #5, in which we look for blocks which match, but are
>    // the result of a move (their not in their original position).  For
>    // these, we'll unmatch the blocks, turning them into a delete and
>    // an insert.
>  
>    if (0 < optVerbose) {
>      fprintf (stderr, "# Pass #5 (unmatching block moves)...\n");
>    }
>  
>    nMatchedBlocks = 0;
>    nMatchedLines = 0;
>  
>    // Starting at the top of both files,...
>  
>    unsigned o = 0;
>    unsigned n = 0;
>  
>    while (o < lines[0].size () || n < lines[1].size ()) {
>  
>      // Skip any unmatched lines at this point in the old file.  These
>      // are deletes.
>  
>      //    Old     New
>      //   +---+
>      // 0 | a |
>      //   +---+   +---+
>      //         0 | b |
>      //   +---+   +---+
>      // 1 | c | 1 | c |
>      //   +---+   +---+
>      //         2 | z |
>      //   +---+   +---+
>      // 2 | d | 3 | d |
>      //   +---+   +---+
>  
>      while (o < lines[0].size () && lines[0][o].l == ~0) {
>        o += 1;
>      }
>  
>      // Skip any unmatched lines at this point in the new file.  These
>      // are inserts.
>  
>      while (n < lines[1].size () && lines[1][n].l == ~0) {
>        n += 1;
>      }
>  
>      // When we get here, we know that we're dealing with matching
>      // lines (or the end of one or both files).  We're done with this
>      // pass, if we've reached the end of either file.
>  
>      if (lines[0].size () <= o || lines[1].size () <= n) {
>        break;
>      }
>  
>      // We now know that we've got a pair of matching lines, the start
>      // of a matching block.  If the new file's line number is what we
>      // expect, then the matched pair is unmoved, and we can skip over
>      // the pair.  (If this is really the start of a block of more than
>      // 1 lines, we'll handle it one pair at a time.)
>  
>      if (lines[0][o].l == n) {
>        o += 1;
>        n += 1;
>        continue;
>      }
>  
>      // If, on the other hand, we don't expect this [new] line number,
>      // then this matching block has been moved.  We need to turn the
>      // matched pair into an *unmatched* pair, one of deletes, and one
>      // of inserts.  First, though, we need to know how big this block
>      // is, and how far it was moved....
>  
>      // Remember where we were when we started.
>  
>      unsigned oOld = o;
>      unsigned nOld = n;
>  
>      // Remember where the block came from.
>  
>      unsigned nNew = lines[0][o].l;
>  
>      // Find the end of this matched pair.
>  
>      for (n = nNew; o < lines[0].size () && n < lines[1].size (); o += 1, n += 1) {
>        if (lines[0][o].l != n) {
>          break;
>        }
>      }
>  
>      // When we get here:
>      // * oOld..o is the old file's block,
>      // * nNew..n is the new file's *moved* block, and
>      // * nOld is where we originally expected the new block from.
>   
>      // We can now calculate the length of the block...
>      
>      unsigned bSize = o - oOld;  // (or n - nNew)
>  
>      // ... and we can calculate how far the block moved:
>  
>      unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
>  
>      // The larger of the two will become our delete, and the smaller
>      // will become our insert.
>  
>      //    Old     New
>      //   +---+   +---+
>      // 0 | a | 0 | b |
>      //   +---+ 1 | b |
>      // 1 | b |   +---+
>      // 2 | b | 2 | a |
>      //   +---+   +---+
>      // 3 | c | 3 | c |
>      //   +---+   +---+
>  
>      // (1) Delete a@0, insert a@2, or
>      // (2) insert bb@0, delete bb@1?
>  
>      // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and bMove
>      // (of a) is 2-0 or 2, the size of b@0.  We choose to delete a@0,
>      // and reinsert a@2.
>  
>      // if (bSize <= bMove) {
>        for (unsigned a = oOld; a < o; a += 1) {
>          lines[0][a].l = ~0;
>        }
>        for (unsigned d = nNew; d < n; d += 1) {
>          lines[1][d].l = ~0;
>        }
>      // } else {
>        // for (unsigned a = oOld; a < o; a += 1) {
>        //   lines[0][a].l = ~0;
>        // }
>        // for (unsigned d = nNew; d < n; d += 1) {
>        //   lines[1][d].l = ~0;
>        // }
>      // }
>  
>      // Continue from where we left off.
>  
>      n = nOld;
>    }
>    nTotalMatchedLines -= nMatchedLines;
>    nTotalMatchedBlocks -= nMatchedBlocks;
>  
>    // Let's see the intermediate results.
>  
>    if (0 < optVerbose) {
>      fprintf (stderr,
>               " found %u/%u matched lines/blocks (%u/%u totals).\n",
>               nMatchedLines,
>               nMatchedBlocks,
>               nTotalMatchedLines,
>               nTotalMatchedBlocks
>              );
>  
>      if (1 < optVerbose) {
>        for (int f = 0; f < 2; f += 1) {
>          fprintf (stderr, "# file #%d\n", f + 1);
>          for (int l = 0; l < lines[f].size (); l += 1) {
>            fprintf (stderr, "#   [%d] ", l);
>            lines[f][l].Dump (stderr);
>          }
>        }
>      }
>    }
>  
>    // Perform Pass #6, in which we create the desired output.
>  
>    if (0 < optVerbose) {
>      fprintf (stderr, "# Pass #6 (walking the differences)...\n");
>    }
>  
>    nMatchedLines = 0;
>  
>    // Write the header.
>  
>    switch (diffFormat) {
>    case Default:
>    case Normal:
>      break;
>    case Unified:
>      fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
>      fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
>      fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), lines[1].size ());
>      break;
>    }
>  
>    // Starting at the top of both files,...
>  
>    o = 0;
>    n = 0;
>  
>    while (o < lines[0].size () || n < lines[1].size ()) {
>  
>      // Find any unmatched lines at this point in the old file.  These
>      // are deletes.
>  
>      unsigned boDeletes;
>      for (boDeletes = o;
>           o < lines[0].size () && lines[0][o].l == ~0;
>           o += 1
>          )
>      {}
>  
>      // Find any unmatched lines at this point in the new file.  These
>      // are inserts.
>  
>      unsigned boInserts;
>      for (boInserts = n;
>           n < lines[1].size () && lines[1][n].l == ~0;
>           n += 1
>          )
>      {}
>  
>      // We've got deleted line(s) from boDeletes .. o.
>      // We've got deleted line(s) from boInserts .. n.
>  
>      unsigned nDeletes = o - boDeletes;
>      unsigned nInserts = n - boInserts;
>  
>      // We've got...
>  
>      if (nDeletes && nInserts) {
>  
>        // ... deletes and inserts.
>  
>        switch (diffFormat) {
>        case Default:
>        case Normal:
>          if (1 < nDeletes && 1 < nInserts) {
>            fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, boInserts + 1, n);
>          } else if (1 < nDeletes) {
>            fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boInserts + 1);
>          } else if (1 < nInserts) {
>            fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInserts + 1, n);
>          } 
>          for (unsigned l = boDeletes; l < o; l += 1) {
>            fprintf (stdout, "< %s", lines[0][l].line->c_str ());
>          }
>          fprintf (stderr, "---\n");
>          for (unsigned l = boInserts; l < n; l += 1) {
>            fprintf (stdout, "> %s", lines[1][l].line->c_str ());
>          }
>          break;
>  
>        case Unified:
>          for (unsigned l = boDeletes; l < o; l += 1) {
>            fprintf (stdout, "-%s", lines[0][l].line->c_str ());
>          }
>          for (unsigned l = boInserts; l < n; l += 1) {
>            fprintf (stdout, "+%s", lines[1][l].line->c_str ());
>          }
>          break;
>        }
>      } else if (nDeletes) {
>  
>        //  ... just deletes.
>  
>        switch (diffFormat) {
>        case Default:
>        case Normal:
>          if (1 < nDeletes) {
>            fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
>          } else {
>            fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
>          }
>          for (unsigned l = boDeletes; l < o; l += 1) {
>            fprintf (stdout, "< %s", lines[0][l].line->c_str ());
>          }
>          break;
>        case Unified:
>          for (unsigned l = boDeletes; l < o; l += 1) {
>            fprintf (stdout, "-%s", lines[0][l].line->c_str ());
>          }
>          break;
>        }
>      } else if (nInserts) {
>  
>        //  ... just inserts.
>  
>        switch (diffFormat) {
>        case Default:
>        case Normal:
>          if (1 < nInserts) {
>            fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
>          } else {
>            fprintf (stdout, "%da%d\n", o, boInserts + 1);
>          }
>          for (unsigned l = boInserts; l < n; l += 1) {
>            fprintf (stdout, "> %s", lines[1][l].line->c_str ());
>          }
>          break;
>        case Unified:
>          for (unsigned l = boInserts; l < n; l += 1) {
>            fprintf (stdout, "+%s", lines[1][l].line->c_str ());
>          }
>          break;
>        }
>      }
>  
>      // When we get here, we're dealing with matching lines.
>  
>      switch (diffFormat) {
>      case Default:
>      case Normal:
>        break;
>      case Unified:
>        fprintf (stdout, " %s", lines[0][o].line->c_str ());
>        break;
>      }
>      o += 1;
>      n += 1;
>    }
>  }
# ../sdiff -u dif.4.cpp dif.5.cpp >& dif.4.5.diff-u.test
# dif.4.5.diff-u ---------------------------------------------------------------
1,3c1,24
< --- dif.4.cpp	2008-02-25 18:06:37.000000000 +0000
< +++ dif.5.cpp	2008-02-25 19:19:42.000000000 +0000
< @@ -22,7 +22,8 @@
---
> --- dif.4.cpp	0000-00-00 00:00:00.000000000 +0000
> +++ dif.5.cpp	0000-00-00 00:00:00.000000000 +0000
> @@ -1,747 +1,1011 @@
>  #include <algorithm>
>  using std::find;
>  #include <string>
>  using std::string;
>  #include <list>
>  using std::list;
>  #include <map>
>  using std::map;
>  #include <vector>
>  using std::vector;
>  #include <stdio.h>
>  
>  enum DiffFormat {
>    Default,
>  
>    Context,
>    EdScript,
>    IfThenElse,
>    Normal,
>    RCS,
>    SideBySide,
13c34,70
< @@ -66,20 +67,38 @@
---
>  struct Line : public string {
>    Line (string _text) :
>      string (_text)
>    {
>    }
>    ~Line () {
>      copies[0].erase (copies[0].begin (), copies[0].end ());
>      copies[1].erase (copies[1].begin (), copies[1].end ());
>    }
>    void Dump (FILE *out) {
>      fprintf (out, "{{ ");
>      for (list<unsigned>::iterator i = copies[0].begin (); i != copies[0].end (); i++) {
>        fprintf (out, "%u ", *i);
>      }
>      fprintf (out, "},{ ");
>      for (list<unsigned>::iterator i = copies[1].begin (); i != copies[1].end (); i++) {
>        fprintf (out, "%u ", *i);
>      }
>      fprintf (out, "}}\t%s", c_str ());
>    }
>    list<unsigned> copies[2];
>  };
>  
>  struct LinePtr {
>    LinePtr (Line *_line) :
>      line (_line),
>      l (~0u)
>    {
>    }
>    void Dump (FILE *out) {
>      fprintf (out, "[%d] ", l);
>      line->Dump (out);
>    }
>    Line *line;
>    unsigned l;
>  };
>  
18,19c75
< +// Our name.
<  
---
> -
22a79,82
> +// Our name.
>  
> -  MapStringToLinePtr table;
> -  VectorLinePtr lines[2];
24c84,88
< +
---
>  
> -  unsigned nTotalMatchedBlocks = 0;
> -  unsigned nMatchedBlocks = 0;
> -  unsigned nTotalMatchedLines = 0;
> -  unsigned nMatchedLines = 0;
26c90,142
< +
---
>  
> -  // Read the old [0] file, and the new [1] file.
> -
> -  for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
> -    files[n] = argv[a];
> -
> -    if (FILE *f = fopen (files[n], "r")) {
> -      if (0 < optVerbose) {
> -        fprintf (stderr, "# Reading %s...", files[n]);
> -      }
> -
> -      char buffer[1024];
> -      unsigned nUniq = 0;
> -
> -      while (fgets (buffer, sizeof (buffer), f)) {
> -        string text (buffer);
> -
> -        Line *line = table[text];
> -
> -        if (!line) {
> -          table[text] = line = new Line (text);
> -          nUniq += 1;
> -        }
> -        line->copies[n].push_back (lines[n].size ());
> -        lines[n].push_back (line);
> -      }
> -
> -      if (0 < optVerbose) {
> -        fprintf (stderr, " %u lines, %u unique.\n", lines[n].size (), nUniq);
> -      }
> -    } else {
> -      fprintf (stderr, "%s: Unable to open %s!  Exiting....\n", ARGV0, files[n]);
> -      perror (ARGV0);
> -      exit (1);
> -    }
> -  }
> -
> -  if (0 < optVerbose) {
> -    printf ("# Total unique lines = %d\n", table.size ());
> -  }
> -
> -  // map<int, int> counts;
> -  // for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> -  //   Line *l = i->second;
> -  //   counts[l->counts[0].size () + l->counts[1].size ()] += 1;
> -  // }
> -  // for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
> -  //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
> -  // }
> -
> -  // Perform pass #1, in which we find all explicit matches amongst
> -  // the unique lines.  For every unique line that appears the same
> -  // number of times in both files, we declare the lines to match.
28c144,199
< +
---
>  
> -  if (0 < optVerbose) {
> -    fprintf (stderr, "# Pass 1 (finding matches amongst unique lines)...");
> -  }
> -
> -  nMatchedLines = 0;
> -
> -  for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> -    Line *l = i->second;
> -
> -    // If the number of old and new lines match, then we declare that
> -    // they are (all) the same line.  Note, it isn't possible for the
> -    // numbers of both files to be 0.
> -
> -    // (In the original algorithm, we only recognized a match, here,
> -    // if there was exactly 1 copy for each file.)
> -
> -    if (l->copies[0].size () == l->copies[1].size ()) {
> -      nMatchedLines += 1;
> -
> -      // For each matched line in the new file, mark it with the
> -      // corresponding line (number) in the old file.
> -
> -      while (!l->copies[0].empty ()) {
> -        unsigned o = l->copies[0].front ();
> -        unsigned n = l->copies[1].front ();
> -
> -        // Match up the pair.
> -
> -        lines[0][o].l = n;
> -        lines[1][n].l = o;
> -
> -        // Remove the matched line numbers from the lists.
> -
> -        l->copies[0].pop_front ();
> -        l->copies[1].pop_front ();
> -      }
> -    }
> -  }
> -  nTotalMatchedLines += nMatchedLines;
> -
> -  // Let's see the intermediate results.
> -
> -  if (0 < optVerbose) {
> -    fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
> -
> -    if (1 < optVerbose) {
> -      for (int f = 0; f < 2; f += 1) {
> -        fprintf (stderr, "# file #%d\n", f + 1);
> -        for (int l = 0; l < lines[f].size (); l += 1) {
> -          fprintf (stderr, "#   [%d] ", l);
> -          lines[f][l].Dump (stderr);
> -        }
> -      }
> -    }
> -  }
30c201,203
< +
---
>  
> -  // Perform Pass #2, in which we attempt to 'widen' blocks of matched
> -  // lines, by appending lines which are the same in both files.
32c205,293
< +
---
>  
> -  if (0 < optVerbose) {
> -    fprintf (stderr, "# Pass #2 (spreading matches down)...");
> -  }
> -
> -  nMatchedBlocks = 0;
> -  nMatchedLines = 0;
> -
> -  // Starting at the top of the old file,...
> -
> -  for (unsigned o = 0; o < lines[0].size (); o += 1) {
> -
> -    // ... skip any currently unmatched lines...
> -
> -    if (lines[0][o].l == ~0) {
> -      continue;
> -    }
> -
> -    // ... until we find an [already] matched line.  Then, skip over
> -    // the set of 1 or more matched lines, until we reach any
> -    // following, still-unmatched line.
> -
> -    unsigned n;
> -    do {
> -      n = lines[0][o].l + 1;
> -      o += 1;
> -    } while (o < lines[0].size () && lines[0][o].l != ~0);
> -
> -    // Now, o - 1 is the line number of the last matched old line, and
> -    // n - 1 is the line number of the last matched new line.  We want
> -    // to add new old and new lines, if they match.
> -
> -    // Finally, attempt to add unmatched lines to the preceeding
> -    // matched set.
> -
> -    for (; o < lines[0].size () && lines[0][o].l == ~0; o += 1, n += 1) {
> -
> -      // If the [next] pair of old and new lines aren't the same line, we're done.
> -
> -      if (lines[0][o].line != lines[1][n].line) {
> -        break;
> -      }
> -
> -      // Match up the pair.
> -
> -      lines[0][o].l = n;
> -      lines[1][n].l = o;
> -
> -      // Remove the matched line numbers form the lists.
> -
> -      Line *line = lines[0][o].line;
> -      list<unsigned> &oldCopies = line->copies[0];
> -      list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
> -      if (oL != oldCopies.end ()) {
> -        oldCopies.erase (oL);
> -      }
> -      list<unsigned> &newCopies = line->copies[0];
> -      list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
> -      if (nL != newCopies.end ()) {
> -        newCopies.erase (nL);
> -      }
> -
> -      nMatchedLines += 1;
> -    }
> -    nMatchedBlocks += 1;
> -  }
> -  nTotalMatchedLines += nMatchedLines;
> -  nTotalMatchedBlocks += nMatchedBlocks;
> -
> -  // Let's see the intermediate results.
> -
> -  if (0 < optVerbose) {
> -    fprintf (stderr,
> -             " found %u/%u matched lines/blocks (%u/%u totals).\n",
> -             nMatchedLines,
> -             nMatchedBlocks,
> -             nTotalMatchedLines,
> -             nTotalMatchedBlocks
> -            );
> -    if (1 < optVerbose) {
> -      for (int f = 0; f < 2; f += 1) {
> -        fprintf (stderr, "# file #%d\n", f + 1);
> -        for (int l = 0; l < lines[f].size (); l += 1) {
> -          fprintf (stderr, "#   [%d] ", l);
> -          lines[f][l].Dump (stderr);
> -        }
> -      }
> -    }
> -  }
34c295,297
< +
---
>  
> -  // Perform Pass #3, in which we attempt to 'widen' blocks of matched
> -  // lines, by prepending lines which are the same in both files.
37,38c300,387
< -  MapStringToLinePtr table;
< -  VectorLinePtr lines[2];
---
> -  if (0 < optVerbose) {
> -    fprintf (stderr, "# Pass #3 (spreading matches up)...");
> -  }
> -
> -  nMatchedBlocks = 0;
> -  nMatchedLines = 0;
> -
> -  // Starting at the bottom of the old file,...
> -
> -  for (int o = lines[0].size (); 0 <= o; o -= 1) {
> -
> -    // ... skip any currently unmatched lines...
> -
> -    if (lines[0][o].l == ~0) {
> -      continue;
> -    }
> -
> -    // ... until we find an [already] matched line.  Then, skip over
> -    // the set of 1 or more matched lines, until we reach any
> -    // following, still-unmatched line.
> -
> -    unsigned n;
> -    do {
> -      n = lines[0][o].l - 1;
> -      o -= 1;
> -    } while (0 <= o && lines[0][o].l != ~0);
> -
> -    // Now, o + 1 is the line number of the last matched old line, and
> -    // n + 1 is the line number of the last matched new line.  We want
> -    // to add new old and new lines, if they match.
> -
> -    // Finally, attempt to add unmatched lines to the preceeding
> -    // matched set.
> -
> -    for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
> -
> -      // If the [next] pair of old and new lines aren't the same line, we're done.
> -
> -      if (lines[0][o].line != lines[1][n].line) {
> -        break;
> -      }
> -
> -      // Match up the pair.
> -
> -      lines[0][o].l = n;
> -      lines[1][n].l = o;
> -
> -      // Remove the matched line numbers form the lists.
> -
> -      Line *line = lines[0][o].line;
> -      list<unsigned> &oldCopies = line->copies[0];
> -      list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
> -      if (oL != oldCopies.end ()) {
> -        oldCopies.erase (oL);
> -      }
> -      list<unsigned> &newCopies = line->copies[0];
> -      list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
> -      if (nL != newCopies.end ()) {
> -        newCopies.erase (nL);
> -      }
> -
> -      nMatchedLines += 1;
> -    }
> -    nMatchedBlocks += 1;
> -  }
> -  nTotalMatchedLines += nMatchedLines;
> -
> -  // Let's see the intermediate results.
> -
> -  if (0 < optVerbose) {
> -    fprintf (stderr,
> -             " found %u/%u matched lines/blocks (%u/%u totals).\n",
> -             nMatchedLines,
> -             nMatchedBlocks,
> -             nTotalMatchedLines,
> -             nTotalMatchedBlocks
> -            );
> -
> -    if (1 < optVerbose) {
> -      for (int f = 0; f < 2; f += 1) {
> -        fprintf (stderr, "# file #%d\n", f + 1);
> -        for (int l = 0; l < lines[f].size (); l += 1) {
> -          fprintf (stderr, "#   [%d] ", l);
> -          lines[f][l].Dump (stderr);
> -        }
> -      }
> -    }
> -  }
41,44c390,392
< -  unsigned nTotalMatchedBlocks = 0;
< -  unsigned nMatchedBlocks = 0;
< -  unsigned nTotalMatchedLines = 0;
< -  unsigned nMatchedLines = 0;
---
> -  // Perform pass #4, in which we find any remaining matches amongst
> -  // the unique lines.  For every unique line that has more than 1
> -  // copy in both files, we declare the copies to match.
49a398,449
> -  if (0 < optVerbose) {
> -    fprintf (stderr, "# Pass 4 (finding remaining matches amongst unique lines)...");
> -  }
> -
> -  nMatchedLines = 0;
> -
> -  for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> -    Line *l = i->second;
> -
> -    // If there's more than 1 matching old and new lines, then we
> -    // declare that each pair are (all) the same line.
> -
> -    // (In the original algorithm, we only recognized a match, here,
> -    // if there was exactly 1 copy for each file.)
> -
> -    while (0 < l->copies[0].size () && 0 < l->copies[1].size ()) {
> -      nMatchedLines += 1;
> -
> -      // For each matched line in the new file, mark it with the
> -      // corresponding line (number) in the old file.
> -
> -      unsigned o = l->copies[0].front ();
> -      unsigned n = l->copies[1].front ();
> -
> -      // Match up the pair.
> -
> -      lines[0][o].l = n;
> -      lines[1][n].l = o;
> -
> -      // Remove the matched line numbers from the lists.
> -
> -      l->copies[0].pop_front ();
> -      l->copies[1].pop_front ();
> -    }
> -  }
> -  nTotalMatchedLines += nMatchedLines;
> -
> -  // Let's see the intermediate results.
> -
> -  if (0 < optVerbose) {
> -    fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
> -
> -    if (1 < optVerbose) {
> -      for (int f = 0; f < 2; f += 1) {
> -        fprintf (stderr, "# file #%d\n", f + 1);
> -        for (int l = 0; l < lines[f].size (); l += 1) {
> -          fprintf (stderr, "#   [%d] ", l);
> -          lines[f][l].Dump (stderr);
> -        }
> -      }
> -    }
> -  }
59,66c459,495
<    // Read the old [0] file, and the new [1] file.
<  
<    for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
< @@ -117,7 +136,7 @@
<    }
<  
<    if (0 < optVerbose) {
< -    printf ("# Total unique lines = %d\n", table.size ());
---
> +  // Read the old [0] file, and the new [1] file.
> +
> +  for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
> +    files[n] = argv[a];
> +
> +    if (FILE *f = fopen (files[n], "r")) {
> +      if (0 < optVerbose) {
> +        fprintf (stderr, "# Reading %s...", files[n]);
> +      }
> +
> +      char buffer[1024];
> +      unsigned nUniq = 0;
> +
> +      while (fgets (buffer, sizeof (buffer), f)) {
> +        string text (buffer);
> +
> +        Line *line = table[text];
> +
> +        if (!line) {
> +          table[text] = line = new Line (text);
> +          nUniq += 1;
> +        }
> +        line->copies[n].push_back (lines[n].size ());
> +        lines[n].push_back (line);
> +      }
> +
> +      if (0 < optVerbose) {
> +        fprintf (stderr, " %u lines, %u unique.\n", lines[n].size (), nUniq);
> +      }
> +    } else {
> +      fprintf (stderr, "%s: Unable to open %s!  Exiting....\n", ARGV0, files[n]);
> +      perror (ARGV0);
> +      exit (1);
> +    }
> +  }
> +
> +  if (0 < optVerbose) {
68,77c497,507
<    }
<  
<    // map<int, int> counts;
< @@ -129,10 +148,22 @@
<    //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
<    // }
<  
< -  // Perform pass #1, in which we find all explicit matches amongst
< -  // the unique lines.  For every unique line that appears the same
< -  // number of times in both files, we declare the lines to match.
---
> +  }
> +
> +  // map<int, int> counts;
> +  // for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> +  //   Line *l = i->second;
> +  //   counts[l->counts[0].size () + l->counts[1].size ()] += 1;
> +  // }
> +  // for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
> +  //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
> +  // }
> +
84a515,518
> -  // Perform Pass #5, in which we look for blocks which match, but are
> -  // the result of a move (their not in their original position).  For
> -  // these, we'll unmatch the blocks, turning them into a delete and
> -  // an insert.
87c521,682
< +
---
>  
> -  if (0 < optVerbose) {
> -    fprintf (stderr, "# Pass #5 (unmatching block moves)...\n");
> -  }
> -
> -  nMatchedBlocks = 0;
> -  nMatchedLines = 0;
> -
> -  // Starting at the top of both files,...
> -
> -  unsigned o = 0;
> -  unsigned n = 0;
> -
> -  while (o < lines[0].size () || n < lines[1].size ()) {
> -
> -    // Skip any unmatched lines at this point in the old file.  These
> -    // are deletes.
> -
> -    //    Old     New
> -    //   +---+
> -    // 0 | a |
> -    //   +---+   +---+
> -    //         0 | b |
> -    //   +---+   +---+
> -    // 1 | c | 1 | c |
> -    //   +---+   +---+
> -    //         2 | z |
> -    //   +---+   +---+
> -    // 2 | d | 3 | d |
> -    //   +---+   +---+
> -
> -    while (o < lines[0].size () && lines[0][o].l == ~0) {
> -      o += 1;
> -    }
> -
> -    // Skip any unmatched lines at this point in the new file.  These
> -    // are inserts.
> -
> -    while (n < lines[1].size () && lines[1][n].l == ~0) {
> -      n += 1;
> -    }
> -
> -    // When we get here, we know that we're dealing with matching
> -    // lines (or the end of one or both files).  We're done with this
> -    // pass, if we've reached the end of either file.
> -
> -    if (lines[0].size () <= o || lines[1].size () <= n) {
> -      break;
> -    }
> -
> -    // We now know that we've got a pair of matching lines, the start
> -    // of a matching block.  If the new file's line number is what we
> -    // expect, then the matched pair is unmoved, and we can skip over
> -    // the pair.  (If this is really the start of a block of more than
> -    // 1 lines, we'll handle it one pair at a time.)
> -
> -    if (lines[0][o].l == n) {
> -      o += 1;
> -      n += 1;
> -      continue;
> -    }
> -
> -    // If, on the other hand, we don't expect this [new] line number,
> -    // then this matching block has been moved.  We need to turn the
> -    // matched pair into an *unmatched* pair, one of deletes, and one
> -    // of inserts.  First, though, we need to know how big this block
> -    // is, and how far it was moved....
> -
> -    // Remember where we were when we started.
> -
> -    unsigned oOld = o;
> -    unsigned nOld = n;
> -
> -    // Remember where the block came from.
> -
> -    unsigned nNew = lines[0][o].l;
> -
> -    // Find the end of this matched pair.
> -
> -    for (n = nNew; o < lines[0].size () && n < lines[1].size (); o += 1, n += 1) {
> -      if (lines[0][o].l != n) {
> -        break;
> -      }
> -    }
> -
> -    // When we get here:
> -    // * oOld..o is the old file's block,
> -    // * nNew..n is the new file's *moved* block, and
> -    // * nOld is where we originally expected the new block from.
> - 
> -    // We can now calculate the length of the block...
> -    
> -    unsigned bSize = o - oOld;  // (or n - nNew)
> -
> -    // ... and we can calculate how far the block moved:
> -
> -    unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
> -
> -    // The larger of the two will become our delete, and the smaller
> -    // will become our insert.
> -
> -    //    Old     New
> -    //   +---+   +---+
> -    // 0 | a | 0 | b |
> -    //   +---+ 1 | b |
> -    // 1 | b |   +---+
> -    // 2 | b | 2 | a |
> -    //   +---+   +---+
> -    // 3 | c | 3 | c |
> -    //   +---+   +---+
> -
> -    // (1) Delete a@0, insert a@2, or
> -    // (2) insert bb@0, delete bb@1?
> -
> -    // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and bMove
> -    // (of a) is 2-0 or 2, the size of b@0.  We choose to delete a@0,
> -    // and reinsert a@2.
> -
> -    // if (bSize <= bMove) {
> -      for (unsigned a = oOld; a < o; a += 1) {
> -        lines[0][a].l = ~0;
> -      }
> -      for (unsigned d = nNew; d < n; d += 1) {
> -        lines[1][d].l = ~0;
> -      }
> -    // } else {
> -      // for (unsigned a = oOld; a < o; a += 1) {
> -      //   lines[0][a].l = ~0;
> -      // }
> -      // for (unsigned d = nNew; d < n; d += 1) {
> -      //   lines[1][d].l = ~0;
> -      // }
> -    // }
> -
> -    // Continue from where we left off.
> -
> -    n = nOld;
> -  }
> -  nTotalMatchedLines -= nMatchedLines;
> -  nTotalMatchedBlocks -= nMatchedBlocks;
> -
> -  // Let's see the intermediate results.
> -
> -  if (0 < optVerbose) {
> -    fprintf (stderr,
> -             " found %u/%u matched lines/blocks (%u/%u totals).\n",
> -             nMatchedLines,
> -             nMatchedBlocks,
> -             nTotalMatchedLines,
> -             nTotalMatchedBlocks
> -            );
> -
> -    if (1 < optVerbose) {
> -      for (int f = 0; f < 2; f += 1) {
> -        fprintf (stderr, "# file #%d\n", f + 1);
> -        for (int l = 0; l < lines[f].size (); l += 1) {
> -          fprintf (stderr, "#   [%d] ", l);
> -          lines[f][l].Dump (stderr);
> -        }
> -      }
> -    }
> -  }
91c686,687
< +
---
>  
> -  // Perform Pass #6, in which we create the desired output.
94,100c690,744
<    if (0 < optVerbose) {
<      fprintf (stderr, "# Pass 1 (finding matches amongst unique lines)...");
<    }
< @@ -188,10 +219,13 @@
<        }
<      }
<    }
---
> +  if (0 < optVerbose) {
> +    fprintf (stderr, "# Pass 1 (finding matches amongst unique lines)...");
> +  }
> +
> +  nMatchedLines = 0;
> +
> +  for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> +    Line *l = i->second;
> +
> +    // If the number of old and new lines match, then we declare that
> +    // they are (all) the same line.  Note, it isn't possible for the
> +    // numbers of both files to be 0.
> +
> +    // (In the original algorithm, we only recognized a match, here,
> +    // if there was exactly 1 copy for each file.)
> +
> +    if (l->copies[0].size () == l->copies[1].size ()) {
> +      nMatchedLines += 1;
> +
> +      // For each matched line in the new file, mark it with the
> +      // corresponding line (number) in the old file.
> +
> +      while (!l->copies[0].empty ()) {
> +        unsigned o = l->copies[0].front ();
> +        unsigned n = l->copies[1].front ();
> +
> +        // Match up the pair.
> +
> +        lines[0][o].l = n;
> +        lines[1][n].l = o;
> +
> +        // Remove the matched line numbers from the lists.
> +
> +        l->copies[0].pop_front ();
> +        l->copies[1].pop_front ();
> +      }
> +    }
> +  }
> +  nTotalMatchedLines += nMatchedLines;
> +
> +  // Let's see the intermediate results.
> +
> +  if (0 < optVerbose) {
> +    fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
> +
> +    if (1 < optVerbose) {
> +      for (int f = 0; f < 2; f += 1) {
> +        fprintf (stderr, "# file #%d\n", f + 1);
> +        for (int l = 0; l < lines[f].size (); l += 1) {
> +          fprintf (stderr, "#   [%d] ", l);
> +          lines[f][l].Dump (stderr);
> +        }
> +      }
> +    }
> +  }
103,104c747,749
< -  // Perform Pass #2, in which we attempt to 'widen' blocks of matched
< -  // lines, by appending lines which are the same in both files.
---
> -  if (0 < optVerbose) {
> -    fprintf (stderr, "# Pass #6 (walking the differences)...\n");
> -  }
107a753
> -  nMatchedLines = 0;
110,116c756,843
<    if (0 < optVerbose) {
<      fprintf (stderr, "# Pass #2 (spreading matches down)...");
<    }
< @@ -280,10 +314,13 @@
<        }
<      }
<    }
---
> +  if (0 < optVerbose) {
> +    fprintf (stderr, "# Pass #2 (spreading matches down)...");
> +  }
> +
> +  nMatchedBlocks = 0;
> +  nMatchedLines = 0;
> +
> +  // Starting at the top of the old file,...
> +
> +  for (unsigned o = 0; o < lines[0].size (); o += 1) {
> +
> +    // ... skip any currently unmatched lines...
> +
> +    if (lines[0][o].l == ~0) {
> +      continue;
> +    }
> +
> +    // ... until we find an [already] matched line.  Then, skip over
> +    // the set of 1 or more matched lines, until we reach any
> +    // following, still-unmatched line.
> +
> +    unsigned n;
> +    do {
> +      n = lines[0][o].l + 1;
> +      o += 1;
> +    } while (o < lines[0].size () && lines[0][o].l != ~0);
> +
> +    // Now, o - 1 is the line number of the last matched old line, and
> +    // n - 1 is the line number of the last matched new line.  We want
> +    // to add new old and new lines, if they match.
> +
> +    // Finally, attempt to add unmatched lines to the preceeding
> +    // matched set.
> +
> +    for (; o < lines[0].size () && lines[0][o].l == ~0; o += 1, n += 1) {
> +
> +      // If the [next] pair of old and new lines aren't the same line, we're done.
> +
> +      if (lines[0][o].line != lines[1][n].line) {
> +        break;
> +      }
> +
> +      // Match up the pair.
> +
> +      lines[0][o].l = n;
> +      lines[1][n].l = o;
> +
> +      // Remove the matched line numbers form the lists.
> +
> +      Line *line = lines[0][o].line;
> +      list<unsigned> &oldCopies = line->copies[0];
> +      list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
> +      if (oL != oldCopies.end ()) {
> +        oldCopies.erase (oL);
> +      }
> +      list<unsigned> &newCopies = line->copies[0];
> +      list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
> +      if (nL != newCopies.end ()) {
> +        newCopies.erase (nL);
> +      }
> +
> +      nMatchedLines += 1;
> +    }
> +    nMatchedBlocks += 1;
> +  }
> +  nTotalMatchedLines += nMatchedLines;
> +  nTotalMatchedBlocks += nMatchedBlocks;
> +
> +  // Let's see the intermediate results.
> +
> +  if (0 < optVerbose) {
> +    fprintf (stderr,
> +             " found %u/%u matched lines/blocks (%u/%u totals).\n",
> +             nMatchedLines,
> +             nMatchedBlocks,
> +             nTotalMatchedLines,
> +             nTotalMatchedBlocks
> +            );
> +    if (1 < optVerbose) {
> +      for (int f = 0; f < 2; f += 1) {
> +        fprintf (stderr, "# file #%d\n", f + 1);
> +        for (int l = 0; l < lines[f].size (); l += 1) {
> +          fprintf (stderr, "#   [%d] ", l);
> +          lines[f][l].Dump (stderr);
> +        }
> +      }
> +    }
> +  }
119,120c846,857
< -  // Perform Pass #3, in which we attempt to 'widen' blocks of matched
< -  // lines, by prepending lines which are the same in both files.
---
> -  // Write the header.
> -
> -  switch (diffFormat) {
> -  case Default:
> -  case Normal:
> -    break;
> -  case Unified:
> -    fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
> -    fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
> -    fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), lines[1].size ());
> -    break;
> -  }
123a861
> -  // Starting at the top of both files,...
126,132c864,951
<    if (0 < optVerbose) {
<      fprintf (stderr, "# Pass #3 (spreading matches up)...");
<    }
< @@ -372,11 +409,14 @@
<        }
<      }
<    }
---
> +  if (0 < optVerbose) {
> +    fprintf (stderr, "# Pass #3 (spreading matches up)...");
> +  }
> +
> +  nMatchedBlocks = 0;
> +  nMatchedLines = 0;
> +
> +  // Starting at the bottom of the old file,...
> +
> +  for (int o = lines[0].size (); 0 <= o; o -= 1) {
> +
> +    // ... skip any currently unmatched lines...
> +
> +    if (lines[0][o].l == ~0) {
> +      continue;
> +    }
> +
> +    // ... until we find an [already] matched line.  Then, skip over
> +    // the set of 1 or more matched lines, until we reach any
> +    // following, still-unmatched line.
> +
> +    unsigned n;
> +    do {
> +      n = lines[0][o].l - 1;
> +      o -= 1;
> +    } while (0 <= o && lines[0][o].l != ~0);
> +
> +    // Now, o + 1 is the line number of the last matched old line, and
> +    // n + 1 is the line number of the last matched new line.  We want
> +    // to add new old and new lines, if they match.
> +
> +    // Finally, attempt to add unmatched lines to the preceeding
> +    // matched set.
> +
> +    for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
> +
> +      // If the [next] pair of old and new lines aren't the same line, we're done.
> +
> +      if (lines[0][o].line != lines[1][n].line) {
> +        break;
> +      }
> +
> +      // Match up the pair.
> +
> +      lines[0][o].l = n;
> +      lines[1][n].l = o;
> +
> +      // Remove the matched line numbers form the lists.
> +
> +      Line *line = lines[0][o].line;
> +      list<unsigned> &oldCopies = line->copies[0];
> +      list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
> +      if (oL != oldCopies.end ()) {
> +        oldCopies.erase (oL);
> +      }
> +      list<unsigned> &newCopies = line->copies[0];
> +      list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
> +      if (nL != newCopies.end ()) {
> +        newCopies.erase (nL);
> +      }
> +
> +      nMatchedLines += 1;
> +    }
> +    nMatchedBlocks += 1;
> +  }
> +  nTotalMatchedLines += nMatchedLines;
> +
> +  // Let's see the intermediate results.
> +
> +  if (0 < optVerbose) {
> +    fprintf (stderr,
> +             " found %u/%u matched lines/blocks (%u/%u totals).\n",
> +             nMatchedLines,
> +             nMatchedBlocks,
> +             nTotalMatchedLines,
> +             nTotalMatchedBlocks
> +            );
> +
> +    if (1 < optVerbose) {
> +      for (int f = 0; f < 2; f += 1) {
> +        fprintf (stderr, "# file #%d\n", f + 1);
> +        for (int l = 0; l < lines[f].size (); l += 1) {
> +          fprintf (stderr, "#   [%d] ", l);
> +          lines[f][l].Dump (stderr);
> +        }
> +      }
> +    }
> +  }
135,137c954,955
< -  // Perform pass #4, in which we find any remaining matches amongst
< -  // the unique lines.  For every unique line that has more than 1
< -  // copy in both files, we declare the copies to match.
---
> -  o = 0;
> -  n = 0;
141a960
> -  while (o < lines[0].size () || n < lines[1].size ()) {
144,150c963,1014
<    if (0 < optVerbose) {
<      fprintf (stderr, "# Pass 4 (finding remaining matches amongst unique lines)...");
<    }
< @@ -429,12 +469,15 @@
<        }
<      }
<    }
---
> +  if (0 < optVerbose) {
> +    fprintf (stderr, "# Pass 4 (finding remaining matches amongst unique lines)...");
> +  }
> +
> +  nMatchedLines = 0;
> +
> +  for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> +    Line *l = i->second;
> +
> +    // If there's more than 1 matching old and new lines, then we
> +    // declare that each pair are (all) the same line.
> +
> +    // (In the original algorithm, we only recognized a match, here,
> +    // if there was exactly 1 copy for each file.)
> +
> +    while (0 < l->copies[0].size () && 0 < l->copies[1].size ()) {
> +      nMatchedLines += 1;
> +
> +      // For each matched line in the new file, mark it with the
> +      // corresponding line (number) in the old file.
> +
> +      unsigned o = l->copies[0].front ();
> +      unsigned n = l->copies[1].front ();
> +
> +      // Match up the pair.
> +
> +      lines[0][o].l = n;
> +      lines[1][n].l = o;
> +
> +      // Remove the matched line numbers from the lists.
> +
> +      l->copies[0].pop_front ();
> +      l->copies[1].pop_front ();
> +    }
> +  }
> +  nTotalMatchedLines += nMatchedLines;
> +
> +  // Let's see the intermediate results.
> +
> +  if (0 < optVerbose) {
> +    fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
> +
> +    if (1 < optVerbose) {
> +      for (int f = 0; f < 2; f += 1) {
> +        fprintf (stderr, "# file #%d\n", f + 1);
> +        for (int l = 0; l < lines[f].size (); l += 1) {
> +          fprintf (stderr, "#   [%d] ", l);
> +          lines[f][l].Dump (stderr);
> +        }
> +      }
> +    }
> +  }
153,156c1017,1018
< -  // Perform Pass #5, in which we look for blocks which match, but are
< -  // the result of a move (their not in their original position).  For
< -  // these, we'll unmatch the blocks, turning them into a delete and
< -  // an insert.
---
> -    // Find any unmatched lines at this point in the old file.  These
> -    // are deletes.
161a1024,1029
> -    unsigned boDeletes;
> -    for (boDeletes = o;
> -         o < lines[0].size () && lines[0][o].l == ~0;
> -         o += 1
> -        )
> -    {}
164,170c1032,1192
<    if (0 < optVerbose) {
<      fprintf (stderr, "# Pass #5 (unmatching block moves)...\n");
<    }
< @@ -596,32 +639,87 @@
<        }
<      }
<    }
---
> +  if (0 < optVerbose) {
> +    fprintf (stderr, "# Pass #5 (unmatching block moves)...\n");
> +  }
> +
> +  nMatchedBlocks = 0;
> +  nMatchedLines = 0;
> +
> +  // Starting at the top of both files,...
> +
> +  unsigned o = 0;
> +  unsigned n = 0;
> +
> +  while (o < lines[0].size () || n < lines[1].size ()) {
> +
> +    // Skip any unmatched lines at this point in the old file.  These
> +    // are deletes.
> +
> +    //    Old     New
> +    //   +---+
> +    // 0 | a |
> +    //   +---+   +---+
> +    //         0 | b |
> +    //   +---+   +---+
> +    // 1 | c | 1 | c |
> +    //   +---+   +---+
> +    //         2 | z |
> +    //   +---+   +---+
> +    // 2 | d | 3 | d |
> +    //   +---+   +---+
> +
> +    while (o < lines[0].size () && lines[0][o].l == ~0) {
> +      o += 1;
> +    }
> +
> +    // Skip any unmatched lines at this point in the new file.  These
> +    // are inserts.
> +
> +    while (n < lines[1].size () && lines[1][n].l == ~0) {
> +      n += 1;
> +    }
> +
> +    // When we get here, we know that we're dealing with matching
> +    // lines (or the end of one or both files).  We're done with this
> +    // pass, if we've reached the end of either file.
> +
> +    if (lines[0].size () <= o || lines[1].size () <= n) {
> +      break;
> +    }
> +
> +    // We now know that we've got a pair of matching lines, the start
> +    // of a matching block.  If the new file's line number is what we
> +    // expect, then the matched pair is unmoved, and we can skip over
> +    // the pair.  (If this is really the start of a block of more than
> +    // 1 lines, we'll handle it one pair at a time.)
> +
> +    if (lines[0][o].l == n) {
> +      o += 1;
> +      n += 1;
> +      continue;
> +    }
> +
> +    // If, on the other hand, we don't expect this [new] line number,
> +    // then this matching block has been moved.  We need to turn the
> +    // matched pair into an *unmatched* pair, one of deletes, and one
> +    // of inserts.  First, though, we need to know how big this block
> +    // is, and how far it was moved....
> +
> +    // Remember where we were when we started.
> +
> +    unsigned oOld = o;
> +    unsigned nOld = n;
> +
> +    // Remember where the block came from.
> +
> +    unsigned nNew = lines[0][o].l;
> +
> +    // Find the end of this matched pair.
> +
> +    for (n = nNew; o < lines[0].size () && n < lines[1].size (); o += 1, n += 1) {
> +      if (lines[0][o].l != n) {
> +        break;
> +      }
> +    }
> +
> +    // When we get here:
> +    // * oOld..o is the old file's block,
> +    // * nNew..n is the new file's *moved* block, and
> +    // * nOld is where we originally expected the new block from.
> + 
> +    // We can now calculate the length of the block...
> +    
> +    unsigned bSize = o - oOld;  // (or n - nNew)
> +
> +    // ... and we can calculate how far the block moved:
> +
> +    unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
> +
> +    // The larger of the two will become our delete, and the smaller
> +    // will become our insert.
> +
> +    //    Old     New
> +    //   +---+   +---+
> +    // 0 | a | 0 | b |
> +    //   +---+ 1 | b |
> +    // 1 | b |   +---+
> +    // 2 | b | 2 | a |
> +    //   +---+   +---+
> +    // 3 | c | 3 | c |
> +    //   +---+   +---+
> +
> +    // (1) Delete a@0, insert a@2, or
> +    // (2) insert bb@0, delete bb@1?
> +
> +    // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and bMove
> +    // (of a) is 2-0 or 2, the size of b@0.  We choose to delete a@0,
> +    // and reinsert a@2.
> +
> +    // if (bSize <= bMove) {
> +      for (unsigned a = oOld; a < o; a += 1) {
> +        lines[0][a].l = ~0;
> +      }
> +      for (unsigned d = nNew; d < n; d += 1) {
> +        lines[1][d].l = ~0;
> +      }
> +    // } else {
> +      // for (unsigned a = oOld; a < o; a += 1) {
> +      //   lines[0][a].l = ~0;
> +      // }
> +      // for (unsigned d = nNew; d < n; d += 1) {
> +      //   lines[1][d].l = ~0;
> +      // }
> +    // }
> +
> +    // Continue from where we left off.
> +
> +    n = nOld;
> +  }
> +  nTotalMatchedLines -= nMatchedLines;
> +  nTotalMatchedBlocks -= nMatchedBlocks;
> +
> +  // Let's see the intermediate results.
> +
> +  if (0 < optVerbose) {
> +    fprintf (stderr,
> +             " found %u/%u matched lines/blocks (%u/%u totals).\n",
> +             nMatchedLines,
> +             nMatchedBlocks,
> +             nTotalMatchedLines,
> +             nTotalMatchedBlocks
> +            );
> +
> +    if (1 < optVerbose) {
> +      for (int f = 0; f < 2; f += 1) {
> +        fprintf (stderr, "# file #%d\n", f + 1);
> +        for (int l = 0; l < lines[f].size (); l += 1) {
> +          fprintf (stderr, "#   [%d] ", l);
> +          lines[f][l].Dump (stderr);
> +        }
> +      }
> +    }
> +  }
173c1195,1196
< -  // Perform Pass #6, in which we create the desired output.
---
> -    // Find any unmatched lines at this point in the new file.  These
> -    // are inserts.
176,178c1199,1204
< -  if (0 < optVerbose) {
< -    fprintf (stderr, "# Pass #6 (walking the differences)...\n");
< -  }
---
> -    unsigned boInserts;
> -    for (boInserts = n;
> -         n < lines[1].size () && lines[1][n].l == ~0;
> -         n += 1
> -        )
> -    {}
187,189c1213,1214
< -  nMatchedLines = 0;
< -
< -  // Write the header.
---
> -    // We've got deleted line(s) from boDeletes .. o.
> -    // We've got deleted line(s) from boInserts .. n.
192,194c1217,1218
<  
<    switch (diffFormat) {
< -  case Default:
---
> +
> +  switch (diffFormat) {
198c1222,1224
< +
---
>  
> -    unsigned nDeletes = o - boDeletes;
> -    unsigned nInserts = n - boInserts;
202c1228,1229
< +
---
>  
> -    // We've got...
206,207c1233,1235
< +
<    case Normal:
---
>  
> -    if (nDeletes && nInserts) {
> +  case Normal:
209,210c1237,1239
<      break;
< +
---
> +    break;
>  
> -      // ... deletes and inserts.
214c1243,1261
< +
---
>  
> -      switch (diffFormat) {
> -      case Default:
> -      case Normal:
> -        if (1 < nDeletes && 1 < nInserts) {
> -          fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, boInserts + 1, n);
> -        } else if (1 < nDeletes) {
> -          fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boInserts + 1);
> -        } else if (1 < nInserts) {
> -          fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInserts + 1, n);
> -        } 
> -        for (unsigned l = boDeletes; l < o; l += 1) {
> -          fprintf (stdout, "< %s", lines[0][l].line->c_str ());
> -        }
> -        fprintf (stderr, "---\n");
> -        for (unsigned l = boInserts; l < n; l += 1) {
> -          fprintf (stdout, "> %s", lines[1][l].line->c_str ());
> -        }
> -        break;
218,222c1265,1276
< +
<    case Unified:
< -    fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
< -    fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
< -    fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), lines[1].size ());
---
>  
> -      case Unified:
> -        for (unsigned l = boDeletes; l < o; l += 1) {
> -          fprintf (stdout, "-%s", lines[0][l].line->c_str ());
> -        }
> -        for (unsigned l = boInserts; l < n; l += 1) {
> -          fprintf (stdout, "+%s", lines[1][l].line->c_str ());
> -        }
> -        break;
> -      }
> -    } else if (nDeletes) {
> +  case Unified:
225c1279,1280
< +
---
>  
> -      //  ... just deletes.
229,230c1284,1285
<      break;
<    }
---
> +    break;
> +  }
232c1287,1306
< +
---
>  
> -      switch (diffFormat) {
> -      case Default:
> -      case Normal:
> -        if (1 < nDeletes) {
> -          fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
> -        } else {
> -          fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
> -        }
> -        for (unsigned l = boDeletes; l < o; l += 1) {
> -          fprintf (stdout, "< %s", lines[0][l].line->c_str ());
> -        }
> -        break;
> -      case Unified:
> -        for (unsigned l = boDeletes; l < o; l += 1) {
> -          fprintf (stdout, "-%s", lines[0][l].line->c_str ());
> -        }
> -        break;
> -      }
> -    } else if (nInserts) {
239c1313,1314
< +
---
>  
> -      //  ... just inserts.
246c1321,1340
< +
---
>  
> -      switch (diffFormat) {
> -      case Default:
> -      case Normal:
> -        if (1 < nInserts) {
> -          fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
> -        } else {
> -          fprintf (stdout, "%da%d\n", o, boInserts + 1);
> -        }
> -        for (unsigned l = boInserts; l < n; l += 1) {
> -          fprintf (stdout, "> %s", lines[1][l].line->c_str ());
> -        }
> -        break;
> -      case Unified:
> -        for (unsigned l = boInserts; l < n; l += 1) {
> -          fprintf (stdout, "+%s", lines[1][l].line->c_str ());
> -        }
> -        break;
> -      }
> -    }
251c1345,1346
< +
---
>  
> -    // When we get here, we're dealing with matching lines.
253c1348,1355
< +
---
>  
> -    switch (diffFormat) {
> -    case Default:
> -    case Normal:
> -      break;
> -    case Unified:
> -      fprintf (stdout, " %s", lines[0][o].line->c_str ());
> -      break;
258,262c1360,1362
<  
<    // Starting at the top of both files,...
<  
< -  o = 0;
< -  n = 0;
---
> +
> +  // Starting at the top of both files,...
> +
265,272c1365,1393
<  
<    while (o < lines[0].size () || n < lines[1].size ()) {
<  
< @@ -651,96 +749,262 @@
<      unsigned nDeletes = o - boDeletes;
<      unsigned nInserts = n - boInserts;
<  
< -    // We've got...
---
> +
> +  while (o < lines[0].size () || n < lines[1].size ()) {
> +
> +    // Find any unmatched lines at this point in the old file.  These
> +    // are deletes.
> +
> +    unsigned boDeletes;
> +    for (boDeletes = o;
> +         o < lines[0].size () && lines[0][o].l == ~0;
> +         o += 1
> +        )
> +    {}
> +
> +    // Find any unmatched lines at this point in the new file.  These
> +    // are inserts.
> +
> +    unsigned boInserts;
> +    for (boInserts = n;
> +         n < lines[1].size () && lines[1][n].l == ~0;
> +         n += 1
> +        )
> +    {}
> +
> +    // We've got deleted line(s) from boDeletes .. o.
> +    // We've got deleted line(s) from boInserts .. n.
> +
> +    unsigned nDeletes = o - boDeletes;
> +    unsigned nInserts = n - boInserts;
> +
274,275c1395
<  
< -    if (nDeletes && nInserts) {
---
> +
279,280c1399
<  
< -      // ... deletes and inserts.
---
> +
294,310c1413,1414
<  
< -      switch (diffFormat) {
< -      case Default:
< -      case Normal:
< -        if (1 < nDeletes && 1 < nInserts) {
< -          fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, boInserts + 1, n);
< -        } else if (1 < nDeletes) {
< -          fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boInserts + 1);
< -        } else if (1 < nInserts) {
< -          fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInserts + 1, n);
< -        } 
<          for (unsigned l = boDeletes; l < o; l += 1) {
< -          fprintf (stdout, "< %s", lines[0][l].line->c_str ());
< -        }
< -        fprintf (stderr, "---\n");
< -        for (unsigned l = boInserts; l < n; l += 1) {
< -          fprintf (stdout, "> %s", lines[1][l].line->c_str ());
---
> +
> +        for (unsigned l = boDeletes; l < o; l += 1) {
312,313c1416
<          }
< -        break;
---
> +        }
317,320c1420,1421
<  
< -      case Unified:
<          for (unsigned l = boDeletes; l < o; l += 1) {
< -          fprintf (stdout, "-%s", lines[0][l].line->c_str ());
---
> +
> +        for (unsigned l = boDeletes; l < o; l += 1) {
341c1442
<          }
---
> +        }
346,347c1447
<          for (unsigned l = boInserts; l < n; l += 1) {
< -          fprintf (stdout, "+%s", lines[1][l].line->c_str ());
---
> +        for (unsigned l = boInserts; l < n; l += 1) {
349,350c1449
<          }
< -        break;
---
> +        }
433,454c1532,1536
<        }
<      } else if (nDeletes) {
<  
<        //  ... just deletes.
<  
< -      switch (diffFormat) {
< -      case Default:
< -      case Normal:
< -        if (1 < nDeletes) {
< -          fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
< -        } else {
< -          fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
< -        }
< -        for (unsigned l = boDeletes; l < o; l += 1) {
< -          fprintf (stdout, "< %s", lines[0][l].line->c_str ());
< -        }
< -        break;
< -      case Unified:
< -        for (unsigned l = boDeletes; l < o; l += 1) {
< -          fprintf (stdout, "-%s", lines[0][l].line->c_str ());
< -        }
< -        break;
---
> +      }
> +    } else if (nDeletes) {
> +
> +      //  ... just deletes.
> +
462,483c1544,1548
<        }
<      } else if (nInserts) {
<  
<        //  ... just inserts.
<  
< -      switch (diffFormat) {
< -      case Default:
< -      case Normal:
< -        if (1 < nInserts) {
< -          fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
< -        } else {
< -          fprintf (stdout, "%da%d\n", o, boInserts + 1);
< -        }
< -        for (unsigned l = boInserts; l < n; l += 1) {
< -          fprintf (stdout, "> %s", lines[1][l].line->c_str ());
< -        }
< -        break;
< -      case Unified:
< -        for (unsigned l = boInserts; l < n; l += 1) {
< -          fprintf (stdout, "+%s", lines[1][l].line->c_str ());
< -        }
< -        break;
---
> +      }
> +    } else if (nInserts) {
> +
> +      //  ... just inserts.
> +
491c1556
<        }
---
> +      }
493,502c1558,1560
<  
<      // When we get here, we're dealing with matching lines.
<  
< -    switch (diffFormat) {
< -    case Default:
< -    case Normal:
< -      break;
< -    case Unified:
< -      fprintf (stdout, " %s", lines[0][o].line->c_str ());
< -      break;
---
> +
> +    // When we get here, we're dealing with matching lines.
> +
587c1645
<      }
---
> +    }
594a1653
>  }
# ../sdiff -u dif.5.cpp dif.4.cpp >& dif.5.4.diff-u.test
# dif.5.4.diff-u ---------------------------------------------------------------
1,3c1,24
< --- dif.5.cpp	2008-02-25 19:19:42.000000000 +0000
< +++ dif.4.cpp	2008-02-25 18:06:37.000000000 +0000
< @@ -22,8 +22,7 @@
---
> --- dif.5.cpp	0000-00-00 00:00:00.000000000 +0000
> +++ dif.4.cpp	0000-00-00 00:00:00.000000000 +0000
> @@ -1,1011 +1,747 @@
>  #include <algorithm>
>  using std::find;
>  #include <string>
>  using std::string;
>  #include <list>
>  using std::list;
>  #include <map>
>  using std::map;
>  #include <vector>
>  using std::vector;
>  #include <stdio.h>
>  
>  enum DiffFormat {
>    Default,
>  
>    Context,
>    EdScript,
>    IfThenElse,
>    Normal,
>    RCS,
>    SideBySide,
13c34,70
< @@ -67,38 +66,20 @@
---
>  struct Line : public string {
>    Line (string _text) :
>      string (_text)
>    {
>    }
>    ~Line () {
>      copies[0].erase (copies[0].begin (), copies[0].end ());
>      copies[1].erase (copies[1].begin (), copies[1].end ());
>    }
>    void Dump (FILE *out) {
>      fprintf (out, "{{ ");
>      for (list<unsigned>::iterator i = copies[0].begin (); i != copies[0].end (); i++) {
>        fprintf (out, "%u ", *i);
>      }
>      fprintf (out, "},{ ");
>      for (list<unsigned>::iterator i = copies[1].begin (); i != copies[1].end (); i++) {
>        fprintf (out, "%u ", *i);
>      }
>      fprintf (out, "}}\t%s", c_str ());
>    }
>    list<unsigned> copies[2];
>  };
>  
>  struct LinePtr {
>    LinePtr (Line *_line) :
>      line (_line),
>      l (~0u)
>    {
>    }
>    void Dump (FILE *out) {
>      fprintf (out, "[%d] ", l);
>      line->Dump (out);
>    }
>    Line *line;
>    unsigned l;
>  };
>  
18,19c75
< +char *ARGV0 = "dif2";
<  
---
> -
35,38c91
< +int main (int argc, char *argv[])
< +{
< +  char const *files[2] = { 0, 0 };
<  
---
> -
43,45c96
< +  MapStringToLinePtr table;
< +  VectorLinePtr lines[2];
<  
---
> -
51a103,111
> +char *ARGV0 = "dif2";
>  
>  int main (int argc, char *argv[])
>  {
> +  char const *files[2] = { 0, 0 };
> +
> +  MapStringToLinePtr table;
> +  VectorLinePtr lines[2];
> +
56,58c116
<  
< -int main (int argc, char *argv[])
< -{
---
> +
62c120,150
< @@ -136,7 +117,7 @@
---
>      files[n] = argv[a];
>  
>      if (FILE *f = fopen (files[n], "r")) {
>        if (0 < optVerbose) {
>          fprintf (stderr, "# Reading %s...", files[n]);
>        }
>  
>        char buffer[1024];
>        unsigned nUniq = 0;
>  
>        while (fgets (buffer, sizeof (buffer), f)) {
>          string text (buffer);
>  
>          Line *line = table[text];
>  
>          if (!line) {
>            table[text] = line = new Line (text);
>            nUniq += 1;
>          }
>          line->copies[n].push_back (lines[n].size ());
>          lines[n].push_back (line);
>        }
>  
>        if (0 < optVerbose) {
>          fprintf (stderr, " %u lines, %u unique.\n", lines[n].size (), nUniq);
>        }
>      } else {
>        fprintf (stderr, "%s: Unable to open %s!  Exiting....\n", ARGV0, files[n]);
>        perror (ARGV0);
>        exit (1);
>      }
71c159,163
< @@ -148,22 +129,10 @@
---
>    // for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
>    //   Line *l = i->second;
>    //   counts[l->counts[0].size () + l->counts[1].size ()] += 1;
>    // }
>    // for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
81,84c173
< +  // Perform pass #1, in which we find all explicit matches amongst
< +  // the unique lines.  For every unique line that appears the same
< +  // number of times in both files, we declare the lines to match.
<  
---
> -
93a183,186
> +  // Perform pass #1, in which we find all explicit matches amongst
> +  // the unique lines.  For every unique line that appears the same
> +  // number of times in both files, we declare the lines to match.
> +
97c190,221
< @@ -219,13 +188,10 @@
---
>  
>    nMatchedLines = 0;
>  
>    for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
>      Line *l = i->second;
>  
>      // If the number of old and new lines match, then we declare that
>      // they are (all) the same line.  Note, it isn't possible for the
>      // numbers of both files to be 0.
>  
>      // (In the original algorithm, we only recognized a match, here,
>      // if there was exactly 1 copy for each file.)
>  
>      if (l->copies[0].size () == l->copies[1].size ()) {
>        nMatchedLines += 1;
>  
>        // For each matched line in the new file, mark it with the
>        // corresponding line (number) in the old file.
>  
>        while (!l->copies[0].empty ()) {
>          unsigned o = l->copies[0].front ();
>          unsigned n = l->copies[1].front ();
>  
>          // Match up the pair.
>  
>          lines[0][o].l = n;
>          lines[1][n].l = o;
>  
>          // Remove the matched line numbers from the lists.
>  
>          l->copies[0].pop_front ();
>          l->copies[1].pop_front ();
101c225,227
< -}
---
>    nTotalMatchedLines += nMatchedLines;
>  
>    // Let's see the intermediate results.
102a229,243
>    if (0 < optVerbose) {
>      fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
>  
>      if (1 < optVerbose) {
>        for (int f = 0; f < 2; f += 1) {
>          fprintf (stderr, "# file #%d\n", f + 1);
>          for (int l = 0; l < lines[f].size (); l += 1) {
>            fprintf (stderr, "#   [%d] ", l);
>            lines[f][l].Dump (stderr);
>          }
>        }
>      }
>    }
> -}
> -
105,107c246
< +  // Perform Pass #2, in which we attempt to 'widen' blocks of matched
< +  // lines, by appending lines which are the same in both files.
<  
---
> -
109a249,252
> +
> +  // Perform Pass #2, in which we attempt to 'widen' blocks of matched
> +  // lines, by appending lines which are the same in both files.
> +
113c256,337
< @@ -314,13 +280,10 @@
---
>  
>    nMatchedBlocks = 0;
>    nMatchedLines = 0;
>  
>    // Starting at the top of the old file,...
>  
>    for (unsigned o = 0; o < lines[0].size (); o += 1) {
>  
>      // ... skip any currently unmatched lines...
>  
>      if (lines[0][o].l == ~0) {
>        continue;
>      }
>  
>      // ... until we find an [already] matched line.  Then, skip over
>      // the set of 1 or more matched lines, until we reach any
>      // following, still-unmatched line.
>  
>      unsigned n;
>      do {
>        n = lines[0][o].l + 1;
>        o += 1;
>      } while (o < lines[0].size () && lines[0][o].l != ~0);
>  
>      // Now, o - 1 is the line number of the last matched old line, and
>      // n - 1 is the line number of the last matched new line.  We want
>      // to add new old and new lines, if they match.
>  
>      // Finally, attempt to add unmatched lines to the preceeding
>      // matched set.
>  
>      for (; o < lines[0].size () && lines[0][o].l == ~0; o += 1, n += 1) {
>  
>        // If the [next] pair of old and new lines aren't the same line, we're done.
>  
>        if (lines[0][o].line != lines[1][n].line) {
>          break;
>        }
>  
>        // Match up the pair.
>  
>        lines[0][o].l = n;
>        lines[1][n].l = o;
>  
>        // Remove the matched line numbers form the lists.
>  
>        Line *line = lines[0][o].line;
>        list<unsigned> &oldCopies = line->copies[0];
>        list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
>        if (oL != oldCopies.end ()) {
>          oldCopies.erase (oL);
>        }
>        list<unsigned> &newCopies = line->copies[0];
>        list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
>        if (nL != newCopies.end ()) {
>          newCopies.erase (nL);
>        }
>  
>        nMatchedLines += 1;
>      }
>      nMatchedBlocks += 1;
>    }
>    nTotalMatchedLines += nMatchedLines;
>    nTotalMatchedBlocks += nMatchedBlocks;
>  
>    // Let's see the intermediate results.
>  
>    if (0 < optVerbose) {
>      fprintf (stderr,
>               " found %u/%u matched lines/blocks (%u/%u totals).\n",
>               nMatchedLines,
>               nMatchedBlocks,
>               nTotalMatchedLines,
>               nTotalMatchedBlocks
>              );
>      if (1 < optVerbose) {
>        for (int f = 0; f < 2; f += 1) {
>          fprintf (stderr, "# file #%d\n", f + 1);
>          for (int l = 0; l < lines[f].size (); l += 1) {
>            fprintf (stderr, "#   [%d] ", l);
>            lines[f][l].Dump (stderr);
>          }
118c342
<  
---
> -
121,123c345
< +  // Perform Pass #3, in which we attempt to 'widen' blocks of matched
< +  // lines, by prepending lines which are the same in both files.
<  
---
> -
125a348,351
> +
> +  // Perform Pass #3, in which we attempt to 'widen' blocks of matched
> +  // lines, by prepending lines which are the same in both files.
> +
129c355,391
< @@ -409,14 +372,11 @@
---
>  
>    nMatchedBlocks = 0;
>    nMatchedLines = 0;
>  
>    // Starting at the bottom of the old file,...
>  
>    for (int o = lines[0].size (); 0 <= o; o -= 1) {
>  
>      // ... skip any currently unmatched lines...
>  
>      if (lines[0][o].l == ~0) {
>        continue;
>      }
>  
>      // ... until we find an [already] matched line.  Then, skip over
>      // the set of 1 or more matched lines, until we reach any
>      // following, still-unmatched line.
>  
>      unsigned n;
>      do {
>        n = lines[0][o].l - 1;
>        o -= 1;
>      } while (0 <= o && lines[0][o].l != ~0);
>  
>      // Now, o + 1 is the line number of the last matched old line, and
>      // n + 1 is the line number of the last matched new line.  We want
>      // to add new old and new lines, if they match.
>  
>      // Finally, attempt to add unmatched lines to the preceeding
>      // matched set.
>  
>      for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
>  
>        // If the [next] pair of old and new lines aren't the same line, we're done.
>  
>        if (lines[0][o].line != lines[1][n].line) {
>          break;
130a393,413
>  
>        // Match up the pair.
>  
>        lines[0][o].l = n;
>        lines[1][n].l = o;
>  
>        // Remove the matched line numbers form the lists.
>  
>        Line *line = lines[0][o].line;
>        list<unsigned> &oldCopies = line->copies[0];
>        list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
>        if (oL != oldCopies.end ()) {
>          oldCopies.erase (oL);
>        }
>        list<unsigned> &newCopies = line->copies[0];
>        list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
>        if (nL != newCopies.end ()) {
>          newCopies.erase (nL);
>        }
>  
>        nMatchedLines += 1;
131a415
>      nMatchedBlocks += 1;
133c417,419
< -}
---
>    nTotalMatchedLines += nMatchedLines;
>  
>    // Let's see the intermediate results.
134a421,441
>    if (0 < optVerbose) {
>      fprintf (stderr,
>               " found %u/%u matched lines/blocks (%u/%u totals).\n",
>               nMatchedLines,
>               nMatchedBlocks,
>               nTotalMatchedLines,
>               nTotalMatchedBlocks
>              );
>  
>      if (1 < optVerbose) {
>        for (int f = 0; f < 2; f += 1) {
>          fprintf (stderr, "# file #%d\n", f + 1);
>          for (int l = 0; l < lines[f].size (); l += 1) {
>            fprintf (stderr, "#   [%d] ", l);
>            lines[f][l].Dump (stderr);
>          }
>        }
>      }
>    }
> -}
> -
137a445,448
> -
> -void pass4 ()
> -{
> +
141,143c452
<  
< -void pass4 ()
< -{
---
> +
147c456,501
< @@ -469,15 +429,12 @@
---
>  
>    nMatchedLines = 0;
>  
>    for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
>      Line *l = i->second;
>  
>      // If there's more than 1 matching old and new lines, then we
>      // declare that each pair are (all) the same line.
>  
>      // (In the original algorithm, we only recognized a match, here,
>      // if there was exactly 1 copy for each file.)
>  
>      while (0 < l->copies[0].size () && 0 < l->copies[1].size ()) {
>        nMatchedLines += 1;
>  
>        // For each matched line in the new file, mark it with the
>        // corresponding line (number) in the old file.
>  
>        unsigned o = l->copies[0].front ();
>        unsigned n = l->copies[1].front ();
>  
>        // Match up the pair.
>  
>        lines[0][o].l = n;
>        lines[1][n].l = o;
>  
>        // Remove the matched line numbers from the lists.
>  
>        l->copies[0].pop_front ();
>        l->copies[1].pop_front ();
>      }
>    }
>    nTotalMatchedLines += nMatchedLines;
>  
>    // Let's see the intermediate results.
>  
>    if (0 < optVerbose) {
>      fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
>  
>      if (1 < optVerbose) {
>        for (int f = 0; f < 2; f += 1) {
>          fprintf (stderr, "# file #%d\n", f + 1);
>          for (int l = 0; l < lines[f].size (); l += 1) {
>            fprintf (stderr, "#   [%d] ", l);
>            lines[f][l].Dump (stderr);
>          }
152c506
<  
---
> -
156a511,514
> -
> -void pass5 ()
> -{
> +
161,163c519
<  
< -void pass5 ()
< -{
---
> +
167c523,677
< @@ -639,87 +596,32 @@
---
>  
>    nMatchedBlocks = 0;
>    nMatchedLines = 0;
>  
>    // Starting at the top of both files,...
>  
>    unsigned o = 0;
>    unsigned n = 0;
>  
>    while (o < lines[0].size () || n < lines[1].size ()) {
>  
>      // Skip any unmatched lines at this point in the old file.  These
>      // are deletes.
>  
>      //    Old     New
>      //   +---+
>      // 0 | a |
>      //   +---+   +---+
>      //         0 | b |
>      //   +---+   +---+
>      // 1 | c | 1 | c |
>      //   +---+   +---+
>      //         2 | z |
>      //   +---+   +---+
>      // 2 | d | 3 | d |
>      //   +---+   +---+
>  
>      while (o < lines[0].size () && lines[0][o].l == ~0) {
>        o += 1;
>      }
>  
>      // Skip any unmatched lines at this point in the new file.  These
>      // are inserts.
>  
>      while (n < lines[1].size () && lines[1][n].l == ~0) {
>        n += 1;
>      }
>  
>      // When we get here, we know that we're dealing with matching
>      // lines (or the end of one or both files).  We're done with this
>      // pass, if we've reached the end of either file.
>  
>      if (lines[0].size () <= o || lines[1].size () <= n) {
>        break;
>      }
>  
>      // We now know that we've got a pair of matching lines, the start
>      // of a matching block.  If the new file's line number is what we
>      // expect, then the matched pair is unmoved, and we can skip over
>      // the pair.  (If this is really the start of a block of more than
>      // 1 lines, we'll handle it one pair at a time.)
>  
>      if (lines[0][o].l == n) {
>        o += 1;
>        n += 1;
>        continue;
>      }
>  
>      // If, on the other hand, we don't expect this [new] line number,
>      // then this matching block has been moved.  We need to turn the
>      // matched pair into an *unmatched* pair, one of deletes, and one
>      // of inserts.  First, though, we need to know how big this block
>      // is, and how far it was moved....
>  
>      // Remember where we were when we started.
>  
>      unsigned oOld = o;
>      unsigned nOld = n;
>  
>      // Remember where the block came from.
>  
>      unsigned nNew = lines[0][o].l;
>  
>      // Find the end of this matched pair.
>  
>      for (n = nNew; o < lines[0].size () && n < lines[1].size (); o += 1, n += 1) {
>        if (lines[0][o].l != n) {
>          break;
>        }
>      }
>  
>      // When we get here:
>      // * oOld..o is the old file's block,
>      // * nNew..n is the new file's *moved* block, and
>      // * nOld is where we originally expected the new block from.
>   
>      // We can now calculate the length of the block...
>      
>      unsigned bSize = o - oOld;  // (or n - nNew)
>  
>      // ... and we can calculate how far the block moved:
>  
>      unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
>  
>      // The larger of the two will become our delete, and the smaller
>      // will become our insert.
>  
>      //    Old     New
>      //   +---+   +---+
>      // 0 | a | 0 | b |
>      //   +---+ 1 | b |
>      // 1 | b |   +---+
>      // 2 | b | 2 | a |
>      //   +---+   +---+
>      // 3 | c | 3 | c |
>      //   +---+   +---+
>  
>      // (1) Delete a@0, insert a@2, or
>      // (2) insert bb@0, delete bb@1?
>  
>      // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and bMove
>      // (of a) is 2-0 or 2, the size of b@0.  We choose to delete a@0,
>      // and reinsert a@2.
>  
>      // if (bSize <= bMove) {
>        for (unsigned a = oOld; a < o; a += 1) {
>          lines[0][a].l = ~0;
>        }
>        for (unsigned d = nNew; d < n; d += 1) {
>          lines[1][d].l = ~0;
>        }
>      // } else {
>        // for (unsigned a = oOld; a < o; a += 1) {
>        //   lines[0][a].l = ~0;
>        // }
>        // for (unsigned d = nNew; d < n; d += 1) {
>        //   lines[1][d].l = ~0;
>        // }
>      // }
>  
>      // Continue from where we left off.
>  
>      n = nOld;
>    }
>    nTotalMatchedLines -= nMatchedLines;
>    nTotalMatchedBlocks -= nMatchedBlocks;
>  
>    // Let's see the intermediate results.
>  
>    if (0 < optVerbose) {
>      fprintf (stderr,
>               " found %u/%u matched lines/blocks (%u/%u totals).\n",
>               nMatchedLines,
>               nMatchedBlocks,
>               nTotalMatchedLines,
>               nTotalMatchedBlocks
>              );
>  
>      if (1 < optVerbose) {
>        for (int f = 0; f < 2; f += 1) {
>          fprintf (stderr, "# file #%d\n", f + 1);
>          for (int l = 0; l < lines[f].size (); l += 1) {
>            fprintf (stderr, "#   [%d] ", l);
>            lines[f][l].Dump (stderr);
>          }
174c684
<  
---
> -
185,186c695
< +  // Perform Pass #6, in which we create the desired output.
<  
---
> -
191,194c700
< +  if (0 < optVerbose) {
< +    fprintf (stderr, "# Pass #6 (walking the differences)...\n");
< +  }
<  
---
> -
198,199c704
< +  nMatchedLines = 0;
<  
---
> -
203,207c708,709
< +  // Write the header.
<  
< +  switch (diffFormat) {
< +  case Default:
<    case Normal:
---
> -
> -  case Normal:
209c711
<      break;
---
> -    break;
219c721
<    case Unified:
---
> -  case Unified:
226,230c728,729
< +    fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
< +    fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
< +    fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), lines[1].size ());
<      break;
<    }
---
> -    break;
> -  }
248c747,750
< -  if (0 < optVerbose) {
---
> +
> +  // Perform Pass #6, in which we create the desired output.
> +
>    if (0 < optVerbose) {
252c754,757
< -  nMatchedLines = 0;
---
> +    fprintf (stderr, "# Pass #6 (walking the differences)...\n");
> +  }
> +
>    nMatchedLines = 0;
254c759,760
< -  // Write the header.
---
> +
>    // Write the header.
258c764,776
<  
---
> -
> +
> +  switch (diffFormat) {
> +  case Default:
> +  case Normal:
> +    break;
> +  case Unified:
> +    fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
> +    fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
> +    fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), lines[1].size ());
> +    break;
> +  }
> +
260c778
<  
---
> -
262a781,782
> -
> +
265c785
<  
---
> +
267,268c787,816
<  
< @@ -749,262 +651,96 @@
---
> -
> +
>      // Find any unmatched lines at this point in the old file.  These
>      // are deletes.
> -
> +
>      unsigned boDeletes;
>      for (boDeletes = o;
>           o < lines[0].size () && lines[0][o].l == ~0;
>           o += 1
>          )
>      {}
> -
> +
>      // Find any unmatched lines at this point in the new file.  These
>      // are inserts.
> -
> +
>      unsigned boInserts;
>      for (boInserts = n;
>           n < lines[1].size () && lines[1][n].l == ~0;
>           n += 1
>          )
>      {}
> -
> +
>      // We've got deleted line(s) from boDeletes .. o.
>      // We've got deleted line(s) from boInserts .. n.
> -
> +
271c819
<  
---
> -
291,292c839
< +    // We've got...
<  
---
> -
297,298c844
< +    if (nDeletes && nInserts) {
<  
---
> -
300,312c846,847
< +      // ... deletes and inserts.
<  
< +      switch (diffFormat) {
< +      case Default:
< +      case Normal:
< +        if (1 < nDeletes && 1 < nInserts) {
< +          fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, boInserts + 1, n);
< +        } else if (1 < nDeletes) {
< +          fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boInserts + 1);
< +        } else if (1 < nInserts) {
< +          fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInserts + 1, n);
< +        } 
<          for (unsigned l = boDeletes; l < o; l += 1) {
---
> -
> -        for (unsigned l = boDeletes; l < o; l += 1) {
314,315c849
< +          fprintf (stdout, "< %s", lines[0][l].line->c_str ());
<          }
---
> -        }
332,333c866
< +        fprintf (stderr, "---\n");
<          for (unsigned l = boInserts; l < n; l += 1) {
---
> -        for (unsigned l = boInserts; l < n; l += 1) {
335,336c868
< +          fprintf (stdout, "> %s", lines[1][l].line->c_str ());
<          }
---
> -        }
340,346c872,873
< +        break;
<  
< +      case Unified:
< +        for (unsigned l = boDeletes; l < o; l += 1) {
< +          fprintf (stdout, "-%s", lines[0][l].line->c_str ());
< +        }
<          for (unsigned l = boInserts; l < n; l += 1) {
---
> -
> -        for (unsigned l = boInserts; l < n; l += 1) {
348,349c875
< +          fprintf (stdout, "+%s", lines[1][l].line->c_str ());
<          }
---
> -        }
413c939,940
< -    // We've got...
---
> +
>      // We've got...
415c942,943
< -    if (nDeletes && nInserts) {
---
> +
>      if (nDeletes && nInserts) {
417c945,946
< -      // ... deletes and inserts.
---
> +
>        // ... deletes and inserts.
431a961,979
> -      }
> +
> +      switch (diffFormat) {
> +      case Default:
> +      case Normal:
> +        if (1 < nDeletes && 1 < nInserts) {
> +          fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, boInserts + 1, n);
> +        } else if (1 < nDeletes) {
> +          fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boInserts + 1);
> +        } else if (1 < nInserts) {
> +          fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInserts + 1, n);
> +        } 
> +        for (unsigned l = boDeletes; l < o; l += 1) {
> +          fprintf (stdout, "< %s", lines[0][l].line->c_str ());
> +        }
> +        fprintf (stderr, "---\n");
> +        for (unsigned l = boInserts; l < n; l += 1) {
> +          fprintf (stdout, "> %s", lines[1][l].line->c_str ());
> +        }
433c981,990
<        }
---
> +
> +      case Unified:
> +        for (unsigned l = boDeletes; l < o; l += 1) {
> +          fprintf (stdout, "-%s", lines[0][l].line->c_str ());
> +        }
> +        for (unsigned l = boInserts; l < n; l += 1) {
> +          fprintf (stdout, "+%s", lines[1][l].line->c_str ());
> +        }
> +        break;
> +      }
435c992,993
<  
---
> -
> +
437c995
<  
---
> -
444a1003,1004
> -      }
> +
462c1022
<        }
---
> +      }
464c1024,1025
<  
---
> -
> +
466c1027
<  
---
> -
473a1035,1036
> -      }
> +
491c1054,1065
<        }
---
> +      }
> +    }
> +
> +    // When we get here, we're dealing with matching lines.
> +
> +    switch (diffFormat) {
> +    case Default:
> +    case Normal:
> +      break;
> +    case Unified:
> +      fprintf (stdout, " %s", lines[0][o].line->c_str ());
> +      break;
493,495c1067,1069
<  
<      // When we get here, we're dealing with matching lines.
<  
---
> -
> -    // When we get here, we're dealing with matching lines.
> -
580,587c1154
< +    switch (diffFormat) {
< +    case Default:
< +    case Normal:
< +      break;
< +    case Unified:
< +      fprintf (stdout, " %s", lines[0][o].line->c_str ());
< +      break;
<      }
---
> -    }
594a1162
>  }
# ../sdiff -u dif.5.cpp dif.6.cpp >& dif.5.6.diff-u.test
# dif.5.6.diff-u ---------------------------------------------------------------
1,3c1,725
< --- dif.5.cpp	2008-02-25 19:19:42.000000000 +0000
< +++ dif.6.cpp	2008-02-25 19:54:55.000000000 +0000
< @@ -723,46 +723,98 @@
---
> --- dif.5.cpp	0000-00-00 00:00:00.000000000 +0000
> +++ dif.6.cpp	0000-00-00 00:00:00.000000000 +0000
> @@ -1,1011 +1,1088 @@
>  #include <algorithm>
>  using std::find;
>  #include <string>
>  using std::string;
>  #include <list>
>  using std::list;
>  #include <map>
>  using std::map;
>  #include <vector>
>  using std::vector;
>  #include <stdio.h>
>  
>  enum DiffFormat {
>    Default,
>  
>    Context,
>    EdScript,
>    IfThenElse,
>    Normal,
>    RCS,
>    SideBySide,
>    Unified
>  };
>  
>  DiffFormat diffFormat = Context;
>  unsigned optCopyContext = 3;
>  
>  int optVerbose = 1;
>  
>  struct Line : public string {
>    Line (string _text) :
>      string (_text)
>    {
>    }
>    ~Line () {
>      copies[0].erase (copies[0].begin (), copies[0].end ());
>      copies[1].erase (copies[1].begin (), copies[1].end ());
>    }
>    void Dump (FILE *out) {
>      fprintf (out, "{{ ");
>      for (list<unsigned>::iterator i = copies[0].begin (); i != copies[0].end (); i++) {
>        fprintf (out, "%u ", *i);
>      }
>      fprintf (out, "},{ ");
>      for (list<unsigned>::iterator i = copies[1].begin (); i != copies[1].end (); i++) {
>        fprintf (out, "%u ", *i);
>      }
>      fprintf (out, "}}\t%s", c_str ());
>    }
>    list<unsigned> copies[2];
>  };
>  
>  struct LinePtr {
>    LinePtr (Line *_line) :
>      line (_line),
>      l (~0u)
>    {
>    }
>    void Dump (FILE *out) {
>      fprintf (out, "[%d] ", l);
>      line->Dump (out);
>    }
>    Line *line;
>    unsigned l;
>  };
>  
>  typedef map<string, Line *> MapStringToLinePtr;
>  typedef vector<LinePtr> VectorLinePtr;
>  
>  // Our name.
>  
>  char *ARGV0 = "dif3";
>  
>  // The 'symbol' (line) table.
>  
>  MapStringToLinePtr table;
>  
>  // The names of the 2 files to be diff'd.
>  
>  char const *files[2] = { 0, 0 };
>  
>  // The lines of the 2 files to be diff'd.
>  
>  VectorLinePtr lines[2];
>  
>  // Miscellaneous metrics.
>  
>  unsigned nTotalMatchedBlocks = 0;
>  unsigned nMatchedBlocks = 0;
>  unsigned nTotalMatchedLines = 0;
>  unsigned nMatchedLines = 0;
>  
>  void pass1 ();
>  void pass2 ();
>  void pass3 ();
>  void pass4 ();
>  void pass5 ();
>  void pass6 ();
>  
>  int main (int argc, char *argv[])
>  {
>    // Read the old [0] file, and the new [1] file.
>  
>    for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
>      files[n] = argv[a];
>  
>      if (FILE *f = fopen (files[n], "r")) {
>        if (0 < optVerbose) {
>          fprintf (stderr, "# Reading %s...", files[n]);
>        }
>  
>        char buffer[1024];
>        unsigned nUniq = 0;
>  
>        while (fgets (buffer, sizeof (buffer), f)) {
>          string text (buffer);
>  
>          Line *line = table[text];
>  
>          if (!line) {
>            table[text] = line = new Line (text);
>            nUniq += 1;
>          }
>          line->copies[n].push_back (lines[n].size ());
>          lines[n].push_back (line);
>        }
>  
>        if (0 < optVerbose) {
>          fprintf (stderr, " %u lines, %u unique.\n", lines[n].size (), nUniq);
>        }
>      } else {
>        fprintf (stderr, "%s: Unable to open %s!  Exiting....\n", ARGV0, files[n]);
>        perror (ARGV0);
>        exit (1);
>      }
>    }
>  
>    if (0 < optVerbose) {
>      fprintf (stderr, "# Total unique lines = %d\n", table.size ());
>    }
>  
>    // map<int, int> counts;
>    // for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
>    //   Line *l = i->second;
>    //   counts[l->counts[0].size () + l->counts[1].size ()] += 1;
>    // }
>    // for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
>    //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
>    // }
>  
>    pass1 ();
>    pass2 ();
>    pass3 ();
>    pass4 ();
>    pass5 ();
>    pass6 ();
>  
>    return 0;
>  }
>  
>  // Perform pass #1, in which we find all explicit matches amongst the
>  // unique lines.  For every unique line that appears the same number
>  // of times in both files, we declare the lines to match.
>  
>  void pass1 ()
>  {
>    if (0 < optVerbose) {
>      fprintf (stderr, "# Pass 1 (finding matches amongst unique lines)...");
>    }
>  
>    nMatchedLines = 0;
>  
>    for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
>      Line *l = i->second;
>  
>      // If the number of old and new lines match, then we declare that
>      // they are (all) the same line.  Note, it isn't possible for the
>      // numbers of both files to be 0.
>  
>      // (In the original algorithm, we only recognized a match, here,
>      // if there was exactly 1 copy for each file.)
>  
>      if (l->copies[0].size () == l->copies[1].size ()) {
>        nMatchedLines += 1;
>  
>        // For each matched line in the new file, mark it with the
>        // corresponding line (number) in the old file.
>  
>        while (!l->copies[0].empty ()) {
>          unsigned o = l->copies[0].front ();
>          unsigned n = l->copies[1].front ();
>  
>          // Match up the pair.
>  
>          lines[0][o].l = n;
>          lines[1][n].l = o;
>  
>          // Remove the matched line numbers from the lists.
>  
>          l->copies[0].pop_front ();
>          l->copies[1].pop_front ();
>        }
>      }
>    }
>    nTotalMatchedLines += nMatchedLines;
>  
>    // Let's see the intermediate results.
>  
>    if (0 < optVerbose) {
>      fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
>  
>      if (1 < optVerbose) {
>        for (int f = 0; f < 2; f += 1) {
>          fprintf (stderr, "# file #%d\n", f + 1);
>          for (int l = 0; l < lines[f].size (); l += 1) {
>            fprintf (stderr, "#   [%d] ", l);
>            lines[f][l].Dump (stderr);
>          }
>        }
>      }
>    }
>  }
>  
>  // Perform Pass #2, in which we attempt to 'widen' blocks of matched
>  // lines, by appending lines which are the same in both files.
>  
>  void pass2 ()
>  {
>    if (0 < optVerbose) {
>      fprintf (stderr, "# Pass #2 (spreading matches down)...");
>    }
>  
>    nMatchedBlocks = 0;
>    nMatchedLines = 0;
>  
>    // Starting at the top of the old file,...
>  
>    for (unsigned o = 0; o < lines[0].size (); o += 1) {
>  
>      // ... skip any currently unmatched lines...
>  
>      if (lines[0][o].l == ~0) {
>        continue;
>      }
>  
>      // ... until we find an [already] matched line.  Then, skip over
>      // the set of 1 or more matched lines, until we reach any
>      // following, still-unmatched line.
>  
>      unsigned n;
>      do {
>        n = lines[0][o].l + 1;
>        o += 1;
>      } while (o < lines[0].size () && lines[0][o].l != ~0);
>  
>      // Now, o - 1 is the line number of the last matched old line, and
>      // n - 1 is the line number of the last matched new line.  We want
>      // to add new old and new lines, if they match.
>  
>      // Finally, attempt to add unmatched lines to the preceeding
>      // matched set.
>  
>      for (; o < lines[0].size () && lines[0][o].l == ~0; o += 1, n += 1) {
>  
>        // If the [next] pair of old and new lines aren't the same line, we're done.
>  
>        if (lines[0][o].line != lines[1][n].line) {
>          break;
>        }
>  
>        // Match up the pair.
>  
>        lines[0][o].l = n;
>        lines[1][n].l = o;
>  
>        // Remove the matched line numbers form the lists.
>  
>        Line *line = lines[0][o].line;
>        list<unsigned> &oldCopies = line->copies[0];
>        list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
>        if (oL != oldCopies.end ()) {
>          oldCopies.erase (oL);
>        }
>        list<unsigned> &newCopies = line->copies[0];
>        list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
>        if (nL != newCopies.end ()) {
>          newCopies.erase (nL);
>        }
>  
>        nMatchedLines += 1;
>      }
>      nMatchedBlocks += 1;
>    }
>    nTotalMatchedLines += nMatchedLines;
>    nTotalMatchedBlocks += nMatchedBlocks;
>  
>    // Let's see the intermediate results.
>  
>    if (0 < optVerbose) {
>      fprintf (stderr,
>               " found %u/%u matched lines/blocks (%u/%u totals).\n",
>               nMatchedLines,
>               nMatchedBlocks,
>               nTotalMatchedLines,
>               nTotalMatchedBlocks
>              );
>      if (1 < optVerbose) {
>        for (int f = 0; f < 2; f += 1) {
>          fprintf (stderr, "# file #%d\n", f + 1);
>          for (int l = 0; l < lines[f].size (); l += 1) {
>            fprintf (stderr, "#   [%d] ", l);
>            lines[f][l].Dump (stderr);
>          }
>        }
>      }
>    }
>  }
>  
>  // Perform Pass #3, in which we attempt to 'widen' blocks of matched
>  // lines, by prepending lines which are the same in both files.
>  
>  void pass3 ()
>  {
>    if (0 < optVerbose) {
>      fprintf (stderr, "# Pass #3 (spreading matches up)...");
>    }
>  
>    nMatchedBlocks = 0;
>    nMatchedLines = 0;
>  
>    // Starting at the bottom of the old file,...
>  
>    for (int o = lines[0].size (); 0 <= o; o -= 1) {
>  
>      // ... skip any currently unmatched lines...
>  
>      if (lines[0][o].l == ~0) {
>        continue;
>      }
>  
>      // ... until we find an [already] matched line.  Then, skip over
>      // the set of 1 or more matched lines, until we reach any
>      // following, still-unmatched line.
>  
>      unsigned n;
>      do {
>        n = lines[0][o].l - 1;
>        o -= 1;
>      } while (0 <= o && lines[0][o].l != ~0);
>  
>      // Now, o + 1 is the line number of the last matched old line, and
>      // n + 1 is the line number of the last matched new line.  We want
>      // to add new old and new lines, if they match.
>  
>      // Finally, attempt to add unmatched lines to the preceeding
>      // matched set.
>  
>      for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
>  
>        // If the [next] pair of old and new lines aren't the same line, we're done.
>  
>        if (lines[0][o].line != lines[1][n].line) {
>          break;
>        }
>  
>        // Match up the pair.
>  
>        lines[0][o].l = n;
>        lines[1][n].l = o;
>  
>        // Remove the matched line numbers form the lists.
>  
>        Line *line = lines[0][o].line;
>        list<unsigned> &oldCopies = line->copies[0];
>        list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
>        if (oL != oldCopies.end ()) {
>          oldCopies.erase (oL);
>        }
>        list<unsigned> &newCopies = line->copies[0];
>        list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
>        if (nL != newCopies.end ()) {
>          newCopies.erase (nL);
>        }
>  
>        nMatchedLines += 1;
>      }
>      nMatchedBlocks += 1;
>    }
>    nTotalMatchedLines += nMatchedLines;
>  
>    // Let's see the intermediate results.
>  
>    if (0 < optVerbose) {
>      fprintf (stderr,
>               " found %u/%u matched lines/blocks (%u/%u totals).\n",
>               nMatchedLines,
>               nMatchedBlocks,
>               nTotalMatchedLines,
>               nTotalMatchedBlocks
>              );
>  
>      if (1 < optVerbose) {
>        for (int f = 0; f < 2; f += 1) {
>          fprintf (stderr, "# file #%d\n", f + 1);
>          for (int l = 0; l < lines[f].size (); l += 1) {
>            fprintf (stderr, "#   [%d] ", l);
>            lines[f][l].Dump (stderr);
>          }
>        }
>      }
>    }
>  }
>  
>  // Perform pass #4, in which we find any remaining matches amongst the
>  // unique lines.  For every unique line that has more than 1 copy in
>  // both files, we declare the copies to match.
>  
>  void pass4 ()
>  {
>    if (0 < optVerbose) {
>      fprintf (stderr, "# Pass 4 (finding remaining matches amongst unique lines)...");
>    }
>  
>    nMatchedLines = 0;
>  
>    for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
>      Line *l = i->second;
>  
>      // If there's more than 1 matching old and new lines, then we
>      // declare that each pair are (all) the same line.
>  
>      // (In the original algorithm, we only recognized a match, here,
>      // if there was exactly 1 copy for each file.)
>  
>      while (0 < l->copies[0].size () && 0 < l->copies[1].size ()) {
>        nMatchedLines += 1;
>  
>        // For each matched line in the new file, mark it with the
>        // corresponding line (number) in the old file.
>  
>        unsigned o = l->copies[0].front ();
>        unsigned n = l->copies[1].front ();
>  
>        // Match up the pair.
>  
>        lines[0][o].l = n;
>        lines[1][n].l = o;
>  
>        // Remove the matched line numbers from the lists.
>  
>        l->copies[0].pop_front ();
>        l->copies[1].pop_front ();
>      }
>    }
>    nTotalMatchedLines += nMatchedLines;
>  
>    // Let's see the intermediate results.
>  
>    if (0 < optVerbose) {
>      fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
>  
>      if (1 < optVerbose) {
>        for (int f = 0; f < 2; f += 1) {
>          fprintf (stderr, "# file #%d\n", f + 1);
>          for (int l = 0; l < lines[f].size (); l += 1) {
>            fprintf (stderr, "#   [%d] ", l);
>            lines[f][l].Dump (stderr);
>          }
>        }
>      }
>    }
>  }
>  
>  // Perform Pass #5, in which we look for blocks which match, but are
>  // the result of a move (their not in their original position).  For
>  // these, we'll unmatch the blocks, turning them into a delete and an
>  // insert.
>  
>  void pass5 ()
>  {
>    if (0 < optVerbose) {
>      fprintf (stderr, "# Pass #5 (unmatching block moves)...\n");
>    }
>  
>    nMatchedBlocks = 0;
>    nMatchedLines = 0;
>  
>    // Starting at the top of both files,...
>  
>    unsigned o = 0;
>    unsigned n = 0;
>  
>    while (o < lines[0].size () || n < lines[1].size ()) {
>  
>      // Skip any unmatched lines at this point in the old file.  These
>      // are deletes.
>  
>      //    Old     New
>      //   +---+
>      // 0 | a |
>      //   +---+   +---+
>      //         0 | b |
>      //   +---+   +---+
>      // 1 | c | 1 | c |
>      //   +---+   +---+
>      //         2 | z |
>      //   +---+   +---+
>      // 2 | d | 3 | d |
>      //   +---+   +---+
>  
>      while (o < lines[0].size () && lines[0][o].l == ~0) {
>        o += 1;
>      }
>  
>      // Skip any unmatched lines at this point in the new file.  These
>      // are inserts.
>  
>      while (n < lines[1].size () && lines[1][n].l == ~0) {
>        n += 1;
>      }
>  
>      // When we get here, we know that we're dealing with matching
>      // lines (or the end of one or both files).  We're done with this
>      // pass, if we've reached the end of either file.
>  
>      if (lines[0].size () <= o || lines[1].size () <= n) {
>        break;
>      }
>  
>      // We now know that we've got a pair of matching lines, the start
>      // of a matching block.  If the new file's line number is what we
>      // expect, then the matched pair is unmoved, and we can skip over
>      // the pair.  (If this is really the start of a block of more than
>      // 1 lines, we'll handle it one pair at a time.)
>  
>      if (lines[0][o].l == n) {
>        o += 1;
>        n += 1;
>        continue;
>      }
>  
>      // If, on the other hand, we don't expect this [new] line number,
>      // then this matching block has been moved.  We need to turn the
>      // matched pair into an *unmatched* pair, one of deletes, and one
>      // of inserts.  First, though, we need to know how big this block
>      // is, and how far it was moved....
>  
>      // Remember where we were when we started.
>  
>      unsigned oOld = o;
>      unsigned nOld = n;
>  
>      // Remember where the block came from.
>  
>      unsigned nNew = lines[0][o].l;
>  
>      // Find the end of this matched pair.
>  
>      for (n = nNew; o < lines[0].size () && n < lines[1].size (); o += 1, n += 1) {
>        if (lines[0][o].l != n) {
>          break;
>        }
>      }
>  
>      // When we get here:
>      // * oOld..o is the old file's block,
>      // * nNew..n is the new file's *moved* block, and
>      // * nOld is where we originally expected the new block from.
>   
>      // We can now calculate the length of the block...
>      
>      unsigned bSize = o - oOld;  // (or n - nNew)
>  
>      // ... and we can calculate how far the block moved:
>  
>      unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
>  
>      // The larger of the two will become our delete, and the smaller
>      // will become our insert.
>  
>      //    Old     New
>      //   +---+   +---+
>      // 0 | a | 0 | b |
>      //   +---+ 1 | b |
>      // 1 | b |   +---+
>      // 2 | b | 2 | a |
>      //   +---+   +---+
>      // 3 | c | 3 | c |
>      //   +---+   +---+
>  
>      // (1) Delete a@0, insert a@2, or
>      // (2) insert bb@0, delete bb@1?
>  
>      // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and bMove
>      // (of a) is 2-0 or 2, the size of b@0.  We choose to delete a@0,
>      // and reinsert a@2.
>  
>      // if (bSize <= bMove) {
>        for (unsigned a = oOld; a < o; a += 1) {
>          lines[0][a].l = ~0;
>        }
>        for (unsigned d = nNew; d < n; d += 1) {
>          lines[1][d].l = ~0;
>        }
>      // } else {
>        // for (unsigned a = oOld; a < o; a += 1) {
>        //   lines[0][a].l = ~0;
>        // }
>        // for (unsigned d = nNew; d < n; d += 1) {
>        //   lines[1][d].l = ~0;
>        // }
>      // }
>  
>      // Continue from where we left off.
>  
>      n = nOld;
>    }
>    nTotalMatchedLines -= nMatchedLines;
>    nTotalMatchedBlocks -= nMatchedBlocks;
>  
>    // Let's see the intermediate results.
>  
>    if (0 < optVerbose) {
>      fprintf (stderr,
>               " found %u/%u matched lines/blocks (%u/%u totals).\n",
>               nMatchedLines,
>               nMatchedBlocks,
>               nTotalMatchedLines,
>               nTotalMatchedBlocks
>              );
>  
>      if (1 < optVerbose) {
>        for (int f = 0; f < 2; f += 1) {
>          fprintf (stderr, "# file #%d\n", f + 1);
>          for (int l = 0; l < lines[f].size (); l += 1) {
>            fprintf (stderr, "#   [%d] ", l);
>            lines[f][l].Dump (stderr);
>          }
>        }
>      }
>    }
>  }
>  
>  // Perform Pass #6, in which we create the desired output.
>  
>  void pass6c ();
>  void pass6e ();
>  void pass6i ();
>  void pass6n ();
>  void pass6r ();
>  void pass6s ();
>  void pass6u ();
>  
>  void pass6 ()
>  {
>  
>    switch (diffFormat) {
>    case Context:
>      pass6c ();
>      break;
>  
>    case EdScript:
>      pass6e ();
>      break;
>  
>    case IfThenElse:
>      pass6i ();
>      break;
>  
>    case Normal:
>      pass6n ();
>      break;
>  
>    case RCS:
>      pass6r ();
>      break;
>  
>    case SideBySide:
>      pass6s ();
>      break;
>  
>    case Unified:
>      pass6u ();
>      break;
>  
>    case Default:
>    default:
>      pass6c ();
>      break;
>    }
>  }
>  
>  template<typename T> T min (T l, T r) {
>    if (l < r) {
>      return l;
>    }
>    return r;
>  }
>  
>  template<typename T> T max (T l, T r) {
>    if (l < r) {
>      return r;
>    }
>    return l;
>  }
>  
>  void pass6c () {
>    if (0 < optVerbose) {
>      fprintf (stderr, "# Pass #6u (walking the differences)...\n");
>    }
>  
>    nMatchedLines = 0;
>  
>    // Write the header.
>  
>    fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
>    fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
>  
>    // Starting at the top of both files,...
>  
>    unsigned o = 0;
>    unsigned n = 0;
22,27c744
< +    if (lines[0][o].l != ~0 && lines[1][n].l != ~0) {
< +      o += 1;
< +      n += 1;
< +      continue;
< +    }
<  
---
> -
33a751,824
> -
> -    // We've got deleted line(s) from boDeletes .. o.
> -    // We've got deleted line(s) from boInserts .. n.
> -
> -    unsigned nDeletes = o - boDeletes;
> -    unsigned nInserts = n - boInserts;
> -
> -    // Have we got anything?
> -
> -    if (nDeletes || nInserts) {
> -      int boOldWindow = max (0, int (boDeletes) - int(optCopyContext));
> -      int eoOldWindow = min (int (lines[0].size ()), int(o) + int(optCopyContext));
> -
> -      int boNewWindow = max (0, int (boInserts) - int (optCopyContext));
> -      int eoNewWindow = min (int (lines[1].size ()), int(n) + int (optCopyContext));
> -
> -      fprintf (stdout, "***************\n*** %d,%d ****", boOldWindow, eoOldWindow);
> -      for (unsigned l = boOldWindow; l < boDeletes; l += 1) {
> -        fprintf (stdout, "  %s", lines[0][l].line->c_str ());
> -      }
> -
> -      // We've got...
> -
> -      if (nDeletes && nInserts) {
> -
> -        // ... deletes and inserts.
> -
> -        for (unsigned l = boDeletes; l < o; l += 1) {
> -          fprintf (stdout, "! %s", lines[0][l].line->c_str ());
> -        }
> -      } else if (nDeletes) {
> -
> -        //  ... just deletes.
> -
> -        for (unsigned l = boDeletes; l < o; l += 1) {
> -          fprintf (stdout, "- %s", lines[0][l].line->c_str ());
> -        }
> -      }
> -
> -      for (unsigned l = o; l < eoOldWindow; l += 1) {
> -        fprintf (stdout, "  %s", lines[0][l].line->c_str ());
> -      }
> -      fprintf (stdout, "--- %d,%d ----", boNewWindow, eoNewWindow);
> -      for (unsigned l = boNewWindow; l < boInserts; l += 1) {
> -        fprintf (stdout, "  %s", lines[1][l].line->c_str ());
> -      }
> -
> -      // We've got...
> -
> -      if (nDeletes && nInserts) {
> -
> -        // ... deletes and inserts.
> -
> -        for (unsigned l = boInserts; l < n; l += 1) {
> -          fprintf (stdout, "! %s", lines[1][l].line->c_str ());
> -        }
> -      } else if (nInserts) {
> -
> -        //  ... just inserts.
> -
> -        for (unsigned l = boInserts; l < n; l += 1) {
> -          fprintf (stdout, "+ %s", lines[1][l].line->c_str ());
> -        }
> -      }
> -
> -      for (unsigned l = n; l < eoNewWindow; l += 1) {
> -        fprintf (stdout, "  %s", lines[1][l].line->c_str ());
> -      }
> +    if (lines[0][o].l != ~0 && lines[1][n].l != ~0) {
> +      o += 1;
> +      n += 1;
> +      continue;
>      }
> +
76,77c867
< -    // We've got deleted line(s) from boDeletes .. o.
< -    // We've got deleted line(s) from boInserts .. n.
---
> -    // When we get here, we're dealing with matching lines.
80,81c870,871
< -    unsigned nDeletes = o - boDeletes;
< -    unsigned nInserts = n - boInserts;
---
> -    o += 1;
> -    n += 1;
91,92c881
<  
< -    // Have we got anything?
---
> +
95,105c884
<  
< -    if (nDeletes || nInserts) {
< -      int boOldWindow = max (0, int (boDeletes) - int(optCopyContext));
< -      int eoOldWindow = min (int (lines[0].size ()), int(o) + int(optCopyContext));
< -
< -      int boNewWindow = max (0, int (boInserts) - int (optCopyContext));
< -      int eoNewWindow = min (int (lines[1].size ()), int(n) + int (optCopyContext));
< -
< -      fprintf (stdout, "***************\n*** %d,%d ****", boOldWindow, eoOldWindow);
< -      for (unsigned l = boOldWindow; l < boDeletes; l += 1) {
< -        fprintf (stdout, "  %s", lines[0][l].line->c_str ());
---
> +
114,115c893,894
<        }
<  
---
> +      }
> +
130,138c909,926
<        // We've got...
<  
<        if (nDeletes && nInserts) {
< @@ -781,14 +833,42 @@
<          }
<        }
<  
< -      for (unsigned l = o; l < eoOldWindow; l += 1) {
< -        fprintf (stdout, "  %s", lines[0][l].line->c_str ());
---
> +      // We've got...
> +
> +      if (nDeletes && nInserts) {
> +
> +        // ... deletes and inserts.
> +
> +        for (unsigned l = boDeletes; l < o; l += 1) {
> +          fprintf (stdout, "! %s", lines[0][l].line->c_str ());
> +        }
> +      } else if (nDeletes) {
> +
> +        //  ... just deletes.
> +
> +        for (unsigned l = boDeletes; l < o; l += 1) {
> +          fprintf (stdout, "- %s", lines[0][l].line->c_str ());
> +        }
> +      }
> +
159,162c947
<        }
< -      fprintf (stdout, "--- %d,%d ----", boNewWindow, eoNewWindow);
< -      for (unsigned l = boNewWindow; l < boInserts; l += 1) {
< -        fprintf (stdout, "  %s", lines[1][l].line->c_str ());
---
> +      }
170,171c955,956
<        }
<  
---
> +      }
> +
178,190c963,980
<        // We've got...
<  
<        if (nDeletes && nInserts) {
< @@ -807,15 +887,12 @@
<          }
<        }
<  
< -      for (unsigned l = n; l < eoNewWindow; l += 1) {
< -        fprintf (stdout, "  %s", lines[1][l].line->c_str ());
< -      }
< -    }
< -
< -    // When we get here, we're dealing with matching lines.
---
> +      // We've got...
> +
> +      if (nDeletes && nInserts) {
> +
> +        // ... deletes and inserts.
> +
> +        for (unsigned l = boInserts; l < n; l += 1) {
> +          fprintf (stdout, "! %s", lines[1][l].line->c_str ());
> +        }
> +      } else if (nInserts) {
> +
> +        //  ... just inserts.
> +
> +        for (unsigned l = boInserts; l < n; l += 1) {
> +          fprintf (stdout, "+ %s", lines[1][l].line->c_str ());
> +        }
> +      }
> +
192,194c982
<  
< -    o += 1;
< -    n += 1;
---
> +
201a990,1179
>  void pass6e () {
>  }
>  
>  void pass6i () {
>  }
>  
>  void pass6n ()
>  {
>    if (0 < optVerbose) {
>      fprintf (stderr, "# Pass #6n (walking the differences)...\n");
>    }
>  
>    nMatchedLines = 0;
>  
>    // Write the header.  (None for normal.)
>  
>    // Starting at the top of both files,...
>  
>    unsigned o = 0;
>    unsigned n = 0;
>  
>    while (o < lines[0].size () || n < lines[1].size ()) {
>  
>      // Find any unmatched lines at this point in the old file.  These
>      // are deletes.
>  
>      unsigned boDeletes;
>      for (boDeletes = o;
>           o < lines[0].size () && lines[0][o].l == ~0;
>           o += 1
>          )
>      {}
>  
>      // Find any unmatched lines at this point in the new file.  These
>      // are inserts.
>  
>      unsigned boInserts;
>      for (boInserts = n;
>           n < lines[1].size () && lines[1][n].l == ~0;
>           n += 1
>          )
>      {}
>  
>      // We've got deleted line(s) from boDeletes .. o.
>      // We've got deleted line(s) from boInserts .. n.
>  
>      unsigned nDeletes = o - boDeletes;
>      unsigned nInserts = n - boInserts;
>  
>      // We've got...
>  
>      if (nDeletes && nInserts) {
>  
>        // ... deletes and inserts.
>  
>        if (1 < nDeletes && 1 < nInserts) {
>          fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, boInserts + 1, n);
>        } else if (1 < nDeletes) {
>          fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boInserts + 1);
>        } else if (1 < nInserts) {
>          fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInserts + 1, n);
>        } 
>        for (unsigned l = boDeletes; l < o; l += 1) {
>          fprintf (stdout, "< %s", lines[0][l].line->c_str ());
>        }
>        fprintf (stderr, "---\n");
>        for (unsigned l = boInserts; l < n; l += 1) {
>          fprintf (stdout, "> %s", lines[1][l].line->c_str ());
>        }
>      } else if (nDeletes) {
>  
>        //  ... just deletes.
>  
>        if (1 < nDeletes) {
>          fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
>        } else {
>          fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
>        }
>        for (unsigned l = boDeletes; l < o; l += 1) {
>          fprintf (stdout, "< %s", lines[0][l].line->c_str ());
>        }
>      } else if (nInserts) {
>  
>        //  ... just inserts.
>  
>        if (1 < nInserts) {
>          fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
>        } else {
>          fprintf (stdout, "%da%d\n", o, boInserts + 1);
>        }
>        for (unsigned l = boInserts; l < n; l += 1) {
>          fprintf (stdout, "> %s", lines[1][l].line->c_str ());
>        }
>      }
>  
>      // When we get here, we're dealing with matching lines.
>  
>      o += 1;
>      n += 1;
>    }
>  }
>  
>  void pass6r () {
>  }
>  
>  void pass6s () {
>  }
>  
>  void pass6u ()
>  {
>    if (0 < optVerbose) {
>      fprintf (stderr, "# Pass #6u (walking the differences)...\n");
>    }
>  
>    nMatchedLines = 0;
>  
>    // Write the header.
>  
>    fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
>    fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
>    fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), lines[1].size ());
>  
>    // Starting at the top of both files,...
>  
>    unsigned o = 0;
>    unsigned n = 0;
>  
>    while (o < lines[0].size () || n < lines[1].size ()) {
>  
>      // Find any unmatched lines at this point in the old file.  These
>      // are deletes.
>  
>      unsigned boDeletes;
>      for (boDeletes = o;
>           o < lines[0].size () && lines[0][o].l == ~0;
>           o += 1
>          )
>      {}
>  
>      // Find any unmatched lines at this point in the new file.  These
>      // are inserts.
>  
>      unsigned boInserts;
>      for (boInserts = n;
>           n < lines[1].size () && lines[1][n].l == ~0;
>           n += 1
>          )
>      {}
>  
>      // We've got deleted line(s) from boDeletes .. o.
>      // We've got deleted line(s) from boInserts .. n.
>  
>      unsigned nDeletes = o - boDeletes;
>      unsigned nInserts = n - boInserts;
>  
>      // We've got...
>  
>      if (nDeletes && nInserts) {
>  
>        // ... deletes and inserts.
>  
>        for (unsigned l = boDeletes; l < o; l += 1) {
>          fprintf (stdout, "-%s", lines[0][l].line->c_str ());
>        }
>        for (unsigned l = boInserts; l < n; l += 1) {
>          fprintf (stdout, "+%s", lines[1][l].line->c_str ());
>        }
>      } else if (nDeletes) {
>  
>        //  ... just deletes.
>  
>        for (unsigned l = boDeletes; l < o; l += 1) {
>          fprintf (stdout, "-%s", lines[0][l].line->c_str ());
>        }
>      } else if (nInserts) {
>  
>        //  ... just inserts.
>  
>        for (unsigned l = boInserts; l < n; l += 1) {
>          fprintf (stdout, "+%s", lines[1][l].line->c_str ());
>        }
>      }
>  
>      // When we get here, we're dealing with matching lines.
>  
>      fprintf (stdout, " %s", lines[0][o].line->c_str ());
>      o += 1;
>      n += 1;
>    }
>  }
# ../sdiff -u dif.6.cpp dif.5.cpp >& dif.6.5.diff-u.test
# dif.6.5.diff-u ---------------------------------------------------------------
1,3c1,725
< --- dif.6.cpp	2008-02-25 19:54:55.000000000 +0000
< +++ dif.5.cpp	2008-02-25 19:19:42.000000000 +0000
< @@ -723,98 +723,46 @@
---
> --- dif.6.cpp	0000-00-00 00:00:00.000000000 +0000
> +++ dif.5.cpp	0000-00-00 00:00:00.000000000 +0000
> @@ -1,1088 +1,1011 @@
>  #include <algorithm>
>  using std::find;
>  #include <string>
>  using std::string;
>  #include <list>
>  using std::list;
>  #include <map>
>  using std::map;
>  #include <vector>
>  using std::vector;
>  #include <stdio.h>
>  
>  enum DiffFormat {
>    Default,
>  
>    Context,
>    EdScript,
>    IfThenElse,
>    Normal,
>    RCS,
>    SideBySide,
>    Unified
>  };
>  
>  DiffFormat diffFormat = Context;
>  unsigned optCopyContext = 3;
>  
>  int optVerbose = 1;
>  
>  struct Line : public string {
>    Line (string _text) :
>      string (_text)
>    {
>    }
>    ~Line () {
>      copies[0].erase (copies[0].begin (), copies[0].end ());
>      copies[1].erase (copies[1].begin (), copies[1].end ());
>    }
>    void Dump (FILE *out) {
>      fprintf (out, "{{ ");
>      for (list<unsigned>::iterator i = copies[0].begin (); i != copies[0].end (); i++) {
>        fprintf (out, "%u ", *i);
>      }
>      fprintf (out, "},{ ");
>      for (list<unsigned>::iterator i = copies[1].begin (); i != copies[1].end (); i++) {
>        fprintf (out, "%u ", *i);
>      }
>      fprintf (out, "}}\t%s", c_str ());
>    }
>    list<unsigned> copies[2];
>  };
>  
>  struct LinePtr {
>    LinePtr (Line *_line) :
>      line (_line),
>      l (~0u)
>    {
>    }
>    void Dump (FILE *out) {
>      fprintf (out, "[%d] ", l);
>      line->Dump (out);
>    }
>    Line *line;
>    unsigned l;
>  };
>  
>  typedef map<string, Line *> MapStringToLinePtr;
>  typedef vector<LinePtr> VectorLinePtr;
>  
>  // Our name.
>  
>  char *ARGV0 = "dif3";
>  
>  // The 'symbol' (line) table.
>  
>  MapStringToLinePtr table;
>  
>  // The names of the 2 files to be diff'd.
>  
>  char const *files[2] = { 0, 0 };
>  
>  // The lines of the 2 files to be diff'd.
>  
>  VectorLinePtr lines[2];
>  
>  // Miscellaneous metrics.
>  
>  unsigned nTotalMatchedBlocks = 0;
>  unsigned nMatchedBlocks = 0;
>  unsigned nTotalMatchedLines = 0;
>  unsigned nMatchedLines = 0;
>  
>  void pass1 ();
>  void pass2 ();
>  void pass3 ();
>  void pass4 ();
>  void pass5 ();
>  void pass6 ();
>  
>  int main (int argc, char *argv[])
>  {
>    // Read the old [0] file, and the new [1] file.
>  
>    for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
>      files[n] = argv[a];
>  
>      if (FILE *f = fopen (files[n], "r")) {
>        if (0 < optVerbose) {
>          fprintf (stderr, "# Reading %s...", files[n]);
>        }
>  
>        char buffer[1024];
>        unsigned nUniq = 0;
>  
>        while (fgets (buffer, sizeof (buffer), f)) {
>          string text (buffer);
>  
>          Line *line = table[text];
>  
>          if (!line) {
>            table[text] = line = new Line (text);
>            nUniq += 1;
>          }
>          line->copies[n].push_back (lines[n].size ());
>          lines[n].push_back (line);
>        }
>  
>        if (0 < optVerbose) {
>          fprintf (stderr, " %u lines, %u unique.\n", lines[n].size (), nUniq);
>        }
>      } else {
>        fprintf (stderr, "%s: Unable to open %s!  Exiting....\n", ARGV0, files[n]);
>        perror (ARGV0);
>        exit (1);
>      }
>    }
>  
>    if (0 < optVerbose) {
>      fprintf (stderr, "# Total unique lines = %d\n", table.size ());
>    }
>  
>    // map<int, int> counts;
>    // for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
>    //   Line *l = i->second;
>    //   counts[l->counts[0].size () + l->counts[1].size ()] += 1;
>    // }
>    // for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
>    //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
>    // }
>  
>    pass1 ();
>    pass2 ();
>    pass3 ();
>    pass4 ();
>    pass5 ();
>    pass6 ();
>  
>    return 0;
>  }
>  
>  // Perform pass #1, in which we find all explicit matches amongst the
>  // unique lines.  For every unique line that appears the same number
>  // of times in both files, we declare the lines to match.
>  
>  void pass1 ()
>  {
>    if (0 < optVerbose) {
>      fprintf (stderr, "# Pass 1 (finding matches amongst unique lines)...");
>    }
>  
>    nMatchedLines = 0;
>  
>    for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
>      Line *l = i->second;
>  
>      // If the number of old and new lines match, then we declare that
>      // they are (all) the same line.  Note, it isn't possible for the
>      // numbers of both files to be 0.
>  
>      // (In the original algorithm, we only recognized a match, here,
>      // if there was exactly 1 copy for each file.)
>  
>      if (l->copies[0].size () == l->copies[1].size ()) {
>        nMatchedLines += 1;
>  
>        // For each matched line in the new file, mark it with the
>        // corresponding line (number) in the old file.
>  
>        while (!l->copies[0].empty ()) {
>          unsigned o = l->copies[0].front ();
>          unsigned n = l->copies[1].front ();
>  
>          // Match up the pair.
>  
>          lines[0][o].l = n;
>          lines[1][n].l = o;
>  
>          // Remove the matched line numbers from the lists.
>  
>          l->copies[0].pop_front ();
>          l->copies[1].pop_front ();
>        }
>      }
>    }
>    nTotalMatchedLines += nMatchedLines;
>  
>    // Let's see the intermediate results.
>  
>    if (0 < optVerbose) {
>      fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
>  
>      if (1 < optVerbose) {
>        for (int f = 0; f < 2; f += 1) {
>          fprintf (stderr, "# file #%d\n", f + 1);
>          for (int l = 0; l < lines[f].size (); l += 1) {
>            fprintf (stderr, "#   [%d] ", l);
>            lines[f][l].Dump (stderr);
>          }
>        }
>      }
>    }
>  }
>  
>  // Perform Pass #2, in which we attempt to 'widen' blocks of matched
>  // lines, by appending lines which are the same in both files.
>  
>  void pass2 ()
>  {
>    if (0 < optVerbose) {
>      fprintf (stderr, "# Pass #2 (spreading matches down)...");
>    }
>  
>    nMatchedBlocks = 0;
>    nMatchedLines = 0;
>  
>    // Starting at the top of the old file,...
>  
>    for (unsigned o = 0; o < lines[0].size (); o += 1) {
>  
>      // ... skip any currently unmatched lines...
>  
>      if (lines[0][o].l == ~0) {
>        continue;
>      }
>  
>      // ... until we find an [already] matched line.  Then, skip over
>      // the set of 1 or more matched lines, until we reach any
>      // following, still-unmatched line.
>  
>      unsigned n;
>      do {
>        n = lines[0][o].l + 1;
>        o += 1;
>      } while (o < lines[0].size () && lines[0][o].l != ~0);
>  
>      // Now, o - 1 is the line number of the last matched old line, and
>      // n - 1 is the line number of the last matched new line.  We want
>      // to add new old and new lines, if they match.
>  
>      // Finally, attempt to add unmatched lines to the preceeding
>      // matched set.
>  
>      for (; o < lines[0].size () && lines[0][o].l == ~0; o += 1, n += 1) {
>  
>        // If the [next] pair of old and new lines aren't the same line, we're done.
>  
>        if (lines[0][o].line != lines[1][n].line) {
>          break;
>        }
>  
>        // Match up the pair.
>  
>        lines[0][o].l = n;
>        lines[1][n].l = o;
>  
>        // Remove the matched line numbers form the lists.
>  
>        Line *line = lines[0][o].line;
>        list<unsigned> &oldCopies = line->copies[0];
>        list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
>        if (oL != oldCopies.end ()) {
>          oldCopies.erase (oL);
>        }
>        list<unsigned> &newCopies = line->copies[0];
>        list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
>        if (nL != newCopies.end ()) {
>          newCopies.erase (nL);
>        }
>  
>        nMatchedLines += 1;
>      }
>      nMatchedBlocks += 1;
>    }
>    nTotalMatchedLines += nMatchedLines;
>    nTotalMatchedBlocks += nMatchedBlocks;
>  
>    // Let's see the intermediate results.
>  
>    if (0 < optVerbose) {
>      fprintf (stderr,
>               " found %u/%u matched lines/blocks (%u/%u totals).\n",
>               nMatchedLines,
>               nMatchedBlocks,
>               nTotalMatchedLines,
>               nTotalMatchedBlocks
>              );
>      if (1 < optVerbose) {
>        for (int f = 0; f < 2; f += 1) {
>          fprintf (stderr, "# file #%d\n", f + 1);
>          for (int l = 0; l < lines[f].size (); l += 1) {
>            fprintf (stderr, "#   [%d] ", l);
>            lines[f][l].Dump (stderr);
>          }
>        }
>      }
>    }
>  }
>  
>  // Perform Pass #3, in which we attempt to 'widen' blocks of matched
>  // lines, by prepending lines which are the same in both files.
>  
>  void pass3 ()
>  {
>    if (0 < optVerbose) {
>      fprintf (stderr, "# Pass #3 (spreading matches up)...");
>    }
>  
>    nMatchedBlocks = 0;
>    nMatchedLines = 0;
>  
>    // Starting at the bottom of the old file,...
>  
>    for (int o = lines[0].size (); 0 <= o; o -= 1) {
>  
>      // ... skip any currently unmatched lines...
>  
>      if (lines[0][o].l == ~0) {
>        continue;
>      }
>  
>      // ... until we find an [already] matched line.  Then, skip over
>      // the set of 1 or more matched lines, until we reach any
>      // following, still-unmatched line.
>  
>      unsigned n;
>      do {
>        n = lines[0][o].l - 1;
>        o -= 1;
>      } while (0 <= o && lines[0][o].l != ~0);
>  
>      // Now, o + 1 is the line number of the last matched old line, and
>      // n + 1 is the line number of the last matched new line.  We want
>      // to add new old and new lines, if they match.
>  
>      // Finally, attempt to add unmatched lines to the preceeding
>      // matched set.
>  
>      for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
>  
>        // If the [next] pair of old and new lines aren't the same line, we're done.
>  
>        if (lines[0][o].line != lines[1][n].line) {
>          break;
>        }
>  
>        // Match up the pair.
>  
>        lines[0][o].l = n;
>        lines[1][n].l = o;
>  
>        // Remove the matched line numbers form the lists.
>  
>        Line *line = lines[0][o].line;
>        list<unsigned> &oldCopies = line->copies[0];
>        list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
>        if (oL != oldCopies.end ()) {
>          oldCopies.erase (oL);
>        }
>        list<unsigned> &newCopies = line->copies[0];
>        list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
>        if (nL != newCopies.end ()) {
>          newCopies.erase (nL);
>        }
>  
>        nMatchedLines += 1;
>      }
>      nMatchedBlocks += 1;
>    }
>    nTotalMatchedLines += nMatchedLines;
>  
>    // Let's see the intermediate results.
>  
>    if (0 < optVerbose) {
>      fprintf (stderr,
>               " found %u/%u matched lines/blocks (%u/%u totals).\n",
>               nMatchedLines,
>               nMatchedBlocks,
>               nTotalMatchedLines,
>               nTotalMatchedBlocks
>              );
>  
>      if (1 < optVerbose) {
>        for (int f = 0; f < 2; f += 1) {
>          fprintf (stderr, "# file #%d\n", f + 1);
>          for (int l = 0; l < lines[f].size (); l += 1) {
>            fprintf (stderr, "#   [%d] ", l);
>            lines[f][l].Dump (stderr);
>          }
>        }
>      }
>    }
>  }
>  
>  // Perform pass #4, in which we find any remaining matches amongst the
>  // unique lines.  For every unique line that has more than 1 copy in
>  // both files, we declare the copies to match.
>  
>  void pass4 ()
>  {
>    if (0 < optVerbose) {
>      fprintf (stderr, "# Pass 4 (finding remaining matches amongst unique lines)...");
>    }
>  
>    nMatchedLines = 0;
>  
>    for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
>      Line *l = i->second;
>  
>      // If there's more than 1 matching old and new lines, then we
>      // declare that each pair are (all) the same line.
>  
>      // (In the original algorithm, we only recognized a match, here,
>      // if there was exactly 1 copy for each file.)
>  
>      while (0 < l->copies[0].size () && 0 < l->copies[1].size ()) {
>        nMatchedLines += 1;
>  
>        // For each matched line in the new file, mark it with the
>        // corresponding line (number) in the old file.
>  
>        unsigned o = l->copies[0].front ();
>        unsigned n = l->copies[1].front ();
>  
>        // Match up the pair.
>  
>        lines[0][o].l = n;
>        lines[1][n].l = o;
>  
>        // Remove the matched line numbers from the lists.
>  
>        l->copies[0].pop_front ();
>        l->copies[1].pop_front ();
>      }
>    }
>    nTotalMatchedLines += nMatchedLines;
>  
>    // Let's see the intermediate results.
>  
>    if (0 < optVerbose) {
>      fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
>  
>      if (1 < optVerbose) {
>        for (int f = 0; f < 2; f += 1) {
>          fprintf (stderr, "# file #%d\n", f + 1);
>          for (int l = 0; l < lines[f].size (); l += 1) {
>            fprintf (stderr, "#   [%d] ", l);
>            lines[f][l].Dump (stderr);
>          }
>        }
>      }
>    }
>  }
>  
>  // Perform Pass #5, in which we look for blocks which match, but are
>  // the result of a move (their not in their original position).  For
>  // these, we'll unmatch the blocks, turning them into a delete and an
>  // insert.
>  
>  void pass5 ()
>  {
>    if (0 < optVerbose) {
>      fprintf (stderr, "# Pass #5 (unmatching block moves)...\n");
>    }
>  
>    nMatchedBlocks = 0;
>    nMatchedLines = 0;
>  
>    // Starting at the top of both files,...
>  
>    unsigned o = 0;
>    unsigned n = 0;
>  
>    while (o < lines[0].size () || n < lines[1].size ()) {
>  
>      // Skip any unmatched lines at this point in the old file.  These
>      // are deletes.
>  
>      //    Old     New
>      //   +---+
>      // 0 | a |
>      //   +---+   +---+
>      //         0 | b |
>      //   +---+   +---+
>      // 1 | c | 1 | c |
>      //   +---+   +---+
>      //         2 | z |
>      //   +---+   +---+
>      // 2 | d | 3 | d |
>      //   +---+   +---+
>  
>      while (o < lines[0].size () && lines[0][o].l == ~0) {
>        o += 1;
>      }
>  
>      // Skip any unmatched lines at this point in the new file.  These
>      // are inserts.
>  
>      while (n < lines[1].size () && lines[1][n].l == ~0) {
>        n += 1;
>      }
>  
>      // When we get here, we know that we're dealing with matching
>      // lines (or the end of one or both files).  We're done with this
>      // pass, if we've reached the end of either file.
>  
>      if (lines[0].size () <= o || lines[1].size () <= n) {
>        break;
>      }
>  
>      // We now know that we've got a pair of matching lines, the start
>      // of a matching block.  If the new file's line number is what we
>      // expect, then the matched pair is unmoved, and we can skip over
>      // the pair.  (If this is really the start of a block of more than
>      // 1 lines, we'll handle it one pair at a time.)
>  
>      if (lines[0][o].l == n) {
>        o += 1;
>        n += 1;
>        continue;
>      }
>  
>      // If, on the other hand, we don't expect this [new] line number,
>      // then this matching block has been moved.  We need to turn the
>      // matched pair into an *unmatched* pair, one of deletes, and one
>      // of inserts.  First, though, we need to know how big this block
>      // is, and how far it was moved....
>  
>      // Remember where we were when we started.
>  
>      unsigned oOld = o;
>      unsigned nOld = n;
>  
>      // Remember where the block came from.
>  
>      unsigned nNew = lines[0][o].l;
>  
>      // Find the end of this matched pair.
>  
>      for (n = nNew; o < lines[0].size () && n < lines[1].size (); o += 1, n += 1) {
>        if (lines[0][o].l != n) {
>          break;
>        }
>      }
>  
>      // When we get here:
>      // * oOld..o is the old file's block,
>      // * nNew..n is the new file's *moved* block, and
>      // * nOld is where we originally expected the new block from.
>   
>      // We can now calculate the length of the block...
>      
>      unsigned bSize = o - oOld;  // (or n - nNew)
>  
>      // ... and we can calculate how far the block moved:
>  
>      unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
>  
>      // The larger of the two will become our delete, and the smaller
>      // will become our insert.
>  
>      //    Old     New
>      //   +---+   +---+
>      // 0 | a | 0 | b |
>      //   +---+ 1 | b |
>      // 1 | b |   +---+
>      // 2 | b | 2 | a |
>      //   +---+   +---+
>      // 3 | c | 3 | c |
>      //   +---+   +---+
>  
>      // (1) Delete a@0, insert a@2, or
>      // (2) insert bb@0, delete bb@1?
>  
>      // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and bMove
>      // (of a) is 2-0 or 2, the size of b@0.  We choose to delete a@0,
>      // and reinsert a@2.
>  
>      // if (bSize <= bMove) {
>        for (unsigned a = oOld; a < o; a += 1) {
>          lines[0][a].l = ~0;
>        }
>        for (unsigned d = nNew; d < n; d += 1) {
>          lines[1][d].l = ~0;
>        }
>      // } else {
>        // for (unsigned a = oOld; a < o; a += 1) {
>        //   lines[0][a].l = ~0;
>        // }
>        // for (unsigned d = nNew; d < n; d += 1) {
>        //   lines[1][d].l = ~0;
>        // }
>      // }
>  
>      // Continue from where we left off.
>  
>      n = nOld;
>    }
>    nTotalMatchedLines -= nMatchedLines;
>    nTotalMatchedBlocks -= nMatchedBlocks;
>  
>    // Let's see the intermediate results.
>  
>    if (0 < optVerbose) {
>      fprintf (stderr,
>               " found %u/%u matched lines/blocks (%u/%u totals).\n",
>               nMatchedLines,
>               nMatchedBlocks,
>               nTotalMatchedLines,
>               nTotalMatchedBlocks
>              );
>  
>      if (1 < optVerbose) {
>        for (int f = 0; f < 2; f += 1) {
>          fprintf (stderr, "# file #%d\n", f + 1);
>          for (int l = 0; l < lines[f].size (); l += 1) {
>            fprintf (stderr, "#   [%d] ", l);
>            lines[f][l].Dump (stderr);
>          }
>        }
>      }
>    }
>  }
>  
>  // Perform Pass #6, in which we create the desired output.
>  
>  void pass6c ();
>  void pass6e ();
>  void pass6i ();
>  void pass6n ();
>  void pass6r ();
>  void pass6s ();
>  void pass6u ();
>  
>  void pass6 ()
>  {
>  
>    switch (diffFormat) {
>    case Context:
>      pass6c ();
>      break;
>  
>    case EdScript:
>      pass6e ();
>      break;
>  
>    case IfThenElse:
>      pass6i ();
>      break;
>  
>    case Normal:
>      pass6n ();
>      break;
>  
>    case RCS:
>      pass6r ();
>      break;
>  
>    case SideBySide:
>      pass6s ();
>      break;
>  
>    case Unified:
>      pass6u ();
>      break;
>  
>    case Default:
>    default:
>      pass6c ();
>      break;
>    }
>  }
>  
>  template<typename T> T min (T l, T r) {
>    if (l < r) {
>      return l;
>    }
>    return r;
>  }
>  
>  template<typename T> T max (T l, T r) {
>    if (l < r) {
>      return r;
>    }
>    return l;
>  }
>  
>  void pass6c () {
>    if (0 < optVerbose) {
>      fprintf (stderr, "# Pass #6u (walking the differences)...\n");
>    }
>  
>    nMatchedLines = 0;
>  
>    // Write the header.
>  
>    fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
>    fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
>  
>    // Starting at the top of both files,...
>  
>    unsigned o = 0;
>    unsigned n = 0;
8c730,732
< -
---
> +    // Find any unmatched lines at this point in the old file.  These
> +    // are deletes.
>  
11c735,741
< -
---
> +    unsigned boDeletes;
> +    for (boDeletes = o;
> +         o < lines[0].size () && lines[0][o].l == ~0;
> +         o += 1
> +        )
> +    {}
>  
17c747,749
< -
---
> +    // Find any unmatched lines at this point in the new file.  These
> +    // are inserts.
>  
23c755,761
< -
---
> +    unsigned boInserts;
> +    for (boInserts = n;
> +         n < lines[1].size () && lines[1][n].l == ~0;
> +         n += 1
> +        )
> +    {}
>  
25c763,765
< -
---
> +    // We've got deleted line(s) from boDeletes .. o.
> +    // We've got deleted line(s) from boInserts .. n.
>  
28c768,770
< -
---
> +    unsigned nDeletes = o - boDeletes;
> +    unsigned nInserts = n - boInserts;
>  
31c773,774
< -
---
> +    // Have we got anything?
>  
38c781,784
< -
---
> +    if (nDeletes || nInserts) {
> +      int boOldWindow = max (0, int (boDeletes) - int(optCopyContext));
> +      int eoOldWindow = min (int (lines[0].size ()), int(o) + int(optCopyContext));
>  
43c789,791
< -
---
> +      int boNewWindow = max (0, int (boInserts) - int (optCopyContext));
> +      int eoNewWindow = min (int (lines[1].size ()), int(n) + int (optCopyContext));
>  
68,70c816
< +    // Find any unmatched lines at this point in the old file.  These
< +    // are deletes.
<  
---
> -
73,79c819
< +    unsigned boDeletes;
< +    for (boDeletes = o;
< +         o < lines[0].size () && lines[0][o].l == ~0;
< +         o += 1
< +        )
< +    {}
<  
---
> -
82,84c822
< +    // Find any unmatched lines at this point in the new file.  These
< +    // are inserts.
<  
---
> -
86,92c824
< +    unsigned boInserts;
< +    for (boInserts = n;
< +         n < lines[1].size () && lines[1][n].l == ~0;
< +         n += 1
< +        )
< +    {}
<  
---
> -
95,97c827
< +    // We've got deleted line(s) from boDeletes .. o.
< +    // We've got deleted line(s) from boInserts .. n.
<  
---
> -
102,104c832
< +    unsigned nDeletes = o - boDeletes;
< +    unsigned nInserts = n - boInserts;
<  
---
> -
107,108c835
< +    // Have we got anything?
<  
---
> -
112,123c839,840
< +    if (nDeletes || nInserts) {
< +      int boOldWindow = max (0, int (boDeletes) - int(optCopyContext));
< +      int eoOldWindow = min (int (lines[0].size ()), int(o) + int(optCopyContext));
< +
< +      int boNewWindow = max (0, int (boInserts) - int (optCopyContext));
< +      int eoNewWindow = min (int (lines[1].size ()), int(n) + int (optCopyContext));
< +
< +      fprintf (stdout, "***************\n*** %d,%d ****", boOldWindow, eoOldWindow);
< +      for (unsigned l = boOldWindow; l < boDeletes; l += 1) {
< +        fprintf (stdout, "  %s", lines[0][l].line->c_str ());
<        }
<  
---
> -      }
> -
129c846,850
< -
---
> +      fprintf (stdout, "***************\n*** %d,%d ****", boOldWindow, eoOldWindow);
> +      for (unsigned l = boOldWindow; l < boDeletes; l += 1) {
> +        fprintf (stdout, "  %s", lines[0][l].line->c_str ());
> +      }
>  
133c854,865
< @@ -833,42 +781,14 @@
---
>  
>          // ... deletes and inserts.
>  
>          for (unsigned l = boDeletes; l < o; l += 1) {
>            fprintf (stdout, "! %s", lines[0][l].line->c_str ());
>          }
>        } else if (nDeletes) {
>  
>          //  ... just deletes.
>  
>          for (unsigned l = boDeletes; l < o; l += 1) {
>            fprintf (stdout, "- %s", lines[0][l].line->c_str ());
157,159c889
< +      for (unsigned l = o; l < eoOldWindow; l += 1) {
< +        fprintf (stdout, "  %s", lines[0][l].line->c_str ());
<        }
---
> -      }
167,171c897,898
< +      fprintf (stdout, "--- %d,%d ----", boNewWindow, eoNewWindow);
< +      for (unsigned l = boNewWindow; l < boInserts; l += 1) {
< +        fprintf (stdout, "  %s", lines[1][l].line->c_str ());
<        }
<  
---
> -      }
> -
177c904,911
< -
---
> +      for (unsigned l = o; l < eoOldWindow; l += 1) {
> +        fprintf (stdout, "  %s", lines[0][l].line->c_str ());
> +      }
> +      fprintf (stdout, "--- %d,%d ----", boNewWindow, eoNewWindow);
> +      for (unsigned l = boNewWindow; l < boInserts; l += 1) {
> +        fprintf (stdout, "  %s", lines[1][l].line->c_str ());
> +      }
>  
181c915,926
< @@ -887,12 +807,15 @@
---
>  
>          // ... deletes and inserts.
>  
>          for (unsigned l = boInserts; l < n; l += 1) {
>            fprintf (stdout, "! %s", lines[1][l].line->c_str ());
>          }
>        } else if (nInserts) {
>  
>          //  ... just inserts.
>  
>          for (unsigned l = boInserts; l < n; l += 1) {
>            fprintf (stdout, "+ %s", lines[1][l].line->c_str ());
189a935
> -    }
193c939
<      }
---
> +    }
201a948,1137
>  void pass6e () {
>  }
>  
>  void pass6i () {
>  }
>  
>  void pass6n ()
>  {
>    if (0 < optVerbose) {
>      fprintf (stderr, "# Pass #6n (walking the differences)...\n");
>    }
>  
>    nMatchedLines = 0;
>  
>    // Write the header.  (None for normal.)
>  
>    // Starting at the top of both files,...
>  
>    unsigned o = 0;
>    unsigned n = 0;
>  
>    while (o < lines[0].size () || n < lines[1].size ()) {
>  
>      // Find any unmatched lines at this point in the old file.  These
>      // are deletes.
>  
>      unsigned boDeletes;
>      for (boDeletes = o;
>           o < lines[0].size () && lines[0][o].l == ~0;
>           o += 1
>          )
>      {}
>  
>      // Find any unmatched lines at this point in the new file.  These
>      // are inserts.
>  
>      unsigned boInserts;
>      for (boInserts = n;
>           n < lines[1].size () && lines[1][n].l == ~0;
>           n += 1
>          )
>      {}
>  
>      // We've got deleted line(s) from boDeletes .. o.
>      // We've got deleted line(s) from boInserts .. n.
>  
>      unsigned nDeletes = o - boDeletes;
>      unsigned nInserts = n - boInserts;
>  
>      // We've got...
>  
>      if (nDeletes && nInserts) {
>  
>        // ... deletes and inserts.
>  
>        if (1 < nDeletes && 1 < nInserts) {
>          fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, boInserts + 1, n);
>        } else if (1 < nDeletes) {
>          fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boInserts + 1);
>        } else if (1 < nInserts) {
>          fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInserts + 1, n);
>        } 
>        for (unsigned l = boDeletes; l < o; l += 1) {
>          fprintf (stdout, "< %s", lines[0][l].line->c_str ());
>        }
>        fprintf (stderr, "---\n");
>        for (unsigned l = boInserts; l < n; l += 1) {
>          fprintf (stdout, "> %s", lines[1][l].line->c_str ());
>        }
>      } else if (nDeletes) {
>  
>        //  ... just deletes.
>  
>        if (1 < nDeletes) {
>          fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
>        } else {
>          fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
>        }
>        for (unsigned l = boDeletes; l < o; l += 1) {
>          fprintf (stdout, "< %s", lines[0][l].line->c_str ());
>        }
>      } else if (nInserts) {
>  
>        //  ... just inserts.
>  
>        if (1 < nInserts) {
>          fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
>        } else {
>          fprintf (stdout, "%da%d\n", o, boInserts + 1);
>        }
>        for (unsigned l = boInserts; l < n; l += 1) {
>          fprintf (stdout, "> %s", lines[1][l].line->c_str ());
>        }
>      }
>  
>      // When we get here, we're dealing with matching lines.
>  
>      o += 1;
>      n += 1;
>    }
>  }
>  
>  void pass6r () {
>  }
>  
>  void pass6s () {
>  }
>  
>  void pass6u ()
>  {
>    if (0 < optVerbose) {
>      fprintf (stderr, "# Pass #6u (walking the differences)...\n");
>    }
>  
>    nMatchedLines = 0;
>  
>    // Write the header.
>  
>    fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
>    fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
>    fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), lines[1].size ());
>  
>    // Starting at the top of both files,...
>  
>    unsigned o = 0;
>    unsigned n = 0;
>  
>    while (o < lines[0].size () || n < lines[1].size ()) {
>  
>      // Find any unmatched lines at this point in the old file.  These
>      // are deletes.
>  
>      unsigned boDeletes;
>      for (boDeletes = o;
>           o < lines[0].size () && lines[0][o].l == ~0;
>           o += 1
>          )
>      {}
>  
>      // Find any unmatched lines at this point in the new file.  These
>      // are inserts.
>  
>      unsigned boInserts;
>      for (boInserts = n;
>           n < lines[1].size () && lines[1][n].l == ~0;
>           n += 1
>          )
>      {}
>  
>      // We've got deleted line(s) from boDeletes .. o.
>      // We've got deleted line(s) from boInserts .. n.
>  
>      unsigned nDeletes = o - boDeletes;
>      unsigned nInserts = n - boInserts;
>  
>      // We've got...
>  
>      if (nDeletes && nInserts) {
>  
>        // ... deletes and inserts.
>  
>        for (unsigned l = boDeletes; l < o; l += 1) {
>          fprintf (stdout, "-%s", lines[0][l].line->c_str ());
>        }
>        for (unsigned l = boInserts; l < n; l += 1) {
>          fprintf (stdout, "+%s", lines[1][l].line->c_str ());
>        }
>      } else if (nDeletes) {
>  
>        //  ... just deletes.
>  
>        for (unsigned l = boDeletes; l < o; l += 1) {
>          fprintf (stdout, "-%s", lines[0][l].line->c_str ());
>        }
>      } else if (nInserts) {
>  
>        //  ... just inserts.
>  
>        for (unsigned l = boInserts; l < n; l += 1) {
>          fprintf (stdout, "+%s", lines[1][l].line->c_str ());
>        }
>      }
>  
>      // When we get here, we're dealing with matching lines.
>  
>      fprintf (stdout, " %s", lines[0][o].line->c_str ());
>      o += 1;
>      n += 1;
>    }
>  }
# ../sdiff -u dif.6.cpp dif.7.cpp >& dif.6.7.diff-u.test
# dif.6.7.diff-u ---------------------------------------------------------------
1,3c1,24
< --- dif.6.cpp	2008-02-25 19:54:55.000000000 +0000
< +++ dif.7.cpp	2008-02-25 22:43:43.000000000 +0000
< @@ -22,10 +22,11 @@
---
> --- dif.6.cpp	0000-00-00 00:00:00.000000000 +0000
> +++ dif.7.cpp	0000-00-00 00:00:00.000000000 +0000
> @@ -1,1088 +1,1252 @@
>  #include <algorithm>
>  using std::find;
>  #include <string>
>  using std::string;
>  #include <list>
>  using std::list;
>  #include <map>
>  using std::map;
>  #include <vector>
>  using std::vector;
>  #include <stdio.h>
>  
>  enum DiffFormat {
>    Default,
>  
>    Context,
>    EdScript,
>    IfThenElse,
>    Normal,
>    RCS,
>    SideBySide,
18c39,51
< @@ -45,7 +46,7 @@
---
>      string (_text)
>    {
>    }
>    ~Line () {
>      copies[0].erase (copies[0].begin (), copies[0].end ());
>      copies[1].erase (copies[1].begin (), copies[1].end ());
>    }
>    void Dump (FILE *out) {
>      fprintf (out, "{{ ");
>      for (list<unsigned>::iterator i = copies[0].begin (); i != copies[0].end (); i++) {
>        fprintf (out, "%u ", *i);
>      }
>      fprintf (out, "},{ ");
27c60,114
< @@ -107,6 +108,7 @@
---
>  
>  struct LinePtr {
>    LinePtr (Line *_line) :
>      line (_line),
>      l (~0u)
>    {
>    }
>    void Dump (FILE *out) {
>      fprintf (out, "[%d] ", l);
>      line->Dump (out);
>    }
>    Line *line;
>    unsigned l;
>  };
>  
>  typedef map<string, Line *> MapStringToLinePtr;
>  typedef vector<LinePtr> VectorLinePtr;
>  
>  // Our name.
>  
>  char *ARGV0 = "dif3";
>  
>  // The 'symbol' (line) table.
>  
>  MapStringToLinePtr table;
>  
>  // The names of the 2 files to be diff'd.
>  
>  char const *files[2] = { 0, 0 };
>  
>  // The lines of the 2 files to be diff'd.
>  
>  VectorLinePtr lines[2];
>  
>  // Miscellaneous metrics.
>  
>  unsigned nTotalMatchedBlocks = 0;
>  unsigned nMatchedBlocks = 0;
>  unsigned nTotalMatchedLines = 0;
>  unsigned nMatchedLines = 0;
>  
>  void pass1 ();
>  void pass2 ();
>  void pass3 ();
>  void pass4 ();
>  void pass5 ();
>  void pass6 ();
>  
>  int main (int argc, char *argv[])
>  {
>    // Read the old [0] file, and the new [1] file.
>  
>    for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
>      files[n] = argv[a];
>  
35c122,123
< @@ -115,6 +117,8 @@
---
>        unsigned nUniq = 0;
>  
38a127,219
> -        Line *line = table[text];
> -
> -        if (!line) {
> -          table[text] = line = new Line (text);
> -          nUniq += 1;
> -        }
> -        line->copies[n].push_back (lines[n].size ());
> -        lines[n].push_back (line);
> -      }
> -
> -      if (0 < optVerbose) {
> -        fprintf (stderr, " %u lines, %u unique.\n", lines[n].size (), nUniq);
> -      }
> -    } else {
> -      fprintf (stderr, "%s: Unable to open %s!  Exiting....\n", ARGV0, files[n]);
> -      perror (ARGV0);
> -      exit (1);
> -    }
> -  }
> -
> -  if (0 < optVerbose) {
> -    fprintf (stderr, "# Total unique lines = %d\n", table.size ());
> -  }
> -
> -  // map<int, int> counts;
> -  // for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> -  //   Line *l = i->second;
> -  //   counts[l->counts[0].size () + l->counts[1].size ()] += 1;
> -  // }
> -  // for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
> -  //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
> -  // }
> -
> -  pass1 ();
> -  pass2 ();
> -  pass3 ();
> -  pass4 ();
> -  pass5 ();
> -  pass6 ();
> -
> -  return 0;
> -}
> -
> -// Perform pass #1, in which we find all explicit matches amongst the
> -// unique lines.  For every unique line that appears the same number
> -// of times in both files, we declare the lines to match.
> -
> -void pass1 ()
> -{
> -  if (0 < optVerbose) {
> -    fprintf (stderr, "# Pass 1 (finding matches amongst unique lines)...");
> -  }
> -
> -  nMatchedLines = 0;
> -
> -  for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> -    Line *l = i->second;
> -
> -    // If the number of old and new lines match, then we declare that
> -    // they are (all) the same line.  Note, it isn't possible for the
> -    // numbers of both files to be 0.
> -
> -    // (In the original algorithm, we only recognized a match, here,
> -    // if there was exactly 1 copy for each file.)
> -
> -    if (l->copies[0].size () == l->copies[1].size ()) {
> -      nMatchedLines += 1;
> -
> -      // For each matched line in the new file, mark it with the
> -      // corresponding line (number) in the old file.
> -
> -      while (!l->copies[0].empty ()) {
> -        unsigned o = l->copies[0].front ();
> -        unsigned n = l->copies[1].front ();
> -
> -        // Match up the pair.
> -
> -        lines[0][o].l = n;
> -        lines[1][n].l = o;
> -
> -        // Remove the matched line numbers from the lists.
> -
> -        l->copies[0].pop_front ();
> -        l->copies[1].pop_front ();
> -      }
> -    }
> -  }
> -  nTotalMatchedLines += nMatchedLines;
> -
> -  // Let's see the intermediate results.
> -
> -  if (0 < optVerbose) {
> -    fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
40,44d220
< +
<          Line *line = table[text];
<  
<          if (!line) {
< @@ -127,9 +131,11 @@
46,47c222,422
<        if (0 < optVerbose) {
<          fprintf (stderr, " %u lines, %u unique.\n", lines[n].size (), nUniq);
---
> -    if (1 < optVerbose) {
> -      for (int f = 0; f < 2; f += 1) {
> -        fprintf (stderr, "# file #%d\n", f + 1);
> -        for (int l = 0; l < lines[f].size (); l += 1) {
> -          fprintf (stderr, "#   [%d] ", l);
> -          lines[f][l].Dump (stderr);
> -        }
> -      }
> -    }
> -  }
> -}
> -
> -// Perform Pass #2, in which we attempt to 'widen' blocks of matched
> -// lines, by appending lines which are the same in both files.
> -
> -void pass2 ()
> -{
> -  if (0 < optVerbose) {
> -    fprintf (stderr, "# Pass #2 (spreading matches down)...");
> -  }
> -
> -  nMatchedBlocks = 0;
> -  nMatchedLines = 0;
> -
> -  // Starting at the top of the old file,...
> -
> -  for (unsigned o = 0; o < lines[0].size (); o += 1) {
> -
> -    // ... skip any currently unmatched lines...
> -
> -    if (lines[0][o].l == ~0) {
> -      continue;
> -    }
> -
> -    // ... until we find an [already] matched line.  Then, skip over
> -    // the set of 1 or more matched lines, until we reach any
> -    // following, still-unmatched line.
> -
> -    unsigned n;
> -    do {
> -      n = lines[0][o].l + 1;
> -      o += 1;
> -    } while (o < lines[0].size () && lines[0][o].l != ~0);
> -
> -    // Now, o - 1 is the line number of the last matched old line, and
> -    // n - 1 is the line number of the last matched new line.  We want
> -    // to add new old and new lines, if they match.
> -
> -    // Finally, attempt to add unmatched lines to the preceeding
> -    // matched set.
> -
> -    for (; o < lines[0].size () && lines[0][o].l == ~0; o += 1, n += 1) {
> -
> -      // If the [next] pair of old and new lines aren't the same line, we're done.
> -
> -      if (lines[0][o].line != lines[1][n].line) {
> -        break;
> -      }
> -
> -      // Match up the pair.
> -
> -      lines[0][o].l = n;
> -      lines[1][n].l = o;
> -
> -      // Remove the matched line numbers form the lists.
> -
> -      Line *line = lines[0][o].line;
> -      list<unsigned> &oldCopies = line->copies[0];
> -      list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
> -      if (oL != oldCopies.end ()) {
> -        oldCopies.erase (oL);
> -      }
> -      list<unsigned> &newCopies = line->copies[0];
> -      list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
> -      if (nL != newCopies.end ()) {
> -        newCopies.erase (nL);
> -      }
> -
> -      nMatchedLines += 1;
> -    }
> -    nMatchedBlocks += 1;
> -  }
> -  nTotalMatchedLines += nMatchedLines;
> -  nTotalMatchedBlocks += nMatchedBlocks;
> -
> -  // Let's see the intermediate results.
> -
> -  if (0 < optVerbose) {
> -    fprintf (stderr,
> -             " found %u/%u matched lines/blocks (%u/%u totals).\n",
> -             nMatchedLines,
> -             nMatchedBlocks,
> -             nTotalMatchedLines,
> -             nTotalMatchedBlocks
> -            );
> -    if (1 < optVerbose) {
> -      for (int f = 0; f < 2; f += 1) {
> -        fprintf (stderr, "# file #%d\n", f + 1);
> -        for (int l = 0; l < lines[f].size (); l += 1) {
> -          fprintf (stderr, "#   [%d] ", l);
> -          lines[f][l].Dump (stderr);
> -        }
> -      }
> -    }
> -  }
> -}
> -
> -// Perform Pass #3, in which we attempt to 'widen' blocks of matched
> -// lines, by prepending lines which are the same in both files.
> -
> -void pass3 ()
> -{
> -  if (0 < optVerbose) {
> -    fprintf (stderr, "# Pass #3 (spreading matches up)...");
> -  }
> -
> -  nMatchedBlocks = 0;
> -  nMatchedLines = 0;
> -
> -  // Starting at the bottom of the old file,...
> -
> -  for (int o = lines[0].size (); 0 <= o; o -= 1) {
> -
> -    // ... skip any currently unmatched lines...
> -
> -    if (lines[0][o].l == ~0) {
> -      continue;
> -    }
> -
> -    // ... until we find an [already] matched line.  Then, skip over
> -    // the set of 1 or more matched lines, until we reach any
> -    // following, still-unmatched line.
> -
> -    unsigned n;
> -    do {
> -      n = lines[0][o].l - 1;
> -      o -= 1;
> -    } while (0 <= o && lines[0][o].l != ~0);
> -
> -    // Now, o + 1 is the line number of the last matched old line, and
> -    // n + 1 is the line number of the last matched new line.  We want
> -    // to add new old and new lines, if they match.
> -
> -    // Finally, attempt to add unmatched lines to the preceeding
> -    // matched set.
> -
> -    for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
> -
> -      // If the [next] pair of old and new lines aren't the same line, we're done.
> -
> -      if (lines[0][o].line != lines[1][n].line) {
> -        break;
> -      }
> -
> -      // Match up the pair.
> -
> -      lines[0][o].l = n;
> -      lines[1][n].l = o;
> -
> -      // Remove the matched line numbers form the lists.
> -
> -      Line *line = lines[0][o].line;
> -      list<unsigned> &oldCopies = line->copies[0];
> -      list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
> -      if (oL != oldCopies.end ()) {
> -        oldCopies.erase (oL);
> -      }
> -      list<unsigned> &newCopies = line->copies[0];
> -      list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
> -      if (nL != newCopies.end ()) {
> -        newCopies.erase (nL);
> -      }
> -
> -      nMatchedLines += 1;
> -    }
> -    nMatchedBlocks += 1;
> -  }
> -  nTotalMatchedLines += nMatchedLines;
> -
> -  // Let's see the intermediate results.
> -
> -  if (0 < optVerbose) {
> -    fprintf (stderr,
> -             " found %u/%u matched lines/blocks (%u/%u totals).\n",
> -             nMatchedLines,
> -             nMatchedBlocks,
> -             nTotalMatchedLines,
> -             nTotalMatchedBlocks
> -            );
> +        Line *line = table[text];
> +
> +        if (!line) {
> +          table[text] = line = new Line (text);
> +          nUniq += 1;
> +        }
> +        line->copies[n].push_back (lines[n].size ());
> +        lines[n].push_back (line);
> +      }
> +
> +      if (0 < optVerbose) {
> +        fprintf (stderr, " %u lines, %u unique.\n", lines[n].size (), nUniq);
49,51c424,426
<        }
<      } else {
<        fprintf (stderr, "%s: Unable to open %s!  Exiting....\n", ARGV0, files[n]);
---
> +      }
> +    } else {
> +      fprintf (stderr, "%s: Unable to open %s!  Exiting....\n", ARGV0, files[n]);
53,59c428,434
<        perror (ARGV0);
<        exit (1);
<      }
< @@ -137,6 +143,7 @@
<  
<    if (0 < optVerbose) {
<      fprintf (stderr, "# Total unique lines = %d\n", table.size ());
---
> +      perror (ARGV0);
> +      exit (1);
> +    }
> +  }
> +
> +  if (0 < optVerbose) {
> +    fprintf (stderr, "# Total unique lines = %d\n", table.size ());
61,67c436,464
<    }
<  
<    // map<int, int> counts;
< @@ -166,6 +173,7 @@
<  {
<    if (0 < optVerbose) {
<      fprintf (stderr, "# Pass 1 (finding matches amongst unique lines)...");
---
> +  }
> +
> +  // map<int, int> counts;
> +  // for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> +  //   Line *l = i->second;
> +  //   counts[l->counts[0].size () + l->counts[1].size ()] += 1;
> +  // }
> +  // for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
> +  //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
> +  // }
> +
> +  pass1 ();
> +  pass2 ();
> +  pass3 ();
> +  pass4 ();
> +  pass5 ();
> +  pass6 ();
> +
> +  return 0;
> +}
> +
> +// Perform pass #1, in which we find all explicit matches amongst the
> +// unique lines.  For every unique line that appears the same number
> +// of times in both files, we declare the lines to match.
> +
> +void pass1 ()
> +{
> +  if (0 < optVerbose) {
> +    fprintf (stderr, "# Pass 1 (finding matches amongst unique lines)...");
69,75c466,507
<    }
<  
<    nMatchedLines = 0;
< @@ -208,12 +216,15 @@
<  
<    if (0 < optVerbose) {
<      fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
---
> +  }
> +
> +  nMatchedLines = 0;
> +
> +  for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> +    Line *l = i->second;
> +
> +    // If the number of old and new lines match, then we declare that
> +    // they are (all) the same line.  Note, it isn't possible for the
> +    // numbers of both files to be 0.
> +
> +    // (In the original algorithm, we only recognized a match, here,
> +    // if there was exactly 1 copy for each file.)
> +
> +    if (l->copies[0].size () == l->copies[1].size ()) {
> +      nMatchedLines += 1;
> +
> +      // For each matched line in the new file, mark it with the
> +      // corresponding line (number) in the old file.
> +
> +      while (!l->copies[0].empty ()) {
> +        unsigned o = l->copies[0].front ();
> +        unsigned n = l->copies[1].front ();
> +
> +        // Match up the pair.
> +
> +        lines[0][o].l = n;
> +        lines[1][n].l = o;
> +
> +        // Remove the matched line numbers from the lists.
> +
> +        l->copies[0].pop_front ();
> +        l->copies[1].pop_front ();
> +      }
> +    }
> +  }
> +  nTotalMatchedLines += nMatchedLines;
> +
> +  // Let's see the intermediate results.
> +
> +  if (0 < optVerbose) {
> +    fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
78a511,568
> -      for (int f = 0; f < 2; f += 1) {
> -        fprintf (stderr, "# file #%d\n", f + 1);
> -        for (int l = 0; l < lines[f].size (); l += 1) {
> -          fprintf (stderr, "#   [%d] ", l);
> -          lines[f][l].Dump (stderr);
> -        }
> -      }
> -    }
> -  }
> -}
> -
> -// Perform pass #4, in which we find any remaining matches amongst the
> -// unique lines.  For every unique line that has more than 1 copy in
> -// both files, we declare the copies to match.
> -
> -void pass4 ()
> -{
> -  if (0 < optVerbose) {
> -    fprintf (stderr, "# Pass 4 (finding remaining matches amongst unique lines)...");
> -  }
> -
> -  nMatchedLines = 0;
> -
> -  for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> -    Line *l = i->second;
> -
> -    // If there's more than 1 matching old and new lines, then we
> -    // declare that each pair are (all) the same line.
> -
> -    // (In the original algorithm, we only recognized a match, here,
> -    // if there was exactly 1 copy for each file.)
> -
> -    while (0 < l->copies[0].size () && 0 < l->copies[1].size ()) {
> -      nMatchedLines += 1;
> -
> -      // For each matched line in the new file, mark it with the
> -      // corresponding line (number) in the old file.
> -
> -      unsigned o = l->copies[0].front ();
> -      unsigned n = l->copies[1].front ();
> -
> -      // Match up the pair.
> -
> -      lines[0][o].l = n;
> -      lines[1][n].l = o;
> -
> -      // Remove the matched line numbers from the lists.
> -
> -      l->copies[0].pop_front ();
> -      l->copies[1].pop_front ();
> -    }
> -  }
> -  nTotalMatchedLines += nMatchedLines;
> -
> -  // Let's see the intermediate results.
> -
> -  if (0 < optVerbose) {
> -    fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
80,81c570,571
<        for (int f = 0; f < 2; f += 1) {
<          fprintf (stderr, "# file #%d\n", f + 1);
---
> +      for (int f = 0; f < 2; f += 1) {
> +        fprintf (stderr, "# file #%d\n", f + 1);
83,84c573,574
<          for (int l = 0; l < lines[f].size (); l += 1) {
<            fprintf (stderr, "#   [%d] ", l);
---
> +        for (int l = 0; l < lines[f].size (); l += 1) {
> +          fprintf (stderr, "#   [%d] ", l);
86,92c576,589
<            lines[f][l].Dump (stderr);
<          }
<        }
< @@ -228,6 +239,7 @@
<  {
<    if (0 < optVerbose) {
<      fprintf (stderr, "# Pass #2 (spreading matches down)...");
---
> +          lines[f][l].Dump (stderr);
> +        }
> +      }
> +    }
> +  }
> +}
> +
> +// Perform Pass #2, in which we attempt to 'widen' blocks of matched
> +// lines, by appending lines which are the same in both files.
> +
> +void pass2 ()
> +{
> +  if (0 < optVerbose) {
> +    fprintf (stderr, "# Pass #2 (spreading matches down)...");
94,101c591,666
<    }
<  
<    nMatchedBlocks = 0;
< @@ -304,11 +316,14 @@
<               nTotalMatchedLines,
<               nTotalMatchedBlocks
<              );
< -    if (1 < optVerbose) {
---
> +  }
> +
> +  nMatchedBlocks = 0;
> +  nMatchedLines = 0;
> +
> +  // Starting at the top of the old file,...
> +
> +  for (unsigned o = 0; o < lines[0].size (); o += 1) {
> +
> +    // ... skip any currently unmatched lines...
> +
> +    if (lines[0][o].l == ~0) {
> +      continue;
> +    }
> +
> +    // ... until we find an [already] matched line.  Then, skip over
> +    // the set of 1 or more matched lines, until we reach any
> +    // following, still-unmatched line.
> +
> +    unsigned n;
> +    do {
> +      n = lines[0][o].l + 1;
> +      o += 1;
> +    } while (o < lines[0].size () && lines[0][o].l != ~0);
> +
> +    // Now, o - 1 is the line number of the last matched old line, and
> +    // n - 1 is the line number of the last matched new line.  We want
> +    // to add new old and new lines, if they match.
> +
> +    // Finally, attempt to add unmatched lines to the preceeding
> +    // matched set.
> +
> +    for (; o < lines[0].size () && lines[0][o].l == ~0; o += 1, n += 1) {
> +
> +      // If the [next] pair of old and new lines aren't the same line, we're done.
> +
> +      if (lines[0][o].line != lines[1][n].line) {
> +        break;
> +      }
> +
> +      // Match up the pair.
> +
> +      lines[0][o].l = n;
> +      lines[1][n].l = o;
> +
> +      // Remove the matched line numbers form the lists.
> +
> +      Line *line = lines[0][o].line;
> +      list<unsigned> &oldCopies = line->copies[0];
> +      list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
> +      if (oL != oldCopies.end ()) {
> +        oldCopies.erase (oL);
> +      }
> +      list<unsigned> &newCopies = line->copies[0];
> +      list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
> +      if (nL != newCopies.end ()) {
> +        newCopies.erase (nL);
> +      }
> +
> +      nMatchedLines += 1;
> +    }
> +    nMatchedBlocks += 1;
> +  }
> +  nTotalMatchedLines += nMatchedLines;
> +  nTotalMatchedBlocks += nMatchedBlocks;
> +
> +  // Let's see the intermediate results.
> +
> +  if (0 < optVerbose) {
> +    fprintf (stderr,
> +             " found %u/%u matched lines/blocks (%u/%u totals).\n",
> +             nMatchedLines,
> +             nMatchedBlocks,
> +             nTotalMatchedLines,
> +             nTotalMatchedBlocks
> +            );
104,105c669,670
<        for (int f = 0; f < 2; f += 1) {
<          fprintf (stderr, "# file #%d\n", f + 1);
---
> +      for (int f = 0; f < 2; f += 1) {
> +        fprintf (stderr, "# file #%d\n", f + 1);
107,108c672,673
<          for (int l = 0; l < lines[f].size (); l += 1) {
<            fprintf (stderr, "#   [%d] ", l);
---
> +        for (int l = 0; l < lines[f].size (); l += 1) {
> +          fprintf (stderr, "#   [%d] ", l);
110,116c675,688
<            lines[f][l].Dump (stderr);
<          }
<        }
< @@ -323,6 +338,7 @@
<  {
<    if (0 < optVerbose) {
<      fprintf (stderr, "# Pass #3 (spreading matches up)...");
---
> +          lines[f][l].Dump (stderr);
> +        }
> +      }
> +    }
> +  }
> +}
> +
> +// Perform Pass #3, in which we attempt to 'widen' blocks of matched
> +// lines, by prepending lines which are the same in both files.
> +
> +void pass3 ()
> +{
> +  if (0 < optVerbose) {
> +    fprintf (stderr, "# Pass #3 (spreading matches up)...");
118,124c690,764
<    }
<  
<    nMatchedBlocks = 0;
< @@ -398,12 +414,15 @@
<               nTotalMatchedLines,
<               nTotalMatchedBlocks
<              );
---
> +  }
> +
> +  nMatchedBlocks = 0;
> +  nMatchedLines = 0;
> +
> +  // Starting at the bottom of the old file,...
> +
> +  for (int o = lines[0].size (); 0 <= o; o -= 1) {
> +
> +    // ... skip any currently unmatched lines...
> +
> +    if (lines[0][o].l == ~0) {
> +      continue;
> +    }
> +
> +    // ... until we find an [already] matched line.  Then, skip over
> +    // the set of 1 or more matched lines, until we reach any
> +    // following, still-unmatched line.
> +
> +    unsigned n;
> +    do {
> +      n = lines[0][o].l - 1;
> +      o -= 1;
> +    } while (0 <= o && lines[0][o].l != ~0);
> +
> +    // Now, o + 1 is the line number of the last matched old line, and
> +    // n + 1 is the line number of the last matched new line.  We want
> +    // to add new old and new lines, if they match.
> +
> +    // Finally, attempt to add unmatched lines to the preceeding
> +    // matched set.
> +
> +    for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
> +
> +      // If the [next] pair of old and new lines aren't the same line, we're done.
> +
> +      if (lines[0][o].line != lines[1][n].line) {
> +        break;
> +      }
> +
> +      // Match up the pair.
> +
> +      lines[0][o].l = n;
> +      lines[1][n].l = o;
> +
> +      // Remove the matched line numbers form the lists.
> +
> +      Line *line = lines[0][o].line;
> +      list<unsigned> &oldCopies = line->copies[0];
> +      list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
> +      if (oL != oldCopies.end ()) {
> +        oldCopies.erase (oL);
> +      }
> +      list<unsigned> &newCopies = line->copies[0];
> +      list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
> +      if (nL != newCopies.end ()) {
> +        newCopies.erase (nL);
> +      }
> +
> +      nMatchedLines += 1;
> +    }
> +    nMatchedBlocks += 1;
> +  }
> +  nTotalMatchedLines += nMatchedLines;
> +
> +  // Let's see the intermediate results.
> +
> +  if (0 < optVerbose) {
> +    fprintf (stderr,
> +             " found %u/%u matched lines/blocks (%u/%u totals).\n",
> +             nMatchedLines,
> +             nMatchedBlocks,
> +             nTotalMatchedLines,
> +             nTotalMatchedBlocks
> +            );
127a768,935
> -      for (int f = 0; f < 2; f += 1) {
> -        fprintf (stderr, "# file #%d\n", f + 1);
> -        for (int l = 0; l < lines[f].size (); l += 1) {
> -          fprintf (stderr, "#   [%d] ", l);
> -          lines[f][l].Dump (stderr);
> -        }
> -      }
> -    }
> -  }
> -}
> -
> -// Perform Pass #5, in which we look for blocks which match, but are
> -// the result of a move (their not in their original position).  For
> -// these, we'll unmatch the blocks, turning them into a delete and an
> -// insert.
> -
> -void pass5 ()
> -{
> -  if (0 < optVerbose) {
> -    fprintf (stderr, "# Pass #5 (unmatching block moves)...\n");
> -  }
> -
> -  nMatchedBlocks = 0;
> -  nMatchedLines = 0;
> -
> -  // Starting at the top of both files,...
> -
> -  unsigned o = 0;
> -  unsigned n = 0;
> -
> -  while (o < lines[0].size () || n < lines[1].size ()) {
> -
> -    // Skip any unmatched lines at this point in the old file.  These
> -    // are deletes.
> -
> -    //    Old     New
> -    //   +---+
> -    // 0 | a |
> -    //   +---+   +---+
> -    //         0 | b |
> -    //   +---+   +---+
> -    // 1 | c | 1 | c |
> -    //   +---+   +---+
> -    //         2 | z |
> -    //   +---+   +---+
> -    // 2 | d | 3 | d |
> -    //   +---+   +---+
> -
> -    while (o < lines[0].size () && lines[0][o].l == ~0) {
> -      o += 1;
> -    }
> -
> -    // Skip any unmatched lines at this point in the new file.  These
> -    // are inserts.
> -
> -    while (n < lines[1].size () && lines[1][n].l == ~0) {
> -      n += 1;
> -    }
> -
> -    // When we get here, we know that we're dealing with matching
> -    // lines (or the end of one or both files).  We're done with this
> -    // pass, if we've reached the end of either file.
> -
> -    if (lines[0].size () <= o || lines[1].size () <= n) {
> -      break;
> -    }
> -
> -    // We now know that we've got a pair of matching lines, the start
> -    // of a matching block.  If the new file's line number is what we
> -    // expect, then the matched pair is unmoved, and we can skip over
> -    // the pair.  (If this is really the start of a block of more than
> -    // 1 lines, we'll handle it one pair at a time.)
> -
> -    if (lines[0][o].l == n) {
> -      o += 1;
> -      n += 1;
> -      continue;
> -    }
> -
> -    // If, on the other hand, we don't expect this [new] line number,
> -    // then this matching block has been moved.  We need to turn the
> -    // matched pair into an *unmatched* pair, one of deletes, and one
> -    // of inserts.  First, though, we need to know how big this block
> -    // is, and how far it was moved....
> -
> -    // Remember where we were when we started.
> -
> -    unsigned oOld = o;
> -    unsigned nOld = n;
> -
> -    // Remember where the block came from.
> -
> -    unsigned nNew = lines[0][o].l;
> -
> -    // Find the end of this matched pair.
> -
> -    for (n = nNew; o < lines[0].size () && n < lines[1].size (); o += 1, n += 1) {
> -      if (lines[0][o].l != n) {
> -        break;
> -      }
> -    }
> -
> -    // When we get here:
> -    // * oOld..o is the old file's block,
> -    // * nNew..n is the new file's *moved* block, and
> -    // * nOld is where we originally expected the new block from.
> - 
> -    // We can now calculate the length of the block...
> -    
> -    unsigned bSize = o - oOld;  // (or n - nNew)
> -
> -    // ... and we can calculate how far the block moved:
> -
> -    unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
> -
> -    // The larger of the two will become our delete, and the smaller
> -    // will become our insert.
> -
> -    //    Old     New
> -    //   +---+   +---+
> -    // 0 | a | 0 | b |
> -    //   +---+ 1 | b |
> -    // 1 | b |   +---+
> -    // 2 | b | 2 | a |
> -    //   +---+   +---+
> -    // 3 | c | 3 | c |
> -    //   +---+   +---+
> -
> -    // (1) Delete a@0, insert a@2, or
> -    // (2) insert bb@0, delete bb@1?
> -
> -    // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and bMove
> -    // (of a) is 2-0 or 2, the size of b@0.  We choose to delete a@0,
> -    // and reinsert a@2.
> -
> -    // if (bSize <= bMove) {
> -      for (unsigned a = oOld; a < o; a += 1) {
> -        lines[0][a].l = ~0;
> -      }
> -      for (unsigned d = nNew; d < n; d += 1) {
> -        lines[1][d].l = ~0;
> -      }
> -    // } else {
> -      // for (unsigned a = oOld; a < o; a += 1) {
> -      //   lines[0][a].l = ~0;
> -      // }
> -      // for (unsigned d = nNew; d < n; d += 1) {
> -      //   lines[1][d].l = ~0;
> -      // }
> -    // }
> -
> -    // Continue from where we left off.
> -
> -    n = nOld;
> -  }
> -  nTotalMatchedLines -= nMatchedLines;
> -  nTotalMatchedBlocks -= nMatchedBlocks;
> -
> -  // Let's see the intermediate results.
> -
> -  if (0 < optVerbose) {
> -    fprintf (stderr,
> -             " found %u/%u matched lines/blocks (%u/%u totals).\n",
> -             nMatchedLines,
> -             nMatchedBlocks,
> -             nTotalMatchedLines,
> -             nTotalMatchedBlocks
> -            );
129,130c937,938
<        for (int f = 0; f < 2; f += 1) {
<          fprintf (stderr, "# file #%d\n", f + 1);
---
> +      for (int f = 0; f < 2; f += 1) {
> +        fprintf (stderr, "# file #%d\n", f + 1);
132,133c940,941
<          for (int l = 0; l < lines[f].size (); l += 1) {
<            fprintf (stderr, "#   [%d] ", l);
---
> +        for (int l = 0; l < lines[f].size (); l += 1) {
> +          fprintf (stderr, "#   [%d] ", l);
135,141c943,957
<            lines[f][l].Dump (stderr);
<          }
<        }
< @@ -419,6 +438,7 @@
<  {
<    if (0 < optVerbose) {
<      fprintf (stderr, "# Pass 4 (finding remaining matches amongst unique lines)...");
---
> +          lines[f][l].Dump (stderr);
> +        }
> +      }
> +    }
> +  }
> +}
> +
> +// Perform pass #4, in which we find any remaining matches amongst the
> +// unique lines.  For every unique line that has more than 1 copy in
> +// both files, we declare the copies to match.
> +
> +void pass4 ()
> +{
> +  if (0 < optVerbose) {
> +    fprintf (stderr, "# Pass 4 (finding remaining matches amongst unique lines)...");
143,149c959,997
<    }
<  
<    nMatchedLines = 0;
< @@ -458,12 +478,15 @@
<  
<    if (0 < optVerbose) {
<      fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
---
> +  }
> +
> +  nMatchedLines = 0;
> +
> +  for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> +    Line *l = i->second;
> +
> +    // If there's more than 1 matching old and new lines, then we
> +    // declare that each pair are (all) the same line.
> +
> +    // (In the original algorithm, we only recognized a match, here,
> +    // if there was exactly 1 copy for each file.)
> +
> +    while (0 < l->copies[0].size () && 0 < l->copies[1].size ()) {
> +      nMatchedLines += 1;
> +
> +      // For each matched line in the new file, mark it with the
> +      // corresponding line (number) in the old file.
> +
> +      unsigned o = l->copies[0].front ();
> +      unsigned n = l->copies[1].front ();
> +
> +      // Match up the pair.
> +
> +      lines[0][o].l = n;
> +      lines[1][n].l = o;
> +
> +      // Remove the matched line numbers from the lists.
> +
> +      l->copies[0].pop_front ();
> +      l->copies[1].pop_front ();
> +    }
> +  }
> +  nTotalMatchedLines += nMatchedLines;
> +
> +  // Let's see the intermediate results.
> +
> +  if (0 < optVerbose) {
> +    fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
152a1001,1109
> -      for (int f = 0; f < 2; f += 1) {
> -        fprintf (stderr, "# file #%d\n", f + 1);
> -        for (int l = 0; l < lines[f].size (); l += 1) {
> -          fprintf (stderr, "#   [%d] ", l);
> -          lines[f][l].Dump (stderr);
> -        }
> -      }
> -    }
> -  }
> -}
> -
> -// Perform Pass #6, in which we create the desired output.
> -
> -void pass6c ();
> -void pass6e ();
> -void pass6i ();
> -void pass6n ();
> -void pass6r ();
> -void pass6s ();
> -void pass6u ();
> -
> -void pass6 ()
> -{
> -
> -  switch (diffFormat) {
> -  case Context:
> -    pass6c ();
> -    break;
> -
> -  case EdScript:
> -    pass6e ();
> -    break;
> -
> -  case IfThenElse:
> -    pass6i ();
> -    break;
> -
> -  case Normal:
> -    pass6n ();
> -    break;
> -
> -  case RCS:
> -    pass6r ();
> -    break;
> -
> -  case SideBySide:
> -    pass6s ();
> -    break;
> -
> -  case Unified:
> -    pass6u ();
> -    break;
> -
> -  case Default:
> -  default:
> -    pass6c ();
> -    break;
> -  }
> -}
> -
> -template<typename T> T min (T l, T r) {
> -  if (l < r) {
> -    return l;
> -  }
> -  return r;
> -}
> -
> -template<typename T> T max (T l, T r) {
> -  if (l < r) {
> -    return r;
> -  }
> -  return l;
> -}
> -
> -void pass6c () {
> -  if (0 < optVerbose) {
> -    fprintf (stderr, "# Pass #6u (walking the differences)...\n");
> -  }
> -
> -  nMatchedLines = 0;
> -
> -  // Write the header.
> -
> -  fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
> -  fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
> -
> -  // Starting at the top of both files,...
> -
> -  unsigned o = 0;
> -  unsigned n = 0;
> -
> -  while (o < lines[0].size () || n < lines[1].size ()) {
> -
> -    // Find the bounds of the current contextual 'window'.
> -
> -    // If we aren't looking at a delete or an insert, we're not at the
> -    // start of a context window.
> -
> -    if (lines[0][o].l != ~0 && lines[1][n].l != ~0) {
> -      o += 1;
> -      n += 1;
> -      continue;
> -    }
> -
> -    // We're looking at at least 1 delete or insert, so a window
> -    // begins here (or, rather, optCopyContext lines earlier).
> -    
> -    int boOldWindow = max (0, int (boDeletes) - int(optCopyContext));
> -    int eoOldWindow = min (int (lines[0].size ()), int(o) + int(optCopyContext));
154,155c1111,1112
<        for (int f = 0; f < 2; f += 1) {
<          fprintf (stderr, "# file #%d\n", f + 1);
---
> +      for (int f = 0; f < 2; f += 1) {
> +        fprintf (stderr, "# file #%d\n", f + 1);
157,158c1114,1115
<          for (int l = 0; l < lines[f].size (); l += 1) {
<            fprintf (stderr, "#   [%d] ", l);
---
> +        for (int l = 0; l < lines[f].size (); l += 1) {
> +          fprintf (stderr, "#   [%d] ", l);
160,166c1117,1132
<            lines[f][l].Dump (stderr);
<          }
<        }
< @@ -480,6 +503,7 @@
<  {
<    if (0 < optVerbose) {
<      fprintf (stderr, "# Pass #5 (unmatching block moves)...\n");
---
> +          lines[f][l].Dump (stderr);
> +        }
> +      }
> +    }
> +  }
> +}
> +
> +// Perform Pass #5, in which we look for blocks which match, but are
> +// the result of a move (their not in their original position).  For
> +// these, we'll unmatch the blocks, turning them into a delete and an
> +// insert.
> +
> +void pass5 ()
> +{
> +  if (0 < optVerbose) {
> +    fprintf (stderr, "# Pass #5 (unmatching block moves)...\n");
168,174c1134,1281
<    }
<  
<    nMatchedBlocks = 0;
< @@ -628,12 +652,15 @@
<               nTotalMatchedLines,
<               nTotalMatchedBlocks
<              );
---
> +  }
> +
> +  nMatchedBlocks = 0;
> +  nMatchedLines = 0;
> +
> +  // Starting at the top of both files,...
> +
> +  unsigned o = 0;
> +  unsigned n = 0;
> +
> +  while (o < lines[0].size () || n < lines[1].size ()) {
> +
> +    // Skip any unmatched lines at this point in the old file.  These
> +    // are deletes.
> +
> +    //    Old     New
> +    //   +---+
> +    // 0 | a |
> +    //   +---+   +---+
> +    //         0 | b |
> +    //   +---+   +---+
> +    // 1 | c | 1 | c |
> +    //   +---+   +---+
> +    //         2 | z |
> +    //   +---+   +---+
> +    // 2 | d | 3 | d |
> +    //   +---+   +---+
> +
> +    while (o < lines[0].size () && lines[0][o].l == ~0) {
> +      o += 1;
> +    }
> +
> +    // Skip any unmatched lines at this point in the new file.  These
> +    // are inserts.
> +
> +    while (n < lines[1].size () && lines[1][n].l == ~0) {
> +      n += 1;
> +    }
> +
> +    // When we get here, we know that we're dealing with matching
> +    // lines (or the end of one or both files).  We're done with this
> +    // pass, if we've reached the end of either file.
> +
> +    if (lines[0].size () <= o || lines[1].size () <= n) {
> +      break;
> +    }
> +
> +    // We now know that we've got a pair of matching lines, the start
> +    // of a matching block.  If the new file's line number is what we
> +    // expect, then the matched pair is unmoved, and we can skip over
> +    // the pair.  (If this is really the start of a block of more than
> +    // 1 lines, we'll handle it one pair at a time.)
> +
> +    if (lines[0][o].l == n) {
> +      o += 1;
> +      n += 1;
> +      continue;
> +    }
> +
> +    // If, on the other hand, we don't expect this [new] line number,
> +    // then this matching block has been moved.  We need to turn the
> +    // matched pair into an *unmatched* pair, one of deletes, and one
> +    // of inserts.  First, though, we need to know how big this block
> +    // is, and how far it was moved....
> +
> +    // Remember where we were when we started.
> +
> +    unsigned oOld = o;
> +    unsigned nOld = n;
> +
> +    // Remember where the block came from.
> +
> +    unsigned nNew = lines[0][o].l;
> +
> +    // Find the end of this matched pair.
> +
> +    for (n = nNew; o < lines[0].size () && n < lines[1].size (); o += 1, n += 1) {
> +      if (lines[0][o].l != n) {
> +        break;
> +      }
> +    }
> +
> +    // When we get here:
> +    // * oOld..o is the old file's block,
> +    // * nNew..n is the new file's *moved* block, and
> +    // * nOld is where we originally expected the new block from.
> + 
> +    // We can now calculate the length of the block...
> +    
> +    unsigned bSize = o - oOld;  // (or n - nNew)
> +
> +    // ... and we can calculate how far the block moved:
> +
> +    unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
> +
> +    // The larger of the two will become our delete, and the smaller
> +    // will become our insert.
> +
> +    //    Old     New
> +    //   +---+   +---+
> +    // 0 | a | 0 | b |
> +    //   +---+ 1 | b |
> +    // 1 | b |   +---+
> +    // 2 | b | 2 | a |
> +    //   +---+   +---+
> +    // 3 | c | 3 | c |
> +    //   +---+   +---+
> +
> +    // (1) Delete a@0, insert a@2, or
> +    // (2) insert bb@0, delete bb@1?
> +
> +    // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and bMove
> +    // (of a) is 2-0 or 2, the size of b@0.  We choose to delete a@0,
> +    // and reinsert a@2.
> +
> +    // if (bSize <= bMove) {
> +      for (unsigned a = oOld; a < o; a += 1) {
> +        lines[0][a].l = ~0;
> +      }
> +      for (unsigned d = nNew; d < n; d += 1) {
> +        lines[1][d].l = ~0;
> +      }
> +    // } else {
> +      // for (unsigned a = oOld; a < o; a += 1) {
> +      //   lines[0][a].l = ~0;
> +      // }
> +      // for (unsigned d = nNew; d < n; d += 1) {
> +      //   lines[1][d].l = ~0;
> +      // }
> +    // }
> +
> +    // Continue from where we left off.
> +
> +    n = nOld;
> +  }
> +  nTotalMatchedLines -= nMatchedLines;
> +  nTotalMatchedBlocks -= nMatchedBlocks;
> +
> +  // Let's see the intermediate results.
> +
> +  if (0 < optVerbose) {
> +    fprintf (stderr,
> +             " found %u/%u matched lines/blocks (%u/%u totals).\n",
> +             nMatchedLines,
> +             nMatchedBlocks,
> +             nTotalMatchedLines,
> +             nTotalMatchedBlocks
> +            );
177c1284
< -    if (1 < optVerbose) {
---
> -    // Look for the end of the window.
179,180c1286,1287
<        for (int f = 0; f < 2; f += 1) {
<          fprintf (stderr, "# file #%d\n", f + 1);
---
> +      for (int f = 0; f < 2; f += 1) {
> +        fprintf (stderr, "# file #%d\n", f + 1);
182,183c1289,1290
<          for (int l = 0; l < lines[f].size (); l += 1) {
<            fprintf (stderr, "#   [%d] ", l);
---
> +        for (int l = 0; l < lines[f].size (); l += 1) {
> +          fprintf (stderr, "#   [%d] ", l);
185,191c1292,1307
<            lines[f][l].Dump (stderr);
<          }
<        }
< @@ -650,6 +677,7 @@
<  void pass6r ();
<  void pass6s ();
<  void pass6u ();
---
> +          lines[f][l].Dump (stderr);
> +        }
> +      }
> +    }
> +  }
> +}
> +
> +// Perform Pass #6, in which we create the desired output.
> +
> +void pass6c ();
> +void pass6e ();
> +void pass6i ();
> +void pass6n ();
> +void pass6r ();
> +void pass6s ();
> +void pass6u ();
193,200c1309,1334
<  
<  void pass6 ()
<  {
< @@ -676,7 +704,7 @@
<      break;
<  
<    case SideBySide:
< -    pass6s ();
---
> +
> +void pass6 ()
> +{
> +
> +  switch (diffFormat) {
> +  case Context:
> +    pass6c ();
> +    break;
> +
> +  case EdScript:
> +    pass6e ();
> +    break;
> +
> +  case IfThenElse:
> +    pass6i ();
> +    break;
> +
> +  case Normal:
> +    pass6n ();
> +    break;
> +
> +  case RCS:
> +    pass6r ();
> +    break;
> +
> +  case SideBySide:
202,209c1336,1364
<      break;
<  
<    case Unified:
< @@ -706,7 +734,8 @@
<  
<  void pass6c () {
<    if (0 < optVerbose) {
< -    fprintf (stderr, "# Pass #6u (walking the differences)...\n");
---
> +    break;
> +
> +  case Unified:
> +    pass6u ();
> +    break;
> +
> +  case Default:
> +  default:
> +    pass6c ();
> +    break;
> +  }
> +}
> +
> +template<typename T> T min (T l, T r) {
> +  if (l < r) {
> +    return l;
> +  }
> +  return r;
> +}
> +
> +template<typename T> T max (T l, T r) {
> +  if (l < r) {
> +    return r;
> +  }
> +  return l;
> +}
> +
> +void pass6c () {
> +  if (0 < optVerbose) {
212,219c1367,1393
<    }
<  
<    nMatchedLines = 0;
< @@ -734,16 +763,24 @@
<        continue;
<      }
<  
< -    // We're looking at at least 1 delete or insert, so a window
---
> +  }
> +
> +  nMatchedLines = 0;
> +
> +  // Write the header.
> +
> +  fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
> +  fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
> +
> +  // Starting at the top of both files,...
> +
> +  unsigned o = 0;
> +  unsigned n = 0;
> +
> +  while (o < lines[0].size () || n < lines[1].size ()) {
> +
> +    // Find the bounds of the current contextual 'window'.
> +
> +    // If we aren't looking at a delete or an insert, we're not at the
> +    // start of a context window.
> +
> +    if (lines[0][o].l != ~0 && lines[1][n].l != ~0) {
> +      o += 1;
> +      n += 1;
> +      continue;
> +    }
> +
221,224c1395,1396
<      // begins here (or, rather, optCopyContext lines earlier).
<      
< -    int boOldWindow = max (0, int (boDeletes) - int(optCopyContext));
< -    int eoOldWindow = min (int (lines[0].size ()), int(o) + int(optCopyContext));
---
> +    // begins here (or, rather, optCopyContext lines earlier).
> +    
228,233d1399
< -    // Look for the end of the window.
< +    if (1 < optVerbose) {
< +      fprintf (stderr, "boOldWindow = %d, boNewWindow = %d\n", boOldWindow, boNewWindow);
< +      fflush (stderr);
< +    }
<  
236,249c1402,1412
< +    // Look for the end of the current window.
< +
< +    int eoOldWindow;
< +    int eoNewWindow;
< +
< +    bool widenWindow = true;
< +    while (widenWindow && o < lines[0].size () || n < lines[1].size ()) {
<  
<        // Skip over the delete(s) and/or insert(s) defining the current
<        // context.
< @@ -755,43 +792,59 @@
<          n += 1;
<        }
<  
---
> -
> -      // Skip over the delete(s) and/or insert(s) defining the current
> -      // context.
> -
> -      while (o < lines[0].size () && lines[0][o].l == ~0) {
> -        o += 1;
> -      }
> -      while (n < lines[1].size () && lines[1][n].l == ~0) {
> -        n += 1;
> -      }
> -
254,256c1417
< +      // This context will end optCopyContext matched lines past the
< +      // last set of deletes or inserts we find.
<  
---
> -
258,260c1419
< +      widenWindow = false;
< +      for (unsigned l = 0; !widenWindow && l < optCopyContext; l += 1) {
<          if (o < lines[0].size ()) {
---
> -        if (o < lines[0].size ()) {
264,267c1423,1425
< +          widenWindow |= lines[0][o].l == ~0;
<            o += 1;
<          }
<          if (n < lines[1].size ()) {
---
> -          o += 1;
> -        }
> -        if (n < lines[1].size ()) {
271,274c1429,1431
< +          widenWindow |= lines[1][n].l == ~0;
<            n += 1;
<          }
<        }
---
> -          n += 1;
> -        }
> -      }
275a1433,1666
> -
> -    // We've found the end of the window.
> -
> -    int boNewWindow = max (0, int (boInserts) - int (optCopyContext));
> -    int eoNewWindow = min (int (lines[1].size ()), int(n) + int (optCopyContext));
> -
> -    // Now, reset ourselves to the start of the window, and walk it to
> -    // produce the output.  We'll walk it twice, first for the old
> -    // file part, then for the new file part.
> -
> -    fprintf (stdout, "***************\n");
> -    fprintf (stdout, "*** %d,%d ****\n", boOldWindow + 1, eoOldWindow + 1);
> -
> -    o = boOldWindow;
> -    n = boNewWindow;
> -
> -    while (o < eoOldWindow && n < eoNewWindow) {
> -
> -      // Find any unmatched lines at this point in the old file.  These
> -      // are deletes.
> -
> -      unsigned boDeletes = o;
> -      while (o < eoOldWindow && lines[0][o].l == ~0) {
> -        o += 1;
> -      }
> -
> -      // Find any unmatched lines at this point in the new file.  These
> -      // are inserts.
> -
> -      unsigned boInserts = n;
> -      while (n < eoNewWindow && lines[1][n].l == ~0) {
> -        n += 1;
> -      }
> -
> -      // We've got deleted line(s) from boDeletes .. o.
> -      // We've got deleted line(s) from boInserts .. n.
> -
> -      unsigned nDeletes = o - boDeletes;
> -      unsigned nInserts = n - boInserts;
> -
> -      // We've got...
> -
> -      if (nDeletes && nInserts) {
> -
> -        // ... deletes and inserts.
> -
> -        for (unsigned l = boDeletes; l < o; l += 1) {
> -          fprintf (stdout, "! %s", lines[0][l].line->c_str ());
> -        }
> -      } else if (nDeletes) {
> -
> -        //  ... just deletes.
> -
> -        for (unsigned l = boDeletes; l < o; l += 1) {
> -          fprintf (stdout, "- %s", lines[0][l].line->c_str ());
> -        }
> -      }
> -
> -      // When we get here, we're dealing with matching lines.
> -
> -      fprintf (stdout, "  %s", lines[0][l].line->c_str ());
> -      o += 1;
> -      n += 1;
> +    if (1 < optVerbose) {
> +      fprintf (stderr, "boOldWindow = %d, boNewWindow = %d\n", boOldWindow, boNewWindow);
> +      fflush (stderr);
>      }
> +
> +    // Look for the end of the current window.
>  
> -    fprintf (stdout, "--- %d,%d ----\n", boNewWindow + 1, eoNewWindow + 1);
> -
> -    o = boOldWindow;
> -    n = boNewWindow;
> -
> -    while (o < eoOldWindow && n < eoNewWindow) {
> -
> -      // Find any unmatched lines at this point in the old file.  These
> -      // are deletes.
> -
> -      unsigned boDeletes = o;
> -      while (o < eoOldWindow && lines[0][o].l == ~0) {
> -        o += 1;
> -      }
> -
> -      // Find any unmatched lines at this point in the new file.  These
> -      // are inserts.
> -
> -      unsigned boInserts = n;
> -      while (n < eoNewWindow && lines[1][n].l == ~0) {
> -        n += 1;
> -      }
> -
> -      // We've got deleted line(s) from boDeletes .. o.
> -      // We've got deleted line(s) from boInserts .. n.
> -
> -      unsigned nDeletes = o - boDeletes;
> -      unsigned nInserts = n - boInserts;
> -
> -      // We've got...
> -
> -      if (nDeletes && nInserts) {
> -
> -        // ... deletes and inserts.
> -
> -        for (unsigned l = boInserts; l < n; l += 1) {
> -          fprintf (stdout, "! %s", lines[1][l].line->c_str ());
> -        }
> -      } else if (nInserts) {
> -
> -        //  ... just inserts.
> -
> -        for (unsigned l = boInserts; l < n; l += 1) {
> -          fprintf (stdout, "+ %s", lines[1][l].line->c_str ());
> -        }
> -      }
> -
> -      // When we get here, we're dealing with matching lines.
> -
> -      fprintf (stdout, "  %s", lines[1][l].line->c_str ());
> -      o += 1;
> -      n += 1;
> -    }
> -  }
> -}
> -
> -void pass6e () {
> -}
> +    int eoOldWindow;
> +    int eoNewWindow;
>  
> -void pass6i () {
> -}
> -
> -void pass6n ()
> -{
> -  if (0 < optVerbose) {
> -    fprintf (stderr, "# Pass #6n (walking the differences)...\n");
> -  }
> -
> -  nMatchedLines = 0;
> -
> -  // Write the header.  (None for normal.)
> -
> -  // Starting at the top of both files,...
> -
> -  unsigned o = 0;
> -  unsigned n = 0;
> -
> -  while (o < lines[0].size () || n < lines[1].size ()) {
> -
> -    // Find any unmatched lines at this point in the old file.  These
> -    // are deletes.
> -
> -    unsigned boDeletes;
> -    for (boDeletes = o;
> -         o < lines[0].size () && lines[0][o].l == ~0;
> -         o += 1
> -        )
> -    {}
> -
> -    // Find any unmatched lines at this point in the new file.  These
> -    // are inserts.
> -
> -    unsigned boInserts;
> -    for (boInserts = n;
> -         n < lines[1].size () && lines[1][n].l == ~0;
> -         n += 1
> -        )
> -    {}
> -
> -    // We've got deleted line(s) from boDeletes .. o.
> -    // We've got deleted line(s) from boInserts .. n.
> -
> -    unsigned nDeletes = o - boDeletes;
> -    unsigned nInserts = n - boInserts;
> -
> -    // We've got...
> -
> -    if (nDeletes && nInserts) {
> -
> -      // ... deletes and inserts.
> -
> -      if (1 < nDeletes && 1 < nInserts) {
> -        fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, boInserts + 1, n);
> -      } else if (1 < nDeletes) {
> -        fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boInserts + 1);
> -      } else if (1 < nInserts) {
> -        fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInserts + 1, n);
> -      } 
> -      for (unsigned l = boDeletes; l < o; l += 1) {
> -        fprintf (stdout, "< %s", lines[0][l].line->c_str ());
> -      }
> -      fprintf (stderr, "---\n");
> -      for (unsigned l = boInserts; l < n; l += 1) {
> -        fprintf (stdout, "> %s", lines[1][l].line->c_str ());
> -      }
> -    } else if (nDeletes) {
> -
> -      //  ... just deletes.
> -
> -      if (1 < nDeletes) {
> -        fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
> -      } else {
> -        fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
> -      }
> -      for (unsigned l = boDeletes; l < o; l += 1) {
> -        fprintf (stdout, "< %s", lines[0][l].line->c_str ());
> -      }
> -    } else if (nInserts) {
> -
> -      //  ... just inserts.
> -
> -      if (1 < nInserts) {
> -        fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
> -      } else {
> -        fprintf (stdout, "%da%d\n", o, boInserts + 1);
> -      }
> -      for (unsigned l = boInserts; l < n; l += 1) {
> -        fprintf (stdout, "> %s", lines[1][l].line->c_str ());
> -      }
> -    }
> -
> -    // When we get here, we're dealing with matching lines.
> -
> -    o += 1;
> -    n += 1;
> -  }
> -}
> -
> -void pass6r () {
> -}
> +    bool widenWindow = true;
> +    while (widenWindow && o < lines[0].size () || n < lines[1].size ()) {
276a1668,1770
> +      // Skip over the delete(s) and/or insert(s) defining the current
> +      // context.
> +
> +      while (o < lines[0].size () && lines[0][o].l == ~0) {
> +        o += 1;
> +      }
> +      while (n < lines[1].size () && lines[1][n].l == ~0) {
> +        n += 1;
> +      }
> +
> +      // This context will end optCopyContext matched lines past the
> +      // last set of deletes or inserts we find.
>  
> -void pass6s () {
> -}
> -
> -void pass6u ()
> -{
> -  if (0 < optVerbose) {
> -    fprintf (stderr, "# Pass #6u (walking the differences)...\n");
> -  }
> -
> -  nMatchedLines = 0;
> -
> -  // Write the header.
> -
> -  fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
> -  fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
> -  fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), lines[1].size ());
> -
> -  // Starting at the top of both files,...
> -
> -  unsigned o = 0;
> -  unsigned n = 0;
> -
> -  while (o < lines[0].size () || n < lines[1].size ()) {
> -
> -    // Find any unmatched lines at this point in the old file.  These
> -    // are deletes.
> -
> -    unsigned boDeletes;
> -    for (boDeletes = o;
> -         o < lines[0].size () && lines[0][o].l == ~0;
> -         o += 1
> -        )
> -    {}
> -
> -    // Find any unmatched lines at this point in the new file.  These
> -    // are inserts.
> -
> -    unsigned boInserts;
> -    for (boInserts = n;
> -         n < lines[1].size () && lines[1][n].l == ~0;
> -         n += 1
> -        )
> -    {}
> -
> -    // We've got deleted line(s) from boDeletes .. o.
> -    // We've got deleted line(s) from boInserts .. n.
> -
> -    unsigned nDeletes = o - boDeletes;
> -    unsigned nInserts = n - boInserts;
> -
> -    // We've got...
> -
> -    if (nDeletes && nInserts) {
> -
> -      // ... deletes and inserts.
> -
> -      for (unsigned l = boDeletes; l < o; l += 1) {
> -        fprintf (stdout, "-%s", lines[0][l].line->c_str ());
> -      }
> -      for (unsigned l = boInserts; l < n; l += 1) {
> -        fprintf (stdout, "+%s", lines[1][l].line->c_str ());
> -      }
> -    } else if (nDeletes) {
> -
> -      //  ... just deletes.
> -
> -      for (unsigned l = boDeletes; l < o; l += 1) {
> -        fprintf (stdout, "-%s", lines[0][l].line->c_str ());
> -      }
> -    } else if (nInserts) {
> -
> -      //  ... just inserts.
> -
> -      for (unsigned l = boInserts; l < n; l += 1) {
> -        fprintf (stdout, "+%s", lines[1][l].line->c_str ());
> -      }
> -    }
> +      widenWindow = false;
> +      for (unsigned l = 0; !widenWindow && l < optCopyContext; l += 1) {
> +        if (o < lines[0].size ()) {
> +          widenWindow |= lines[0][o].l == ~0;
> +          o += 1;
> +        }
> +        if (n < lines[1].size ()) {
> +          widenWindow |= lines[1][n].l == ~0;
> +          n += 1;
> +        }
> +      }
>  
> -    // When we get here, we're dealing with matching lines.
279c1773,1774
< +
---
>  
> -    fprintf (stdout, " %s", lines[0][o].line->c_str ());
296,300c1791,1793
<  
<      // We've found the end of the window.
<  
< -    int boNewWindow = max (0, int (boInserts) - int (optCopyContext));
< -    int eoNewWindow = min (int (lines[1].size ()), int(n) + int (optCopyContext));
---
> +
> +    // We've found the end of the window.
> +
305,311c1798,1803
<  
<      // Now, reset ourselves to the start of the window, and walk it to
<      // produce the output.  We'll walk it twice, first for the old
<      // file part, then for the new file part.
<  
<      fprintf (stdout, "***************\n");
< -    fprintf (stdout, "*** %d,%d ****\n", boOldWindow + 1, eoOldWindow + 1);
---
> +
> +    // Now, reset ourselves to the start of the window, and walk it to
> +    // produce the output.  We'll walk it twice, first for the old
> +    // file part, then for the new file part.
> +
> +    fprintf (stdout, "***************\n");
313,317c1805,1808
<  
<      o = boOldWindow;
<      n = boNewWindow;
<  
< -    while (o < eoOldWindow && n < eoNewWindow) {
---
> +
> +    o = boOldWindow;
> +    n = boNewWindow;
> +
319,326c1810,1839
<  
<        // Find any unmatched lines at this point in the old file.  These
<        // are deletes.
< @@ -822,25 +875,25 @@
<          // ... deletes and inserts.
<  
<          for (unsigned l = boDeletes; l < o; l += 1) {
< -          fprintf (stdout, "! %s", lines[0][l].line->c_str ());
---
> +
> +      // Find any unmatched lines at this point in the old file.  These
> +      // are deletes.
> +
> +      unsigned boDeletes = o;
> +      while (o < eoOldWindow && lines[0][o].l == ~0) {
> +        o += 1;
> +      }
> +
> +      // Find any unmatched lines at this point in the new file.  These
> +      // are inserts.
> +
> +      unsigned boInserts = n;
> +      while (n < eoNewWindow && lines[1][n].l == ~0) {
> +        n += 1;
> +      }
> +
> +      // We've got deleted line(s) from boDeletes .. o.
> +      // We've got deleted line(s) from boInserts .. n.
> +
> +      unsigned nDeletes = o - boDeletes;
> +      unsigned nInserts = n - boInserts;
> +
> +      // We've got...
> +
> +      if (nDeletes && nInserts) {
> +
> +        // ... deletes and inserts.
> +
> +        for (unsigned l = boDeletes; l < o; l += 1) {
328,334c1841,1846
<          }
<        } else if (nDeletes) {
<  
<          //  ... just deletes.
<  
<          for (unsigned l = boDeletes; l < o; l += 1) {
< -          fprintf (stdout, "- %s", lines[0][l].line->c_str ());
---
> +        }
> +      } else if (nDeletes) {
> +
> +        //  ... just deletes.
> +
> +        for (unsigned l = boDeletes; l < o; l += 1) {
336,341c1848,1852
<          }
<        }
<  
<        // When we get here, we're dealing with matching lines.
<  
< -      fprintf (stdout, "  %s", lines[0][l].line->c_str ());
---
> +        }
> +      }
> +
> +      // When we get here, we're dealing with matching lines.
> +
343,347c1854,1857
<        o += 1;
<        n += 1;
<      }
<  
< -    fprintf (stdout, "--- %d,%d ----\n", boNewWindow + 1, eoNewWindow + 1);
---
> +      o += 1;
> +      n += 1;
> +    }
> +
349,356c1859,1893
<  
<      o = boOldWindow;
<      n = boNewWindow;
< @@ -876,36 +929,46 @@
<          // ... deletes and inserts.
<  
<          for (unsigned l = boInserts; l < n; l += 1) {
< -          fprintf (stdout, "! %s", lines[1][l].line->c_str ());
---
> +
> +    o = boOldWindow;
> +    n = boNewWindow;
> +
> +    while (o < eoOldWindow && n < eoNewWindow) {
> +
> +      // Find any unmatched lines at this point in the old file.  These
> +      // are deletes.
> +
> +      unsigned boDeletes = o;
> +      while (o < eoOldWindow && lines[0][o].l == ~0) {
> +        o += 1;
> +      }
> +
> +      // Find any unmatched lines at this point in the new file.  These
> +      // are inserts.
> +
> +      unsigned boInserts = n;
> +      while (n < eoNewWindow && lines[1][n].l == ~0) {
> +        n += 1;
> +      }
> +
> +      // We've got deleted line(s) from boDeletes .. o.
> +      // We've got deleted line(s) from boInserts .. n.
> +
> +      unsigned nDeletes = o - boDeletes;
> +      unsigned nInserts = n - boInserts;
> +
> +      // We've got...
> +
> +      if (nDeletes && nInserts) {
> +
> +        // ... deletes and inserts.
> +
> +        for (unsigned l = boInserts; l < n; l += 1) {
358,364c1895,1900
<          }
<        } else if (nInserts) {
<  
<          //  ... just inserts.
<  
<          for (unsigned l = boInserts; l < n; l += 1) {
< -          fprintf (stdout, "+ %s", lines[1][l].line->c_str ());
---
> +        }
> +      } else if (nInserts) {
> +
> +        //  ... just inserts.
> +
> +        for (unsigned l = boInserts; l < n; l += 1) {
366,371c1902,1906
<          }
<        }
<  
<        // When we get here, we're dealing with matching lines.
<  
< -      fprintf (stdout, "  %s", lines[1][l].line->c_str ());
---
> +        }
> +      }
> +
> +      // When we get here, we're dealing with matching lines.
> +
373,375c1908,1910
<        o += 1;
<        n += 1;
<      }
---
> +      o += 1;
> +      n += 1;
> +    }
381,384c1916,1919
<    }
<  }
<  
<  void pass6e () {
---
> +  }
> +}
> +
> +void pass6e () {
387,389c1922,1924
<  }
<  
<  void pass6i () {
---
> +}
> +
> +void pass6i () {
392,397c1927,1932
<  }
<  
<  void pass6n ()
<  {
<    if (0 < optVerbose) {
<      fprintf (stderr, "# Pass #6n (walking the differences)...\n");
---
> +}
> +
> +void pass6n ()
> +{
> +  if (0 < optVerbose) {
> +    fprintf (stderr, "# Pass #6n (walking the differences)...\n");
399,406c1934,1986
<    }
<  
<    nMatchedLines = 0;
< @@ -959,11 +1022,11 @@
<          fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInserts + 1, n);
<        } 
<        for (unsigned l = boDeletes; l < o; l += 1) {
< -        fprintf (stdout, "< %s", lines[0][l].line->c_str ());
---
> +  }
> +
> +  nMatchedLines = 0;
> +
> +  // Write the header.  (None for normal.)
> +
> +  // Starting at the top of both files,...
> +
> +  unsigned o = 0;
> +  unsigned n = 0;
> +
> +  while (o < lines[0].size () || n < lines[1].size ()) {
> +
> +    // Find any unmatched lines at this point in the old file.  These
> +    // are deletes.
> +
> +    unsigned boDeletes;
> +    for (boDeletes = o;
> +         o < lines[0].size () && lines[0][o].l == ~0;
> +         o += 1
> +        )
> +    {}
> +
> +    // Find any unmatched lines at this point in the new file.  These
> +    // are inserts.
> +
> +    unsigned boInserts;
> +    for (boInserts = n;
> +         n < lines[1].size () && lines[1][n].l == ~0;
> +         n += 1
> +        )
> +    {}
> +
> +    // We've got deleted line(s) from boDeletes .. o.
> +    // We've got deleted line(s) from boInserts .. n.
> +
> +    unsigned nDeletes = o - boDeletes;
> +    unsigned nInserts = n - boInserts;
> +
> +    // We've got...
> +
> +    if (nDeletes && nInserts) {
> +
> +      // ... deletes and inserts.
> +
> +      if (1 < nDeletes && 1 < nInserts) {
> +        fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, boInserts + 1, n);
> +      } else if (1 < nDeletes) {
> +        fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boInserts + 1);
> +      } else if (1 < nInserts) {
> +        fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInserts + 1, n);
> +      } 
> +      for (unsigned l = boDeletes; l < o; l += 1) {
408,409c1988
<        }
< -      fprintf (stderr, "---\n");
---
> +      }
411,412c1990
<        for (unsigned l = boInserts; l < n; l += 1) {
< -        fprintf (stdout, "> %s", lines[1][l].line->c_str ());
---
> +      for (unsigned l = boInserts; l < n; l += 1) {
414,421c1992,2002
<        }
<      } else if (nDeletes) {
<  
< @@ -975,7 +1038,7 @@
<          fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
<        }
<        for (unsigned l = boDeletes; l < o; l += 1) {
< -        fprintf (stdout, "< %s", lines[0][l].line->c_str ());
---
> +      }
> +    } else if (nDeletes) {
> +
> +      //  ... just deletes.
> +
> +      if (1 < nDeletes) {
> +        fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
> +      } else {
> +        fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
> +      }
> +      for (unsigned l = boDeletes; l < o; l += 1) {
423,430c2004,2014
<        }
<      } else if (nInserts) {
<  
< @@ -987,7 +1050,7 @@
<          fprintf (stdout, "%da%d\n", o, boInserts + 1);
<        }
<        for (unsigned l = boInserts; l < n; l += 1) {
< -        fprintf (stdout, "> %s", lines[1][l].line->c_str ());
---
> +      }
> +    } else if (nInserts) {
> +
> +      //  ... just inserts.
> +
> +      if (1 < nInserts) {
> +        fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
> +      } else {
> +        fprintf (stdout, "%da%d\n", o, boInserts + 1);
> +      }
> +      for (unsigned l = boInserts; l < n; l += 1) {
432,438c2016,2026
<        }
<      }
<  
< @@ -999,15 +1062,20 @@
<  }
<  
<  void pass6r () {
---
> +      }
> +    }
> +
> +    // When we get here, we're dealing with matching lines.
> +
> +    o += 1;
> +    n += 1;
> +  }
> +}
> +
> +void pass6r () {
441,443c2029,2031
<  }
<  
<  void pass6s () {
---
> +}
> +
> +void pass6s () {
446,451c2034,2039
<  }
<  
<  void pass6u ()
<  {
<    if (0 < optVerbose) {
<      fprintf (stderr, "# Pass #6u (walking the differences)...\n");
---
> +}
> +
> +void pass6u ()
> +{
> +  if (0 < optVerbose) {
> +    fprintf (stderr, "# Pass #6u (walking the differences)...\n");
453,460c2041,2090
<    }
<  
<    nMatchedLines = 0;
< @@ -1058,30 +1126,126 @@
<        // ... deletes and inserts.
<  
<        for (unsigned l = boDeletes; l < o; l += 1) {
< -        fprintf (stdout, "-%s", lines[0][l].line->c_str ());
---
> +  }
> +
> +  nMatchedLines = 0;
> +
> +  // Write the header.
> +
> +  fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
> +  fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
> +  fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), lines[1].size ());
> +
> +  // Starting at the top of both files,...
> +
> +  unsigned o = 0;
> +  unsigned n = 0;
> +
> +  while (o < lines[0].size () || n < lines[1].size ()) {
> +
> +    // Find any unmatched lines at this point in the old file.  These
> +    // are deletes.
> +
> +    unsigned boDeletes;
> +    for (boDeletes = o;
> +         o < lines[0].size () && lines[0][o].l == ~0;
> +         o += 1
> +        )
> +    {}
> +
> +    // Find any unmatched lines at this point in the new file.  These
> +    // are inserts.
> +
> +    unsigned boInserts;
> +    for (boInserts = n;
> +         n < lines[1].size () && lines[1][n].l == ~0;
> +         n += 1
> +        )
> +    {}
> +
> +    // We've got deleted line(s) from boDeletes .. o.
> +    // We've got deleted line(s) from boInserts .. n.
> +
> +    unsigned nDeletes = o - boDeletes;
> +    unsigned nInserts = n - boInserts;
> +
> +    // We've got...
> +
> +    if (nDeletes && nInserts) {
> +
> +      // ... deletes and inserts.
> +
> +      for (unsigned l = boDeletes; l < o; l += 1) {
462,464c2092,2093
<        }
<        for (unsigned l = boInserts; l < n; l += 1) {
< -        fprintf (stdout, "+%s", lines[1][l].line->c_str ());
---
> +      }
> +      for (unsigned l = boInserts; l < n; l += 1) {
466,472c2095,2100
<        }
<      } else if (nDeletes) {
<  
<        //  ... just deletes.
<  
<        for (unsigned l = boDeletes; l < o; l += 1) {
< -        fprintf (stdout, "-%s", lines[0][l].line->c_str ());
---
> +      }
> +    } else if (nDeletes) {
> +
> +      //  ... just deletes.
> +
> +      for (unsigned l = boDeletes; l < o; l += 1) {
474,480c2102,2107
<        }
<      } else if (nInserts) {
<  
<        //  ... just inserts.
<  
<        for (unsigned l = boInserts; l < n; l += 1) {
< -        fprintf (stdout, "+%s", lines[1][l].line->c_str ());
---
> +      }
> +    } else if (nInserts) {
> +
> +      //  ... just inserts.
> +
> +      for (unsigned l = boInserts; l < n; l += 1) {
482,487c2109,2113
<        }
<      }
<  
<      // When we get here, we're dealing with matching lines.
<  
< -    fprintf (stdout, " %s", lines[0][o].line->c_str ());
---
> +      }
> +    }
> +
> +    // When we get here, we're dealing with matching lines.
> +
587a2214
>  }
# ../sdiff -u dif.7.cpp dif.6.cpp >& dif.7.6.diff-u.test
./test: line 46: 23483 Aborted                 (core dumped) ${DIFF} "${option}" "${oSrc}" "${nSrc}" 1>&"${dst}.test"
# dif.7.6.diff-u ---------------------------------------------------------------
1,3c1,25
< --- dif.7.cpp	2008-02-25 22:43:43.000000000 +0000
< +++ dif.6.cpp	2008-02-25 19:54:55.000000000 +0000
< @@ -22,11 +22,10 @@
---
> sdiff: sdiff.cpp:1745: void pass6u(): Assertion `lines[0][o].line == lines[1][n].line' failed.
> --- dif.7.cpp	0000-00-00 00:00:00.000000000 +0000
> +++ dif.6.cpp	0000-00-00 00:00:00.000000000 +0000
> @@ -1,1252 +1,1088 @@
>  #include <algorithm>
>  using std::find;
>  #include <string>
>  using std::string;
>  #include <list>
>  using std::list;
>  #include <map>
>  using std::map;
>  #include <vector>
>  using std::vector;
>  #include <stdio.h>
>  
>  enum DiffFormat {
>    Default,
>  
>    Context,
>    EdScript,
>    IfThenElse,
>    Normal,
>    RCS,
>    SideBySide,
18c40,52
< @@ -46,7 +45,7 @@
---
>      string (_text)
>    {
>    }
>    ~Line () {
>      copies[0].erase (copies[0].begin (), copies[0].end ());
>      copies[1].erase (copies[1].begin (), copies[1].end ());
>    }
>    void Dump (FILE *out) {
>      fprintf (out, "{{ ");
>      for (list<unsigned>::iterator i = copies[0].begin (); i != copies[0].end (); i++) {
>        fprintf (out, "%u ", *i);
>      }
>      fprintf (out, "},{ ");
27,197d60
< @@ -108,7 +107,6 @@
<      if (FILE *f = fopen (files[n], "r")) {
<        if (0 < optVerbose) {
<          fprintf (stderr, "# Reading %s...", files[n]);
< -        fflush (stderr);
<        }
<  
<        char buffer[1024];
< @@ -117,8 +115,6 @@
<        while (fgets (buffer, sizeof (buffer), f)) {
<          string text (buffer);
<  
< -        text.erase (text.end () - 1);
< -
<          Line *line = table[text];
<  
<          if (!line) {
< @@ -131,11 +127,9 @@
<  
<        if (0 < optVerbose) {
<          fprintf (stderr, " %u lines, %u unique.\n", lines[n].size (), nUniq);
< -        fflush (stderr);
<        }
<      } else {
<        fprintf (stderr, "%s: Unable to open %s!  Exiting....\n", ARGV0, files[n]);
< -      fflush (stderr);
<        perror (ARGV0);
<        exit (1);
<      }
< @@ -143,7 +137,6 @@
<  
<    if (0 < optVerbose) {
<      fprintf (stderr, "# Total unique lines = %d\n", table.size ());
< -    fflush (stderr);
<    }
<  
<    // map<int, int> counts;
< @@ -173,7 +166,6 @@
<  {
<    if (0 < optVerbose) {
<      fprintf (stderr, "# Pass 1 (finding matches amongst unique lines)...");
< -    fflush (stderr);
<    }
<  
<    nMatchedLines = 0;
< @@ -216,15 +208,12 @@
<  
<    if (0 < optVerbose) {
<      fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
< -    fflush (stderr);
<  
< -    if (2 < optVerbose) {
< +    if (1 < optVerbose) {
<        for (int f = 0; f < 2; f += 1) {
<          fprintf (stderr, "# file #%d\n", f + 1);
< -        fflush (stderr);
<          for (int l = 0; l < lines[f].size (); l += 1) {
<            fprintf (stderr, "#   [%d] ", l);
< -          fflush (stderr);
<            lines[f][l].Dump (stderr);
<          }
<        }
< @@ -239,7 +228,6 @@
<  {
<    if (0 < optVerbose) {
<      fprintf (stderr, "# Pass #2 (spreading matches down)...");
< -    fflush (stderr);
<    }
<  
<    nMatchedBlocks = 0;
< @@ -316,14 +304,11 @@
<               nTotalMatchedLines,
<               nTotalMatchedBlocks
<              );
< -    fflush (stderr);
< -    if (2 < optVerbose) {
< +    if (1 < optVerbose) {
<        for (int f = 0; f < 2; f += 1) {
<          fprintf (stderr, "# file #%d\n", f + 1);
< -        fflush (stderr);
<          for (int l = 0; l < lines[f].size (); l += 1) {
<            fprintf (stderr, "#   [%d] ", l);
< -          fflush (stderr);
<            lines[f][l].Dump (stderr);
<          }
<        }
< @@ -338,7 +323,6 @@
<  {
<    if (0 < optVerbose) {
<      fprintf (stderr, "# Pass #3 (spreading matches up)...");
< -    fflush (stderr);
<    }
<  
<    nMatchedBlocks = 0;
< @@ -414,15 +398,12 @@
<               nTotalMatchedLines,
<               nTotalMatchedBlocks
<              );
< -    fflush (stderr);
<  
< -    if (2 < optVerbose) {
< +    if (1 < optVerbose) {
<        for (int f = 0; f < 2; f += 1) {
<          fprintf (stderr, "# file #%d\n", f + 1);
< -        fflush (stderr);
<          for (int l = 0; l < lines[f].size (); l += 1) {
<            fprintf (stderr, "#   [%d] ", l);
< -          fflush (stderr);
<            lines[f][l].Dump (stderr);
<          }
<        }
< @@ -438,7 +419,6 @@
<  {
<    if (0 < optVerbose) {
<      fprintf (stderr, "# Pass 4 (finding remaining matches amongst unique lines)...");
< -    fflush (stderr);
<    }
<  
<    nMatchedLines = 0;
< @@ -478,15 +458,12 @@
<  
<    if (0 < optVerbose) {
<      fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
< -    fflush (stderr);
<  
< -    if (2 < optVerbose) {
< +    if (1 < optVerbose) {
<        for (int f = 0; f < 2; f += 1) {
<          fprintf (stderr, "# file #%d\n", f + 1);
< -        fflush (stderr);
<          for (int l = 0; l < lines[f].size (); l += 1) {
<            fprintf (stderr, "#   [%d] ", l);
< -          fflush (stderr);
<            lines[f][l].Dump (stderr);
<          }
<        }
< @@ -503,7 +480,6 @@
<  {
<    if (0 < optVerbose) {
<      fprintf (stderr, "# Pass #5 (unmatching block moves)...\n");
< -    fflush (stderr);
<    }
<  
<    nMatchedBlocks = 0;
< @@ -652,15 +628,12 @@
<               nTotalMatchedLines,
<               nTotalMatchedBlocks
<              );
< -    fflush (stderr);
<  
< -    if (2 < optVerbose) {
< +    if (1 < optVerbose) {
<        for (int f = 0; f < 2; f += 1) {
<          fprintf (stderr, "# file #%d\n", f + 1);
< -        fflush (stderr);
<          for (int l = 0; l < lines[f].size (); l += 1) {
<            fprintf (stderr, "#   [%d] ", l);
< -          fflush (stderr);
<            lines[f][l].Dump (stderr);
<          }
<        }
< @@ -677,7 +650,6 @@
<  void pass6r ();
<  void pass6s ();
<  void pass6u ();
< -void pass6y ();
<  
<  void pass6 ()
<  {
< @@ -704,7 +676,7 @@
<      break;
199,211c62,70
<    case SideBySide:
< -    pass6y ();
< +    pass6s ();
<      break;
<  
<    case Unified:
< @@ -734,8 +706,7 @@
<  
<  void pass6c () {
<    if (0 < optVerbose) {
< -    fprintf (stderr, "# Pass #6c (walking the differences)...\n");
< -    fflush (stderr);
< +    fprintf (stderr, "# Pass #6u (walking the differences)...\n");
---
>  struct LinePtr {
>    LinePtr (Line *_line) :
>      line (_line),
>      l (~0u)
>    {
>    }
>    void Dump (FILE *out) {
>      fprintf (out, "[%d] ", l);
>      line->Dump (out);
212a72,74
>    Line *line;
>    unsigned l;
>  };
214,345c76,77
<    nMatchedLines = 0;
< @@ -763,24 +734,16 @@
<        continue;
<      }
<  
< -    // We're now looking at at least 1 delete or insert, so a window
< +    // We're looking at at least 1 delete or insert, so a window
<      // begins here (or, rather, optCopyContext lines earlier).
<      
< -    int boOldWindow = max (0, int (o) - int (optCopyContext));
< -    int boNewWindow = max (0, int (n) - int (optCopyContext));
< -
< -    if (1 < optVerbose) {
< -      fprintf (stderr, "boOldWindow = %d, boNewWindow = %d\n", boOldWindow, boNewWindow);
< -      fflush (stderr);
< -    }
< +    int boOldWindow = max (0, int (boDeletes) - int(optCopyContext));
< +    int eoOldWindow = min (int (lines[0].size ()), int(o) + int(optCopyContext));
<  
< -    // Look for the end of the current window.
< +    // Look for the end of the window.
<  
< -    int eoOldWindow;
< -    int eoNewWindow;
< -
< -    bool widenWindow = true;
< -    while (widenWindow && o < lines[0].size () || n < lines[1].size ()) {
< +    bool widenWindow = false;
< +    do {
<  
<        // Skip over the delete(s) and/or insert(s) defining the current
<        // context.
< @@ -792,59 +755,43 @@
<          n += 1;
<        }
<  
< -      // This context will end optCopyContext matched lines past the
< -      // last set of deletes or inserts we find.
< +      // ...  This context will end optCopyContext lines past the last
< +      // set of deletes or inserts we find.  However, since another
< +      // window could follow, we look 2 * optCopyContext ahead for
< +      // another delete or insert.
<  
< -      widenWindow = false;
< -      for (unsigned l = 0; !widenWindow && l < optCopyContext; l += 1) {
< +      for (unsigned l = 0; l < (2 * optCopyContext); i += 1) {
<          if (o < lines[0].size ()) {
< -          widenWindow |= lines[0][o].l == ~0;
< +          if (widenWindow |= lines[0][o].l == ~0) {
< +            break;
< +          }
<            o += 1;
<          }
<          if (n < lines[1].size ()) {
< -          widenWindow |= lines[1][n].l == ~0;
< +          if (widenWindow |= lines[1][o].l == ~0) {
< +            break;
< +          }
<            n += 1;
<          }
<        }
< -
< -      eoOldWindow = o;
< -      eoNewWindow = n;
< -
< -      // However, since another window could follow, we look
< -      // optCopyContext ahead for another delete or insert.
< -
< -      if (!widenWindow) {
< -        for (unsigned l = 0; l < (2 * optCopyContext + 1); l += 1) {
< -          if (o < lines[0].size ()) {
< -            widenWindow |= lines[0][o].l == ~0;
< -            o += 1;
< -          }
< -          if (n < lines[1].size ()) {
< -            widenWindow |= lines[1][n].l == ~0;
< -            n += 1;
< -          }
< -        }
< -      }
< -    }
< +    } while (widenWindow);
<  
<      // We've found the end of the window.
<  
< -    if (1 < optVerbose) {
< -      fprintf (stderr, "eoOldWindow = %d, eoNewWindow = %d\n", eoOldWindow, eoNewWindow);
< -      fflush (stderr);
< -    }
< +    int boNewWindow = max (0, int (boInserts) - int (optCopyContext));
< +    int eoNewWindow = min (int (lines[1].size ()), int(n) + int (optCopyContext));
<  
<      // Now, reset ourselves to the start of the window, and walk it to
<      // produce the output.  We'll walk it twice, first for the old
<      // file part, then for the new file part.
<  
<      fprintf (stdout, "***************\n");
< -    fprintf (stdout, "*** %d,%d ****\n", boOldWindow + 1, eoOldWindow);
< +    fprintf (stdout, "*** %d,%d ****\n", boOldWindow + 1, eoOldWindow + 1);
<  
<      o = boOldWindow;
<      n = boNewWindow;
<  
< -    while (o < eoOldWindow || n < eoNewWindow) {
< +    while (o < eoOldWindow && n < eoNewWindow) {
<  
<        // Find any unmatched lines at this point in the old file.  These
<        // are deletes.
< @@ -875,25 +822,25 @@
<          // ... deletes and inserts.
<  
<          for (unsigned l = boDeletes; l < o; l += 1) {
< -          fprintf (stdout, "! %s\n", lines[0][l].line->c_str ());
< +          fprintf (stdout, "! %s", lines[0][l].line->c_str ());
<          }
<        } else if (nDeletes) {
<  
<          //  ... just deletes.
<  
<          for (unsigned l = boDeletes; l < o; l += 1) {
< -          fprintf (stdout, "- %s\n", lines[0][l].line->c_str ());
< +          fprintf (stdout, "- %s", lines[0][l].line->c_str ());
<          }
<        }
<  
<        // When we get here, we're dealing with matching lines.
<  
< -      fprintf (stdout, "  %s\n", lines[0][o].line->c_str ());
< +      fprintf (stdout, "  %s", lines[0][l].line->c_str ());
<        o += 1;
<        n += 1;
<      }
---
>  typedef map<string, Line *> MapStringToLinePtr;
>  typedef vector<LinePtr> VectorLinePtr;
347,348c79
< -    fprintf (stdout, "--- %d,%d ----\n", boNewWindow + 1, eoNewWindow);
< +    fprintf (stdout, "--- %d,%d ----\n", boNewWindow + 1, eoNewWindow + 1);
---
>  // Our name.
350,367c81
<      o = boOldWindow;
<      n = boNewWindow;
< @@ -929,46 +876,36 @@
<          // ... deletes and inserts.
<  
<          for (unsigned l = boInserts; l < n; l += 1) {
< -          fprintf (stdout, "! %s\n", lines[1][l].line->c_str ());
< +          fprintf (stdout, "! %s", lines[1][l].line->c_str ());
<          }
<        } else if (nInserts) {
<  
<          //  ... just inserts.
<  
<          for (unsigned l = boInserts; l < n; l += 1) {
< -          fprintf (stdout, "+ %s\n", lines[1][l].line->c_str ());
< +          fprintf (stdout, "+ %s", lines[1][l].line->c_str ());
<          }
<        }
---
>  char *ARGV0 = "dif3";
369c83
<        // When we get here, we're dealing with matching lines.
---
>  // The 'symbol' (line) table.
371,382c85
< -      fprintf (stdout, "  %s\n", lines[1][n].line->c_str ());
< +      fprintf (stdout, "  %s", lines[1][l].line->c_str ());
<        o += 1;
<        n += 1;
<      }
< -
< -    // Reset to the end of the current window.
< -
< -    o = eoOldWindow;
< -    n = eoNewWindow;
<    }
<  }
---
>  MapStringToLinePtr table;
384,392c87
<  void pass6e () {
< -  fprintf (stderr, "pass6e() is unimplemented!\n");
< -  fflush (stderr);
<  }
<  
<  void pass6i () {
< -  fprintf (stderr, "pass6i() is unimplemented!\n");
< -  fflush (stderr);
<  }
---
>  // The names of the 2 files to be diff'd.
394,399c89
<  void pass6n ()
<  {
<    if (0 < optVerbose) {
<      fprintf (stderr, "# Pass #6n (walking the differences)...\n");
< -    fflush (stderr);
<    }
---
>  char const *files[2] = { 0, 0 };
401,415c91
<    nMatchedLines = 0;
< @@ -1022,11 +959,11 @@
<          fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInserts + 1, n);
<        } 
<        for (unsigned l = boDeletes; l < o; l += 1) {
< -        fprintf (stdout, "< %s\n", lines[0][l].line->c_str ());
< +        fprintf (stdout, "< %s", lines[0][l].line->c_str ());
<        }
< -      fprintf (stdout, "---\n");
< +      fprintf (stderr, "---\n");
<        for (unsigned l = boInserts; l < n; l += 1) {
< -        fprintf (stdout, "> %s\n", lines[1][l].line->c_str ());
< +        fprintf (stdout, "> %s", lines[1][l].line->c_str ());
<        }
<      } else if (nDeletes) {
---
>  // The lines of the 2 files to be diff'd.
417,424c93
< @@ -1038,7 +975,7 @@
<          fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
<        }
<        for (unsigned l = boDeletes; l < o; l += 1) {
< -        fprintf (stdout, "< %s\n", lines[0][l].line->c_str ());
< +        fprintf (stdout, "< %s", lines[0][l].line->c_str ());
<        }
<      } else if (nInserts) {
---
>  VectorLinePtr lines[2];
426,433c95
< @@ -1050,7 +987,7 @@
<          fprintf (stdout, "%da%d\n", o, boInserts + 1);
<        }
<        for (unsigned l = boInserts; l < n; l += 1) {
< -        fprintf (stdout, "> %s\n", lines[1][l].line->c_str ());
< +        fprintf (stdout, "> %s", lines[1][l].line->c_str ());
<        }
<      }
---
>  // Miscellaneous metrics.
435,436c97,100
< @@ -1062,20 +999,15 @@
<  }
---
>  unsigned nTotalMatchedBlocks = 0;
>  unsigned nMatchedBlocks = 0;
>  unsigned nTotalMatchedLines = 0;
>  unsigned nMatchedLines = 0;
438,446c102,107
<  void pass6r () {
< -  fprintf (stderr, "pass6r() is unimplemented!\n");
< -  fflush (stderr);
<  }
<  
<  void pass6s () {
< -  fprintf (stderr, "pass6s() is unimplemented!\n");
< -  fflush (stderr);
<  }
---
>  void pass1 ();
>  void pass2 ();
>  void pass3 ();
>  void pass4 ();
>  void pass5 ();
>  void pass6 ();
448c109
<  void pass6u ()
---
>  int main (int argc, char *argv[])
450,469c111
<    if (0 < optVerbose) {
<      fprintf (stderr, "# Pass #6u (walking the differences)...\n");
< -    fflush (stderr);
<    }
<  
<    nMatchedLines = 0;
< @@ -1126,126 +1058,30 @@
<        // ... deletes and inserts.
<  
<        for (unsigned l = boDeletes; l < o; l += 1) {
< -        fprintf (stdout, "-%s\n", lines[0][l].line->c_str ());
< +        fprintf (stdout, "-%s", lines[0][l].line->c_str ());
<        }
<        for (unsigned l = boInserts; l < n; l += 1) {
< -        fprintf (stdout, "+%s\n", lines[1][l].line->c_str ());
< +        fprintf (stdout, "+%s", lines[1][l].line->c_str ());
<        }
<      } else if (nDeletes) {
<  
<        //  ... just deletes.
---
>    // Read the old [0] file, and the new [1] file.
471,477c113,114
<        for (unsigned l = boDeletes; l < o; l += 1) {
< -        fprintf (stdout, "-%s\n", lines[0][l].line->c_str ());
< +        fprintf (stdout, "-%s", lines[0][l].line->c_str ());
<        }
<      } else if (nInserts) {
<  
<        //  ... just inserts.
---
>    for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
>      files[n] = argv[a];
479,481c116,119
<        for (unsigned l = boInserts; l < n; l += 1) {
< -        fprintf (stdout, "+%s\n", lines[1][l].line->c_str ());
< +        fprintf (stdout, "+%s", lines[1][l].line->c_str ());
---
>      if (FILE *f = fopen (files[n], "r")) {
>        if (0 < optVerbose) {
>          fprintf (stderr, "# Reading %s...", files[n]);
> -        fflush (stderr);
483d120
<      }
485c122,123
<      // When we get here, we're dealing with matching lines.
---
>        char buffer[1024];
>        unsigned nUniq = 0;
487,587c125,139
< -    fprintf (stdout, " %s\n", lines[0][o].line->c_str ());
< -    o += 1;
< -    n += 1;
< -  }
< -}
< -
< -void pass6y ()
< -{
< -  if (0 < optVerbose) {
< -    fprintf (stderr, "# Pass #6y (walking the differences)...\n");
< -    fflush (stderr);
< -  }
< -
< -  // Write the header.
< -
< -  // None for side-by-side.
< -
< -  // Starting at the top of both files,...
< -
< -  int columnWidth = (optPageWidth - 7) / 2;
< -
< -  unsigned o = 0;
< -  unsigned n = 0;
< -
< -  while (o < lines[0].size () || n < lines[1].size ()) {
< -
< -    // Find any unmatched lines at this point in the old file.  These
< -    // are deletes.
< -
< -    unsigned boDeletes = o;
< -    while (o < lines[0].size () && lines[0][o].l == ~0) {
< -      o += 1;
< -    }
< -
< -    // Find any unmatched lines at this point in the new file.  These
< -    // are inserts.
< -
< -    unsigned boInserts = n;
< -    while (n < lines[1].size () && lines[1][n].l == ~0) {
< -      n += 1;
< -    }
< -
< -    // We've got deleted line(s) from boDeletes .. o.
< -    // We've got deleted line(s) from boInserts .. n.
< -
< -    unsigned nDeletes = o - boDeletes;
< -    unsigned nInserts = n - boInserts;
< -
< -    // We've got...
< -
< -    while (boDeletes < o && boInserts < n) {
< -
< -      // ... deletes and inserts.
< -
< -      fprintf (stdout,
< -               "%-*s | %s\n",
< -               columnWidth,
< -               lines[0][boDeletes].line->substr (0, columnWidth).c_str (),
< -               lines[1][boInserts].line->substr (0, columnWidth).c_str ()
< -              );
< -      boDeletes += 1;
< -      boInserts += 1;
< -    }
< -
< -    while (boDeletes < o) {
< -
< -      //  ... just deletes.
< -
< -      fprintf (stdout,
< -               "%-*s <\n",
< -               columnWidth,
< -               lines[0][boDeletes].line->substr (0, columnWidth).c_str ()
< -              );
< -      boDeletes += 1;
< -    }
< -
< -    while (boInserts < n) {
< -
< -      //  ... just inserts.
< -
< -      fprintf (stdout,
< -               "%-*s > %s\n",
< -               columnWidth,
< -               "",
< -               lines[1][boInserts].line->substr (0, columnWidth).c_str ()
< -              );
< -      boInserts += 1;
< -    }
< -
< -    // When we get here, we're dealing with matching lines.
< -
< -    fprintf (stdout,
< -             "%-*s   %s\n",
< -             columnWidth,
< -             lines[0][o].line->substr (0, columnWidth).c_str (),
< -             lines[1][n].line->substr (0, columnWidth).c_str ()
< -            );
< +    fprintf (stdout, " %s", lines[0][o].line->c_str ());
<      o += 1;
<      n += 1;
<    }
---
>        while (fgets (buffer, sizeof (buffer), f)) {
>          string text (buffer);
> +
> +        Line *line = table[text];
> +
> +        if (!line) {
> +          table[text] = line = new Line (text);
> +          nUniq += 1;
> +        }
> +        line->copies[n].push_back (lines[n].size ());
> +        lines[n].push_back (line);
> +      }
> +
> +      if (0 < optVerbose) {
> +        fprintf (stderr, " %u lines, %u unique.\n", lines[n].size (), nUniq);
# ../sdiff -u dif.7.cpp dif.8.cpp >& dif.7.8.diff-u.test
# dif.7.8.diff-u ---------------------------------------------------------------
1,3c1,11
< --- dif.7.cpp	2008-02-25 22:43:43.000000000 +0000
< +++ dif.8.cpp	2008-02-26 01:32:31.000000000 +0000
< @@ -9,23 +9,46 @@
---
> --- dif.7.cpp	0000-00-00 00:00:00.000000000 +0000
> +++ dif.8.cpp	0000-00-00 00:00:00.000000000 +0000
> @@ -1,1252 +1,1674 @@
>  #include <algorithm>
>  using std::find;
>  #include <string>
>  using std::string;
>  #include <list>
>  using std::list;
>  #include <map>
>  using std::map;
62c70,128
< @@ -91,6 +114,8 @@
---
>    Line (string _text) :
>      string (_text)
>    {
>    }
>    ~Line () {
>      copies[0].erase (copies[0].begin (), copies[0].end ());
>      copies[1].erase (copies[1].begin (), copies[1].end ());
>    }
>    void Dump (FILE *out) {
>      fprintf (out, "{{ ");
>      for (list<unsigned>::iterator i = copies[0].begin (); i != copies[0].end (); i++) {
>        fprintf (out, "%u ", *i);
>      }
>      fprintf (out, "},{ ");
>      for (list<unsigned>::iterator i = copies[1].begin (); i != copies[1].end (); i++) {
>        fprintf (out, "%u ", *i);
>      }
>      fprintf (out, "}}\t%s\n", c_str ());
>    }
>    list<unsigned> copies[2];
>  };
>  
>  struct LinePtr {
>    LinePtr (Line *_line) :
>      line (_line),
>      l (~0u)
>    {
>    }
>    void Dump (FILE *out) {
>      fprintf (out, "[%d] ", l);
>      line->Dump (out);
>    }
>    Line *line;
>    unsigned l;
>  };
>  
>  typedef map<string, Line *> MapStringToLinePtr;
>  typedef vector<LinePtr> VectorLinePtr;
>  
>  // Our name.
>  
>  char *ARGV0 = "dif3";
>  
>  // The 'symbol' (line) table.
>  
>  MapStringToLinePtr table;
>  
>  // The names of the 2 files to be diff'd.
>  
>  char const *files[2] = { 0, 0 };
>  
>  // The lines of the 2 files to be diff'd.
>  
>  VectorLinePtr lines[2];
>  
>  // Miscellaneous metrics.
>  
>  unsigned nTotalMatchedBlocks = 0;
>  unsigned nMatchedBlocks = 0;
65a132,721
> -void pass1 ();
> -void pass2 ();
> -void pass3 ();
> -void pass4 ();
> -void pass5 ();
> -void pass6 ();
> -
> -int main (int argc, char *argv[])
> -{
> -  // Read the old [0] file, and the new [1] file.
> -
> -  for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
> -    files[n] = argv[a];
> -
> -    if (FILE *f = fopen (files[n], "r")) {
> -      if (0 < optVerbose) {
> -        fprintf (stderr, "# Reading %s...", files[n]);
> -        fflush (stderr);
> -      }
> -
> -      char buffer[1024];
> -      unsigned nUniq = 0;
> -
> -      while (fgets (buffer, sizeof (buffer), f)) {
> -        string text (buffer);
> -
> -        text.erase (text.end () - 1);
> -
> -        Line *line = table[text];
> -
> -        if (!line) {
> -          table[text] = line = new Line (text);
> -          nUniq += 1;
> -        }
> -        line->copies[n].push_back (lines[n].size ());
> -        lines[n].push_back (line);
> -      }
> -
> -      if (0 < optVerbose) {
> -        fprintf (stderr, " %u lines, %u unique.\n", lines[n].size (), nUniq);
> -        fflush (stderr);
> -      }
> -    } else {
> -      fprintf (stderr, "%s: Unable to open %s!  Exiting....\n", ARGV0, files[n]);
> -      fflush (stderr);
> -      perror (ARGV0);
> -      exit (1);
> -    }
> -  }
> -
> -  if (0 < optVerbose) {
> -    fprintf (stderr, "# Total unique lines = %d\n", table.size ());
> -    fflush (stderr);
> -  }
> -
> -  // map<int, int> counts;
> -  // for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> -  //   Line *l = i->second;
> -  //   counts[l->counts[0].size () + l->counts[1].size ()] += 1;
> -  // }
> -  // for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
> -  //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
> -  // }
> -
> -  pass1 ();
> -  pass2 ();
> -  pass3 ();
> -  pass4 ();
> -  pass5 ();
> -  pass6 ();
> -
> -  return 0;
> -}
> -
> -// Perform pass #1, in which we find all explicit matches amongst the
> -// unique lines.  For every unique line that appears the same number
> -// of times in both files, we declare the lines to match.
> -
> -void pass1 ()
> -{
> -  if (0 < optVerbose) {
> -    fprintf (stderr, "# Pass 1 (finding matches amongst unique lines)...");
> -    fflush (stderr);
> -  }
> -
> -  nMatchedLines = 0;
> -
> -  for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> -    Line *l = i->second;
> -
> -    // If the number of old and new lines match, then we declare that
> -    // they are (all) the same line.  Note, it isn't possible for the
> -    // numbers of both files to be 0.
> -
> -    // (In the original algorithm, we only recognized a match, here,
> -    // if there was exactly 1 copy for each file.)
> -
> -    if (l->copies[0].size () == l->copies[1].size ()) {
> -      nMatchedLines += 1;
> -
> -      // For each matched line in the new file, mark it with the
> -      // corresponding line (number) in the old file.
> -
> -      while (!l->copies[0].empty ()) {
> -        unsigned o = l->copies[0].front ();
> -        unsigned n = l->copies[1].front ();
> -
> -        // Match up the pair.
> -
> -        lines[0][o].l = n;
> -        lines[1][n].l = o;
> -
> -        // Remove the matched line numbers from the lists.
> -
> -        l->copies[0].pop_front ();
> -        l->copies[1].pop_front ();
> -      }
> -    }
> -  }
> -  nTotalMatchedLines += nMatchedLines;
> -
> -  // Let's see the intermediate results.
> -
> -  if (0 < optVerbose) {
> -    fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
> -    fflush (stderr);
> -
> -    if (2 < optVerbose) {
> -      for (int f = 0; f < 2; f += 1) {
> -        fprintf (stderr, "# file #%d\n", f + 1);
> -        fflush (stderr);
> -        for (int l = 0; l < lines[f].size (); l += 1) {
> -          fprintf (stderr, "#   [%d] ", l);
> -          fflush (stderr);
> -          lines[f][l].Dump (stderr);
> -        }
> -      }
> -    }
> -  }
> -}
> -
> -// Perform Pass #2, in which we attempt to 'widen' blocks of matched
> -// lines, by appending lines which are the same in both files.
> -
> -void pass2 ()
> -{
> -  if (0 < optVerbose) {
> -    fprintf (stderr, "# Pass #2 (spreading matches down)...");
> -    fflush (stderr);
> -  }
> -
> -  nMatchedBlocks = 0;
> -  nMatchedLines = 0;
> -
> -  // Starting at the top of the old file,...
> -
> -  for (unsigned o = 0; o < lines[0].size (); o += 1) {
> -
> -    // ... skip any currently unmatched lines...
> -
> -    if (lines[0][o].l == ~0) {
> -      continue;
> -    }
> -
> -    // ... until we find an [already] matched line.  Then, skip over
> -    // the set of 1 or more matched lines, until we reach any
> -    // following, still-unmatched line.
> -
> -    unsigned n;
> -    do {
> -      n = lines[0][o].l + 1;
> -      o += 1;
> -    } while (o < lines[0].size () && lines[0][o].l != ~0);
> -
> -    // Now, o - 1 is the line number of the last matched old line, and
> -    // n - 1 is the line number of the last matched new line.  We want
> -    // to add new old and new lines, if they match.
> -
> -    // Finally, attempt to add unmatched lines to the preceeding
> -    // matched set.
> -
> -    for (; o < lines[0].size () && lines[0][o].l == ~0; o += 1, n += 1) {
> -
> -      // If the [next] pair of old and new lines aren't the same line, we're done.
> -
> -      if (lines[0][o].line != lines[1][n].line) {
> -        break;
> -      }
> -
> -      // Match up the pair.
> -
> -      lines[0][o].l = n;
> -      lines[1][n].l = o;
> -
> -      // Remove the matched line numbers form the lists.
> -
> -      Line *line = lines[0][o].line;
> -      list<unsigned> &oldCopies = line->copies[0];
> -      list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
> -      if (oL != oldCopies.end ()) {
> -        oldCopies.erase (oL);
> -      }
> -      list<unsigned> &newCopies = line->copies[0];
> -      list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
> -      if (nL != newCopies.end ()) {
> -        newCopies.erase (nL);
> -      }
> -
> -      nMatchedLines += 1;
> -    }
> -    nMatchedBlocks += 1;
> -  }
> -  nTotalMatchedLines += nMatchedLines;
> -  nTotalMatchedBlocks += nMatchedBlocks;
> -
> -  // Let's see the intermediate results.
> -
> -  if (0 < optVerbose) {
> -    fprintf (stderr,
> -             " found %u/%u matched lines/blocks (%u/%u totals).\n",
> -             nMatchedLines,
> -             nMatchedBlocks,
> -             nTotalMatchedLines,
> -             nTotalMatchedBlocks
> -            );
> -    fflush (stderr);
> -    if (2 < optVerbose) {
> -      for (int f = 0; f < 2; f += 1) {
> -        fprintf (stderr, "# file #%d\n", f + 1);
> -        fflush (stderr);
> -        for (int l = 0; l < lines[f].size (); l += 1) {
> -          fprintf (stderr, "#   [%d] ", l);
> -          fflush (stderr);
> -          lines[f][l].Dump (stderr);
> -        }
> -      }
> -    }
> -  }
> -}
> -
> -// Perform Pass #3, in which we attempt to 'widen' blocks of matched
> -// lines, by prepending lines which are the same in both files.
> -
> -void pass3 ()
> -{
> -  if (0 < optVerbose) {
> -    fprintf (stderr, "# Pass #3 (spreading matches up)...");
> -    fflush (stderr);
> -  }
> -
> -  nMatchedBlocks = 0;
> -  nMatchedLines = 0;
> -
> -  // Starting at the bottom of the old file,...
> -
> -  for (int o = lines[0].size (); 0 <= o; o -= 1) {
> -
> -    // ... skip any currently unmatched lines...
> -
> -    if (lines[0][o].l == ~0) {
> -      continue;
> -    }
> -
> -    // ... until we find an [already] matched line.  Then, skip over
> -    // the set of 1 or more matched lines, until we reach any
> -    // following, still-unmatched line.
> -
> -    unsigned n;
> -    do {
> -      n = lines[0][o].l - 1;
> -      o -= 1;
> -    } while (0 <= o && lines[0][o].l != ~0);
> -
> -    // Now, o + 1 is the line number of the last matched old line, and
> -    // n + 1 is the line number of the last matched new line.  We want
> -    // to add new old and new lines, if they match.
> -
> -    // Finally, attempt to add unmatched lines to the preceeding
> -    // matched set.
> -
> -    for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
> -
> -      // If the [next] pair of old and new lines aren't the same line, we're done.
> -
> -      if (lines[0][o].line != lines[1][n].line) {
> -        break;
> -      }
> -
> -      // Match up the pair.
> -
> -      lines[0][o].l = n;
> -      lines[1][n].l = o;
> -
> -      // Remove the matched line numbers form the lists.
> -
> -      Line *line = lines[0][o].line;
> -      list<unsigned> &oldCopies = line->copies[0];
> -      list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
> -      if (oL != oldCopies.end ()) {
> -        oldCopies.erase (oL);
> -      }
> -      list<unsigned> &newCopies = line->copies[0];
> -      list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
> -      if (nL != newCopies.end ()) {
> -        newCopies.erase (nL);
> -      }
> -
> -      nMatchedLines += 1;
> -    }
> -    nMatchedBlocks += 1;
> -  }
> -  nTotalMatchedLines += nMatchedLines;
> -
> -  // Let's see the intermediate results.
> -
> -  if (0 < optVerbose) {
> -    fprintf (stderr,
> -             " found %u/%u matched lines/blocks (%u/%u totals).\n",
> -             nMatchedLines,
> -             nMatchedBlocks,
> -             nTotalMatchedLines,
> -             nTotalMatchedBlocks
> -            );
> -    fflush (stderr);
> -
> -    if (2 < optVerbose) {
> -      for (int f = 0; f < 2; f += 1) {
> -        fprintf (stderr, "# file #%d\n", f + 1);
> -        fflush (stderr);
> -        for (int l = 0; l < lines[f].size (); l += 1) {
> -          fprintf (stderr, "#   [%d] ", l);
> -          fflush (stderr);
> -          lines[f][l].Dump (stderr);
> -        }
> -      }
> -    }
> -  }
> -}
> -
> -// Perform pass #4, in which we find any remaining matches amongst the
> -// unique lines.  For every unique line that has more than 1 copy in
> -// both files, we declare the copies to match.
> -
> -void pass4 ()
> -{
> -  if (0 < optVerbose) {
> -    fprintf (stderr, "# Pass 4 (finding remaining matches amongst unique lines)...");
> -    fflush (stderr);
> -  }
> -
> -  nMatchedLines = 0;
> -
> -  for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> -    Line *l = i->second;
> -
> -    // If there's more than 1 matching old and new lines, then we
> -    // declare that each pair are (all) the same line.
> -
> -    // (In the original algorithm, we only recognized a match, here,
> -    // if there was exactly 1 copy for each file.)
> -
> -    while (0 < l->copies[0].size () && 0 < l->copies[1].size ()) {
> -      nMatchedLines += 1;
> -
> -      // For each matched line in the new file, mark it with the
> -      // corresponding line (number) in the old file.
> -
> -      unsigned o = l->copies[0].front ();
> -      unsigned n = l->copies[1].front ();
> -
> -      // Match up the pair.
> -
> -      lines[0][o].l = n;
> -      lines[1][n].l = o;
> -
> -      // Remove the matched line numbers from the lists.
> -
> -      l->copies[0].pop_front ();
> -      l->copies[1].pop_front ();
> -    }
> -  }
> -  nTotalMatchedLines += nMatchedLines;
> -
> -  // Let's see the intermediate results.
> -
> -  if (0 < optVerbose) {
> -    fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
> -    fflush (stderr);
> -
> -    if (2 < optVerbose) {
> -      for (int f = 0; f < 2; f += 1) {
> -        fprintf (stderr, "# file #%d\n", f + 1);
> -        fflush (stderr);
> -        for (int l = 0; l < lines[f].size (); l += 1) {
> -          fprintf (stderr, "#   [%d] ", l);
> -          fflush (stderr);
> -          lines[f][l].Dump (stderr);
> -        }
> -      }
> -    }
> -  }
> -}
> -
> -// Perform Pass #5, in which we look for blocks which match, but are
> -// the result of a move (their not in their original position).  For
> -// these, we'll unmatch the blocks, turning them into a delete and an
> -// insert.
> -
> -void pass5 ()
> -{
> -  if (0 < optVerbose) {
> -    fprintf (stderr, "# Pass #5 (unmatching block moves)...\n");
> -    fflush (stderr);
> -  }
> -
> -  nMatchedBlocks = 0;
> -  nMatchedLines = 0;
> -
> -  // Starting at the top of both files,...
> -
> -  unsigned o = 0;
> -  unsigned n = 0;
> -
> -  while (o < lines[0].size () || n < lines[1].size ()) {
> -
> -    // Skip any unmatched lines at this point in the old file.  These
> -    // are deletes.
> -
> -    //    Old     New
> -    //   +---+
> -    // 0 | a |
> -    //   +---+   +---+
> -    //         0 | b |
> -    //   +---+   +---+
> -    // 1 | c | 1 | c |
> -    //   +---+   +---+
> -    //         2 | z |
> -    //   +---+   +---+
> -    // 2 | d | 3 | d |
> -    //   +---+   +---+
> -
> -    while (o < lines[0].size () && lines[0][o].l == ~0) {
> -      o += 1;
> -    }
> -
> -    // Skip any unmatched lines at this point in the new file.  These
> -    // are inserts.
> -
> -    while (n < lines[1].size () && lines[1][n].l == ~0) {
> -      n += 1;
> -    }
> -
> -    // When we get here, we know that we're dealing with matching
> -    // lines (or the end of one or both files).  We're done with this
> -    // pass, if we've reached the end of either file.
> -
> -    if (lines[0].size () <= o || lines[1].size () <= n) {
> -      break;
> -    }
> -
> -    // We now know that we've got a pair of matching lines, the start
> -    // of a matching block.  If the new file's line number is what we
> -    // expect, then the matched pair is unmoved, and we can skip over
> -    // the pair.  (If this is really the start of a block of more than
> -    // 1 lines, we'll handle it one pair at a time.)
> -
> -    if (lines[0][o].l == n) {
> -      o += 1;
> -      n += 1;
> -      continue;
> -    }
> -
> -    // If, on the other hand, we don't expect this [new] line number,
> -    // then this matching block has been moved.  We need to turn the
> -    // matched pair into an *unmatched* pair, one of deletes, and one
> -    // of inserts.  First, though, we need to know how big this block
> -    // is, and how far it was moved....
> -
> -    // Remember where we were when we started.
> -
> -    unsigned oOld = o;
> -    unsigned nOld = n;
> -
> -    // Remember where the block came from.
> -
> -    unsigned nNew = lines[0][o].l;
> -
> -    // Find the end of this matched pair.
> -
> -    for (n = nNew; o < lines[0].size () && n < lines[1].size (); o += 1, n += 1) {
> -      if (lines[0][o].l != n) {
> -        break;
> -      }
> -    }
> -
> -    // When we get here:
> -    // * oOld..o is the old file's block,
> -    // * nNew..n is the new file's *moved* block, and
> -    // * nOld is where we originally expected the new block from.
> - 
> -    // We can now calculate the length of the block...
> -    
> -    unsigned bSize = o - oOld;  // (or n - nNew)
> -
> -    // ... and we can calculate how far the block moved:
> -
> -    unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
> -
> -    // The larger of the two will become our delete, and the smaller
> -    // will become our insert.
> -
> -    //    Old     New
> -    //   +---+   +---+
> -    // 0 | a | 0 | b |
> -    //   +---+ 1 | b |
> -    // 1 | b |   +---+
> -    // 2 | b | 2 | a |
> -    //   +---+   +---+
> -    // 3 | c | 3 | c |
> -    //   +---+   +---+
> -
> -    // (1) Delete a@0, insert a@2, or
> -    // (2) insert bb@0, delete bb@1?
> -
> -    // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and bMove
> -    // (of a) is 2-0 or 2, the size of b@0.  We choose to delete a@0,
> -    // and reinsert a@2.
> -
> -    // if (bSize <= bMove) {
> -      for (unsigned a = oOld; a < o; a += 1) {
> -        lines[0][a].l = ~0;
> -      }
> -      for (unsigned d = nNew; d < n; d += 1) {
> -        lines[1][d].l = ~0;
> -      }
> -    // } else {
> -      // for (unsigned a = oOld; a < o; a += 1) {
> -      //   lines[0][a].l = ~0;
> -      // }
> -      // for (unsigned d = nNew; d < n; d += 1) {
> -      //   lines[1][d].l = ~0;
> -      // }
> -    // }
> -
> -    // Continue from where we left off.
> -
> -    n = nOld;
> -  }
> -  nTotalMatchedLines -= nMatchedLines;
> -  nTotalMatchedBlocks -= nMatchedBlocks;
> -
> -  // Let's see the intermediate results.
> -
> -  if (0 < optVerbose) {
> -    fprintf (stderr,
> -             " found %u/%u matched lines/blocks (%u/%u totals).\n",
> -             nMatchedLines,
> -             nMatchedBlocks,
> -             nTotalMatchedLines,
> -             nTotalMatchedBlocks
> -            );
> -    fflush (stderr);
> -
> -    if (2 < optVerbose) {
> -      for (int f = 0; f < 2; f += 1) {
> -        fprintf (stderr, "# file #%d\n", f + 1);
> -        fflush (stderr);
> -        for (int l = 0; l < lines[f].size (); l += 1) {
> -          fprintf (stderr, "#   [%d] ", l);
> -          fflush (stderr);
> -          lines[f][l].Dump (stderr);
> -        }
> -      }
> -    }
> -  }
> -}
> -
> -// Perform Pass #6, in which we create the desired output.
> -
> -void pass6c ();
> -void pass6e ();
> -void pass6i ();
> -void pass6n ();
> -void pass6r ();
> -void pass6s ();
> -void pass6u ();
> -void pass6y ();
> -
> -void pass6 ()
> -{
67,73d722
< +
<  void pass1 ();
<  void pass2 ();
<  void pass3 ();
< @@ -98,11 +123,29 @@
<  void pass5 ();
<  void pass6 ();
75c724,1215
< -int main (int argc, char *argv[])
---
> -  switch (diffFormat) {
> -  case Context:
> -    pass6c ();
> -    break;
> -
> -  case EdScript:
> -    pass6e ();
> -    break;
> -
> -  case IfThenElse:
> -    pass6i ();
> -    break;
> -
> -  case Normal:
> -    pass6n ();
> -    break;
> -
> -  case RCS:
> -    pass6r ();
> -    break;
> -
> -  case SideBySide:
> -    pass6y ();
> -    break;
> -
> -  case Unified:
> -    pass6u ();
> -    break;
> -
> -  case Default:
> -  default:
> -    pass6c ();
> -    break;
> -  }
> -}
> -
> -template<typename T> T min (T l, T r) {
> -  if (l < r) {
> -    return l;
> -  }
> -  return r;
> -}
> -
> -template<typename T> T max (T l, T r) {
> -  if (l < r) {
> -    return r;
> -  }
> -  return l;
> -}
> -
> -void pass6c () {
> -  if (0 < optVerbose) {
> -    fprintf (stderr, "# Pass #6c (walking the differences)...\n");
> -    fflush (stderr);
> -  }
> -
> -  nMatchedLines = 0;
> -
> -  // Write the header.
> -
> -  fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
> -  fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
> -
> -  // Starting at the top of both files,...
> -
> -  unsigned o = 0;
> -  unsigned n = 0;
> -
> -  while (o < lines[0].size () || n < lines[1].size ()) {
> -
> -    // Find the bounds of the current contextual 'window'.
> -
> -    // If we aren't looking at a delete or an insert, we're not at the
> -    // start of a context window.
> -
> -    if (lines[0][o].l != ~0 && lines[1][n].l != ~0) {
> -      o += 1;
> -      n += 1;
> -      continue;
> -    }
> -
> -    // We're now looking at at least 1 delete or insert, so a window
> -    // begins here (or, rather, optCopyContext lines earlier).
> -    
> -    int boOldWindow = max (0, int (o) - int (optCopyContext));
> -    int boNewWindow = max (0, int (n) - int (optCopyContext));
> -
> -    if (1 < optVerbose) {
> -      fprintf (stderr, "boOldWindow = %d, boNewWindow = %d\n", boOldWindow, boNewWindow);
> -      fflush (stderr);
> -    }
> -
> -    // Look for the end of the current window.
> -
> -    int eoOldWindow;
> -    int eoNewWindow;
> -
> -    bool widenWindow = true;
> -    while (widenWindow && o < lines[0].size () || n < lines[1].size ()) {
> -
> -      // Skip over the delete(s) and/or insert(s) defining the current
> -      // context.
> -
> -      while (o < lines[0].size () && lines[0][o].l == ~0) {
> -        o += 1;
> -      }
> -      while (n < lines[1].size () && lines[1][n].l == ~0) {
> -        n += 1;
> -      }
> -
> -      // This context will end optCopyContext matched lines past the
> -      // last set of deletes or inserts we find.
> -
> -      widenWindow = false;
> -      for (unsigned l = 0; !widenWindow && l < optCopyContext; l += 1) {
> -        if (o < lines[0].size ()) {
> -          widenWindow |= lines[0][o].l == ~0;
> -          o += 1;
> -        }
> -        if (n < lines[1].size ()) {
> -          widenWindow |= lines[1][n].l == ~0;
> -          n += 1;
> -        }
> -      }
> -
> -      eoOldWindow = o;
> -      eoNewWindow = n;
> -
> -      // However, since another window could follow, we look
> -      // optCopyContext ahead for another delete or insert.
> -
> -      if (!widenWindow) {
> -        for (unsigned l = 0; l < (2 * optCopyContext + 1); l += 1) {
> -          if (o < lines[0].size ()) {
> -            widenWindow |= lines[0][o].l == ~0;
> -            o += 1;
> -          }
> -          if (n < lines[1].size ()) {
> -            widenWindow |= lines[1][n].l == ~0;
> -            n += 1;
> -          }
> -        }
> -      }
> -    }
> -
> -    // We've found the end of the window.
> -
> -    if (1 < optVerbose) {
> -      fprintf (stderr, "eoOldWindow = %d, eoNewWindow = %d\n", eoOldWindow, eoNewWindow);
> -      fflush (stderr);
> -    }
> -
> -    // Now, reset ourselves to the start of the window, and walk it to
> -    // produce the output.  We'll walk it twice, first for the old
> -    // file part, then for the new file part.
> -
> -    fprintf (stdout, "***************\n");
> -    fprintf (stdout, "*** %d,%d ****\n", boOldWindow + 1, eoOldWindow);
> -
> -    o = boOldWindow;
> -    n = boNewWindow;
> -
> -    while (o < eoOldWindow || n < eoNewWindow) {
> -
> -      // Find any unmatched lines at this point in the old file.  These
> -      // are deletes.
> -
> -      unsigned boDeletes = o;
> -      while (o < eoOldWindow && lines[0][o].l == ~0) {
> -        o += 1;
> -      }
> -
> -      // Find any unmatched lines at this point in the new file.  These
> -      // are inserts.
> -
> -      unsigned boInserts = n;
> -      while (n < eoNewWindow && lines[1][n].l == ~0) {
> -        n += 1;
> -      }
> -
> -      // We've got deleted line(s) from boDeletes .. o.
> -      // We've got deleted line(s) from boInserts .. n.
> -
> -      unsigned nDeletes = o - boDeletes;
> -      unsigned nInserts = n - boInserts;
> -
> -      // We've got...
> -
> -      if (nDeletes && nInserts) {
> -
> -        // ... deletes and inserts.
> -
> -        for (unsigned l = boDeletes; l < o; l += 1) {
> -          fprintf (stdout, "! %s\n", lines[0][l].line->c_str ());
> -        }
> -      } else if (nDeletes) {
> -
> -        //  ... just deletes.
> -
> -        for (unsigned l = boDeletes; l < o; l += 1) {
> -          fprintf (stdout, "- %s\n", lines[0][l].line->c_str ());
> -        }
> -      }
> -
> -      // When we get here, we're dealing with matching lines.
> -
> -      fprintf (stdout, "  %s\n", lines[0][o].line->c_str ());
> -      o += 1;
> -      n += 1;
> -    }
> -
> -    fprintf (stdout, "--- %d,%d ----\n", boNewWindow + 1, eoNewWindow);
> -
> -    o = boOldWindow;
> -    n = boNewWindow;
> -
> -    while (o < eoOldWindow && n < eoNewWindow) {
> -
> -      // Find any unmatched lines at this point in the old file.  These
> -      // are deletes.
> -
> -      unsigned boDeletes = o;
> -      while (o < eoOldWindow && lines[0][o].l == ~0) {
> -        o += 1;
> -      }
> -
> -      // Find any unmatched lines at this point in the new file.  These
> -      // are inserts.
> -
> -      unsigned boInserts = n;
> -      while (n < eoNewWindow && lines[1][n].l == ~0) {
> -        n += 1;
> -      }
> -
> -      // We've got deleted line(s) from boDeletes .. o.
> -      // We've got deleted line(s) from boInserts .. n.
> -
> -      unsigned nDeletes = o - boDeletes;
> -      unsigned nInserts = n - boInserts;
> -
> -      // We've got...
> -
> -      if (nDeletes && nInserts) {
> -
> -        // ... deletes and inserts.
> -
> -        for (unsigned l = boInserts; l < n; l += 1) {
> -          fprintf (stdout, "! %s\n", lines[1][l].line->c_str ());
> -        }
> -      } else if (nInserts) {
> -
> -        //  ... just inserts.
> -
> -        for (unsigned l = boInserts; l < n; l += 1) {
> -          fprintf (stdout, "+ %s\n", lines[1][l].line->c_str ());
> -        }
> -      }
> -
> -      // When we get here, we're dealing with matching lines.
> -
> -      fprintf (stdout, "  %s\n", lines[1][n].line->c_str ());
> -      o += 1;
> -      n += 1;
> -    }
> -
> -    // Reset to the end of the current window.
> -
> -    o = eoOldWindow;
> -    n = eoNewWindow;
> -  }
> -}
> -
> -void pass6e () {
> -  fprintf (stderr, "pass6e() is unimplemented!\n");
> -  fflush (stderr);
> -}
> -
> -void pass6i () {
> -  fprintf (stderr, "pass6i() is unimplemented!\n");
> -  fflush (stderr);
> -}
> -
> -void pass6n ()
> -{
> -  if (0 < optVerbose) {
> -    fprintf (stderr, "# Pass #6n (walking the differences)...\n");
> -    fflush (stderr);
> -  }
> -
> -  nMatchedLines = 0;
> -
> -  // Write the header.  (None for normal.)
> -
> -  // Starting at the top of both files,...
> -
> -  unsigned o = 0;
> -  unsigned n = 0;
> -
> -  while (o < lines[0].size () || n < lines[1].size ()) {
> -
> -    // Find any unmatched lines at this point in the old file.  These
> -    // are deletes.
> -
> -    unsigned boDeletes;
> -    for (boDeletes = o;
> -         o < lines[0].size () && lines[0][o].l == ~0;
> -         o += 1
> -        )
> -    {}
> -
> -    // Find any unmatched lines at this point in the new file.  These
> -    // are inserts.
> -
> -    unsigned boInserts;
> -    for (boInserts = n;
> -         n < lines[1].size () && lines[1][n].l == ~0;
> -         n += 1
> -        )
> -    {}
> -
> -    // We've got deleted line(s) from boDeletes .. o.
> -    // We've got deleted line(s) from boInserts .. n.
> -
> -    unsigned nDeletes = o - boDeletes;
> -    unsigned nInserts = n - boInserts;
> -
> -    // We've got...
> -
> -    if (nDeletes && nInserts) {
> -
> -      // ... deletes and inserts.
> -
> -      if (1 < nDeletes && 1 < nInserts) {
> -        fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, boInserts + 1, n);
> -      } else if (1 < nDeletes) {
> -        fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boInserts + 1);
> -      } else if (1 < nInserts) {
> -        fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInserts + 1, n);
> -      } 
> -      for (unsigned l = boDeletes; l < o; l += 1) {
> -        fprintf (stdout, "< %s\n", lines[0][l].line->c_str ());
> -      }
> -      fprintf (stdout, "---\n");
> -      for (unsigned l = boInserts; l < n; l += 1) {
> -        fprintf (stdout, "> %s\n", lines[1][l].line->c_str ());
> -      }
> -    } else if (nDeletes) {
> -
> -      //  ... just deletes.
> -
> -      if (1 < nDeletes) {
> -        fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
> -      } else {
> -        fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
> -      }
> -      for (unsigned l = boDeletes; l < o; l += 1) {
> -        fprintf (stdout, "< %s\n", lines[0][l].line->c_str ());
> -      }
> -    } else if (nInserts) {
> -
> -      //  ... just inserts.
> -
> -      if (1 < nInserts) {
> -        fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
> -      } else {
> -        fprintf (stdout, "%da%d\n", o, boInserts + 1);
> -      }
> -      for (unsigned l = boInserts; l < n; l += 1) {
> -        fprintf (stdout, "> %s\n", lines[1][l].line->c_str ());
> -      }
> -    }
> -
> -    // When we get here, we're dealing with matching lines.
> -
> -    o += 1;
> -    n += 1;
> -  }
> -}
> -
> -void pass6r () {
> -  fprintf (stderr, "pass6r() is unimplemented!\n");
> -  fflush (stderr);
> -}
> -
> -void pass6s () {
> -  fprintf (stderr, "pass6s() is unimplemented!\n");
> -  fflush (stderr);
> -}
> -
> -void pass6u ()
> -{
> -  if (0 < optVerbose) {
> -    fprintf (stderr, "# Pass #6u (walking the differences)...\n");
> -    fflush (stderr);
> -  }
> -
> -  nMatchedLines = 0;
> -
> -  // Write the header.
> -
> -  fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
> -  fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
> -  fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), lines[1].size ());
> -
> -  // Starting at the top of both files,...
> -
> -  unsigned o = 0;
> -  unsigned n = 0;
> -
> -  while (o < lines[0].size () || n < lines[1].size ()) {
> -
> -    // Find any unmatched lines at this point in the old file.  These
> -    // are deletes.
> -
> -    unsigned boDeletes;
> -    for (boDeletes = o;
> -         o < lines[0].size () && lines[0][o].l == ~0;
> -         o += 1
> -        )
> -    {}
> -
> -    // Find any unmatched lines at this point in the new file.  These
> -    // are inserts.
> -
> -    unsigned boInserts;
> -    for (boInserts = n;
> -         n < lines[1].size () && lines[1][n].l == ~0;
> -         n += 1
> -        )
> -    {}
> -
> -    // We've got deleted line(s) from boDeletes .. o.
> -    // We've got deleted line(s) from boInserts .. n.
> -
> -    unsigned nDeletes = o - boDeletes;
> -    unsigned nInserts = n - boInserts;
> -
> -    // We've got...
> -
> -    if (nDeletes && nInserts) {
> -
> -      // ... deletes and inserts.
> -
> -      for (unsigned l = boDeletes; l < o; l += 1) {
> -        fprintf (stdout, "-%s\n", lines[0][l].line->c_str ());
> -      }
> -      for (unsigned l = boInserts; l < n; l += 1) {
> -        fprintf (stdout, "+%s\n", lines[1][l].line->c_str ());
> -      }
> -    } else if (nDeletes) {
> -
> -      //  ... just deletes.
> -
> -      for (unsigned l = boDeletes; l < o; l += 1) {
> -        fprintf (stdout, "-%s\n", lines[0][l].line->c_str ());
> -      }
> -    } else if (nInserts) {
> -
> -      //  ... just inserts.
> -
> -      for (unsigned l = boInserts; l < n; l += 1) {
> -        fprintf (stdout, "+%s\n", lines[1][l].line->c_str ());
> -      }
> -    }
> -
> -    // When we get here, we're dealing with matching lines.
> -
> -    fprintf (stdout, " %s\n", lines[0][o].line->c_str ());
> -    o += 1;
> -    n += 1;
> -  }
> -}
> -
> -void pass6y ()
> -{
> -  if (0 < optVerbose) {
> -    fprintf (stderr, "# Pass #6y (walking the differences)...\n");
> -    fflush (stderr);
> -  }
> -
> -  // Write the header.
> -
> -  // None for side-by-side.
> -
> -  // Starting at the top of both files,...
> +void pass1 ();
> +void pass2 ();
> +void pass3 ();
> +void pass4 ();
> +void pass5 ();
> +void pass6 ();
> +
77c1217
<  {
---
> +{
79c1219,1220
< +
---
>  
> -  int columnWidth = (optPageWidth - 7) / 2;
96,98c1237,1238
<    // Read the old [0] file, and the new [1] file.
<  
< -  for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
---
> +  // Read the old [0] file, and the new [1] file.
> +
100,106c1240,1301
<      files[n] = argv[a];
<  
<      if (FILE *f = fopen (files[n], "r")) {
< @@ -165,6 +208,387 @@
<    return 0;
<  }
<  
---
> +    files[n] = argv[a];
> +
> +    if (FILE *f = fopen (files[n], "r")) {
> +      if (0 < optVerbose) {
> +        fprintf (stderr, "# Reading %s...", files[n]);
> +        fflush (stderr);
> +      }
> +
> +      char buffer[1024];
> +      unsigned nUniq = 0;
> +
> +      while (fgets (buffer, sizeof (buffer), f)) {
> +        string text (buffer);
> +
> +        text.erase (text.end () - 1);
> +
> +        Line *line = table[text];
> +
> +        if (!line) {
> +          table[text] = line = new Line (text);
> +          nUniq += 1;
> +        }
> +        line->copies[n].push_back (lines[n].size ());
> +        lines[n].push_back (line);
> +      }
> +
> +      if (0 < optVerbose) {
> +        fprintf (stderr, " %u lines, %u unique.\n", lines[n].size (), nUniq);
> +        fflush (stderr);
> +      }
> +    } else {
> +      fprintf (stderr, "%s: Unable to open %s!  Exiting....\n", ARGV0, files[n]);
> +      fflush (stderr);
> +      perror (ARGV0);
> +      exit (1);
> +    }
> +  }
> +
> +  if (0 < optVerbose) {
> +    fprintf (stderr, "# Total unique lines = %d\n", table.size ());
> +    fflush (stderr);
> +  }
> +
> +  // map<int, int> counts;
> +  // for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> +  //   Line *l = i->second;
> +  //   counts[l->counts[0].size () + l->counts[1].size ()] += 1;
> +  // }
> +  // for (map<int, int>::iterator i = counts.begin (); i != counts.end (); i++) {
> +  //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->second);
> +  // }
> +
> +  pass1 ();
> +  pass2 ();
> +  pass3 ();
> +  pass4 ();
> +  pass5 ();
> +  pass6 ();
> +
> +  return 0;
> +}
> +
488,497c1683,2198
<  // Perform pass #1, in which we find all explicit matches amongst the
<  // unique lines.  For every unique line that appears the same number
<  // of times in both files, we declare the lines to match.
< @@ -681,39 +1105,37 @@
<  
<  void pass6 ()
<  {
< -
< -  switch (diffFormat) {
< -  case Context:
---
> +// Perform pass #1, in which we find all explicit matches amongst the
> +// unique lines.  For every unique line that appears the same number
> +// of times in both files, we declare the lines to match.
> +
> +void pass1 ()
> +{
> +  if (0 < optVerbose) {
> +    fprintf (stderr, "# Pass 1 (finding matches amongst unique lines)...");
> +    fflush (stderr);
> +  }
> +
> +  nMatchedLines = 0;
> +
> +  for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> +    Line *l = i->second;
> +
> +    // If the number of old and new lines match, then we declare that
> +    // they are (all) the same line.  Note, it isn't possible for the
> +    // numbers of both files to be 0.
> +
> +    // (In the original algorithm, we only recognized a match, here,
> +    // if there was exactly 1 copy for each file.)
> +
> +    if (l->copies[0].size () == l->copies[1].size ()) {
> +      nMatchedLines += 1;
> +
> +      // For each matched line in the new file, mark it with the
> +      // corresponding line (number) in the old file.
> +
> +      while (!l->copies[0].empty ()) {
> +        unsigned o = l->copies[0].front ();
> +        unsigned n = l->copies[1].front ();
> +
> +        // Match up the pair.
> +
> +        lines[0][o].l = n;
> +        lines[1][n].l = o;
> +
> +        // Remove the matched line numbers from the lists.
> +
> +        l->copies[0].pop_front ();
> +        l->copies[1].pop_front ();
> +      }
> +    }
> +  }
> +  nTotalMatchedLines += nMatchedLines;
> +
> +  // Let's see the intermediate results.
> +
> +  if (0 < optVerbose) {
> +    fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
> +    fflush (stderr);
> +
> +    if (2 < optVerbose) {
> +      for (int f = 0; f < 2; f += 1) {
> +        fprintf (stderr, "# file #%d\n", f + 1);
> +        fflush (stderr);
> +        for (int l = 0; l < lines[f].size (); l += 1) {
> +          fprintf (stderr, "#   [%d] ", l);
> +          fflush (stderr);
> +          lines[f][l].Dump (stderr);
> +        }
> +      }
> +    }
> +  }
> +}
> +
> +// Perform Pass #2, in which we attempt to 'widen' blocks of matched
> +// lines, by appending lines which are the same in both files.
> +
> +void pass2 ()
> +{
> +  if (0 < optVerbose) {
> +    fprintf (stderr, "# Pass #2 (spreading matches down)...");
> +    fflush (stderr);
> +  }
> +
> +  nMatchedBlocks = 0;
> +  nMatchedLines = 0;
> +
> +  // Starting at the top of the old file,...
> +
> +  for (unsigned o = 0; o < lines[0].size (); o += 1) {
> +
> +    // ... skip any currently unmatched lines...
> +
> +    if (lines[0][o].l == ~0) {
> +      continue;
> +    }
> +
> +    // ... until we find an [already] matched line.  Then, skip over
> +    // the set of 1 or more matched lines, until we reach any
> +    // following, still-unmatched line.
> +
> +    unsigned n;
> +    do {
> +      n = lines[0][o].l + 1;
> +      o += 1;
> +    } while (o < lines[0].size () && lines[0][o].l != ~0);
> +
> +    // Now, o - 1 is the line number of the last matched old line, and
> +    // n - 1 is the line number of the last matched new line.  We want
> +    // to add new old and new lines, if they match.
> +
> +    // Finally, attempt to add unmatched lines to the preceeding
> +    // matched set.
> +
> +    for (; o < lines[0].size () && lines[0][o].l == ~0; o += 1, n += 1) {
> +
> +      // If the [next] pair of old and new lines aren't the same line, we're done.
> +
> +      if (lines[0][o].line != lines[1][n].line) {
> +        break;
> +      }
> +
> +      // Match up the pair.
> +
> +      lines[0][o].l = n;
> +      lines[1][n].l = o;
> +
> +      // Remove the matched line numbers form the lists.
> +
> +      Line *line = lines[0][o].line;
> +      list<unsigned> &oldCopies = line->copies[0];
> +      list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
> +      if (oL != oldCopies.end ()) {
> +        oldCopies.erase (oL);
> +      }
> +      list<unsigned> &newCopies = line->copies[0];
> +      list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
> +      if (nL != newCopies.end ()) {
> +        newCopies.erase (nL);
> +      }
> +
> +      nMatchedLines += 1;
> +    }
> +    nMatchedBlocks += 1;
> +  }
> +  nTotalMatchedLines += nMatchedLines;
> +  nTotalMatchedBlocks += nMatchedBlocks;
> +
> +  // Let's see the intermediate results.
> +
> +  if (0 < optVerbose) {
> +    fprintf (stderr,
> +             " found %u/%u matched lines/blocks (%u/%u totals).\n",
> +             nMatchedLines,
> +             nMatchedBlocks,
> +             nTotalMatchedLines,
> +             nTotalMatchedBlocks
> +            );
> +    fflush (stderr);
> +    if (2 < optVerbose) {
> +      for (int f = 0; f < 2; f += 1) {
> +        fprintf (stderr, "# file #%d\n", f + 1);
> +        fflush (stderr);
> +        for (int l = 0; l < lines[f].size (); l += 1) {
> +          fprintf (stderr, "#   [%d] ", l);
> +          fflush (stderr);
> +          lines[f][l].Dump (stderr);
> +        }
> +      }
> +    }
> +  }
> +}
> +
> +// Perform Pass #3, in which we attempt to 'widen' blocks of matched
> +// lines, by prepending lines which are the same in both files.
> +
> +void pass3 ()
> +{
> +  if (0 < optVerbose) {
> +    fprintf (stderr, "# Pass #3 (spreading matches up)...");
> +    fflush (stderr);
> +  }
> +
> +  nMatchedBlocks = 0;
> +  nMatchedLines = 0;
> +
> +  // Starting at the bottom of the old file,...
> +
> +  for (int o = lines[0].size (); 0 <= o; o -= 1) {
> +
> +    // ... skip any currently unmatched lines...
> +
> +    if (lines[0][o].l == ~0) {
> +      continue;
> +    }
> +
> +    // ... until we find an [already] matched line.  Then, skip over
> +    // the set of 1 or more matched lines, until we reach any
> +    // following, still-unmatched line.
> +
> +    unsigned n;
> +    do {
> +      n = lines[0][o].l - 1;
> +      o -= 1;
> +    } while (0 <= o && lines[0][o].l != ~0);
> +
> +    // Now, o + 1 is the line number of the last matched old line, and
> +    // n + 1 is the line number of the last matched new line.  We want
> +    // to add new old and new lines, if they match.
> +
> +    // Finally, attempt to add unmatched lines to the preceeding
> +    // matched set.
> +
> +    for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
> +
> +      // If the [next] pair of old and new lines aren't the same line, we're done.
> +
> +      if (lines[0][o].line != lines[1][n].line) {
> +        break;
> +      }
> +
> +      // Match up the pair.
> +
> +      lines[0][o].l = n;
> +      lines[1][n].l = o;
> +
> +      // Remove the matched line numbers form the lists.
> +
> +      Line *line = lines[0][o].line;
> +      list<unsigned> &oldCopies = line->copies[0];
> +      list<unsigned>::iterator oL = find (oldCopies.begin (), oldCopies.end (), o);
> +      if (oL != oldCopies.end ()) {
> +        oldCopies.erase (oL);
> +      }
> +      list<unsigned> &newCopies = line->copies[0];
> +      list<unsigned>::iterator nL = find (newCopies.begin (), newCopies.end (), n);
> +      if (nL != newCopies.end ()) {
> +        newCopies.erase (nL);
> +      }
> +
> +      nMatchedLines += 1;
> +    }
> +    nMatchedBlocks += 1;
> +  }
> +  nTotalMatchedLines += nMatchedLines;
> +
> +  // Let's see the intermediate results.
> +
> +  if (0 < optVerbose) {
> +    fprintf (stderr,
> +             " found %u/%u matched lines/blocks (%u/%u totals).\n",
> +             nMatchedLines,
> +             nMatchedBlocks,
> +             nTotalMatchedLines,
> +             nTotalMatchedBlocks
> +            );
> +    fflush (stderr);
> +
> +    if (2 < optVerbose) {
> +      for (int f = 0; f < 2; f += 1) {
> +        fprintf (stderr, "# file #%d\n", f + 1);
> +        fflush (stderr);
> +        for (int l = 0; l < lines[f].size (); l += 1) {
> +          fprintf (stderr, "#   [%d] ", l);
> +          fflush (stderr);
> +          lines[f][l].Dump (stderr);
> +        }
> +      }
> +    }
> +  }
> +}
> +
> +// Perform pass #4, in which we find any remaining matches amongst the
> +// unique lines.  For every unique line that has more than 1 copy in
> +// both files, we declare the copies to match.
> +
> +void pass4 ()
> +{
> +  if (0 < optVerbose) {
> +    fprintf (stderr, "# Pass 4 (finding remaining matches amongst unique lines)...");
> +    fflush (stderr);
> +  }
> +
> +  nMatchedLines = 0;
> +
> +  for (MapStringToLinePtr::iterator i = table.begin (); i != table.end (); i++) {
> +    Line *l = i->second;
> +
> +    // If there's more than 1 matching old and new lines, then we
> +    // declare that each pair are (all) the same line.
> +
> +    // (In the original algorithm, we only recognized a match, here,
> +    // if there was exactly 1 copy for each file.)
> +
> +    while (0 < l->copies[0].size () && 0 < l->copies[1].size ()) {
> +      nMatchedLines += 1;
> +
> +      // For each matched line in the new file, mark it with the
> +      // corresponding line (number) in the old file.
> +
> +      unsigned o = l->copies[0].front ();
> +      unsigned n = l->copies[1].front ();
> +
> +      // Match up the pair.
> +
> +      lines[0][o].l = n;
> +      lines[1][n].l = o;
> +
> +      // Remove the matched line numbers from the lists.
> +
> +      l->copies[0].pop_front ();
> +      l->copies[1].pop_front ();
> +    }
> +  }
> +  nTotalMatchedLines += nMatchedLines;
> +
> +  // Let's see the intermediate results.
> +
> +  if (0 < optVerbose) {
> +    fprintf (stderr, " found %u matched lines (%u total).\n", nMatchedLines, nTotalMatchedLines);
> +    fflush (stderr);
> +
> +    if (2 < optVerbose) {
> +      for (int f = 0; f < 2; f += 1) {
> +        fprintf (stderr, "# file #%d\n", f + 1);
> +        fflush (stderr);
> +        for (int l = 0; l < lines[f].size (); l += 1) {
> +          fprintf (stderr, "#   [%d] ", l);
> +          fflush (stderr);
> +          lines[f][l].Dump (stderr);
> +        }
> +      }
> +    }
> +  }
> +}
> +
> +// Perform Pass #5, in which we look for blocks which match, but are
> +// the result of a move (their not in their original position).  For
> +// these, we'll unmatch the blocks, turning them into a delete and an
> +// insert.
> +
> +void pass5 ()
> +{
> +  if (0 < optVerbose) {
> +    fprintf (stderr, "# Pass #5 (unmatching block moves)...\n");
> +    fflush (stderr);
> +  }
> +
> +  nMatchedBlocks = 0;
> +  nMatchedLines = 0;
> +
> +  // Starting at the top of both files,...
> +
> +  unsigned o = 0;
> +  unsigned n = 0;
> +
> +  while (o < lines[0].size () || n < lines[1].size ()) {
> +
> +    // Skip any unmatched lines at this point in the old file.  These
> +    // are deletes.
> +
> +    //    Old     New
> +    //   +---+
> +    // 0 | a |
> +    //   +---+   +---+
> +    //         0 | b |
> +    //   +---+   +---+
> +    // 1 | c | 1 | c |
> +    //   +---+   +---+
> +    //         2 | z |
> +    //   +---+   +---+
> +    // 2 | d | 3 | d |
> +    //   +---+   +---+
> +
> +    while (o < lines[0].size () && lines[0][o].l == ~0) {
> +      o += 1;
> +    }
> +
> +    // Skip any unmatched lines at this point in the new file.  These
> +    // are inserts.
> +
> +    while (n < lines[1].size () && lines[1][n].l == ~0) {
> +      n += 1;
> +    }
> +
> +    // When we get here, we know that we're dealing with matching
> +    // lines (or the end of one or both files).  We're done with this
> +    // pass, if we've reached the end of either file.
> +
> +    if (lines[0].size () <= o || lines[1].size () <= n) {
> +      break;
> +    }
> +
> +    // We now know that we've got a pair of matching lines, the start
> +    // of a matching block.  If the new file's line number is what we
> +    // expect, then the matched pair is unmoved, and we can skip over
> +    // the pair.  (If this is really the start of a block of more than
> +    // 1 lines, we'll handle it one pair at a time.)
> +
> +    if (lines[0][o].l == n) {
> +      o += 1;
> +      n += 1;
> +      continue;
> +    }
> +
> +    // If, on the other hand, we don't expect this [new] line number,
> +    // then this matching block has been moved.  We need to turn the
> +    // matched pair into an *unmatched* pair, one of deletes, and one
> +    // of inserts.  First, though, we need to know how big this block
> +    // is, and how far it was moved....
> +
> +    // Remember where we were when we started.
> +
> +    unsigned oOld = o;
> +    unsigned nOld = n;
> +
> +    // Remember where the block came from.
> +
> +    unsigned nNew = lines[0][o].l;
> +
> +    // Find the end of this matched pair.
> +
> +    for (n = nNew; o < lines[0].size () && n < lines[1].size (); o += 1, n += 1) {
> +      if (lines[0][o].l != n) {
> +        break;
> +      }
> +    }
> +
> +    // When we get here:
> +    // * oOld..o is the old file's block,
> +    // * nNew..n is the new file's *moved* block, and
> +    // * nOld is where we originally expected the new block from.
> + 
> +    // We can now calculate the length of the block...
> +    
> +    unsigned bSize = o - oOld;  // (or n - nNew)
> +
> +    // ... and we can calculate how far the block moved:
> +
> +    unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
> +
> +    // The larger of the two will become our delete, and the smaller
> +    // will become our insert.
> +
> +    //    Old     New
> +    //   +---+   +---+
> +    // 0 | a | 0 | b |
> +    //   +---+ 1 | b |
> +    // 1 | b |   +---+
> +    // 2 | b | 2 | a |
> +    //   +---+   +---+
> +    // 3 | c | 3 | c |
> +    //   +---+   +---+
> +
> +    // (1) Delete a@0, insert a@2, or
> +    // (2) insert bb@0, delete bb@1?
> +
> +    // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and bMove
> +    // (of a) is 2-0 or 2, the size of b@0.  We choose to delete a@0,
> +    // and reinsert a@2.
> +
> +    // if (bSize <= bMove) {
> +      for (unsigned a = oOld; a < o; a += 1) {
> +        lines[0][a].l = ~0;
> +      }
> +      for (unsigned d = nNew; d < n; d += 1) {
> +        lines[1][d].l = ~0;
> +      }
> +    // } else {
> +      // for (unsigned a = oOld; a < o; a += 1) {
> +      //   lines[0][a].l = ~0;
> +      // }
> +      // for (unsigned d = nNew; d < n; d += 1) {
> +      //   lines[1][d].l = ~0;
> +      // }
> +    // }
> +
> +    // Continue from where we left off.
> +
> +    n = nOld;
> +  }
> +  nTotalMatchedLines -= nMatchedLines;
> +  nTotalMatchedBlocks -= nMatchedBlocks;
> +
> +  // Let's see the intermediate results.
> +
> +  if (0 < optVerbose) {
> +    fprintf (stderr,
> +             " found %u/%u matched lines/blocks (%u/%u totals).\n",
> +             nMatchedLines,
> +             nMatchedBlocks,
> +             nTotalMatchedLines,
> +             nTotalMatchedBlocks
> +            );
> +    fflush (stderr);
> +
> +    if (2 < optVerbose) {
> +      for (int f = 0; f < 2; f += 1) {
> +        fprintf (stderr, "# file #%d\n", f + 1);
> +        fflush (stderr);
> +        for (int l = 0; l < lines[f].size (); l += 1) {
> +          fprintf (stderr, "#   [%d] ", l);
> +          fflush (stderr);
> +          lines[f][l].Dump (stderr);
> +        }
> +      }
> +    }
> +  }
> +}
> +
> +// Perform Pass #6, in which we create the desired output.
> +
> +void pass6c ();
> +void pass6e ();
> +void pass6i ();
> +void pass6n ();
> +void pass6r ();
> +void pass6s ();
> +void pass6u ();
> +void pass6y ();
> +
> +void pass6 ()
> +{
500,503c2201,2203
<      pass6c ();
<      break;
<  
< -  case EdScript:
---
> +    pass6c ();
> +    break;
> +
505,508c2205,2207
<      pass6e ();
<      break;
<  
< -  case IfThenElse:
---
> +    pass6e ();
> +    break;
> +
510,513c2209,2211
<      pass6i ();
<      break;
<  
< -  case Normal:
---
> +    pass6i ();
> +    break;
> +
515,518c2213,2215
<      pass6n ();
<      break;
<  
< -  case RCS:
---
> +    pass6n ();
> +    break;
> +
520,523c2217,2219
<      pass6r ();
<      break;
<  
< -  case SideBySide:
---
> +    pass6r ();
> +    break;
> +
525,528c2221,2223
<      pass6y ();
<      break;
<  
< -  case Unified:
---
> +    pass6y ();
> +    break;
> +
530,535c2225,2228
<      pass6u ();
<      break;
<  
< -  case Default:
<    default:
< -    pass6c ();
---
> +    pass6u ();
> +    break;
> +
> +  default:
537,544c2230,2279
<      break;
<    }
<  }
< @@ -764,10 +1186,10 @@
<      }
<  
<      // We're now looking at at least 1 delete or insert, so a window
< -    // begins here (or, rather, optCopyContext lines earlier).
---
> +    break;
> +  }
> +}
> +
> +template<typename T> T min (T l, T r) {
> +  if (l < r) {
> +    return l;
> +  }
> +  return r;
> +}
> +
> +template<typename T> T max (T l, T r) {
> +  if (l < r) {
> +    return r;
> +  }
> +  return l;
> +}
> +
> +void pass6c () {
> +  if (0 < optVerbose) {
> +    fprintf (stderr, "# Pass #6c (walking the differences)...\n");
> +    fflush (stderr);
> +  }
> +
> +  nMatchedLines = 0;
> +
> +  // Write the header.
> +
> +  fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
> +  fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
> +
> +  // Starting at the top of both files,...
> +
> +  unsigned o = 0;
> +  unsigned n = 0;
> +
> +  while (o < lines[0].size () || n < lines[1].size ()) {
> +
> +    // Find the bounds of the current contextual 'window'.
> +
> +    // If we aren't looking at a delete or an insert, we're not at the
> +    // start of a context window.
> +
> +    if (lines[0][o].l != ~0 && lines[1][n].l != ~0) {
> +      o += 1;
> +      n += 1;
> +      continue;
> +    }
> +
> +    // We're now looking at at least 1 delete or insert, so a window
546,548c2281
<      
< -    int boOldWindow = max (0, int (o) - int (optCopyContext));
< -    int boNewWindow = max (0, int (n) - int (optCopyContext));
---
> +    
551,558c2284,2307
<  
<      if (1 < optVerbose) {
<        fprintf (stderr, "boOldWindow = %d, boNewWindow = %d\n", boOldWindow, boNewWindow);
< @@ -792,11 +1214,11 @@
<          n += 1;
<        }
<  
< -      // This context will end optCopyContext matched lines past the
---
> +
> +    if (1 < optVerbose) {
> +      fprintf (stderr, "boOldWindow = %d, boNewWindow = %d\n", boOldWindow, boNewWindow);
> +      fflush (stderr);
> +    }
> +
> +    // Look for the end of the current window.
> +
> +    int eoOldWindow;
> +    int eoNewWindow;
> +
> +    bool widenWindow = true;
> +    while (widenWindow && o < lines[0].size () || n < lines[1].size ()) {
> +
> +      // Skip over the delete(s) and/or insert(s) defining the current
> +      // context.
> +
> +      while (o < lines[0].size () && lines[0][o].l == ~0) {
> +        o += 1;
> +      }
> +      while (n < lines[1].size () && lines[1][n].l == ~0) {
> +        n += 1;
> +      }
> +
560,563c2309,2311
<        // last set of deletes or inserts we find.
<  
<        widenWindow = false;
< -      for (unsigned l = 0; !widenWindow && l < optCopyContext; l += 1) {
---
> +      // last set of deletes or inserts we find.
> +
> +      widenWindow = false;
565,572c2313,2326
<          if (o < lines[0].size ()) {
<            widenWindow |= lines[0][o].l == ~0;
<            o += 1;
< @@ -811,10 +1233,10 @@
<        eoNewWindow = n;
<  
<        // However, since another window could follow, we look
< -      // optCopyContext ahead for another delete or insert.
---
> +        if (o < lines[0].size ()) {
> +          widenWindow |= lines[0][o].l == ~0;
> +          o += 1;
> +        }
> +        if (n < lines[1].size ()) {
> +          widenWindow |= lines[1][n].l == ~0;
> +          n += 1;
> +        }
> +      }
> +
> +      eoOldWindow = o;
> +      eoNewWindow = n;
> +
> +      // However, since another window could follow, we look
574,576c2328,2329
<  
<        if (!widenWindow) {
< -        for (unsigned l = 0; l < (2 * optCopyContext + 1); l += 1) {
---
> +
> +      if (!widenWindow) {
578,585c2331,2683
<            if (o < lines[0].size ()) {
<              widenWindow |= lines[0][o].l == ~0;
<              o += 1;
< @@ -1168,7 +1590,7 @@
<  
<    // Starting at the top of both files,...
<  
< -  int columnWidth = (optPageWidth - 7) / 2;
---
> +          if (o < lines[0].size ()) {
> +            widenWindow |= lines[0][o].l == ~0;
> +            o += 1;
> +          }
> +          if (n < lines[1].size ()) {
> +            widenWindow |= lines[1][n].l == ~0;
> +            n += 1;
> +          }
> +        }
> +      }
> +    }
> +
> +    // We've found the end of the window.
> +
> +    if (1 < optVerbose) {
> +      fprintf (stderr, "eoOldWindow = %d, eoNewWindow = %d\n", eoOldWindow, eoNewWindow);
> +      fflush (stderr);
> +    }
> +
> +    // Now, reset ourselves to the start of the window, and walk it to
> +    // produce the output.  We'll walk it twice, first for the old
> +    // file part, then for the new file part.
> +
> +    fprintf (stdout, "***************\n");
> +    fprintf (stdout, "*** %d,%d ****\n", boOldWindow + 1, eoOldWindow);
> +
> +    o = boOldWindow;
> +    n = boNewWindow;
> +
> +    while (o < eoOldWindow || n < eoNewWindow) {
> +
> +      // Find any unmatched lines at this point in the old file.  These
> +      // are deletes.
> +
> +      unsigned boDeletes = o;
> +      while (o < eoOldWindow && lines[0][o].l == ~0) {
> +        o += 1;
> +      }
> +
> +      // Find any unmatched lines at this point in the new file.  These
> +      // are inserts.
> +
> +      unsigned boInserts = n;
> +      while (n < eoNewWindow && lines[1][n].l == ~0) {
> +        n += 1;
> +      }
> +
> +      // We've got deleted line(s) from boDeletes .. o.
> +      // We've got deleted line(s) from boInserts .. n.
> +
> +      unsigned nDeletes = o - boDeletes;
> +      unsigned nInserts = n - boInserts;
> +
> +      // We've got...
> +
> +      if (nDeletes && nInserts) {
> +
> +        // ... deletes and inserts.
> +
> +        for (unsigned l = boDeletes; l < o; l += 1) {
> +          fprintf (stdout, "! %s\n", lines[0][l].line->c_str ());
> +        }
> +      } else if (nDeletes) {
> +
> +        //  ... just deletes.
> +
> +        for (unsigned l = boDeletes; l < o; l += 1) {
> +          fprintf (stdout, "- %s\n", lines[0][l].line->c_str ());
> +        }
> +      }
> +
> +      // When we get here, we're dealing with matching lines.
> +
> +      fprintf (stdout, "  %s\n", lines[0][o].line->c_str ());
> +      o += 1;
> +      n += 1;
> +    }
> +
> +    fprintf (stdout, "--- %d,%d ----\n", boNewWindow + 1, eoNewWindow);
> +
> +    o = boOldWindow;
> +    n = boNewWindow;
> +
> +    while (o < eoOldWindow && n < eoNewWindow) {
> +
> +      // Find any unmatched lines at this point in the old file.  These
> +      // are deletes.
> +
> +      unsigned boDeletes = o;
> +      while (o < eoOldWindow && lines[0][o].l == ~0) {
> +        o += 1;
> +      }
> +
> +      // Find any unmatched lines at this point in the new file.  These
> +      // are inserts.
> +
> +      unsigned boInserts = n;
> +      while (n < eoNewWindow && lines[1][n].l == ~0) {
> +        n += 1;
> +      }
> +
> +      // We've got deleted line(s) from boDeletes .. o.
> +      // We've got deleted line(s) from boInserts .. n.
> +
> +      unsigned nDeletes = o - boDeletes;
> +      unsigned nInserts = n - boInserts;
> +
> +      // We've got...
> +
> +      if (nDeletes && nInserts) {
> +
> +        // ... deletes and inserts.
> +
> +        for (unsigned l = boInserts; l < n; l += 1) {
> +          fprintf (stdout, "! %s\n", lines[1][l].line->c_str ());
> +        }
> +      } else if (nInserts) {
> +
> +        //  ... just inserts.
> +
> +        for (unsigned l = boInserts; l < n; l += 1) {
> +          fprintf (stdout, "+ %s\n", lines[1][l].line->c_str ());
> +        }
> +      }
> +
> +      // When we get here, we're dealing with matching lines.
> +
> +      fprintf (stdout, "  %s\n", lines[1][n].line->c_str ());
> +      o += 1;
> +      n += 1;
> +    }
> +
> +    // Reset to the end of the current window.
> +
> +    o = eoOldWindow;
> +    n = eoNewWindow;
> +  }
> +}
> +
> +void pass6e () {
> +  fprintf (stderr, "pass6e() is unimplemented!\n");
> +  fflush (stderr);
> +}
> +
> +void pass6i () {
> +  fprintf (stderr, "pass6i() is unimplemented!\n");
> +  fflush (stderr);
> +}
> +
> +void pass6n ()
> +{
> +  if (0 < optVerbose) {
> +    fprintf (stderr, "# Pass #6n (walking the differences)...\n");
> +    fflush (stderr);
> +  }
> +
> +  nMatchedLines = 0;
> +
> +  // Write the header.  (None for normal.)
> +
> +  // Starting at the top of both files,...
> +
> +  unsigned o = 0;
> +  unsigned n = 0;
> +
> +  while (o < lines[0].size () || n < lines[1].size ()) {
> +
> +    // Find any unmatched lines at this point in the old file.  These
> +    // are deletes.
> +
> +    unsigned boDeletes;
> +    for (boDeletes = o;
> +         o < lines[0].size () && lines[0][o].l == ~0;
> +         o += 1
> +        )
> +    {}
> +
> +    // Find any unmatched lines at this point in the new file.  These
> +    // are inserts.
> +
> +    unsigned boInserts;
> +    for (boInserts = n;
> +         n < lines[1].size () && lines[1][n].l == ~0;
> +         n += 1
> +        )
> +    {}
> +
> +    // We've got deleted line(s) from boDeletes .. o.
> +    // We've got deleted line(s) from boInserts .. n.
> +
> +    unsigned nDeletes = o - boDeletes;
> +    unsigned nInserts = n - boInserts;
> +
> +    // We've got...
> +
> +    if (nDeletes && nInserts) {
> +
> +      // ... deletes and inserts.
> +
> +      if (1 < nDeletes && 1 < nInserts) {
> +        fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, boInserts + 1, n);
> +      } else if (1 < nDeletes) {
> +        fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boInserts + 1);
> +      } else if (1 < nInserts) {
> +        fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInserts + 1, n);
> +      } 
> +      for (unsigned l = boDeletes; l < o; l += 1) {
> +        fprintf (stdout, "< %s\n", lines[0][l].line->c_str ());
> +      }
> +      fprintf (stdout, "---\n");
> +      for (unsigned l = boInserts; l < n; l += 1) {
> +        fprintf (stdout, "> %s\n", lines[1][l].line->c_str ());
> +      }
> +    } else if (nDeletes) {
> +
> +      //  ... just deletes.
> +
> +      if (1 < nDeletes) {
> +        fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
> +      } else {
> +        fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
> +      }
> +      for (unsigned l = boDeletes; l < o; l += 1) {
> +        fprintf (stdout, "< %s\n", lines[0][l].line->c_str ());
> +      }
> +    } else if (nInserts) {
> +
> +      //  ... just inserts.
> +
> +      if (1 < nInserts) {
> +        fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
> +      } else {
> +        fprintf (stdout, "%da%d\n", o, boInserts + 1);
> +      }
> +      for (unsigned l = boInserts; l < n; l += 1) {
> +        fprintf (stdout, "> %s\n", lines[1][l].line->c_str ());
> +      }
> +    }
> +
> +    // When we get here, we're dealing with matching lines.
> +
> +    o += 1;
> +    n += 1;
> +  }
> +}
> +
> +void pass6r () {
> +  fprintf (stderr, "pass6r() is unimplemented!\n");
> +  fflush (stderr);
> +}
> +
> +void pass6s () {
> +  fprintf (stderr, "pass6s() is unimplemented!\n");
> +  fflush (stderr);
> +}
> +
> +void pass6u ()
> +{
> +  if (0 < optVerbose) {
> +    fprintf (stderr, "# Pass #6u (walking the differences)...\n");
> +    fflush (stderr);
> +  }
> +
> +  nMatchedLines = 0;
> +
> +  // Write the header.
> +
> +  fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:00:00.000000000 +0000");
> +  fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:00:00.000000000 +0000");
> +  fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), lines[1].size ());
> +
> +  // Starting at the top of both files,...
> +
> +  unsigned o = 0;
> +  unsigned n = 0;
> +
> +  while (o < lines[0].size () || n < lines[1].size ()) {
> +
> +    // Find any unmatched lines at this point in the old file.  These
> +    // are deletes.
> +
> +    unsigned boDeletes;
> +    for (boDeletes = o;
> +         o < lines[0].size () && lines[0][o].l == ~0;
> +         o += 1
> +        )
> +    {}
> +
> +    // Find any unmatched lines at this point in the new file.  These
> +    // are inserts.
> +
> +    unsigned boInserts;
> +    for (boInserts = n;
> +         n < lines[1].size () && lines[1][n].l == ~0;
> +         n += 1
> +        )
> +    {}
> +
> +    // We've got deleted line(s) from boDeletes .. o.
> +    // We've got deleted line(s) from boInserts .. n.
> +
> +    unsigned nDeletes = o - boDeletes;
> +    unsigned nInserts = n - boInserts;
> +
> +    // We've got...
> +
> +    if (nDeletes && nInserts) {
> +
> +      // ... deletes and inserts.
> +
> +      for (unsigned l = boDeletes; l < o; l += 1) {
> +        fprintf (stdout, "-%s\n", lines[0][l].line->c_str ());
> +      }
> +      for (unsigned l = boInserts; l < n; l += 1) {
> +        fprintf (stdout, "+%s\n", lines[1][l].line->c_str ());
> +      }
> +    } else if (nDeletes) {
> +
> +      //  ... just deletes.
> +
> +      for (unsigned l = boDeletes; l < o; l += 1) {
> +        fprintf (stdout, "-%s\n", lines[0][l].line->c_str ());
> +      }
> +    } else if (nInserts) {
> +
> +      //  ... just inserts.
> +
> +      for (unsigned l = boInserts; l < n; l += 1) {
> +        fprintf (stdout, "+%s\n", lines[1][l].line->c_str ());
> +      }
> +    }
> +
> +    // When we get here, we're dealing with matching lines.
> +
> +    fprintf (stdout, " %s\n", lines[0][o].line->c_str ());
> +    o += 1;
> +    n += 1;
> +  }
> +}
> +
> +void pass6y ()
> +{
> +  if (0 < optVerbose) {
> +    fprintf (stderr, "# Pass #6y (walking the differences)...\n");
> +    fflush (stderr);
> +  }
> +
> +  // Write the header.
> +
> +  // None for side-by-side.
> +
> +  // Starting at the top of both files,...
> +
589a2688,2765
>  
>    while (o < lines[0].size () || n < lines[1].size ()) {
>  
>      // Find any unmatched lines at this point in the old file.  These
>      // are deletes.
>  
>      unsigned boDeletes = o;
>      while (o < lines[0].size () && lines[0][o].l == ~0) {
>        o += 1;
>      }
>  
>      // Find any unmatched lines at this point in the new file.  These
>      // are inserts.
>  
>      unsigned boInserts = n;
>      while (n < lines[1].size () && lines[1][n].l == ~0) {
>        n += 1;
>      }
>  
>      // We've got deleted line(s) from boDeletes .. o.
>      // We've got deleted line(s) from boInserts .. n.
>  
>      unsigned nDeletes = o - boDeletes;
>      unsigned nInserts = n - boInserts;
>  
>      // We've got...
>  
>      while (boDeletes < o && boInserts < n) {
>  
>        // ... deletes and inserts.
>  
>        fprintf (stdout,
>                 "%-*s | %s\n",
>                 columnWidth,
>                 lines[0][boDeletes].line->substr (0, columnWidth).c_str (),
>                 lines[1][boInserts].line->substr (0, columnWidth).c_str ()
>                );
>        boDeletes += 1;
>        boInserts += 1;
>      }
>  
>      while (boDeletes < o) {
>  
>        //  ... just deletes.
>  
>        fprintf (stdout,
>                 "%-*s <\n",
>                 columnWidth,
>                 lines[0][boDeletes].line->substr (0, columnWidth).c_str ()
>                );
>        boDeletes += 1;
>      }
>  
>      while (boInserts < n) {
>  
>        //  ... just inserts.
>  
>        fprintf (stdout,
>                 "%-*s > %s\n",
>                 columnWidth,
>                 "",
>                 lines[1][boInserts].line->substr (0, columnWidth).c_str ()
>                );
>        boInserts += 1;
>      }
>  
>      // When we get here, we're dealing with matching lines.
>  
>      fprintf (stdout,
>               "%-*s   %s\n",
>               columnWidth,
>               lines[0][o].line->substr (0, columnWidth).c_str (),
>               lines[1][n].line->substr (0, columnWidth).c_str ()
>              );
>      o += 1;
>      n += 1;
>    }
>  }
# ../sdiff -u dif.8.cpp dif.7.cpp >& dif.8.7.diff-u.test
./test: line 46: 23496 Aborted                 (core dumped) ${DIFF} "${option}" "${oSrc}" "${nSrc}" 1>&"${dst}.test"
# dif.8.7.diff-u ---------------------------------------------------------------
1,3c1,12
< --- dif.8.cpp	2008-02-26 01:32:31.000000000 +0000
< +++ dif.7.cpp	2008-02-25 22:43:43.000000000 +0000
< @@ -9,46 +9,23 @@
---
> sdiff: sdiff.cpp:1745: void pass6u(): Assertion `lines[0][o].line == lines[1][n].line' failed.
> --- dif.8.cpp	0000-00-00 00:00:00.000000000 +0000
> +++ dif.7.cpp	0000-00-00 00:00:00.000000000 +0000
> @@ -1,1674 +1,1252 @@
>  #include <algorithm>
>  using std::find;
>  #include <string>
>  using std::string;
>  #include <list>
>  using std::list;
>  #include <map>
>  using std::map;
18,19c27
< +  Default,
<  
---
> -
21,28c29
< +  Context,
< +  EdScript,
< +  IfThenElse,
< +  Normal,
< +  RCS,
< +  SideBySide,
< +  Unified
< +};
---
> +  Default,
54a56,64
> +  Context,
> +  EdScript,
> +  IfThenElse,
> +  Normal,
> +  RCS,
> +  SideBySide,
> +  Unified
> +};
> +
62,64c72,92
< @@ -114,8 +91,6 @@
<  unsigned nTotalMatchedLines = 0;
<  unsigned nMatchedLines = 0;
---
>    Line (string _text) :
>      string (_text)
>    {
>    }
>    ~Line () {
>      copies[0].erase (copies[0].begin (), copies[0].end ());
>      copies[1].erase (copies[1].begin (), copies[1].end ());
>    }
>    void Dump (FILE *out) {
>      fprintf (out, "{{ ");
>      for (list<unsigned>::iterator i = copies[0].begin (); i != copies[0].end (); i++) {
>        fprintf (out, "%u ", *i);
>      }
>      fprintf (out, "},{ ");
>      for (list<unsigned>::iterator i = copies[1].begin (); i != copies[1].end (); i++) {
>        fprintf (out, "%u ", *i);
>      }
>      fprintf (out, "}}\t%s\n", c_str ());
>    }
>    list<unsigned> copies[2];
>  };
66,73c94,106
< -void getopts (int argc, char const *const argv[]);
< -
<  void pass1 ();
<  void pass2 ();
<  void pass3 ();
< @@ -123,29 +98,11 @@
<  void pass5 ();
<  void pass6 ();
---
>  struct LinePtr {
>    LinePtr (Line *_line) :
>      line (_line),
>      l (~0u)
>    {
>    }
>    void Dump (FILE *out) {
>      fprintf (out, "[%d] ", l);
>      line->Dump (out);
>    }
>    Line *line;
>    unsigned l;
>  };
75,96c108,109
< -int main (int argc, char const *const argv[])
< +int main (int argc, char *argv[])
<  {
< -  getopts (argc, argv);
< -
< -  if (opt_v_ShowVersionInfo) {
< -    fprintf
< -      (stderr,
< -       "diff () 0.0.1"
< -       "Copyright (C) 2008 Sidney R Maxwell III"
< -       ""
< -       "This program comes with NO WARRANTY, to the extent permitted by law."
< -       "You may redistribute copies of this program"
< -       "under the terms of the GNU General Public License."
< -       "For more information about these matters, see the file named COPYING."
< -       ""
< -       "Written by Sid Maxwell."
< -      );
< -    exit (0);
< -  }
< -
<    // Read the old [0] file, and the new [1] file.
---
>  typedef map<string, Line *> MapStringToLinePtr;
>  typedef vector<LinePtr> VectorLinePtr;
98,541c111,119
< -  for (int a = optind, n = 0; a < argc && n < 2; a += 1, n += 1) {
< +  for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
<      files[n] = argv[a];
<  
<      if (FILE *f = fopen (files[n], "r")) {
< @@ -208,387 +165,6 @@
<    return 0;
<  }
<  
< -// Usage: diff [OPTION]... FILES
< -// Compare files line by line.
< -// 
< -//   --GTYPE-group-format=GFMT  Similar, but format GTYPE input groups with GFMT.
< -//   --LTYPE-line-format=LFMT  Similar, but format LTYPE input lines with LFMT.
< -//     LTYPE is `old', `new', or `unchanged'.  GTYPE is LTYPE or `changed'.
< -//     GFMT may contain:
< -//       %<  lines from FILE1
< -//       %>  lines from FILE2
< -//       %=  lines common to FILE1 and FILE2
< -//       %[-][WIDTH][.[PREC]]{doxX}LETTER  printf-style spec for LETTER
< -//         LETTERs are as follows for new group, lower case for old group:
< -//           F  first line number
< -//           L  last line number
< -//           N  number of lines = L-F+1
< -//           E  F-1
< -//           M  L+1
< -//     LFMT may contain:
< -//       %L  contents of line
< -//       %l  contents of line, excluding any trailing newline
< -//       %[-][WIDTH][.[PREC]]{doxX}n  printf-style spec for input line number
< -//     Either GFMT or LFMT may contain:
< -//       %%  %
< -//       %c'C'  the single character C
< -//       %c'\OOO'  the character with octal code OOO
< -//
< -//   --brief  -q  Output only whether files differ.
< -//   --context[=NUM]  -c  -C NUM  Output NUM (default 3) lines of copied context.
< -//   --ed  -e  Output an ed script.
< -//   --exclude-from=FILE  -X FILE  Exclude files that match any pattern in FILE.
< -//   --exclude=PAT  -x PAT  Exclude files that match PAT.
< -//   --expand-tabs  -t  Expand tabs to spaces in output.
< -//   --from-file=FILE1  Compare FILE1 to all operands.  FILE1 can be a directory.
< -//   --help  Output this help.
< -//   --horizon-lines=NUM  Keep NUM lines of the common prefix and suffix.
< -//   --ifdef=NAME  -D NAME  Output merged file to show `#ifdef NAME' diffs.
< -//   --ignore-all-space  -w  Ignore all white space.
< -//   --ignore-blank-lines  -B  Ignore changes whose lines are all blank.
< -//   --ignore-case  -i  Ignore case differences in file contents.
< -//   --ignore-file-name-case  Ignore case when comparing file names.
< -//   --ignore-matching-lines=RE  -I RE  Ignore changes whose lines all match RE.
< -//   --ignore-space-change  -b  Ignore changes in the amount of white space.
< -//   --ignore-tab-expansion  -E  Ignore changes due to tab expansion.
< -//   --initial-tab  -T  Make tabs line up by prepending a tab.
< -//   --label LABEL  Use LABEL instead of file name.
< -//   --left-column  Output only the left column of common lines.
< -//   --line-format=LFMT  Similar, but format all input lines with LFMT.
< -//   --minimal  -d  Try hard to find a smaller set of changes.
< -//   --new-file  -N  Treat absent files as empty.
< -//   --no-ignore-file-name-case  Consider case when comparing file names.
< -//   --normal  Output a normal diff.
< -//   --paginate  -l  Pass the output through `pr' to paginate it.
< -//   --rcs  -n  Output an RCS format diff.
< -//   --recursive  -r  Recursively compare any subdirectories found.
< -//   --report-identical-files  -s  Report when two files are the same.
< -//   --show-c-function  -p  Show which C function each change is in.
< -//   --show-function-line=RE  -F RE  Show the most recent line matching RE.
< -//   --side-by-side  -y  Output in two columns.
< -//   --speed-large-files  Assume large files and many scattered small changes.
< -//   --starting-file=FILE  -S FILE  Start with FILE when comparing directories.
< -//   --strip-trailing-cr  Strip trailing carriage return on input.
< -//   --suppress-common-lines  Do not output common lines.
< -//   --text  -a  Treat all files as text.
< -//   --to-file=FILE2  Compare all operands to FILE2.  FILE2 can be a directory.
< -//   --unidirectional-new-file  Treat absent first files as empty.
< -//   --unified[=NUM]  -u  -U NUM  Output NUM (default 3) lines of unified context.
< -//   --version  -v  Output version info.
< -//   --width=NUM  -W NUM  Output at most NUM (default 130) print columns.
< -// 
< -// FILES are `FILE1 FILE2' or `DIR1 DIR2' or `DIR FILE...' or `FILE... DIR'.
< -// If --from-file or --to-file is given, there are no restrictions on FILES.
< -// If a FILE is `-', read standard input.
< -// 
< -// Report bugs to <bug-gnu-utils@gnu.org>.
< -
< -void getopts (int argc, char const *const argv[])
< -{
< -  while (1) {
< -    int option_index = 0;
< -    static option long_options[] = {
< -      { "brief",                        0, 0, 'q' }, // Output only whether files differ.
< -      { "context",                      2, 0, 'c' }, // Output NUM (default 3) lines of copied context.
< -      { "ed",                           0, 0, 'e' }, // Output an ed script.
< -      { "exclude-from",                 1, 0, ' ' }, // Exclude files that match any pattern in FILE.
< -      { "exclude",                      1, 0, 'x' }, // Exclude files that match PAT.
< -      { "expand-tabs",                  0, 0, 't' }, // Expand tabs to spaces in output.
< -      { "from-file",                    1, 0, ' ' }, // Compare FILE1 to all operands. FILE1 can be a directory.
< -      { "help",                         0, 0, 'h' }, // Output this help.
< -      { "horizon-lines",                1, 0, ' ' }, // Keep NUM lines of the common prefix and suffix.
< -      { "ifdef",                        1, 0, 'D' }, // Output merged file to show `#ifdef NAME' diffs.
< -      { "ignore-all-space",             0, 0, 'w' }, // Ignore all white space.
< -      { "ignore-blank-lines",           0, 0, 'B' }, // Ignore changes whose lines are all blank.
< -      { "ignore-case",                  0, 0, 'i' }, // Ignore case differences in file contents.
< -      { "ignore-file-name-case",        0, 0, ' ' }, // Ignore case when comparing file names.
< -      { "ignore-matching-lines",        1, 0, 'I' }, // Ignore changes whose lines all match RE.
< -      { "ignore-space-change",          0, 0, 'b' }, // Ignore changes in the amount of white space.
< -      { "ignore-tab-expansion",         0, 0, 'E' }, // Ignore changes due to tab expansion.
< -      { "initial-tab",                  0, 0, 'T' }, // Make tabs line up by prepending a tab.
< -      { "label",                        1, 0, ' ' }, // Use LABEL instead of file name.
< -      { "left-column",                  0, 0, ' ' }, // Output only the left column of common lines.
< -      { "line-format",                  1, 0, ' ' }, // Similar, but format all input lines with LFMT.
< -      { "minimal",                      0, 0, 'd' }, // Try hard to find a smaller set of changes.
< -      { "new-file",                     0, 0, 'N' }, // Treat absent files as empty.
< -      { "no-ignore-file-name-case",     0, 0, ' ' }, // Consider case when comparing file names.
< -      { "normal",                       0, 0, ' ' }, // Output a normal diff.
< -      { "paginate",                     0, 0, 'l' }, // Pass the output through `pr' to paginate it.
< -      { "rcs",                          0, 0, 'n' }, // Output an RCS format diff.
< -      { "recursive",                    0, 0, 'r' }, // Recursively compare any subdirectories found.
< -      { "report-identical-files",       0, 0, 's' }, // Report when two files are the same.
< -      { "show-c-function",              0, 0, 'p' }, // Show which C function each change is in.
< -      { "show-function-line",           1, 0, 'F' }, // Show the most recent line matching RE.
< -      { "side-by-side",                 0, 0, 'y' }, // Output in two columns.
< -      { "speed-large-files",            0, 0, ' ' }, // Assume large files and many scattered small changes.
< -      { "starting-file",                1, 0, 'S' }, // Start with FILE when comparing directories.
< -      { "strip-trailing-cr",            0, 0, ' ' }, // Strip trailing carriage return on input.
< -      { "suppress-common-lines",        0, 0, ' ' }, // Do not output common lines.
< -      { "text",                         0, 0, 'a' }, // Treat all files as text.
< -      { "to-file",                      0, 0, ' ' }, // Compare all operands to FILE2.  FILE2 can be a directory.
< -      { "unidirectional-new-file",      0, 0, ' ' }, // Treat absent first files as empty.
< -      { "unified",                      2, 0, 'u' }, // Output NUM (default 3) lines of unified context.
< -      { "version",                      0, 0, 'v' }, // Output version info.
< -      { "width",                        1, 0, 'W' }, // Output at most NUM (default 130) print columns.
< -      { 0,				0, 0,   0 }
< -    };
< -
< -    char const *short_options =
< -      "B"                       // Ignore changes whose lines are all blank.
< -      "C:"                      // Output NUM (default 3) lines of copied context.
< -      "D:"                      // Output merged file to show `#ifdef NAME' diffs.
< -      "E"                       // Ignore changes due to tab expansion.
< -      "F:"                      // Show the most recent line matching RE.
< -      "I:"                      // Ignore changes whose lines all match RE.
< -      "N"                       // Treat absent files as empty.
< -      "S:"                      // Start with FILE when comparing directories.
< -      "T"                       // Make tabs line up by prepending a tab.
< -      "U:"                      // Output NUM (default 3) lines of unified context.
< -      "W:"                      // Output at most NUM (default 130) print columns.
< -      "X:"                      // Exclude files that match any pattern in FILE.
< -      "a"                       // Treat all files as text.
< -      "b"                       // Ignore changes in the amount of white space.
< -      "c"                       // Output NUM (default 3) lines of copied context.
< -      "d"                       // Try hard to find a smaller set of changes.
< -      "e"                       // Output an ed script.
< -      "i"                       // Ignore case differences in file contents.
< -      "l"                       // Pass the output through `pr' to paginate it.
< -      "n"                       // Output an RCS format diff.
< -      "p"                       // Show which C function each change is in.
< -      "q"                       // Output only whether files differ.
< -      "r"                       // Recursively compare any subdirectories found.
< -      "s"                       // Report when two files are the same.
< -      "t"                       // Expand tabs to spaces in output.
< -      "u"                       // Output NUM (default 3) lines of unified context.
< -      "v"                       // Output version info.
< -      "w"                       // Ignore all white space.
< -      "x:"                      // Exclude files that match PAT.
< -      "y"                       // Output in two columns.
< -      ;
< -
< -    int c =
< -      getopt_long
< -        (argc,
< -         const_cast<char *const *> (argv),
< -         short_options,
< -         long_options,
< -         &option_index
< -        );
< -
< -    switch (c) {
< -    case -1:
< -      return;
< -
< -    case 0:
< -      printf ("option %s", long_options[option_index].name);
< -      if (optarg)
< -        printf (" with arg %s", optarg);
< -      printf ("\n");
< -      break;
< -    case 'B':
< -      opt_B_IgnoreBlankLines = true;
< -      break;
< -    case 'C':
< -      {
< -        unsigned linesOfContext = 3;
< -        if (optarg) {
< -          if (sscanf (optarg, "%u", &linesOfContext) != 1) {
< -            fprintf (stderr, "-C <NUM> or --context[=<NUM>] (%d)\n", opt_C_LinesOfCopyContext);
< -            exit (1);
< -          }
< -        }
< -        opt_C_LinesOfCopyContext = linesOfContext;
< -      }
< -      break;
< -    case 'D':
< -      opt_D_IfdefName = optarg;
< -      break;
< -    case 'E':
< -      opt_E_IgnoreTabExpansionChanges = true;
< -      break;
< -    case 'F':
< -      opt_F_ShowMostRecentLineMatching = optarg;
< -      break;
< -    case 'I':
< -      opt_I_IgnoreLinesMatching = optarg;
< -      break;
< -    case 'N':
< -      opt_N_TreatAbsentFilesAsEmpty = true;
< -      break;
< -    case 'S':
< -      opt_S_StartWithFileMatching = optarg;
< -      break;
< -    case 'T':
< -      opt_T_PrependATab = true;
< -      break;
< -    case 'U':
< -      {
< -        unsigned linesOfContext = 3;
< -        if (optarg) {
< -          if (sscanf (optarg, "%u", &linesOfContext) != 1) {
< -            fprintf (stderr, "-U <NUM> or --unified[=<NUM>] (%d)\n", opt_U_LinesOfUnifiedContext);
< -            exit (1);
< -          }
< -        }
< -        opt_U_LinesOfUnifiedContext = linesOfContext;
< -      }
< -      break;
< -    case 'W':
< -      {
< -        unsigned maxPrintColumns = 130;
< -        if (optarg) {
< -          if (sscanf (optarg, "%u", &maxPrintColumns) != 1) {
< -            fprintf (stderr, "-W <NUM> or --width[=<NUM>] (%d)\n", opt_W_MaxPrintColumns);
< -            exit (1);
< -          }
< -        }
< -        opt_W_MaxPrintColumns = maxPrintColumns;
< -      }
< -      break;
< -    case 'X':
< -      opt_X_ExcludeFilesMatching = optarg;
< -      break;
< -    case 'a':
< -      opt_a_TreatAllFilesAsText = true;
< -      break;
< -    case 'b':
< -      opt_b_IgnoreWhitespaceChanges = true;
< -      break;
< -    case 'c':
< -      opt___OutputFormat = opt_c_Context;
< -      break;
< -    case 'd':
< -      opt_d_TryToFindMinimalChanges = true;
< -      break;
< -    case 'e':
< -      opt___OutputFormat = opt_e_EdScript;
< -      break;
< -    case 'i':
< -      opt_i_IgnoreCaseDifferences = true;
< -      break;
< -    case 'l':
< -      opt_l_PaginateWithPr = true;
< -      break;
< -    case 'n':
< -      opt___OutputFormat = opt_n_RCS;
< -      break;
< -    case 'p':
< -      opt_p_ShowChangedCFunction = true;
< -      break;
< -    case 'q':
< -      opt_q_OutputOnlyIfFilesDiffer = true;
< -      break;
< -    case 'r':
< -      opt_r_RecursivelyCompareSubdirectories = true;
< -      break;
< -    case 's':
< -      opt_s_ReportWhenFilesAreSame = true;
< -      break;
< -    case 't':
< -      opt_t_ExpandTabs = true;
< -      break;
< -    case 'u':
< -      opt___OutputFormat = opt_u_Unified;
< -      break;
< -    case 'v':
< -      opt_v_ShowVersionInfo = true;
< -      break;
< -    case 'w':
< -      opt_w_IgnoreAllWhitespace = true;
< -      break;
< -    case 'x':
< -      opt_x_IgnoreFilesMatching = optarg;
< -      break;
< -    case 'y':
< -      opt___OutputFormat = opt_y_SideBySide;
< -      break;
< -    case 'h':
< -    case '?':
< -      fprintf
< -        (stderr,
< -         "Usage: diff [OPTION]... FILES\n"
< -         "Compare files line by line.\n"
< -         "\n"
< -         "  --GTYPE-group-format=GFMT  Similar, but format GTYPE input groups with GFMT.\n"
< -         "  --LTYPE-line-format=LFMT  Similar, but format LTYPE input lines with LFMT.\n"
< -         "    LTYPE is `old', `new', or `unchanged'.  GTYPE is LTYPE or `changed'.\n"
< -         "    GFMT may contain:\n"
< -         "      %<  lines from FILE1\n"
< -         "      %>  lines from FILE2\n"
< -         "      %=  lines common to FILE1 and FILE2\n"
< -         "      %[-][WIDTH][.[PREC]]{doxX}LETTER  printf-style spec for LETTER\n"
< -         "        LETTERs are as follows for new group, lower case for old group:\n"
< -         "          F  first line number\n"
< -         "          L  last line number\n"
< -         "          N  number of lines = L-F+1\n"
< -         "          E  F-1\n"
< -         "          M  L+1\n"
< -         "    LFMT may contain:\n"
< -         "      %L  contents of line\n"
< -         "      %l  contents of line, excluding any trailing newline\n"
< -         "      %[-][WIDTH][.[PREC]]{doxX}n  printf-style spec for input line number\n"
< -         "    Either GFMT or LFMT may contain:\n"
< -         "      %%  %\n"
< -         "      %c'C'  the single character C\n"
< -         "      %c'\\OOO'  the character with octal code OOO\n"
< -         "\n"
< -         "  --brief  -q  Output only whether files differ.\n"
< -         "  --context[=NUM]  -c  -C NUM  Output NUM (default 3) lines of copied context.\n"
< -         "  --ed  -e  Output an ed script.\n"
< -         "  --exclude-from=FILE  -X FILE  Exclude files that match any pattern in FILE.\n"
< -         "  --exclude=PAT  -x PAT  Exclude files that match PAT.\n"
< -         "  --expand-tabs  -t  Expand tabs to spaces in output.\n"
< -         "  --from-file=FILE1  Compare FILE1 to all operands.  FILE1 can be a directory.\n"
< -         "  --help  Output this help.\n"
< -         "  --horizon-lines=NUM  Keep NUM lines of the common prefix and suffix.\n"
< -         "  --ifdef=NAME  -D NAME  Output merged file to show `#ifdef NAME' diffs.\n"
< -         "  --ignore-all-space  -w  Ignore all white space.\n"
< -         "  --ignore-blank-lines  -B  Ignore changes whose lines are all blank.\n"
< -         "  --ignore-case  -i  Ignore case differences in file contents.\n"
< -         "  --ignore-file-name-case  Ignore case when comparing file names.\n"
< -         "  --ignore-matching-lines=RE  -I RE  Ignore changes whose lines all match RE.\n"
< -         "  --ignore-space-change  -b  Ignore changes in the amount of white space.\n"
< -         "  --ignore-tab-expansion  -E  Ignore changes due to tab expansion.\n"
< -         "  --initial-tab  -T  Make tabs line up by prepending a tab.\n"
< -         "  --label LABEL  Use LABEL instead of file name.\n"
< -         "  --left-column  Output only the left column of common lines.\n"
< -         "  --line-format=LFMT  Similar, but format all input lines with LFMT.\n"
< -         "  --minimal  -d  Try hard to find a smaller set of changes.\n"
< -         "  --new-file  -N  Treat absent files as empty.\n"
< -         "  --no-ignore-file-name-case  Consider case when comparing file names.\n"
< -         "  --normal  Output a normal diff.\n"
< -         "  --paginate  -l  Pass the output through `pr' to paginate it.\n"
< -         "  --rcs  -n  Output an RCS format diff.\n"
< -         "  --recursive  -r  Recursively compare any subdirectories found.\n"
< -         "  --report-identical-files  -s  Report when two files are the same.\n"
< -         "  --show-c-function  -p  Show which C function each change is in.\n"
< -         "  --show-function-line=RE  -F RE  Show the most recent line matching RE.\n"
< -         "  --side-by-side  -y  Output in two columns.\n"
< -         "  --speed-large-files  Assume large files and many scattered small changes.\n"
< -         "  --starting-file=FILE  -S FILE  Start with FILE when comparing directories.\n"
< -         "  --strip-trailing-cr  Strip trailing carriage return on input.\n"
< -         "  --suppress-common-lines  Do not output common lines.\n"
< -         "  --text  -a  Treat all files as text.\n"
< -         "  --to-file=FILE2  Compare all operands to FILE2.  FILE2 can be a directory.\n"
< -         "  --unidirectional-new-file  Treat absent first files as empty.\n"
< -         "  --unified[=NUM]  -u  -U NUM  Output NUM (default 3) lines of unified context.\n"
< -         "  --version  -v  Output version info.\n"
< -         "  --width=NUM  -W NUM  Output at most NUM (default 130) print columns.\n"
< -         "\n"
< -         "FILES are `FILE1 FILE2' or `DIR1 DIR2' or `DIR FILE...' or `FILE... DIR'.\n"
< -         "If --from-file or --to-file is given, there are no restrictions on FILES.\n"
< -         "If a FILE is `-', read standard input.\n"
< -         "\n"
< -         "Report bugs to <bug-gnu-utils@gnu.org>.\n"
< -        );
< -      exit (1);
< -    default:
< -      fprintf (stderr, "Unhandled option (%c%s)!\n", c, optarg ? optarg : "");
< -      exit (1);
< -    }
< -  }
< -}
< -
<  // Perform pass #1, in which we find all explicit matches amongst the
<  // unique lines.  For every unique line that appears the same number
<  // of times in both files, we declare the lines to match.
< @@ -1105,37 +681,39 @@
<  
<  void pass6 ()
<  {
< -  switch (opt___OutputFormat) {
< -  case opt_c_Context:
< +
< +  switch (diffFormat) {
< +  case Context:
<      pass6c ();
<      break;
<  
< -  case opt_e_EdScript:
< +  case EdScript:
<      pass6e ();
<      break;
<  
< -  case opt_D_IfThenElse:
< +  case IfThenElse:
<      pass6i ();
<      break;
<  
< -  case opt___Normal:
< +  case Normal:
<      pass6n ();
<      break;
<  
< -  case opt_n_RCS:
< +  case RCS:
<      pass6r ();
<      break;
<  
< -  case opt_y_SideBySide:
< +  case SideBySide:
<      pass6y ();
<      break;
<  
< -  case opt_u_Unified:
< +  case Unified:
<      pass6u ();
<      break;
<  
< +  case Default:
<    default:
< -    pass6n ();
< +    pass6c ();
<      break;
<    }
<  }
< @@ -1186,10 +764,10 @@
<      }
---
>  // Our name.
>  
>  char *ARGV0 = "dif3";
>  
>  // The 'symbol' (line) table.
>  
>  MapStringToLinePtr table;
>  
>  // The names of the 2 files to be diff'd.
543,581c121
<      // We're now looking at at least 1 delete or insert, so a window
< -    // begins here (or, rather, opt_C_LinesOfCopyContext lines earlier).
< +    // begins here (or, rather, optCopyContext lines earlier).
<      
< -    int boOldWindow = max (0, int (o) - int (opt_C_LinesOfCopyContext));
< -    int boNewWindow = max (0, int (n) - int (opt_C_LinesOfCopyContext));
< +    int boOldWindow = max (0, int (o) - int (optCopyContext));
< +    int boNewWindow = max (0, int (n) - int (optCopyContext));
<  
<      if (1 < optVerbose) {
<        fprintf (stderr, "boOldWindow = %d, boNewWindow = %d\n", boOldWindow, boNewWindow);
< @@ -1214,11 +792,11 @@
<          n += 1;
<        }
<  
< -      // This context will end opt_C_LinesOfCopyContext matched lines past the
< +      // This context will end optCopyContext matched lines past the
<        // last set of deletes or inserts we find.
<  
<        widenWindow = false;
< -      for (unsigned l = 0; !widenWindow && l < opt_C_LinesOfCopyContext; l += 1) {
< +      for (unsigned l = 0; !widenWindow && l < optCopyContext; l += 1) {
<          if (o < lines[0].size ()) {
<            widenWindow |= lines[0][o].l == ~0;
<            o += 1;
< @@ -1233,10 +811,10 @@
<        eoNewWindow = n;
<  
<        // However, since another window could follow, we look
< -      // opt_C_LinesOfCopyContext ahead for another delete or insert.
< +      // optCopyContext ahead for another delete or insert.
<  
<        if (!widenWindow) {
< -        for (unsigned l = 0; l < (2 * opt_C_LinesOfCopyContext + 1); l += 1) {
< +        for (unsigned l = 0; l < (2 * optCopyContext + 1); l += 1) {
<            if (o < lines[0].size ()) {
<              widenWindow |= lines[0][o].l == ~0;
<              o += 1;
< @@ -1590,7 +1168,7 @@
---
>  char const *files[2] = { 0, 0 };
583c123
<    // Starting at the top of both files,...
---
>  // The lines of the 2 files to be diff'd.
585,586c125
< -  int columnWidth = (opt_W_MaxPrintColumns - 7) / 2;
< +  int columnWidth = (optPageWidth - 7) / 2;
---
>  VectorLinePtr lines[2];
588,589c127,141
<    unsigned o = 0;
<    unsigned n = 0;
---
>  // Miscellaneous metrics.
>  
>  unsigned nTotalMatchedBlocks = 0;
>  unsigned nMatchedBlocks = 0;
>  unsigned nTotalMatchedLines = 0;
>  unsigned nMatchedLines = 0;
> +
> +void pass1 ();
> +void pass2 ();
> +void pass3 ();
> +void pass4 ();
> +void pass5 ();
> +void pass6 ();
> +
> +int main (int argc, char *argv[])
# ../sdiff -y dif.0.cpp dif.1.cpp >& dif.0.1.diff-y.test
# dif.0.1.diff-y ---------------------------------------------------------------
1,49c1,49
< #include <map>						      <
< using std::map;						      <
< #include <string>						#include <string>
< using std::string;						using std::string;
< 							      >	#include <map>
< 							      >	using std::map;
< 							      >	#include <vector>
< 							      >	using std::vector;
< #include <stdio.h>						#include <stdio.h>
< 
< int main (int argc, char *argv[])				int main (int argc, char *argv[])
< {								{
<   map<string, int> table;					  map<string, int> table;
< 							      >	  vector<vector<int *> *> fileLines;
< 							      >
<   for (int a = 1; a < argc; a += 1) {				  for (int a = 1; a < argc; a += 1) {
<     if (FILE *f = fopen (argv[a], "r")) {			    if (FILE *f = fopen (argv[a], "r")) {
<       fprintf (stderr, "# Reading %s...", argv[a]);		      fprintf (stderr, "# Reading %s...", argv[a]);
< 							      >	      vector<int *> *lines = new vector<int *> ();
< 							      >
<       char buffer[1024];					      char buffer[1024];
<       unsigned n = 0;					      <
<       while (fgets (buffer, sizeof (buffer), f)) {		      while (fgets (buffer, sizeof (buffer), f)) {
< 	string l (buffer);				      |	        int *line = &table[buffer];
< 	table[l] += 1;					      |	        lines->push_back (line);
< 	n += 1;						      |	        *line += 1;
<       }								      }
<       fprintf (stderr, " %u lines.\n", n);		      |	      fprintf (stderr, " %u lines.\n", lines->size ());
< 							      >	      fileLines.push_back (lines);
<     } else {							    } else {
< 							      >	      fprintf (stderr, "%s: Unable to open %s!  Ignoring....\
<     }								    }
<   }								  }
<   printf ("table.size () = %d\n", table.size ());	      |	  printf ("# table.size () = %d\n", table.size ());
<   map<int, int> counts;						  map<int, int> counts;
<   for (map<string, int>::iterator i = table.begin (); i != ta	  for (map<string, int>::iterator i = table.begin (); i != ta
<     counts[i->second] += 1;					    counts[i->second] += 1;
<   }								  }
<   for (map<int, int>::iterator i = counts.begin (); i != coun	  for (map<int, int>::iterator i = counts.begin (); i != coun
<     fprintf (stderr, "counts[%d] = %d\n", i->first, i->second |	    fprintf (stderr, "# counts[%d] = %d\n", i->first, i->seco
< 							      >	  }
< 							      >	  for (int f = 0; f < fileLines.size (); f += 1) {
< 							      >	    fprintf (stderr, "# file #%d\n", f);
< 							      >	    vector<int *> *lines = fileLines[f];
< 							      >	    for (int l = 0; l < lines->size (); l += 1) {
< 							      >	      fprintf (stderr, "#   [%d] = %d\n", l, *(*lines)[l]);
< 							      >	    }
<   }								  }
< }								}
---
> #include <map>                                                <
> using std::map;                                               <
> #include <string>                                               #include <string>
> using std::string;                                              using std::string;
>                                                               > #include <map>
>                                                               > using std::map;
>                                                               > #include <vector>
>                                                               > using std::vector;
> #include <stdio.h>                                              #include <stdio.h>
>                                                                 
> int main (int argc, char *argv[])                               int main (int argc, char *argv[])
> {                                                               {
>   map<string, int> table;                                         map<string, int> table;
>                                                               >   vector<vector<int *> *> fileLines;
>                                                               > 
>   for (int a = 1; a < argc; a += 1) {                             for (int a = 1; a < argc; a += 1) {
>     if (FILE *f = fopen (argv[a], "r")) {                           if (FILE *f = fopen (argv[a], "r")) {
>       fprintf (stderr, "# Reading %s...", argv[a]);                   fprintf (stderr, "# Reading %s...", argv[a]);
>                                                               >       vector<int *> *lines = new vector<int *> ();
>                                                               > 
>       char buffer[1024];                                              char buffer[1024];
>       unsigned n = 0;                                         <
>       while (fgets (buffer, sizeof (buffer), f)) {                    while (fgets (buffer, sizeof (buffer), f)) {
> 	string l (buffer);                                           |         int *line = &table[buffer];
> 	table[l] += 1;                                               |         lines->push_back (line);
> 	n += 1;                                                      |         *line += 1;
>       }                                                               }
>       fprintf (stderr, " %u lines.\n", n);                    |       fprintf (stderr, " %u lines.\n", lines->size ());
>                                                               >       fileLines.push_back (lines);
>     } else {                                                        } else {
>                                                               >       fprintf (stderr, "%s: Unable to open %s!  Ignoring....\
>     }                                                               }
>   }                                                               }
>   printf ("table.size () = %d\n", table.size ());             |   printf ("# table.size () = %d\n", table.size ());
>   map<int, int> counts;                                           map<int, int> counts;
>   for (map<string, int>::iterator i = table.begin (); i != ta     for (map<string, int>::iterator i = table.begin (); i != ta
>     counts[i->second] += 1;                                         counts[i->second] += 1;
>   }                                                               }
>   for (map<int, int>::iterator i = counts.begin (); i != coun     for (map<int, int>::iterator i = counts.begin (); i != coun
>     fprintf (stderr, "counts[%d] = %d\n", i->first, i->second |     fprintf (stderr, "# counts[%d] = %d\n", i->first, i->seco
>                                                               >   }
>                                                               >   for (int f = 0; f < fileLines.size (); f += 1) {
>                                                               >     fprintf (stderr, "# file #%d\n", f);
>                                                               >     vector<int *> *lines = fileLines[f];
>                                                               >     for (int l = 0; l < lines->size (); l += 1) {
>                                                               >       fprintf (stderr, "#   [%d] = %d\n", l, *(*lines)[l]);
>                                                               >     }
>   }                                                               }
> }                                                               }
# ../sdiff -y dif.1.cpp dif.0.cpp >& dif.1.0.diff-y.test
# dif.1.0.diff-y ---------------------------------------------------------------
1,28c1,28
< #include <string>					      <
< using std::string;					      <
< #include <map>							#include <map>
< using std::map;							using std::map;
< #include <vector>					      |	#include <string>
< using std::vector;					      |	using std::string;
< #include <stdio.h>						#include <stdio.h>
< 
< int main (int argc, char *argv[])				int main (int argc, char *argv[])
< {								{
<   map<string, int> table;					  map<string, int> table;
<   vector<vector<int *> *> fileLines;			      <
< 							      <
<   for (int a = 1; a < argc; a += 1) {				  for (int a = 1; a < argc; a += 1) {
<     if (FILE *f = fopen (argv[a], "r")) {			    if (FILE *f = fopen (argv[a], "r")) {
<       fprintf (stderr, "# Reading %s...", argv[a]);		      fprintf (stderr, "# Reading %s...", argv[a]);
<       vector<int *> *lines = new vector<int *> ();	      <
< 							      <
<       char buffer[1024];					      char buffer[1024];
< 							      >	      unsigned n = 0;
<       while (fgets (buffer, sizeof (buffer), f)) {		      while (fgets (buffer, sizeof (buffer), f)) {
<         int *line = &table[buffer];			      |		string l (buffer);
<         lines->push_back (line);			      |		table[l] += 1;
<         *line += 1;					      |		n += 1;
<       }								      }
<       fprintf (stderr, " %u lines.\n", lines->size ());	      |	      fprintf (stderr, " %u lines.\n", n);
<       fileLines.push_back (lines);			      <
<     } else {							    } else {
---
> #include <string>                                             <
> using std::string;                                            <
> #include <map>                                                  #include <map>
> using std::map;                                                 using std::map;
> #include <vector>                                             | #include <string>
> using std::vector;                                            | using std::string;
> #include <stdio.h>                                              #include <stdio.h>
>                                                                 
> int main (int argc, char *argv[])                               int main (int argc, char *argv[])
> {                                                               {
>   map<string, int> table;                                         map<string, int> table;
>   vector<vector<int *> *> fileLines;                          <
>                                                               <
>   for (int a = 1; a < argc; a += 1) {                             for (int a = 1; a < argc; a += 1) {
>     if (FILE *f = fopen (argv[a], "r")) {                           if (FILE *f = fopen (argv[a], "r")) {
>       fprintf (stderr, "# Reading %s...", argv[a]);                   fprintf (stderr, "# Reading %s...", argv[a]);
>       vector<int *> *lines = new vector<int *> ();            <
>                                                               <
>       char buffer[1024];                                              char buffer[1024];
>                                                               >       unsigned n = 0;
>       while (fgets (buffer, sizeof (buffer), f)) {                    while (fgets (buffer, sizeof (buffer), f)) {
>         int *line = &table[buffer];                           | 	string l (buffer);
>         lines->push_back (line);                              | 	table[l] += 1;
>         *line += 1;                                           | 	n += 1;
>       }                                                               }
>       fprintf (stderr, " %u lines.\n", lines->size ());       |       fprintf (stderr, " %u lines.\n", n);
>       fileLines.push_back (lines);                            <
>     } else {                                                        } else {
30,43c30,43
<     }								    }
<   }								  }
<   printf ("# table.size () = %d\n", table.size ());	      |	  printf ("table.size () = %d\n", table.size ());
<   map<int, int> counts;						  map<int, int> counts;
<   for (map<string, int>::iterator i = table.begin (); i != ta	  for (map<string, int>::iterator i = table.begin (); i != ta
<     counts[i->second] += 1;					    counts[i->second] += 1;
<   }								  }
<   for (map<int, int>::iterator i = counts.begin (); i != coun	  for (map<int, int>::iterator i = counts.begin (); i != coun
<     fprintf (stderr, "# counts[%d] = %d\n", i->first, i->seco |	    fprintf (stderr, "counts[%d] = %d\n", i->first, i->second
<   }							      <
<   for (int f = 0; f < fileLines.size (); f += 1) {	      <
<     fprintf (stderr, "# file #%d\n", f);		      <
<     vector<int *> *lines = fileLines[f];		      <
<     for (int l = 0; l < lines->size (); l += 1) {	      <
---
>     }                                                               }
>   }                                                               }
>   printf ("# table.size () = %d\n", table.size ());           |   printf ("table.size () = %d\n", table.size ());
>   map<int, int> counts;                                           map<int, int> counts;
>   for (map<string, int>::iterator i = table.begin (); i != ta     for (map<string, int>::iterator i = table.begin (); i != ta
>     counts[i->second] += 1;                                         counts[i->second] += 1;
>   }                                                               }
>   for (map<int, int>::iterator i = counts.begin (); i != coun     for (map<int, int>::iterator i = counts.begin (); i != coun
>     fprintf (stderr, "# counts[%d] = %d\n", i->first, i->seco |     fprintf (stderr, "counts[%d] = %d\n", i->first, i->second
>   }                                                           <
>   for (int f = 0; f < fileLines.size (); f += 1) {            <
>     fprintf (stderr, "# file #%d\n", f);                      <
>     vector<int *> *lines = fileLines[f];                      <
>     for (int l = 0; l < lines->size (); l += 1) {             <
45,47c45,47
<     }							      <
<   }								  }
< }								}
---
>     }                                                         <
>   }                                                               }
> }                                                               }
# ../sdiff -y dif.1.cpp dif.2.cpp >& dif.1.2.diff-y.test
# dif.1.2.diff-y ---------------------------------------------------------------
1,64c1,65
< #include <string>						#include <string>
< using std::string;						using std::string;
< 							      >	#include <list>
< 							      >	using std::list;
< #include <map>							#include <map>
< using std::map;							using std::map;
< #include <vector>						#include <vector>
< using std::vector;						using std::vector;
< #include <stdio.h>						#include <stdio.h>
< 
< 							      >	struct Line : public string {
< 							      >	  Line (string _text) :
< 							      >	    text (_text)
< 							      >	  {
< 							      >	  }
< 							      >	  string text;
< 							      >	  list<unsigned> counts[2];
< 							      >	};
< 							      >
< 							      >	typedef map<string, Line *> MapStringToLinePtr;
< 							      >	typedef vector<Line *> VectorLinePtr;
< 							      >
< int main (int argc, char *argv[])				int main (int argc, char *argv[])
< {								{
<   map<string, int> table;				      |	  MapStringToLinePtr table;
<   vector<vector<int *> *> fileLines;			      |	  VectorLinePtr lines[2];
< 
<   for (int a = 1; a < argc; a += 1) {			      |	  for (int a = 1; a < argc && a <= 2; a += 1) {
<     if (FILE *f = fopen (argv[a], "r")) {			    if (FILE *f = fopen (argv[a], "r")) {
<       fprintf (stderr, "# Reading %s...", argv[a]);		      fprintf (stderr, "# Reading %s...", argv[a]);
<       vector<int *> *lines = new vector<int *> ();	      <
< 
< 							      >	      VectorLinePtr *lines = new VectorLinePtr ();
<       char buffer[1024];					      char buffer[1024];
<       while (fgets (buffer, sizeof (buffer), f)) {		      while (fgets (buffer, sizeof (buffer), f)) {
<         int *line = &table[buffer];			      |	        string text (buffer);
<         lines->push_back (line);			      |
<         *line += 1;					      |	        Line *line = table[text];
< 							      >
< 							      >	        if (!line) {
< 							      >	          table[text] = line = new Line (text);
< 							      >	        }
< 							      >	        line->counts[a - 1].push_back (lines[a - 1].size ());
< 							      >	        lines[a - 1].push_back (line);
<       }								      }
<       fprintf (stderr, " %u lines.\n", lines->size ());	      |	      fprintf (stderr, " %u lines.\n", lines[a - 1]->size ())
<       fileLines.push_back (lines);			      <
<     } else {							    } else {
<       fprintf (stderr, "%s: Unable to open %s!  Ignoring....\	      fprintf (stderr, "%s: Unable to open %s!  Ignoring....\
<     }								    }
<   }								  }
<   printf ("# table.size () = %d\n", table.size ());		  printf ("# table.size () = %d\n", table.size ());
<   map<int, int> counts;						  map<int, int> counts;
<   for (map<string, int>::iterator i = table.begin (); i != ta	  for (map<string, int>::iterator i = table.begin (); i != ta
<     counts[i->second] += 1;				      |	    Line *l = i->second;
< 							      >	    counts[l->counts[0].size () + l->counts[1].size ()] += 1;
<   }								  }
<   for (map<int, int>::iterator i = counts.begin (); i != coun	  for (map<int, int>::iterator i = counts.begin (); i != coun
<     fprintf (stderr, "# counts[%d] = %d\n", i->first, i->seco	    fprintf (stderr, "# counts[%d] = %d\n", i->first, i->seco
<   }								  }
<   for (int f = 0; f < fileLines.size (); f += 1) {	      |	  for (int f = 0; f < 2; f += 1) {
<     fprintf (stderr, "# file #%d\n", f);		      |	    fprintf (stderr, "# file #%d\n", f + 1);
<     vector<int *> *lines = fileLines[f];		      |	    for (int l = 0; l < lines[f].size (); l += 1) {
<     for (int l = 0; l < lines->size (); l += 1) {	      |	      fprintf (stderr, "#   [%d] = %d\n", l, lines[f][l]->cou
---
> #include <string>                                               #include <string>
> using std::string;                                              using std::string;
>                                                               > #include <list>
>                                                               > using std::list;
> #include <map>                                                  #include <map>
> using std::map;                                                 using std::map;
> #include <vector>                                               #include <vector>
> using std::vector;                                              using std::vector;
> #include <stdio.h>                                              #include <stdio.h>
>                                                                 
> int main (int argc, char *argv[])                             | struct Line : public string {
> {                                                             |   Line (string _text) :
>   map<string, int> table;                                     |     text (_text)
>   vector<vector<int *> *> fileLines;                          |   {
>                                                               >   }
>                                                               >   string text;
>                                                               >   list<unsigned> counts[2];
>                                                               > };
>                                                                 
>   for (int a = 1; a < argc; a += 1) {                         | typedef map<string, Line *> MapStringToLinePtr;
>     if (FILE *f = fopen (argv[a], "r")) {                     | typedef vector<Line *> VectorLinePtr;
>       fprintf (stderr, "# Reading %s...", argv[a]);           <
>       vector<int *> *lines = new vector<int *> ();            <
>                                                                 
>                                                               > int main (int argc, char *argv[])
>                                                               > {
>                                                               >   MapStringToLinePtr table;
>                                                               >   VectorLinePtr lines[2];
>                                                               > 
>                                                               >   for (int a = 1; a < argc && a <= 2; a += 1) {
>                                                               >     if (FILE *f = fopen (argv[a], "r")) {
>                                                               >       fprintf (stderr, "# Reading %s...", argv[a]);
>                                                               > 
>                                                               >       VectorLinePtr *lines = new VectorLinePtr ();
>       char buffer[1024];                                              char buffer[1024];
>       while (fgets (buffer, sizeof (buffer), f)) {                    while (fgets (buffer, sizeof (buffer), f)) {
>         int *line = &table[buffer];                           |         string text (buffer);
>         lines->push_back (line);                              | 
>         *line += 1;                                           |         Line *line = table[text];
>                                                               > 
>                                                               >         if (!line) {
>                                                               >           table[text] = line = new Line (text);
>                                                               >         }
>                                                               >         line->counts[a - 1].push_back (lines[a - 1].size ());
>                                                               >         lines[a - 1].push_back (line);
>       }                                                               }
>       fprintf (stderr, " %u lines.\n", lines->size ());       |       fprintf (stderr, " %u lines.\n", lines[a - 1]->size ())
>       fileLines.push_back (lines);                            <
>     } else {                                                        } else {
>       fprintf (stderr, "%s: Unable to open %s!  Ignoring....\         fprintf (stderr, "%s: Unable to open %s!  Ignoring....\
>     }                                                               }
>   }                                                               }
>   printf ("# table.size () = %d\n", table.size ());               printf ("# table.size () = %d\n", table.size ());
>   map<int, int> counts;                                           map<int, int> counts;
>   for (map<string, int>::iterator i = table.begin (); i != ta     for (map<string, int>::iterator i = table.begin (); i != ta
>     counts[i->second] += 1;                                   |     Line *l = i->second;
>                                                               >     counts[l->counts[0].size () + l->counts[1].size ()] += 1;
>   }                                                               }
>   for (map<int, int>::iterator i = counts.begin (); i != coun     for (map<int, int>::iterator i = counts.begin (); i != coun
>     fprintf (stderr, "# counts[%d] = %d\n", i->first, i->seco       fprintf (stderr, "# counts[%d] = %d\n", i->first, i->seco
>   }                                                               }
>   for (int f = 0; f < fileLines.size (); f += 1) {            |   for (int f = 0; f < 2; f += 1) {
>     fprintf (stderr, "# file #%d\n", f);                      |     fprintf (stderr, "# file #%d\n", f + 1);
>     vector<int *> *lines = fileLines[f];                      |     for (int l = 0; l < lines[f].size (); l += 1) {
>     for (int l = 0; l < lines->size (); l += 1) {             |       fprintf (stderr, "#   [%d] = %d\n", l, lines[f][l]->cou
66,68c67,69
<     }								    }
<   }								  }
< }								}
---
>     }                                                               }
>   }                                                               }
> }                                                               }
# ../sdiff -y dif.2.cpp dif.1.cpp >& dif.2.1.diff-y.test
./test: line 46: 23522 Aborted                 (core dumped) ${DIFF} "${option}" "${oSrc}" "${nSrc}" 1>&"${dst}.test"
# dif.2.1.diff-y ---------------------------------------------------------------
1,68c1,17
< #include <string>						#include <string>
< using std::string;						using std::string;
< #include <list>						      <
< using std::list;					      <
< #include <map>							#include <map>
< using std::map;							using std::map;
< #include <vector>						#include <vector>
< using std::vector;						using std::vector;
< #include <stdio.h>						#include <stdio.h>
< 
< struct Line : public string {				      <
<   Line (string _text) :					      <
<     text (_text)					      <
<   {							      <
<   }							      <
<   string text;						      <
<   list<unsigned> counts[2];				      <
< };							      <
< 							      <
< typedef map<string, Line *> MapStringToLinePtr;		      <
< typedef vector<Line *> VectorLinePtr;			      <
< 							      <
< int main (int argc, char *argv[])				int main (int argc, char *argv[])
< {								{
<   MapStringToLinePtr table;				      |	  map<string, int> table;
<   VectorLinePtr lines[2];				      |	  vector<vector<int *> *> fileLines;
< 
<   for (int a = 1; a < argc && a <= 2; a += 1) {		      |	  for (int a = 1; a < argc; a += 1) {
<     if (FILE *f = fopen (argv[a], "r")) {			    if (FILE *f = fopen (argv[a], "r")) {
<       fprintf (stderr, "# Reading %s...", argv[a]);		      fprintf (stderr, "# Reading %s...", argv[a]);
< 							      >	      vector<int *> *lines = new vector<int *> ();
< 
<       VectorLinePtr *lines = new VectorLinePtr ();	      <
<       char buffer[1024];					      char buffer[1024];
<       while (fgets (buffer, sizeof (buffer), f)) {		      while (fgets (buffer, sizeof (buffer), f)) {
<         string text (buffer);				      |	        int *line = &table[buffer];
< 							      |	        lines->push_back (line);
<         Line *line = table[text];			      |	        *line += 1;
< 							      <
<         if (!line) {					      <
<           table[text] = line = new Line (text);		      <
<         }						      <
<         line->counts[a - 1].push_back (lines[a - 1].size ()); <
<         lines[a - 1].push_back (line);			      <
<       }								      }
<       fprintf (stderr, " %u lines.\n", lines[a - 1]->size ()) |	      fprintf (stderr, " %u lines.\n", lines->size ());
< 							      >	      fileLines.push_back (lines);
<     } else {							    } else {
<       fprintf (stderr, "%s: Unable to open %s!  Ignoring....\	      fprintf (stderr, "%s: Unable to open %s!  Ignoring....\
<     }								    }
<   }								  }
<   printf ("# table.size () = %d\n", table.size ());		  printf ("# table.size () = %d\n", table.size ());
<   map<int, int> counts;						  map<int, int> counts;
<   for (map<string, int>::iterator i = table.begin (); i != ta	  for (map<string, int>::iterator i = table.begin (); i != ta
<     Line *l = i->second;				      |	    counts[i->second] += 1;
<     counts[l->counts[0].size () + l->counts[1].size ()] += 1; <
<   }								  }
<   for (map<int, int>::iterator i = counts.begin (); i != coun	  for (map<int, int>::iterator i = counts.begin (); i != coun
<     fprintf (stderr, "# counts[%d] = %d\n", i->first, i->seco	    fprintf (stderr, "# counts[%d] = %d\n", i->first, i->seco
<   }								  }
<   for (int f = 0; f < 2; f += 1) {			      |	  for (int f = 0; f < fileLines.size (); f += 1) {
<     fprintf (stderr, "# file #%d\n", f + 1);		      |	    fprintf (stderr, "# file #%d\n", f);
<     for (int l = 0; l < lines[f].size (); l += 1) {	      |	    vector<int *> *lines = fileLines[f];
<       fprintf (stderr, "#   [%d] = %d\n", l, lines[f][l]->cou |	    for (int l = 0; l < lines->size (); l += 1) {
< 							      >	      fprintf (stderr, "#   [%d] = %d\n", l, *(*lines)[l]);
<     }								    }
<   }								  }
< }								}
---
> sdiff: sdiff.cpp:1858: void pass6y(): Assertion `lines[0][o].line == lines[1][n].line' failed.
> #include <string>                                               #include <string>
> using std::string;                                              using std::string;
> #include <list>                                               <
> using std::list;                                              <
> #include <map>                                                  #include <map>
> using std::map;                                                 using std::map;
> #include <vector>                                               #include <vector>
> using std::vector;                                              using std::vector;
> #include <stdio.h>                                              #include <stdio.h>
>                                                               > 
>                                                               > int main (int argc, char *argv[])
>                                                               > {
>                                                               >   map<string, int> table;
>                                                               >   vector<vector<int *> *> fileLines;
>                                                               > 
>                                                               >   for (int a = 1; a < argc; a += 1) {
# ../sdiff -y dif.2.cpp dif.3.cpp >& dif.2.3.diff-y.test
# dif.2.3.diff-y ---------------------------------------------------------------
1,749c1,770
< 							      >	#include <algorithm>
< 							      >	using std::find;
< #include <string>						#include <string>
< using std::string;						using std::string;
< #include <list>							#include <list>
< using std::list;						using std::list;
< #include <map>							#include <map>
< using std::map;							using std::map;
< #include <vector>						#include <vector>
< using std::vector;						using std::vector;
< #include <stdio.h>						#include <stdio.h>
< 
< 							      >	enum DiffFormat {
< 							      >	  Default,
< 							      >
< 							      >	  Context,
< 							      >	  EdScript,
< 							      >	  IfThenElse,
< 							      >	  Normal,
< 							      >	  RCS,
< 							      >	  SideBySide,
< 							      >	  Unified
< 							      >	};
< 							      >
< 							      >	DiffFormat diffFormat = Unified;
< 							      >
< 							      >	int optVerbose = 1;
< 							      >
< struct Line : public string {					struct Line : public string {
<   Line (string _text) :						  Line (string _text) :
<     text (_text)					      |	    string (_text)
<   {								  {
<   }								  }
<   string text;						      |	  ~Line () {
<   list<unsigned> counts[2];				      |	    copies[0].erase (copies[0].begin (), copies[0].end ());
< 							      >	    copies[1].erase (copies[1].begin (), copies[1].end ());
< 							      >	  }
< 							      >	  void Dump (FILE *out) {
< 							      >	    fprintf (out, "{{ ");
< 							      >	    for (list<unsigned>::iterator i = copies[0].begin (); i !
< 							      >	      fprintf (out, "%u ", *i);
< 							      >	    }
< 							      >	    fprintf (out, "},{ ");
< 							      >	    for (list<unsigned>::iterator i = copies[1].begin (); i !
< 							      >	      fprintf (out, "%u ", *i);
< 							      >	    }
< 							      >	    fprintf (out, "}}\t%s", c_str ());
< 							      >	  }
< 							      >	  list<unsigned> copies[2];
< 							      >	};
< 							      >
< 							      >	struct LinePtr {
< 							      >	  LinePtr (Line *_line) :
< 							      >	    line (_line),
< 							      >	    l (~0u)
< 							      >	  {
< 							      >	  }
< 							      >	  void Dump (FILE *out) {
< 							      >	    fprintf (out, "[%d] ", l);
< 							      >	    line->Dump (out);
< 							      >	  }
< 							      >	  Line *line;
< 							      >	  unsigned l;
< };								};
< 
< typedef map<string, Line *> MapStringToLinePtr;			typedef map<string, Line *> MapStringToLinePtr;
< typedef vector<Line *> VectorLinePtr;			      |	typedef vector<LinePtr> VectorLinePtr;
< 							      >
< 							      >	char *ARGV0 = "dif2";
< 
< int main (int argc, char *argv[])				int main (int argc, char *argv[])
< {								{
< 							      >	  char const *files[2] = { 0, 0 };
< 							      >
<   MapStringToLinePtr table;					  MapStringToLinePtr table;
<   VectorLinePtr lines[2];					  VectorLinePtr lines[2];
< 
<   for (int a = 1; a < argc && a <= 2; a += 1) {		      |	  unsigned nTotalMatchedBlocks = 0;
<     if (FILE *f = fopen (argv[a], "r")) {		      |	  unsigned nMatchedBlocks = 0;
<       fprintf (stderr, "# Reading %s...", argv[a]);	      |	  unsigned nTotalMatchedLines = 0;
< 							      >	  unsigned nMatchedLines = 0;
< 							      >
< 							      >	  // Read the old [0] file, and the new [1] file.
< 							      >
< 							      >	  for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
< 							      >	    files[n] = argv[a];
< 							      >
< 							      >	    if (FILE *f = fopen (files[n], "r")) {
< 							      >	      if (0 < optVerbose) {
< 							      >	        fprintf (stderr, "# Reading %s...", files[n]);
< 							      >	      }
< 
<       VectorLinePtr *lines = new VectorLinePtr ();	      <
<       char buffer[1024];					      char buffer[1024];
< 							      >	      unsigned nUniq = 0;
< 							      >
<       while (fgets (buffer, sizeof (buffer), f)) {		      while (fgets (buffer, sizeof (buffer), f)) {
<         string text (buffer);					        string text (buffer);
< 
<         Line *line = table[text];				        Line *line = table[text];
< 
<         if (!line) {						        if (!line) {
<           table[text] = line = new Line (text);			          table[text] = line = new Line (text);
< 							      >	          nUniq += 1;
<         }							        }
<         line->counts[a - 1].push_back (lines[a - 1].size ()); |	        line->copies[n].push_back (lines[n].size ());
<         lines[a - 1].push_back (line);			      |	        lines[n].push_back (line);
< 							      >	      }
< 							      >
< 							      >	      if (0 < optVerbose) {
< 							      >	        fprintf (stderr, " %u lines, %u unique.\n", lines[n].
<       }								      }
<       fprintf (stderr, " %u lines.\n", lines[a - 1]->size ()) <
<     } else {							    } else {
<       fprintf (stderr, "%s: Unable to open %s!  Ignoring....\ |	      fprintf (stderr, "%s: Unable to open %s!  Exiting....\n
< 							      >	      perror (ARGV0);
< 							      >	      exit (1);
<     }								    }
<   }								  }
<   printf ("# table.size () = %d\n", table.size ());	      |
<   map<int, int> counts;					      |	  if (0 < optVerbose) {
<   for (map<string, int>::iterator i = table.begin (); i != ta |	    printf ("# Total unique lines = %d\n", table.size ());
< 							      >	  }
< 							      >
< 							      >	  // map<int, int> counts;
< 							      >	  // for (MapStringToLinePtr::iterator i = table.begin (); i 
< 							      >	  //   Line *l = i->second;
< 							      >	  //   counts[l->counts[0].size () + l->counts[1].size ()] +=
< 							      >	  // }
< 							      >	  // for (map<int, int>::iterator i = counts.begin (); i != c
< 							      >	  //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s
< 							      >	  // }
< 							      >
< 							      >	  // Perform pass #1, in which we find all explicit matches a
< 							      >	  // the unique lines.  For every unique line that appears th
< 							      >	  // number of times in both files, we declare the lines to m
< 							      >
< 							      >	  if (0 < optVerbose) {
< 							      >	    fprintf (stderr, "# Pass 1 (finding matches amongst uniqu
< 							      >	  }
< 							      >
< 							      >	  nMatchedLines = 0;
< 							      >
< 							      >	  for (MapStringToLinePtr::iterator i = table.begin (); i != 
<     Line *l = i->second;					    Line *l = i->second;
<     counts[l->counts[0].size () + l->counts[1].size ()] += 1; |
< 							      >	    // If the number of old and new lines match, then we decl
< 							      >	    // they are (all) the same line.  Note, it isn't possible
< 							      >	    // numbers of both files to be 0.
< 							      >
< 							      >	    // (In the original algorithm, we only recognized a match
< 							      >	    // if there was exactly 1 copy for each file.)
< 							      >
< 							      >	    if (l->copies[0].size () == l->copies[1].size ()) {
< 							      >	      nMatchedLines += 1;
< 							      >
< 							      >	      // For each matched line in the new file, mark it with 
< 							      >	      // corresponding line (number) in the old file.
< 							      >
< 							      >	      while (!l->copies[0].empty ()) {
< 							      >	        unsigned o = l->copies[0].front ();
< 							      >	        unsigned n = l->copies[1].front ();
< 							      >
< 							      >	        // Match up the pair.
< 							      >
< 							      >	        lines[0][o].l = n;
< 							      >	        lines[1][n].l = o;
< 							      >
< 							      >	        // Remove the matched line numbers from the lists.
< 							      >
< 							      >	        l->copies[0].pop_front ();
< 							      >	        l->copies[1].pop_front ();
< 							      >	      }
< 							      >	    }
< 							      >	  }
< 							      >	  nTotalMatchedLines += nMatchedLines;
< 							      >
< 							      >	  // Let's see the intermediate results.
< 							      >
< 							      >	  if (0 < optVerbose) {
< 							      >	    fprintf (stderr, " found %u matched lines (%u total).\n",
< 							      >
< 							      >	    if (1 < optVerbose) {
< 							      >	      for (int f = 0; f < 2; f += 1) {
< 							      >	        fprintf (stderr, "# file #%d\n", f + 1);
< 							      >	        for (int l = 0; l < lines[f].size (); l += 1) {
< 							      >	          fprintf (stderr, "#   [%d] ", l);
< 							      >	          lines[f][l].Dump (stderr);
< 							      >	        }
< 							      >	      }
< 							      >	    }
< 							      >	  }
< 							      >
< 							      >	  // Perform Pass #2, in which we attempt to 'widen' blocks o
< 							      >	  // lines, by appending lines which are the same in both fil
< 							      >
< 							      >	  if (0 < optVerbose) {
< 							      >	    fprintf (stderr, "# Pass #2 (spreading matches down)...")
< 							      >	  }
< 							      >
< 							      >	  nMatchedBlocks = 0;
< 							      >	  nMatchedLines = 0;
< 							      >
< 							      >	  // Starting at the top of the old file,...
< 							      >
< 							      >	  for (unsigned o = 0; o < lines[0].size (); o += 1) {
< 							      >
< 							      >	    // ... skip any currently unmatched lines...
< 							      >
< 							      >	    if (lines[0][o].l == ~0) {
< 							      >	      continue;
< 							      >	    }
< 							      >
< 							      >	    // ... until we find an [already] matched line.  Then, sk
< 							      >	    // the set of 1 or more matched lines, until we reach any
< 							      >	    // following, still-unmatched line.
< 							      >
< 							      >	    unsigned n;
< 							      >	    do {
< 							      >	      n = lines[0][o].l + 1;
< 							      >	      o += 1;
< 							      >	    } while (o < lines[0].size () && lines[0][o].l != ~0);
< 							      >
< 							      >	    // Now, o - 1 is the line number of the last matched old 
< 							      >	    // n - 1 is the line number of the last matched new line.
< 							      >	    // to add new old and new lines, if they match.
< 							      >
< 							      >	    // Finally, attempt to add unmatched lines to the preceed
< 							      >	    // matched set.
< 							      >
< 							      >	    for (; o < lines[0].size () && lines[0][o].l == ~0; o += 
< 							      >
< 							      >	      // If the [next] pair of old and new lines aren't the s
< 							      >
< 							      >	      if (lines[0][o].line != lines[1][n].line) {
< 							      >	        break;
< 							      >	      }
< 							      >
< 							      >	      // Match up the pair.
< 							      >
< 							      >	      lines[0][o].l = n;
< 							      >	      lines[1][n].l = o;
< 							      >
< 							      >	      // Remove the matched line numbers form the lists.
< 							      >
< 							      >	      Line *line = lines[0][o].line;
< 							      >	      list<unsigned> &oldCopies = line->copies[0];
< 							      >	      list<unsigned>::iterator oL = find (oldCopies.begin (),
< 							      >	      if (oL != oldCopies.end ()) {
< 							      >	        oldCopies.erase (oL);
< 							      >	      }
< 							      >	      list<unsigned> &newCopies = line->copies[0];
< 							      >	      list<unsigned>::iterator nL = find (newCopies.begin (),
< 							      >	      if (nL != newCopies.end ()) {
< 							      >	        newCopies.erase (nL);
< 							      >	      }
< 							      >
< 							      >	      nMatchedLines += 1;
< 							      >	    }
< 							      >	    nMatchedBlocks += 1;
< 							      >	  }
< 							      >	  nTotalMatchedLines += nMatchedLines;
< 							      >	  nTotalMatchedBlocks += nMatchedBlocks;
< 							      >
< 							      >	  // Let's see the intermediate results.
< 							      >
< 							      >	  if (0 < optVerbose) {
< 							      >	    fprintf (stderr,
< 							      >	             " found %u/%u matched lines/blocks (%u/%u totals
< 							      >	             nMatchedLines,
< 							      >	             nMatchedBlocks,
< 							      >	             nTotalMatchedLines,
< 							      >	             nTotalMatchedBlocks
< 							      >	            );
< 							      >	    if (1 < optVerbose) {
< 							      >	      for (int f = 0; f < 2; f += 1) {
< 							      >	        fprintf (stderr, "# file #%d\n", f + 1);
< 							      >	        for (int l = 0; l < lines[f].size (); l += 1) {
< 							      >	          fprintf (stderr, "#   [%d] ", l);
< 							      >	          lines[f][l].Dump (stderr);
< 							      >	        }
< 							      >	      }
< 							      >	    }
<   }								  }
<   for (map<int, int>::iterator i = counts.begin (); i != coun |
<     fprintf (stderr, "# counts[%d] = %d\n", i->first, i->seco |	  // Perform Pass #3, in which we attempt to 'widen' blocks o
< 							      >	  // lines, by prepending lines which are the same in both fi
< 							      >
< 							      >	  if (0 < optVerbose) {
< 							      >	    fprintf (stderr, "# Pass #3 (spreading matches up)...");
<   }								  }
<   for (int f = 0; f < 2; f += 1) {			      |
<     fprintf (stderr, "# file #%d\n", f + 1);		      |	  nMatchedBlocks = 0;
<     for (int l = 0; l < lines[f].size (); l += 1) {	      |	  nMatchedLines = 0;
<       fprintf (stderr, "#   [%d] = %d\n", l, lines[f][l]->cou |
< 							      >	  // Starting at the bottom of the old file,...
< 							      >
< 							      >	  for (int o = lines[0].size (); 0 <= o; o -= 1) {
< 							      >
< 							      >	    // ... skip any currently unmatched lines...
< 							      >
< 							      >	    if (lines[0][o].l == ~0) {
< 							      >	      continue;
< 							      >	    }
< 							      >
< 							      >	    // ... until we find an [already] matched line.  Then, sk
< 							      >	    // the set of 1 or more matched lines, until we reach any
< 							      >	    // following, still-unmatched line.
< 							      >
< 							      >	    unsigned n;
< 							      >	    do {
< 							      >	      n = lines[0][o].l - 1;
< 							      >	      o -= 1;
< 							      >	    } while (0 <= o && lines[0][o].l != ~0);
< 							      >
< 							      >	    // Now, o + 1 is the line number of the last matched old 
< 							      >	    // n + 1 is the line number of the last matched new line.
< 							      >	    // to add new old and new lines, if they match.
< 							      >
< 							      >	    // Finally, attempt to add unmatched lines to the preceed
< 							      >	    // matched set.
< 							      >
< 							      >	    for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
< 							      >
< 							      >	      // If the [next] pair of old and new lines aren't the s
< 							      >
< 							      >	      if (lines[0][o].line != lines[1][n].line) {
< 							      >	        break;
< 							      >	      }
< 							      >
< 							      >	      // Match up the pair.
< 							      >
< 							      >	      lines[0][o].l = n;
< 							      >	      lines[1][n].l = o;
< 							      >
< 							      >	      // Remove the matched line numbers form the lists.
< 							      >
< 							      >	      Line *line = lines[0][o].line;
< 							      >	      list<unsigned> &oldCopies = line->copies[0];
< 							      >	      list<unsigned>::iterator oL = find (oldCopies.begin (),
< 							      >	      if (oL != oldCopies.end ()) {
< 							      >	        oldCopies.erase (oL);
< 							      >	      }
< 							      >	      list<unsigned> &newCopies = line->copies[0];
< 							      >	      list<unsigned>::iterator nL = find (newCopies.begin (),
< 							      >	      if (nL != newCopies.end ()) {
< 							      >	        newCopies.erase (nL);
< 							      >	      }
< 							      >
< 							      >	      nMatchedLines += 1;
< 							      >	    }
< 							      >	    nMatchedBlocks += 1;
< 							      >	  }
< 							      >	  nTotalMatchedLines += nMatchedLines;
< 							      >
< 							      >	  // Let's see the intermediate results.
< 							      >
< 							      >	  if (0 < optVerbose) {
< 							      >	    fprintf (stderr,
< 							      >	             " found %u/%u matched lines/blocks (%u/%u totals
< 							      >	             nMatchedLines,
< 							      >	             nMatchedBlocks,
< 							      >	             nTotalMatchedLines,
< 							      >	             nTotalMatchedBlocks
< 							      >	            );
< 							      >
< 							      >	    if (1 < optVerbose) {
< 							      >	      for (int f = 0; f < 2; f += 1) {
< 							      >	        fprintf (stderr, "# file #%d\n", f + 1);
< 							      >	        for (int l = 0; l < lines[f].size (); l += 1) {
< 							      >	          fprintf (stderr, "#   [%d] ", l);
< 							      >	          lines[f][l].Dump (stderr);
< 							      >	        }
< 							      >	      }
< 							      >	    }
< 							      >	  }
< 							      >
< 							      >	  // Perform pass #4, in which we find any remaining matches 
< 							      >	  // the unique lines.  For every unique line that has more t
< 							      >	  // copy in both files, we declare the copies to match.
< 							      >
< 							      >	  if (0 < optVerbose) {
< 							      >	    fprintf (stderr, "# Pass 4 (finding remaining matches amo
< 							      >	  }
< 							      >
< 							      >	  nMatchedLines = 0;
< 							      >
< 							      >	  for (MapStringToLinePtr::iterator i = table.begin (); i != 
< 							      >	    Line *l = i->second;
< 							      >
< 							      >	    // If there's more than 1 matching old and new lines, the
< 							      >	    // declare that each pair are (all) the same line.
< 							      >
< 							      >	    // (In the original algorithm, we only recognized a match
< 							      >	    // if there was exactly 1 copy for each file.)
< 							      >
< 							      >	    while (0 < l->copies[0].size () && 0 < l->copies[1].size 
< 							      >	      nMatchedLines += 1;
< 							      >
< 							      >	      // For each matched line in the new file, mark it with 
< 							      >	      // corresponding line (number) in the old file.
< 							      >
< 							      >	      unsigned o = l->copies[0].front ();
< 							      >	      unsigned n = l->copies[1].front ();
< 							      >
< 							      >	      // Match up the pair.
< 							      >
< 							      >	      lines[0][o].l = n;
< 							      >	      lines[1][n].l = o;
< 							      >
< 							      >	      // Remove the matched line numbers from the lists.
< 							      >
< 							      >	      l->copies[0].pop_front ();
< 							      >	      l->copies[1].pop_front ();
< 							      >	    }
< 							      >	  }
< 							      >	  nTotalMatchedLines += nMatchedLines;
< 							      >
< 							      >	  // Let's see the intermediate results.
< 							      >
< 							      >	  if (0 < optVerbose) {
< 							      >	    fprintf (stderr, " found %u matched lines (%u total).\n",
< 							      >
< 							      >	    if (1 < optVerbose) {
< 							      >	      for (int f = 0; f < 2; f += 1) {
< 							      >	        fprintf (stderr, "# file #%d\n", f + 1);
< 							      >	        for (int l = 0; l < lines[f].size (); l += 1) {
< 							      >	          fprintf (stderr, "#   [%d] ", l);
< 							      >	          lines[f][l].Dump (stderr);
< 							      >	        }
< 							      >	      }
< 							      >	    }
< 							      >	  }
< 							      >
< 							      >	  // Perform Pass #5, in which we look for blocks which match
< 							      >	  // the result of a move (their not in their original positi
< 							      >	  // these, we'll unmatch the blocks, turning them into a del
< 							      >	  // an insert.
< 							      >
< 							      >	  if (0 < optVerbose) {
< 							      >	    fprintf (stderr, "# Pass #5 (unmatching block moves)...\n
< 							      >	  }
< 							      >
< 							      >	  nMatchedBlocks = 0;
< 							      >	  nMatchedLines = 0;
< 							      >
< 							      >	  // Starting at the top of both files,...
< 							      >
< 							      >	  unsigned o = 0;
< 							      >	  unsigned n = 0;
< 							      >
< 							      >	  while (o < lines[0].size () || n < lines[1].size ()) {
< 							      >
< 							      >	    // Skip any unmatched lines at this point in the old file
< 							      >	    // are deletes.
< 							      >
< 							      >	    //    Old     New
< 							      >	    //   +---+
< 							      >	    // 0 | a |
< 							      >	    //   +---+   +---+
< 							      >	    //         0 | b |
< 							      >	    //   +---+   +---+
< 							      >	    // 1 | c | 1 | c |
< 							      >	    //   +---+   +---+
< 							      >	    //         2 | z |
< 							      >	    //   +---+   +---+
< 							      >	    // 2 | d | 3 | d |
< 							      >	    //   +---+   +---+
< 							      >
< 							      >	    while (o < lines[0].size () && lines[0][o].l == ~0) {
< 							      >	      o += 1;
< 							      >	    }
< 							      >
< 							      >	    // Skip any unmatched lines at this point in the new file
< 							      >	    // are inserts.
< 							      >
< 							      >	    while (n < lines[1].size () && lines[1][n].l == ~0) {
< 							      >	      n += 1;
< 							      >	    }
< 							      >
< 							      >	    // When we get here, we know that we're dealing with matc
< 							      >	    // lines (or the end of one or both files).  We're done w
< 							      >	    // pass, if we've reached the end of either file.
< 							      >
< 							      >	    if (lines[0].size () <= o || lines[1].size () <= n) {
< 							      >	      break;
< 							      >	    }
< 							      >
< 							      >	    // We now know that we've got a pair of matching lines, t
< 							      >	    // of a matching block.  If the new file's line number is
< 							      >	    // expect, then the matched pair is unmoved, and we can s
< 							      >	    // the pair.  (If this is really the start of a block of 
< 							      >	    // 1 lines, we'll handle it one pair at a time.)
< 							      >
< 							      >	    if (lines[0][o].l == n) {
< 							      >	      o += 1;
< 							      >	      n += 1;
< 							      >	      continue;
< 							      >	    }
< 							      >
< 							      >	    // If, on the other hand, we don't expect this [new] line
< 							      >	    // then this matching block has been moved.  We need to t
< 							      >	    // matched pair into an *unmatched* pair, one of deletes,
< 							      >	    // of inserts.  First, though, we need to know how big th
< 							      >	    // is, and how far it was moved....
< 							      >
< 							      >	    // Remember where we were when we started.
< 							      >
< 							      >	    unsigned oOld = o;
< 							      >	    unsigned nOld = n;
< 							      >
< 							      >	    // Remember where the block came from.
< 							      >
< 							      >	    unsigned nNew = lines[0][o].l;
< 							      >
< 							      >	    // Find the end of this matched pair.
< 							      >
< 							      >	    for (n = nNew; o < lines[0].size () && n < lines[1].size 
< 							      >	      if (lines[0][o].l != n) {
< 							      >	        break;
< 							      >	      }
< 							      >	    }
< 							      >
< 							      >	    // When we get here:
< 							      >	    // * oOld..o is the old file's block,
< 							      >	    // * nNew..n is the new file's *moved* block, and
< 							      >	    // * nOld is where we originally expected the new block f
< 							      >	 
< 							      >	    // We can now calculate the length of the block...
< 							      >	    
< 							      >	    unsigned bSize = o - oOld;  // (or n - nNew)
< 							      >
< 							      >	    // ... and we can calculate how far the block moved:
< 							      >
< 							      >	    unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
< 							      >
< 							      >	    // The larger of the two will become our delete, and the 
< 							      >	    // will become our insert.
< 							      >
< 							      >	    //    Old     New
< 							      >	    //   +---+   +---+
< 							      >	    // 0 | a | 0 | b |
< 							      >	    //   +---+ 1 | b |
< 							      >	    // 1 | b |   +---+
< 							      >	    // 2 | b | 2 | a |
< 							      >	    //   +---+   +---+
< 							      >	    // 3 | c | 3 | c |
< 							      >	    //   +---+   +---+
< 							      >
< 							      >	    // (1) Delete a@0, insert a@2, or
< 							      >	    // (2) insert bb@0, delete bb@1?
< 							      >
< 							      >	    // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and
< 							      >	    // (of a) is 2-0 or 2, the size of b@0.  We choose to del
< 							      >	    // and reinsert a@2.
< 							      >
< 							      >	    // if (bSize <= bMove) {
< 							      >	      for (unsigned a = oOld; a < o; a += 1) {
< 							      >	        lines[0][a].l = ~0;
< 							      >	      }
< 							      >	      for (unsigned d = nNew; d < n; d += 1) {
< 							      >	        lines[1][d].l = ~0;
< 							      >	      }
< 							      >	    // } else {
< 							      >	      // for (unsigned a = oOld; a < o; a += 1) {
< 							      >	      //   lines[0][a].l = ~0;
< 							      >	      // }
< 							      >	      // for (unsigned d = nNew; d < n; d += 1) {
< 							      >	      //   lines[1][d].l = ~0;
< 							      >	      // }
< 							      >	    // }
< 							      >
< 							      >	    // Continue from where we left off.
< 							      >
< 							      >	    n = nOld;
< 							      >	  }
< 							      >	  nTotalMatchedLines -= nMatchedLines;
< 							      >	  nTotalMatchedBlocks -= nMatchedBlocks;
< 							      >
< 							      >	  // Let's see the intermediate results.
< 							      >
< 							      >	  if (0 < optVerbose) {
< 							      >	    fprintf (stderr,
< 							      >	             " found %u/%u matched lines/blocks (%u/%u totals
< 							      >	             nMatchedLines,
< 							      >	             nMatchedBlocks,
< 							      >	             nTotalMatchedLines,
< 							      >	             nTotalMatchedBlocks
< 							      >	            );
< 							      >
< 							      >	    if (1 < optVerbose) {
< 							      >	      for (int f = 0; f < 2; f += 1) {
< 							      >	        fprintf (stderr, "# file #%d\n", f + 1);
< 							      >	        for (int l = 0; l < lines[f].size (); l += 1) {
< 							      >	          fprintf (stderr, "#   [%d] ", l);
< 							      >	          lines[f][l].Dump (stderr);
< 							      >	        }
< 							      >	      }
< 							      >	    }
< 							      >	  }
< 							      >
< 							      >	  // Perform Pass #6, in which we create the desired output.
< 							      >
< 							      >	  if (0 < optVerbose) {
< 							      >	    fprintf (stderr, "# Pass #6 (walking the differences)...\
< 							      >	  }
< 							      >
< 							      >	  nMatchedLines = 0;
< 							      >
< 							      >	  // Write the header.
< 							      >
< 							      >	  switch (diffFormat) {
< 							      >	  case Default:
< 							      >	  case Normal:
< 							      >	    break;
< 							      >	  case Unified:
< 							      >	    fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00
< 							      >	    fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00
< 							      >	    fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (),
< 							      >	    break;
< 							      >	  }
< 							      >
< 							      >	  // Starting at the top of both files,...
< 							      >
< 							      >	  o = 0;
< 							      >	  n = 0;
< 							      >
< 							      >	  while (o < lines[0].size () || n < lines[1].size ()) {
< 							      >
< 							      >	    // Find any unmatched lines at this point in the old file
< 							      >	    // are deletes.
< 							      >
< 							      >	    unsigned boDeletes;
< 							      >	    for (boDeletes = o;
< 							      >	         o < lines[0].size () && lines[0][o].l == ~0;
< 							      >	         o += 1
< 							      >	        )
< 							      >	    {}
< 							      >
< 							      >	    // Find any unmatched lines at this point in the new file
< 							      >	    // are inserts.
< 							      >
< 							      >	    unsigned boInserts;
< 							      >	    for (boInserts = n;
< 							      >	         n < lines[1].size () && lines[1][n].l == ~0;
< 							      >	         n += 1
< 							      >	        )
< 							      >	    {}
< 							      >
< 							      >	    // We've got deleted line(s) from boDeletes .. o.
< 							      >	    // We've got deleted line(s) from boInserts .. n.
< 							      >
< 							      >	    unsigned nDeletes = o - boDeletes;
< 							      >	    unsigned nInserts = n - boInserts;
< 							      >
< 							      >	    // We've got...
< 							      >
< 							      >	    if (nDeletes && nInserts) {
< 							      >
< 							      >	      // ... deletes and inserts.
< 							      >
< 							      >	      switch (diffFormat) {
< 							      >	      case Default:
< 							      >	      case Normal:
< 							      >	        if (1 < nDeletes && 1 < nInserts) {
< 							      >	          fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o,
< 							      >	        } else if (1 < nDeletes) {
< 							      >	          fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, bo
< 							      >	        } else if (1 < nInserts) {
< 							      >	          fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boIns
< 							      >	        } 
< 							      >	        for (unsigned l = boDeletes; l < o; l += 1) {
< 							      >	          fprintf (stdout, "< %s", lines[0][l].line->c_str ()
< 							      >	        }
< 							      >	        fprintf (stderr, "---\n");
< 							      >	        for (unsigned l = boInserts; l < n; l += 1) {
< 							      >	          fprintf (stdout, "> %s", lines[1][l].line->c_str ()
< 							      >	        }
< 							      >	        break;
< 							      >
< 							      >	      case Unified:
< 							      >	        for (unsigned l = boDeletes; l < o; l += 1) {
< 							      >	          fprintf (stdout, "-%s", lines[0][l].line->c_str ())
< 							      >	        }
< 							      >	        for (unsigned l = boInserts; l < n; l += 1) {
< 							      >	          fprintf (stdout, "+%s", lines[1][l].line->c_str ())
< 							      >	        }
< 							      >	        break;
< 							      >	      }
< 							      >	    } else if (nDeletes) {
< 							      >
< 							      >	      //  ... just deletes.
< 							      >
< 							      >	      switch (diffFormat) {
< 							      >	      case Default:
< 							      >	      case Normal:
< 							      >	        if (1 < nDeletes) {
< 							      >	          fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n)
< 							      >	        } else {
< 							      >	          fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
< 							      >	        }
< 							      >	        for (unsigned l = boDeletes; l < o; l += 1) {
< 							      >	          fprintf (stdout, "< %s", lines[0][l].line->c_str ()
< 							      >	        }
< 							      >	        break;
< 							      >	      case Unified:
< 							      >	        for (unsigned l = boDeletes; l < o; l += 1) {
< 							      >	          fprintf (stdout, "-%s", lines[0][l].line->c_str ())
< 							      >	        }
< 							      >	        break;
< 							      >	      }
< 							      >	    } else if (nInserts) {
< 							      >
< 							      >	      //  ... just inserts.
< 							      >
< 							      >	      switch (diffFormat) {
< 							      >	      case Default:
< 							      >	      case Normal:
< 							      >	        if (1 < nInserts) {
< 							      >	          fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n)
< 							      >	        } else {
< 							      >	          fprintf (stdout, "%da%d\n", o, boInserts + 1);
< 							      >	        }
< 							      >	        for (unsigned l = boInserts; l < n; l += 1) {
< 							      >	          fprintf (stdout, "> %s", lines[1][l].line->c_str ()
< 							      >	        }
< 							      >	        break;
< 							      >	      case Unified:
< 							      >	        for (unsigned l = boInserts; l < n; l += 1) {
< 							      >	          fprintf (stdout, "+%s", lines[1][l].line->c_str ())
< 							      >	        }
< 							      >	        break;
< 							      >	      }
< 							      >	    }
< 							      >
< 							      >	    // When we get here, we're dealing with matching lines.
< 							      >
< 							      >	    switch (diffFormat) {
< 							      >	    case Default:
< 							      >	    case Normal:
< 							      >	      break;
< 							      >	    case Unified:
< 							      >	      fprintf (stdout, " %s", lines[0][o].line->c_str ());
< 							      >	      break;
<     }								    }
< 							      >	    o += 1;
< 							      >	    n += 1;
<   }								  }
< }								}
---
>                                                               > #include <algorithm>
>                                                               > using std::find;
> #include <string>                                               #include <string>
> using std::string;                                              using std::string;
> #include <list>                                                 #include <list>
> using std::list;                                                using std::list;
> #include <map>                                                  #include <map>
> using std::map;                                                 using std::map;
> #include <vector>                                               #include <vector>
> using std::vector;                                              using std::vector;
> #include <stdio.h>                                              #include <stdio.h>
>                                                                 
> struct Line : public string {                                 | enum DiffFormat {
>   Line (string _text) :                                       |   Default,
>     text (_text)                                              <
>   {                                                           <
>   }                                                           <
>   string text;                                                <
>   list<unsigned> counts[2];                                   <
> };                                                            <
>                                                               <
> typedef map<string, Line *> MapStringToLinePtr;               <
> typedef vector<Line *> VectorLinePtr;                         <
>                                                               <
> int main (int argc, char *argv[])                             <
> {                                                             <
>   MapStringToLinePtr table;                                   <
>   VectorLinePtr lines[2];                                     <
>                                                               <
>   for (int a = 1; a < argc && a <= 2; a += 1) {               <
>     if (FILE *f = fopen (argv[a], "r")) {                     <
>       fprintf (stderr, "# Reading %s...", argv[a]);           <
>                                                                 
>       VectorLinePtr *lines = new VectorLinePtr ();            |   Context,
>       char buffer[1024];                                      |   EdScript,
>       while (fgets (buffer, sizeof (buffer), f)) {            |   IfThenElse,
>         string text (buffer);                                 |   Normal,
>                                                               |   RCS,
>         Line *line = table[text];                             |   SideBySide,
>                                                               |   Unified
>         if (!line) {                                          | };
>           table[text] = line = new Line (text);               | 
>         }                                                     | DiffFormat diffFormat = Unified;
>         line->counts[a - 1].push_back (lines[a - 1].size ()); | 
>         lines[a - 1].push_back (line);                        | int optVerbose = 1;
>       }                                                       | 
>       fprintf (stderr, " %u lines.\n", lines[a - 1]->size ()) | struct Line : public string {
>     } else {                                                  |   Line (string _text) :
>       fprintf (stderr, "%s: Unable to open %s!  Ignoring....\ |     string (_text)
>     }                                                         |   {
>                                                               >   }
>                                                               >   ~Line () {
>                                                               >     copies[0].erase (copies[0].begin (), copies[0].end ());
>                                                               >     copies[1].erase (copies[1].begin (), copies[1].end ());
>   }                                                               }
>   printf ("# table.size () = %d\n", table.size ());           |   void Dump (FILE *out) {
>   map<int, int> counts;                                       |     fprintf (out, "{{ ");
>   for (map<string, int>::iterator i = table.begin (); i != ta |     for (list<unsigned>::iterator i = copies[0].begin (); i !
>     Line *l = i->second;                                      |       fprintf (out, "%u ", *i);
>     counts[l->counts[0].size () + l->counts[1].size ()] += 1; |     }
>   }                                                           |     fprintf (out, "},{ ");
>   for (map<int, int>::iterator i = counts.begin (); i != coun |     for (list<unsigned>::iterator i = copies[1].begin (); i !
>     fprintf (stderr, "# counts[%d] = %d\n", i->first, i->seco |       fprintf (out, "%u ", *i);
>   }                                                           <
>   for (int f = 0; f < 2; f += 1) {                            <
>     fprintf (stderr, "# file #%d\n", f + 1);                  <
>     for (int l = 0; l < lines[f].size (); l += 1) {           <
>       fprintf (stderr, "#   [%d] = %d\n", l, lines[f][l]->cou <
>     }                                                               }
>                                                               >     fprintf (out, "}}\t%s", c_str ());
>                                                               >   }
>                                                               >   list<unsigned> copies[2];
>                                                               > };
>                                                               > 
>                                                               > struct LinePtr {
>                                                               >   LinePtr (Line *_line) :
>                                                               >     line (_line),
>                                                               >     l (~0u)
>                                                               >   {
>                                                               >   }
>                                                               >   void Dump (FILE *out) {
>                                                               >     fprintf (out, "[%d] ", l);
>                                                               >     line->Dump (out);
>                                                               >   }
>                                                               >   Line *line;
>                                                               >   unsigned l;
>                                                               > };
>                                                               > 
>                                                               > typedef map<string, Line *> MapStringToLinePtr;
>                                                               > typedef vector<LinePtr> VectorLinePtr;
>                                                               > 
>                                                               > char *ARGV0 = "dif2";
>                                                               > 
>                                                               > int main (int argc, char *argv[])
>                                                               > {
>                                                               >   char const *files[2] = { 0, 0 };
>                                                               > 
>                                                               >   MapStringToLinePtr table;
>                                                               >   VectorLinePtr lines[2];
>                                                               > 
>                                                               >   unsigned nTotalMatchedBlocks = 0;
>                                                               >   unsigned nMatchedBlocks = 0;
>                                                               >   unsigned nTotalMatchedLines = 0;
>                                                               >   unsigned nMatchedLines = 0;
>                                                               > 
>                                                               >   // Read the old [0] file, and the new [1] file.
>                                                               > 
>                                                               >   for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
>                                                               >     files[n] = argv[a];
>                                                               > 
>                                                               >     if (FILE *f = fopen (files[n], "r")) {
>                                                               >       if (0 < optVerbose) {
>                                                               >         fprintf (stderr, "# Reading %s...", files[n]);
>                                                               >       }
>                                                               > 
>                                                               >       char buffer[1024];
>                                                               >       unsigned nUniq = 0;
>                                                               > 
>                                                               >       while (fgets (buffer, sizeof (buffer), f)) {
>                                                               >         string text (buffer);
>                                                               > 
>                                                               >         Line *line = table[text];
>                                                               > 
>                                                               >         if (!line) {
>                                                               >           table[text] = line = new Line (text);
>                                                               >           nUniq += 1;
>                                                               >         }
>                                                               >         line->copies[n].push_back (lines[n].size ());
>                                                               >         lines[n].push_back (line);
>                                                               >       }
>                                                               > 
>                                                               >       if (0 < optVerbose) {
>                                                               >         fprintf (stderr, " %u lines, %u unique.\n", lines[n].
>                                                               >       }
>                                                               >     } else {
>                                                               >       fprintf (stderr, "%s: Unable to open %s!  Exiting....\n
>                                                               >       perror (ARGV0);
>                                                               >       exit (1);
>                                                               >     }
>                                                               >   }
>                                                               > 
>                                                               >   if (0 < optVerbose) {
>                                                               >     printf ("# Total unique lines = %d\n", table.size ());
>                                                               >   }
>                                                               > 
>                                                               >   // map<int, int> counts;
>                                                               >   // for (MapStringToLinePtr::iterator i = table.begin (); i 
>                                                               >   //   Line *l = i->second;
>                                                               >   //   counts[l->counts[0].size () + l->counts[1].size ()] +=
>                                                               >   // }
>                                                               >   // for (map<int, int>::iterator i = counts.begin (); i != c
>                                                               >   //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s
>                                                               >   // }
>                                                               > 
>                                                               >   // Perform pass #1, in which we find all explicit matches a
>                                                               >   // the unique lines.  For every unique line that appears th
>                                                               >   // number of times in both files, we declare the lines to m
>                                                               > 
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr, "# Pass 1 (finding matches amongst uniqu
>                                                               >   }
>                                                               > 
>                                                               >   nMatchedLines = 0;
>                                                               > 
>                                                               >   for (MapStringToLinePtr::iterator i = table.begin (); i != 
>                                                               >     Line *l = i->second;
>                                                               > 
>                                                               >     // If the number of old and new lines match, then we decl
>                                                               >     // they are (all) the same line.  Note, it isn't possible
>                                                               >     // numbers of both files to be 0.
>                                                               > 
>                                                               >     // (In the original algorithm, we only recognized a match
>                                                               >     // if there was exactly 1 copy for each file.)
>                                                               > 
>                                                               >     if (l->copies[0].size () == l->copies[1].size ()) {
>                                                               >       nMatchedLines += 1;
>                                                               > 
>                                                               >       // For each matched line in the new file, mark it with 
>                                                               >       // corresponding line (number) in the old file.
>                                                               > 
>                                                               >       while (!l->copies[0].empty ()) {
>                                                               >         unsigned o = l->copies[0].front ();
>                                                               >         unsigned n = l->copies[1].front ();
>                                                               > 
>                                                               >         // Match up the pair.
>                                                               > 
>                                                               >         lines[0][o].l = n;
>                                                               >         lines[1][n].l = o;
>                                                               > 
>                                                               >         // Remove the matched line numbers from the lists.
>                                                               > 
>                                                               >         l->copies[0].pop_front ();
>                                                               >         l->copies[1].pop_front ();
>                                                               >       }
>                                                               >     }
>                                                               >   }
>                                                               >   nTotalMatchedLines += nMatchedLines;
>                                                               > 
>                                                               >   // Let's see the intermediate results.
>                                                               > 
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr, " found %u matched lines (%u total).\n",
>                                                               > 
>                                                               >     if (1 < optVerbose) {
>                                                               >       for (int f = 0; f < 2; f += 1) {
>                                                               >         fprintf (stderr, "# file #%d\n", f + 1);
>                                                               >         for (int l = 0; l < lines[f].size (); l += 1) {
>                                                               >           fprintf (stderr, "#   [%d] ", l);
>                                                               >           lines[f][l].Dump (stderr);
>                                                               >         }
>                                                               >       }
>                                                               >     }
>                                                               >   }
>                                                               > 
>                                                               >   // Perform Pass #2, in which we attempt to 'widen' blocks o
>                                                               >   // lines, by appending lines which are the same in both fil
>                                                               > 
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr, "# Pass #2 (spreading matches down)...")
>                                                               >   }
>                                                               > 
>                                                               >   nMatchedBlocks = 0;
>                                                               >   nMatchedLines = 0;
>                                                               > 
>                                                               >   // Starting at the top of the old file,...
>                                                               > 
>                                                               >   for (unsigned o = 0; o < lines[0].size (); o += 1) {
>                                                               > 
>                                                               >     // ... skip any currently unmatched lines...
>                                                               > 
>                                                               >     if (lines[0][o].l == ~0) {
>                                                               >       continue;
>                                                               >     }
>                                                               > 
>                                                               >     // ... until we find an [already] matched line.  Then, sk
>                                                               >     // the set of 1 or more matched lines, until we reach any
>                                                               >     // following, still-unmatched line.
>                                                               > 
>                                                               >     unsigned n;
>                                                               >     do {
>                                                               >       n = lines[0][o].l + 1;
>                                                               >       o += 1;
>                                                               >     } while (o < lines[0].size () && lines[0][o].l != ~0);
>                                                               > 
>                                                               >     // Now, o - 1 is the line number of the last matched old 
>                                                               >     // n - 1 is the line number of the last matched new line.
>                                                               >     // to add new old and new lines, if they match.
>                                                               > 
>                                                               >     // Finally, attempt to add unmatched lines to the preceed
>                                                               >     // matched set.
>                                                               > 
>                                                               >     for (; o < lines[0].size () && lines[0][o].l == ~0; o += 
>                                                               > 
>                                                               >       // If the [next] pair of old and new lines aren't the s
>                                                               > 
>                                                               >       if (lines[0][o].line != lines[1][n].line) {
>                                                               >         break;
>                                                               >       }
>                                                               > 
>                                                               >       // Match up the pair.
>                                                               > 
>                                                               >       lines[0][o].l = n;
>                                                               >       lines[1][n].l = o;
>                                                               > 
>                                                               >       // Remove the matched line numbers form the lists.
>                                                               > 
>                                                               >       Line *line = lines[0][o].line;
>                                                               >       list<unsigned> &oldCopies = line->copies[0];
>                                                               >       list<unsigned>::iterator oL = find (oldCopies.begin (),
>                                                               >       if (oL != oldCopies.end ()) {
>                                                               >         oldCopies.erase (oL);
>                                                               >       }
>                                                               >       list<unsigned> &newCopies = line->copies[0];
>                                                               >       list<unsigned>::iterator nL = find (newCopies.begin (),
>                                                               >       if (nL != newCopies.end ()) {
>                                                               >         newCopies.erase (nL);
>                                                               >       }
>                                                               > 
>                                                               >       nMatchedLines += 1;
>                                                               >     }
>                                                               >     nMatchedBlocks += 1;
>                                                               >   }
>                                                               >   nTotalMatchedLines += nMatchedLines;
>                                                               >   nTotalMatchedBlocks += nMatchedBlocks;
>                                                               > 
>                                                               >   // Let's see the intermediate results.
>                                                               > 
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr,
>                                                               >              " found %u/%u matched lines/blocks (%u/%u totals
>                                                               >              nMatchedLines,
>                                                               >              nMatchedBlocks,
>                                                               >              nTotalMatchedLines,
>                                                               >              nTotalMatchedBlocks
>                                                               >             );
>                                                               >     if (1 < optVerbose) {
>                                                               >       for (int f = 0; f < 2; f += 1) {
>                                                               >         fprintf (stderr, "# file #%d\n", f + 1);
>                                                               >         for (int l = 0; l < lines[f].size (); l += 1) {
>                                                               >           fprintf (stderr, "#   [%d] ", l);
>                                                               >           lines[f][l].Dump (stderr);
>                                                               >         }
>                                                               >       }
>                                                               >     }
>                                                               >   }
>                                                               > 
>                                                               >   // Perform Pass #3, in which we attempt to 'widen' blocks o
>                                                               >   // lines, by prepending lines which are the same in both fi
>                                                               > 
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr, "# Pass #3 (spreading matches up)...");
>                                                               >   }
>                                                               > 
>                                                               >   nMatchedBlocks = 0;
>                                                               >   nMatchedLines = 0;
>                                                               > 
>                                                               >   // Starting at the bottom of the old file,...
>                                                               > 
>                                                               >   for (int o = lines[0].size (); 0 <= o; o -= 1) {
>                                                               > 
>                                                               >     // ... skip any currently unmatched lines...
>                                                               > 
>                                                               >     if (lines[0][o].l == ~0) {
>                                                               >       continue;
>                                                               >     }
>                                                               > 
>                                                               >     // ... until we find an [already] matched line.  Then, sk
>                                                               >     // the set of 1 or more matched lines, until we reach any
>                                                               >     // following, still-unmatched line.
>                                                               > 
>                                                               >     unsigned n;
>                                                               >     do {
>                                                               >       n = lines[0][o].l - 1;
>                                                               >       o -= 1;
>                                                               >     } while (0 <= o && lines[0][o].l != ~0);
>                                                               > 
>                                                               >     // Now, o + 1 is the line number of the last matched old 
>                                                               >     // n + 1 is the line number of the last matched new line.
>                                                               >     // to add new old and new lines, if they match.
>                                                               > 
>                                                               >     // Finally, attempt to add unmatched lines to the preceed
>                                                               >     // matched set.
>                                                               > 
>                                                               >     for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
>                                                               > 
>                                                               >       // If the [next] pair of old and new lines aren't the s
>                                                               > 
>                                                               >       if (lines[0][o].line != lines[1][n].line) {
>                                                               >         break;
>                                                               >       }
>                                                               > 
>                                                               >       // Match up the pair.
>                                                               > 
>                                                               >       lines[0][o].l = n;
>                                                               >       lines[1][n].l = o;
>                                                               > 
>                                                               >       // Remove the matched line numbers form the lists.
>                                                               > 
>                                                               >       Line *line = lines[0][o].line;
>                                                               >       list<unsigned> &oldCopies = line->copies[0];
>                                                               >       list<unsigned>::iterator oL = find (oldCopies.begin (),
>                                                               >       if (oL != oldCopies.end ()) {
>                                                               >         oldCopies.erase (oL);
>                                                               >       }
>                                                               >       list<unsigned> &newCopies = line->copies[0];
>                                                               >       list<unsigned>::iterator nL = find (newCopies.begin (),
>                                                               >       if (nL != newCopies.end ()) {
>                                                               >         newCopies.erase (nL);
>                                                               >       }
>                                                               > 
>                                                               >       nMatchedLines += 1;
>                                                               >     }
>                                                               >     nMatchedBlocks += 1;
>                                                               >   }
>                                                               >   nTotalMatchedLines += nMatchedLines;
>                                                               > 
>                                                               >   // Let's see the intermediate results.
>                                                               > 
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr,
>                                                               >              " found %u/%u matched lines/blocks (%u/%u totals
>                                                               >              nMatchedLines,
>                                                               >              nMatchedBlocks,
>                                                               >              nTotalMatchedLines,
>                                                               >              nTotalMatchedBlocks
>                                                               >             );
>                                                               > 
>                                                               >     if (1 < optVerbose) {
>                                                               >       for (int f = 0; f < 2; f += 1) {
>                                                               >         fprintf (stderr, "# file #%d\n", f + 1);
>                                                               >         for (int l = 0; l < lines[f].size (); l += 1) {
>                                                               >           fprintf (stderr, "#   [%d] ", l);
>                                                               >           lines[f][l].Dump (stderr);
>                                                               >         }
>                                                               >       }
>                                                               >     }
>                                                               >   }
>                                                               > 
>                                                               >   // Perform pass #4, in which we find any remaining matches 
>                                                               >   // the unique lines.  For every unique line that has more t
>                                                               >   // copy in both files, we declare the copies to match.
>                                                               > 
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr, "# Pass 4 (finding remaining matches amo
>                                                               >   }
>                                                               > 
>                                                               >   nMatchedLines = 0;
>                                                               > 
>                                                               >   for (MapStringToLinePtr::iterator i = table.begin (); i != 
>                                                               >     Line *l = i->second;
>                                                               > 
>                                                               >     // If there's more than 1 matching old and new lines, the
>                                                               >     // declare that each pair are (all) the same line.
>                                                               > 
>                                                               >     // (In the original algorithm, we only recognized a match
>                                                               >     // if there was exactly 1 copy for each file.)
>                                                               > 
>                                                               >     while (0 < l->copies[0].size () && 0 < l->copies[1].size 
>                                                               >       nMatchedLines += 1;
>                                                               > 
>                                                               >       // For each matched line in the new file, mark it with 
>                                                               >       // corresponding line (number) in the old file.
>                                                               > 
>                                                               >       unsigned o = l->copies[0].front ();
>                                                               >       unsigned n = l->copies[1].front ();
>                                                               > 
>                                                               >       // Match up the pair.
>                                                               > 
>                                                               >       lines[0][o].l = n;
>                                                               >       lines[1][n].l = o;
>                                                               > 
>                                                               >       // Remove the matched line numbers from the lists.
>                                                               > 
>                                                               >       l->copies[0].pop_front ();
>                                                               >       l->copies[1].pop_front ();
>                                                               >     }
>                                                               >   }
>                                                               >   nTotalMatchedLines += nMatchedLines;
>                                                               > 
>                                                               >   // Let's see the intermediate results.
>                                                               > 
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr, " found %u matched lines (%u total).\n",
>                                                               > 
>                                                               >     if (1 < optVerbose) {
>                                                               >       for (int f = 0; f < 2; f += 1) {
>                                                               >         fprintf (stderr, "# file #%d\n", f + 1);
>                                                               >         for (int l = 0; l < lines[f].size (); l += 1) {
>                                                               >           fprintf (stderr, "#   [%d] ", l);
>                                                               >           lines[f][l].Dump (stderr);
>                                                               >         }
>                                                               >       }
>                                                               >     }
>                                                               >   }
>                                                               > 
>                                                               >   // Perform Pass #5, in which we look for blocks which match
>                                                               >   // the result of a move (their not in their original positi
>                                                               >   // these, we'll unmatch the blocks, turning them into a del
>                                                               >   // an insert.
>                                                               > 
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr, "# Pass #5 (unmatching block moves)...\n
>                                                               >   }
>                                                               > 
>                                                               >   nMatchedBlocks = 0;
>                                                               >   nMatchedLines = 0;
>                                                               > 
>                                                               >   // Starting at the top of both files,...
>                                                               > 
>                                                               >   unsigned o = 0;
>                                                               >   unsigned n = 0;
>                                                               > 
>                                                               >   while (o < lines[0].size () || n < lines[1].size ()) {
>                                                               > 
>                                                               >     // Skip any unmatched lines at this point in the old file
>                                                               >     // are deletes.
>                                                               > 
>                                                               >     //    Old     New
>                                                               >     //   +---+
>                                                               >     // 0 | a |
>                                                               >     //   +---+   +---+
>                                                               >     //         0 | b |
>                                                               >     //   +---+   +---+
>                                                               >     // 1 | c | 1 | c |
>                                                               >     //   +---+   +---+
>                                                               >     //         2 | z |
>                                                               >     //   +---+   +---+
>                                                               >     // 2 | d | 3 | d |
>                                                               >     //   +---+   +---+
>                                                               > 
>                                                               >     while (o < lines[0].size () && lines[0][o].l == ~0) {
>                                                               >       o += 1;
>                                                               >     }
>                                                               > 
>                                                               >     // Skip any unmatched lines at this point in the new file
>                                                               >     // are inserts.
>                                                               > 
>                                                               >     while (n < lines[1].size () && lines[1][n].l == ~0) {
>                                                               >       n += 1;
>                                                               >     }
>                                                               > 
>                                                               >     // When we get here, we know that we're dealing with matc
>                                                               >     // lines (or the end of one or both files).  We're done w
>                                                               >     // pass, if we've reached the end of either file.
>                                                               > 
>                                                               >     if (lines[0].size () <= o || lines[1].size () <= n) {
>                                                               >       break;
>                                                               >     }
>                                                               > 
>                                                               >     // We now know that we've got a pair of matching lines, t
>                                                               >     // of a matching block.  If the new file's line number is
>                                                               >     // expect, then the matched pair is unmoved, and we can s
>                                                               >     // the pair.  (If this is really the start of a block of 
>                                                               >     // 1 lines, we'll handle it one pair at a time.)
>                                                               > 
>                                                               >     if (lines[0][o].l == n) {
>                                                               >       o += 1;
>                                                               >       n += 1;
>                                                               >       continue;
>                                                               >     }
>                                                               > 
>                                                               >     // If, on the other hand, we don't expect this [new] line
>                                                               >     // then this matching block has been moved.  We need to t
>                                                               >     // matched pair into an *unmatched* pair, one of deletes,
>                                                               >     // of inserts.  First, though, we need to know how big th
>                                                               >     // is, and how far it was moved....
>                                                               > 
>                                                               >     // Remember where we were when we started.
>                                                               > 
>                                                               >     unsigned oOld = o;
>                                                               >     unsigned nOld = n;
>                                                               > 
>                                                               >     // Remember where the block came from.
>                                                               > 
>                                                               >     unsigned nNew = lines[0][o].l;
>                                                               > 
>                                                               >     // Find the end of this matched pair.
>                                                               > 
>                                                               >     for (n = nNew; o < lines[0].size () && n < lines[1].size 
>                                                               >       if (lines[0][o].l != n) {
>                                                               >         break;
>                                                               >       }
>                                                               >     }
>                                                               > 
>                                                               >     // When we get here:
>                                                               >     // * oOld..o is the old file's block,
>                                                               >     // * nNew..n is the new file's *moved* block, and
>                                                               >     // * nOld is where we originally expected the new block f
>                                                               >  
>                                                               >     // We can now calculate the length of the block...
>                                                               >     
>                                                               >     unsigned bSize = o - oOld;  // (or n - nNew)
>                                                               > 
>                                                               >     // ... and we can calculate how far the block moved:
>                                                               > 
>                                                               >     unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
>                                                               > 
>                                                               >     // The larger of the two will become our delete, and the 
>                                                               >     // will become our insert.
>                                                               > 
>                                                               >     //    Old     New
>                                                               >     //   +---+   +---+
>                                                               >     // 0 | a | 0 | b |
>                                                               >     //   +---+ 1 | b |
>                                                               >     // 1 | b |   +---+
>                                                               >     // 2 | b | 2 | a |
>                                                               >     //   +---+   +---+
>                                                               >     // 3 | c | 3 | c |
>                                                               >     //   +---+   +---+
>                                                               > 
>                                                               >     // (1) Delete a@0, insert a@2, or
>                                                               >     // (2) insert bb@0, delete bb@1?
>                                                               > 
>                                                               >     // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and
>                                                               >     // (of a) is 2-0 or 2, the size of b@0.  We choose to del
>                                                               >     // and reinsert a@2.
>                                                               > 
>                                                               >     // if (bSize <= bMove) {
>                                                               >       for (unsigned a = oOld; a < o; a += 1) {
>                                                               >         lines[0][a].l = ~0;
>                                                               >       }
>                                                               >       for (unsigned d = nNew; d < n; d += 1) {
>                                                               >         lines[1][d].l = ~0;
>                                                               >       }
>                                                               >     // } else {
>                                                               >       // for (unsigned a = oOld; a < o; a += 1) {
>                                                               >       //   lines[0][a].l = ~0;
>                                                               >       // }
>                                                               >       // for (unsigned d = nNew; d < n; d += 1) {
>                                                               >       //   lines[1][d].l = ~0;
>                                                               >       // }
>                                                               >     // }
>                                                               > 
>                                                               >     // Continue from where we left off.
>                                                               > 
>                                                               >     n = nOld;
>                                                               >   }
>                                                               >   nTotalMatchedLines -= nMatchedLines;
>                                                               >   nTotalMatchedBlocks -= nMatchedBlocks;
>                                                               > 
>                                                               >   // Let's see the intermediate results.
>                                                               > 
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr,
>                                                               >              " found %u/%u matched lines/blocks (%u/%u totals
>                                                               >              nMatchedLines,
>                                                               >              nMatchedBlocks,
>                                                               >              nTotalMatchedLines,
>                                                               >              nTotalMatchedBlocks
>                                                               >             );
>                                                               > 
>                                                               >     if (1 < optVerbose) {
>                                                               >       for (int f = 0; f < 2; f += 1) {
>                                                               >         fprintf (stderr, "# file #%d\n", f + 1);
>                                                               >         for (int l = 0; l < lines[f].size (); l += 1) {
>                                                               >           fprintf (stderr, "#   [%d] ", l);
>                                                               >           lines[f][l].Dump (stderr);
>                                                               >         }
>                                                               >       }
>                                                               >     }
>                                                               >   }
>                                                               > 
>                                                               >   // Perform Pass #6, in which we create the desired output.
>                                                               > 
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr, "# Pass #6 (walking the differences)...\
>                                                               >   }
>                                                               > 
>                                                               >   nMatchedLines = 0;
>                                                               > 
>                                                               >   // Write the header.
>                                                               > 
>                                                               >   switch (diffFormat) {
>                                                               >   case Default:
>                                                               >   case Normal:
>                                                               >     break;
>                                                               >   case Unified:
>                                                               >     fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00
>                                                               >     fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00
>                                                               >     fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (),
>                                                               >     break;
>                                                               >   }
>                                                               > 
>                                                               >   // Starting at the top of both files,...
>                                                               > 
>                                                               >   o = 0;
>                                                               >   n = 0;
>                                                               > 
>                                                               >   while (o < lines[0].size () || n < lines[1].size ()) {
>                                                               > 
>                                                               >     // Find any unmatched lines at this point in the old file
>                                                               >     // are deletes.
>                                                               > 
>                                                               >     unsigned boDeletes;
>                                                               >     for (boDeletes = o;
>                                                               >          o < lines[0].size () && lines[0][o].l == ~0;
>                                                               >          o += 1
>                                                               >         )
>                                                               >     {}
>                                                               > 
>                                                               >     // Find any unmatched lines at this point in the new file
>                                                               >     // are inserts.
>                                                               > 
>                                                               >     unsigned boInserts;
>                                                               >     for (boInserts = n;
>                                                               >          n < lines[1].size () && lines[1][n].l == ~0;
>                                                               >          n += 1
>                                                               >         )
>                                                               >     {}
>                                                               > 
>                                                               >     // We've got deleted line(s) from boDeletes .. o.
>                                                               >     // We've got deleted line(s) from boInserts .. n.
>                                                               > 
>                                                               >     unsigned nDeletes = o - boDeletes;
>                                                               >     unsigned nInserts = n - boInserts;
>                                                               > 
>                                                               >     // We've got...
>                                                               > 
>                                                               >     if (nDeletes && nInserts) {
>                                                               > 
>                                                               >       // ... deletes and inserts.
>                                                               > 
>                                                               >       switch (diffFormat) {
>                                                               >       case Default:
>                                                               >       case Normal:
>                                                               >         if (1 < nDeletes && 1 < nInserts) {
>                                                               >           fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o,
>                                                               >         } else if (1 < nDeletes) {
>                                                               >           fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, bo
>                                                               >         } else if (1 < nInserts) {
>                                                               >           fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boIns
>                                                               >         } 
>                                                               >         for (unsigned l = boDeletes; l < o; l += 1) {
>                                                               >           fprintf (stdout, "< %s", lines[0][l].line->c_str ()
>                                                               >         }
>                                                               >         fprintf (stderr, "---\n");
>                                                               >         for (unsigned l = boInserts; l < n; l += 1) {
>                                                               >           fprintf (stdout, "> %s", lines[1][l].line->c_str ()
>                                                               >         }
>                                                               >         break;
>                                                               > 
>                                                               >       case Unified:
>                                                               >         for (unsigned l = boDeletes; l < o; l += 1) {
>                                                               >           fprintf (stdout, "-%s", lines[0][l].line->c_str ())
>                                                               >         }
>                                                               >         for (unsigned l = boInserts; l < n; l += 1) {
>                                                               >           fprintf (stdout, "+%s", lines[1][l].line->c_str ())
>                                                               >         }
>                                                               >         break;
>                                                               >       }
>                                                               >     } else if (nDeletes) {
>                                                               > 
>                                                               >       //  ... just deletes.
>                                                               > 
>                                                               >       switch (diffFormat) {
>                                                               >       case Default:
>                                                               >       case Normal:
>                                                               >         if (1 < nDeletes) {
>                                                               >           fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n)
>                                                               >         } else {
>                                                               >           fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
>                                                               >         }
>                                                               >         for (unsigned l = boDeletes; l < o; l += 1) {
>                                                               >           fprintf (stdout, "< %s", lines[0][l].line->c_str ()
>                                                               >         }
>                                                               >         break;
>                                                               >       case Unified:
>                                                               >         for (unsigned l = boDeletes; l < o; l += 1) {
>                                                               >           fprintf (stdout, "-%s", lines[0][l].line->c_str ())
>                                                               >         }
>                                                               >         break;
>                                                               >       }
>                                                               >     } else if (nInserts) {
>                                                               > 
>                                                               >       //  ... just inserts.
>                                                               > 
>                                                               >       switch (diffFormat) {
>                                                               >       case Default:
>                                                               >       case Normal:
>                                                               >         if (1 < nInserts) {
>                                                               >           fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n)
>                                                               >         } else {
>                                                               >           fprintf (stdout, "%da%d\n", o, boInserts + 1);
>                                                               >         }
>                                                               >         for (unsigned l = boInserts; l < n; l += 1) {
>                                                               >           fprintf (stdout, "> %s", lines[1][l].line->c_str ()
>                                                               >         }
>                                                               >         break;
>                                                               >       case Unified:
>                                                               >         for (unsigned l = boInserts; l < n; l += 1) {
>                                                               >           fprintf (stdout, "+%s", lines[1][l].line->c_str ())
>                                                               >         }
>                                                               >         break;
>                                                               >       }
>                                                               >     }
>                                                               > 
>                                                               >     // When we get here, we're dealing with matching lines.
>                                                               > 
>                                                               >     switch (diffFormat) {
>                                                               >     case Default:
>                                                               >     case Normal:
>                                                               >       break;
>                                                               >     case Unified:
>                                                               >       fprintf (stdout, " %s", lines[0][o].line->c_str ());
>                                                               >       break;
>                                                               >     }
>                                                               >     o += 1;
>                                                               >     n += 1;
>   }                                                               }
> }                                                               }
# ../sdiff -y dif.3.cpp dif.2.cpp >& dif.3.2.diff-y.test
./test: line 46: 23535 Aborted                 (core dumped) ${DIFF} "${option}" "${oSrc}" "${nSrc}" 1>&"${dst}.test"
# dif.3.2.diff-y ---------------------------------------------------------------
1,749c1,16
< #include <algorithm>					      <
< using std::find;					      <
< #include <string>						#include <string>
< using std::string;						using std::string;
< #include <list>							#include <list>
< using std::list;						using std::list;
< #include <map>							#include <map>
< using std::map;							using std::map;
< #include <vector>						#include <vector>
< using std::vector;						using std::vector;
< #include <stdio.h>						#include <stdio.h>
< 
< enum DiffFormat {					      <
<   Default,						      <
< 							      <
<   Context,						      <
<   EdScript,						      <
<   IfThenElse,						      <
<   Normal,						      <
<   RCS,							      <
<   SideBySide,						      <
<   Unified						      <
< };							      <
< 							      <
< DiffFormat diffFormat = Unified;			      <
< 							      <
< int optVerbose = 1;					      <
< 							      <
< struct Line : public string {					struct Line : public string {
<   Line (string _text) :						  Line (string _text) :
<     string (_text)					      |	    text (_text)
<   {								  {
<   }								  }
<   ~Line () {						      |	  string text;
<     copies[0].erase (copies[0].begin (), copies[0].end ());   |	  list<unsigned> counts[2];
<     copies[1].erase (copies[1].begin (), copies[1].end ());   <
<   }							      <
<   void Dump (FILE *out) {				      <
<     fprintf (out, "{{ ");				      <
<     for (list<unsigned>::iterator i = copies[0].begin (); i ! <
<       fprintf (out, "%u ", *i);				      <
<     }							      <
<     fprintf (out, "},{ ");				      <
<     for (list<unsigned>::iterator i = copies[1].begin (); i ! <
<       fprintf (out, "%u ", *i);				      <
<     }							      <
<     fprintf (out, "}}\t%s", c_str ());			      <
<   }							      <
<   list<unsigned> copies[2];				      <
< };							      <
< 							      <
< struct LinePtr {					      <
<   LinePtr (Line *_line) :				      <
<     line (_line),					      <
<     l (~0u)						      <
<   {							      <
<   }							      <
<   void Dump (FILE *out) {				      <
<     fprintf (out, "[%d] ", l);				      <
<     line->Dump (out);					      <
<   }							      <
<   Line *line;						      <
<   unsigned l;						      <
< };								};
< 
< typedef map<string, Line *> MapStringToLinePtr;			typedef map<string, Line *> MapStringToLinePtr;
< typedef vector<LinePtr> VectorLinePtr;			      |	typedef vector<Line *> VectorLinePtr;
< 							      <
< char *ARGV0 = "dif2";					      <
< 
< int main (int argc, char *argv[])				int main (int argc, char *argv[])
< {								{
<   char const *files[2] = { 0, 0 };			      <
< 							      <
<   MapStringToLinePtr table;					  MapStringToLinePtr table;
<   VectorLinePtr lines[2];					  VectorLinePtr lines[2];
< 
<   unsigned nTotalMatchedBlocks = 0;			      |	  for (int a = 1; a < argc && a <= 2; a += 1) {
<   unsigned nMatchedBlocks = 0;				      |	    if (FILE *f = fopen (argv[a], "r")) {
<   unsigned nTotalMatchedLines = 0;			      |	      fprintf (stderr, "# Reading %s...", argv[a]);
<   unsigned nMatchedLines = 0;				      <
< 							      <
<   // Read the old [0] file, and the new [1] file.	      <
< 							      <
<   for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) { <
<     files[n] = argv[a];					      <
< 							      <
<     if (FILE *f = fopen (files[n], "r")) {		      <
<       if (0 < optVerbose) {				      <
<         fprintf (stderr, "# Reading %s...", files[n]);	      <
<       }							      <
< 
< 							      >	      VectorLinePtr *lines = new VectorLinePtr ();
<       char buffer[1024];					      char buffer[1024];
<       unsigned nUniq = 0;				      <
< 							      <
<       while (fgets (buffer, sizeof (buffer), f)) {		      while (fgets (buffer, sizeof (buffer), f)) {
<         string text (buffer);					        string text (buffer);
< 
<         Line *line = table[text];				        Line *line = table[text];
< 
<         if (!line) {						        if (!line) {
<           table[text] = line = new Line (text);			          table[text] = line = new Line (text);
<           nUniq += 1;					      <
<         }							        }
<         line->copies[n].push_back (lines[n].size ());	      |	        line->counts[a - 1].push_back (lines[a - 1].size ());
<         lines[n].push_back (line);			      |	        lines[a - 1].push_back (line);
<       }							      <
< 							      <
<       if (0 < optVerbose) {				      <
<         fprintf (stderr, " %u lines, %u unique.\n", lines[n]. <
<       }								      }
< 							      >	      fprintf (stderr, " %u lines.\n", lines[a - 1]->size ())
<     } else {							    } else {
<       fprintf (stderr, "%s: Unable to open %s!  Exiting....\n |	      fprintf (stderr, "%s: Unable to open %s!  Ignoring....\
<       perror (ARGV0);					      <
<       exit (1);						      <
<     }								    }
<   }								  }
< 							      |	  printf ("# table.size () = %d\n", table.size ());
<   if (0 < optVerbose) {					      |	  map<int, int> counts;
<     printf ("# Total unique lines = %d\n", table.size ());    |	  for (map<string, int>::iterator i = table.begin (); i != ta
<   }							      <
< 							      <
<   // map<int, int> counts;				      <
<   // for (MapStringToLinePtr::iterator i = table.begin (); i  <
<   //   Line *l = i->second;				      <
<   //   counts[l->counts[0].size () + l->counts[1].size ()] += <
<   // }							      <
<   // for (map<int, int>::iterator i = counts.begin (); i != c <
<   //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s <
<   // }							      <
< 							      <
<   // Perform pass #1, in which we find all explicit matches a <
<   // the unique lines.  For every unique line that appears th <
<   // number of times in both files, we declare the lines to m <
< 							      <
<   if (0 < optVerbose) {					      <
<     fprintf (stderr, "# Pass 1 (finding matches amongst uniqu <
<   }							      <
< 							      <
<   nMatchedLines = 0;					      <
< 							      <
<   for (MapStringToLinePtr::iterator i = table.begin (); i !=  <
<     Line *l = i->second;					    Line *l = i->second;
< 							      |	    counts[l->counts[0].size () + l->counts[1].size ()] += 1;
<     // If the number of old and new lines match, then we decl <
<     // they are (all) the same line.  Note, it isn't possible <
<     // numbers of both files to be 0.			      <
< 							      <
<     // (In the original algorithm, we only recognized a match <
<     // if there was exactly 1 copy for each file.)	      <
< 							      <
<     if (l->copies[0].size () == l->copies[1].size ()) {	      <
<       nMatchedLines += 1;				      <
< 							      <
<       // For each matched line in the new file, mark it with  <
<       // corresponding line (number) in the old file.	      <
< 							      <
<       while (!l->copies[0].empty ()) {			      <
<         unsigned o = l->copies[0].front ();		      <
<         unsigned n = l->copies[1].front ();		      <
< 							      <
<         // Match up the pair.				      <
< 							      <
<         lines[0][o].l = n;				      <
<         lines[1][n].l = o;				      <
< 							      <
<         // Remove the matched line numbers from the lists.    <
< 							      <
<         l->copies[0].pop_front ();			      <
<         l->copies[1].pop_front ();			      <
<       }							      <
<     }							      <
<   }							      <
<   nTotalMatchedLines += nMatchedLines;			      <
< 							      <
<   // Let's see the intermediate results.		      <
< 							      <
<   if (0 < optVerbose) {					      <
<     fprintf (stderr, " found %u matched lines (%u total).\n", <
< 							      <
<     if (1 < optVerbose) {				      <
<       for (int f = 0; f < 2; f += 1) {			      <
<         fprintf (stderr, "# file #%d\n", f + 1);	      <
<         for (int l = 0; l < lines[f].size (); l += 1) {	      <
<           fprintf (stderr, "#   [%d] ", l);		      <
<           lines[f][l].Dump (stderr);			      <
<         }						      <
<       }							      <
<     }							      <
<   }							      <
< 							      <
<   // Perform Pass #2, in which we attempt to 'widen' blocks o <
<   // lines, by appending lines which are the same in both fil <
< 							      <
<   if (0 < optVerbose) {					      <
<     fprintf (stderr, "# Pass #2 (spreading matches down)...") <
<   }							      <
< 							      <
<   nMatchedBlocks = 0;					      <
<   nMatchedLines = 0;					      <
< 							      <
<   // Starting at the top of the old file,...		      <
< 							      <
<   for (unsigned o = 0; o < lines[0].size (); o += 1) {	      <
< 							      <
<     // ... skip any currently unmatched lines...	      <
< 							      <
<     if (lines[0][o].l == ~0) {				      <
<       continue;						      <
<     }							      <
< 							      <
<     // ... until we find an [already] matched line.  Then, sk <
<     // the set of 1 or more matched lines, until we reach any <
<     // following, still-unmatched line.			      <
< 							      <
<     unsigned n;						      <
<     do {						      <
<       n = lines[0][o].l + 1;				      <
<       o += 1;						      <
<     } while (o < lines[0].size () && lines[0][o].l != ~0);    <
< 							      <
<     // Now, o - 1 is the line number of the last matched old  <
<     // n - 1 is the line number of the last matched new line. <
<     // to add new old and new lines, if they match.	      <
< 							      <
<     // Finally, attempt to add unmatched lines to the preceed <
<     // matched set.					      <
< 							      <
<     for (; o < lines[0].size () && lines[0][o].l == ~0; o +=  <
< 							      <
<       // If the [next] pair of old and new lines aren't the s <
< 							      <
<       if (lines[0][o].line != lines[1][n].line) {	      <
<         break;						      <
<       }							      <
< 							      <
<       // Match up the pair.				      <
< 							      <
<       lines[0][o].l = n;				      <
<       lines[1][n].l = o;				      <
< 							      <
<       // Remove the matched line numbers form the lists.      <
< 							      <
<       Line *line = lines[0][o].line;			      <
<       list<unsigned> &oldCopies = line->copies[0];	      <
<       list<unsigned>::iterator oL = find (oldCopies.begin (), <
<       if (oL != oldCopies.end ()) {			      <
<         oldCopies.erase (oL);				      <
<       }							      <
<       list<unsigned> &newCopies = line->copies[0];	      <
<       list<unsigned>::iterator nL = find (newCopies.begin (), <
<       if (nL != newCopies.end ()) {			      <
<         newCopies.erase (nL);				      <
<       }							      <
< 							      <
<       nMatchedLines += 1;				      <
<     }							      <
<     nMatchedBlocks += 1;				      <
<   }							      <
<   nTotalMatchedLines += nMatchedLines;			      <
<   nTotalMatchedBlocks += nMatchedBlocks;		      <
< 							      <
<   // Let's see the intermediate results.		      <
< 							      <
<   if (0 < optVerbose) {					      <
<     fprintf (stderr,					      <
<              " found %u/%u matched lines/blocks (%u/%u totals <
<              nMatchedLines,				      <
<              nMatchedBlocks,				      <
<              nTotalMatchedLines,			      <
<              nTotalMatchedBlocks			      <
<             );						      <
<     if (1 < optVerbose) {				      <
<       for (int f = 0; f < 2; f += 1) {			      <
<         fprintf (stderr, "# file #%d\n", f + 1);	      <
<         for (int l = 0; l < lines[f].size (); l += 1) {	      <
<           fprintf (stderr, "#   [%d] ", l);		      <
<           lines[f][l].Dump (stderr);			      <
<         }						      <
<       }							      <
<     }							      <
<   }								  }
< 							      |	  for (map<int, int>::iterator i = counts.begin (); i != coun
<   // Perform Pass #3, in which we attempt to 'widen' blocks o |	    fprintf (stderr, "# counts[%d] = %d\n", i->first, i->seco
<   // lines, by prepending lines which are the same in both fi <
< 							      <
<   if (0 < optVerbose) {					      <
<     fprintf (stderr, "# Pass #3 (spreading matches up)...");  <
<   }								  }
< 							      |	  for (int f = 0; f < 2; f += 1) {
<   nMatchedBlocks = 0;					      |	    fprintf (stderr, "# file #%d\n", f + 1);
<   nMatchedLines = 0;					      |	    for (int l = 0; l < lines[f].size (); l += 1) {
< 							      |	      fprintf (stderr, "#   [%d] = %d\n", l, lines[f][l]->cou
<   // Starting at the bottom of the old file,...		      <
< 							      <
<   for (int o = lines[0].size (); 0 <= o; o -= 1) {	      <
< 							      <
<     // ... skip any currently unmatched lines...	      <
< 							      <
<     if (lines[0][o].l == ~0) {				      <
<       continue;						      <
<     }							      <
< 							      <
<     // ... until we find an [already] matched line.  Then, sk <
<     // the set of 1 or more matched lines, until we reach any <
<     // following, still-unmatched line.			      <
< 							      <
<     unsigned n;						      <
<     do {						      <
<       n = lines[0][o].l - 1;				      <
<       o -= 1;						      <
<     } while (0 <= o && lines[0][o].l != ~0);		      <
< 							      <
<     // Now, o + 1 is the line number of the last matched old  <
<     // n + 1 is the line number of the last matched new line. <
<     // to add new old and new lines, if they match.	      <
< 							      <
<     // Finally, attempt to add unmatched lines to the preceed <
<     // matched set.					      <
< 							      <
<     for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {   <
< 							      <
<       // If the [next] pair of old and new lines aren't the s <
< 							      <
<       if (lines[0][o].line != lines[1][n].line) {	      <
<         break;						      <
<       }							      <
< 							      <
<       // Match up the pair.				      <
< 							      <
<       lines[0][o].l = n;				      <
<       lines[1][n].l = o;				      <
< 							      <
<       // Remove the matched line numbers form the lists.      <
< 							      <
<       Line *line = lines[0][o].line;			      <
<       list<unsigned> &oldCopies = line->copies[0];	      <
<       list<unsigned>::iterator oL = find (oldCopies.begin (), <
<       if (oL != oldCopies.end ()) {			      <
<         oldCopies.erase (oL);				      <
<       }							      <
<       list<unsigned> &newCopies = line->copies[0];	      <
<       list<unsigned>::iterator nL = find (newCopies.begin (), <
<       if (nL != newCopies.end ()) {			      <
<         newCopies.erase (nL);				      <
<       }							      <
< 							      <
<       nMatchedLines += 1;				      <
<     }							      <
<     nMatchedBlocks += 1;				      <
<   }							      <
<   nTotalMatchedLines += nMatchedLines;			      <
< 							      <
<   // Let's see the intermediate results.		      <
< 							      <
<   if (0 < optVerbose) {					      <
<     fprintf (stderr,					      <
<              " found %u/%u matched lines/blocks (%u/%u totals <
<              nMatchedLines,				      <
<              nMatchedBlocks,				      <
<              nTotalMatchedLines,			      <
<              nTotalMatchedBlocks			      <
<             );						      <
< 							      <
<     if (1 < optVerbose) {				      <
<       for (int f = 0; f < 2; f += 1) {			      <
<         fprintf (stderr, "# file #%d\n", f + 1);	      <
<         for (int l = 0; l < lines[f].size (); l += 1) {	      <
<           fprintf (stderr, "#   [%d] ", l);		      <
<           lines[f][l].Dump (stderr);			      <
<         }						      <
<       }							      <
<     }							      <
<   }							      <
< 							      <
<   // Perform pass #4, in which we find any remaining matches  <
<   // the unique lines.  For every unique line that has more t <
<   // copy in both files, we declare the copies to match.      <
< 							      <
<   if (0 < optVerbose) {					      <
<     fprintf (stderr, "# Pass 4 (finding remaining matches amo <
<   }							      <
< 							      <
<   nMatchedLines = 0;					      <
< 							      <
<   for (MapStringToLinePtr::iterator i = table.begin (); i !=  <
<     Line *l = i->second;				      <
< 							      <
<     // If there's more than 1 matching old and new lines, the <
<     // declare that each pair are (all) the same line.	      <
< 							      <
<     // (In the original algorithm, we only recognized a match <
<     // if there was exactly 1 copy for each file.)	      <
< 							      <
<     while (0 < l->copies[0].size () && 0 < l->copies[1].size  <
<       nMatchedLines += 1;				      <
< 							      <
<       // For each matched line in the new file, mark it with  <
<       // corresponding line (number) in the old file.	      <
< 							      <
<       unsigned o = l->copies[0].front ();		      <
<       unsigned n = l->copies[1].front ();		      <
< 							      <
<       // Match up the pair.				      <
< 							      <
<       lines[0][o].l = n;				      <
<       lines[1][n].l = o;				      <
< 							      <
<       // Remove the matched line numbers from the lists.      <
< 							      <
<       l->copies[0].pop_front ();			      <
<       l->copies[1].pop_front ();			      <
<     }							      <
<   }							      <
<   nTotalMatchedLines += nMatchedLines;			      <
< 							      <
<   // Let's see the intermediate results.		      <
< 							      <
<   if (0 < optVerbose) {					      <
<     fprintf (stderr, " found %u matched lines (%u total).\n", <
< 							      <
<     if (1 < optVerbose) {				      <
<       for (int f = 0; f < 2; f += 1) {			      <
<         fprintf (stderr, "# file #%d\n", f + 1);	      <
<         for (int l = 0; l < lines[f].size (); l += 1) {	      <
<           fprintf (stderr, "#   [%d] ", l);		      <
<           lines[f][l].Dump (stderr);			      <
<         }						      <
<       }							      <
<     }							      <
<   }							      <
< 							      <
<   // Perform Pass #5, in which we look for blocks which match <
<   // the result of a move (their not in their original positi <
<   // these, we'll unmatch the blocks, turning them into a del <
<   // an insert.						      <
< 							      <
<   if (0 < optVerbose) {					      <
<     fprintf (stderr, "# Pass #5 (unmatching block moves)...\n <
<   }							      <
< 							      <
<   nMatchedBlocks = 0;					      <
<   nMatchedLines = 0;					      <
< 							      <
<   // Starting at the top of both files,...		      <
< 							      <
<   unsigned o = 0;					      <
<   unsigned n = 0;					      <
< 							      <
<   while (o < lines[0].size () || n < lines[1].size ()) {      <
< 							      <
<     // Skip any unmatched lines at this point in the old file <
<     // are deletes.					      <
< 							      <
<     //    Old     New					      <
<     //   +---+						      <
<     // 0 | a |						      <
<     //   +---+   +---+					      <
<     //         0 | b |					      <
<     //   +---+   +---+					      <
<     // 1 | c | 1 | c |					      <
<     //   +---+   +---+					      <
<     //         2 | z |					      <
<     //   +---+   +---+					      <
<     // 2 | d | 3 | d |					      <
<     //   +---+   +---+					      <
< 							      <
<     while (o < lines[0].size () && lines[0][o].l == ~0) {     <
<       o += 1;						      <
<     }							      <
< 							      <
<     // Skip any unmatched lines at this point in the new file <
<     // are inserts.					      <
< 							      <
<     while (n < lines[1].size () && lines[1][n].l == ~0) {     <
<       n += 1;						      <
<     }							      <
< 							      <
<     // When we get here, we know that we're dealing with matc <
<     // lines (or the end of one or both files).  We're done w <
<     // pass, if we've reached the end of either file.	      <
< 							      <
<     if (lines[0].size () <= o || lines[1].size () <= n) {     <
<       break;						      <
<     }							      <
< 							      <
<     // We now know that we've got a pair of matching lines, t <
<     // of a matching block.  If the new file's line number is <
<     // expect, then the matched pair is unmoved, and we can s <
<     // the pair.  (If this is really the start of a block of  <
<     // 1 lines, we'll handle it one pair at a time.)	      <
< 							      <
<     if (lines[0][o].l == n) {				      <
<       o += 1;						      <
<       n += 1;						      <
<       continue;						      <
<     }							      <
< 							      <
<     // If, on the other hand, we don't expect this [new] line <
<     // then this matching block has been moved.  We need to t <
<     // matched pair into an *unmatched* pair, one of deletes, <
<     // of inserts.  First, though, we need to know how big th <
<     // is, and how far it was moved....			      <
< 							      <
<     // Remember where we were when we started.		      <
< 							      <
<     unsigned oOld = o;					      <
<     unsigned nOld = n;					      <
< 							      <
<     // Remember where the block came from.		      <
< 							      <
<     unsigned nNew = lines[0][o].l;			      <
< 							      <
<     // Find the end of this matched pair.		      <
< 							      <
<     for (n = nNew; o < lines[0].size () && n < lines[1].size  <
<       if (lines[0][o].l != n) {				      <
<         break;						      <
<       }							      <
<     }							      <
< 							      <
<     // When we get here:				      <
<     // * oOld..o is the old file's block,		      <
<     // * nNew..n is the new file's *moved* block, and	      <
<     // * nOld is where we originally expected the new block f <
<  							      <
<     // We can now calculate the length of the block...	      <
<     							      <
<     unsigned bSize = o - oOld;  // (or n - nNew)	      <
< 							      <
<     // ... and we can calculate how far the block moved:      <
< 							      <
<     unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew; <
< 							      <
<     // The larger of the two will become our delete, and the  <
<     // will become our insert.				      <
< 							      <
<     //    Old     New					      <
<     //   +---+   +---+					      <
<     // 0 | a | 0 | b |					      <
<     //   +---+ 1 | b |					      <
<     // 1 | b |   +---+					      <
<     // 2 | b | 2 | a |					      <
<     //   +---+   +---+					      <
<     // 3 | c | 3 | c |					      <
<     //   +---+   +---+					      <
< 							      <
<     // (1) Delete a@0, insert a@2, or			      <
<     // (2) insert bb@0, delete bb@1?			      <
< 							      <
<     // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and <
<     // (of a) is 2-0 or 2, the size of b@0.  We choose to del <
<     // and reinsert a@2.				      <
< 							      <
<     // if (bSize <= bMove) {				      <
<       for (unsigned a = oOld; a < o; a += 1) {		      <
<         lines[0][a].l = ~0;				      <
<       }							      <
<       for (unsigned d = nNew; d < n; d += 1) {		      <
<         lines[1][d].l = ~0;				      <
<       }							      <
<     // } else {						      <
<       // for (unsigned a = oOld; a < o; a += 1) {	      <
<       //   lines[0][a].l = ~0;				      <
<       // }						      <
<       // for (unsigned d = nNew; d < n; d += 1) {	      <
<       //   lines[1][d].l = ~0;				      <
<       // }						      <
<     // }						      <
< 							      <
<     // Continue from where we left off.			      <
< 							      <
<     n = nOld;						      <
<   }							      <
<   nTotalMatchedLines -= nMatchedLines;			      <
<   nTotalMatchedBlocks -= nMatchedBlocks;		      <
< 							      <
<   // Let's see the intermediate results.		      <
< 							      <
<   if (0 < optVerbose) {					      <
<     fprintf (stderr,					      <
<              " found %u/%u matched lines/blocks (%u/%u totals <
<              nMatchedLines,				      <
<              nMatchedBlocks,				      <
<              nTotalMatchedLines,			      <
<              nTotalMatchedBlocks			      <
<             );						      <
< 							      <
<     if (1 < optVerbose) {				      <
<       for (int f = 0; f < 2; f += 1) {			      <
<         fprintf (stderr, "# file #%d\n", f + 1);	      <
<         for (int l = 0; l < lines[f].size (); l += 1) {	      <
<           fprintf (stderr, "#   [%d] ", l);		      <
<           lines[f][l].Dump (stderr);			      <
<         }						      <
<       }							      <
<     }							      <
<   }							      <
< 							      <
<   // Perform Pass #6, in which we create the desired output.  <
< 							      <
<   if (0 < optVerbose) {					      <
<     fprintf (stderr, "# Pass #6 (walking the differences)...\ <
<   }							      <
< 							      <
<   nMatchedLines = 0;					      <
< 							      <
<   // Write the header.					      <
< 							      <
<   switch (diffFormat) {					      <
<   case Default:						      <
<   case Normal:						      <
<     break;						      <
<   case Unified:						      <
<     fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00 <
<     fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00 <
<     fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), <
<     break;						      <
<   }							      <
< 							      <
<   // Starting at the top of both files,...		      <
< 							      <
<   o = 0;						      <
<   n = 0;						      <
< 							      <
<   while (o < lines[0].size () || n < lines[1].size ()) {      <
< 							      <
<     // Find any unmatched lines at this point in the old file <
<     // are deletes.					      <
< 							      <
<     unsigned boDeletes;					      <
<     for (boDeletes = o;					      <
<          o < lines[0].size () && lines[0][o].l == ~0;	      <
<          o += 1						      <
<         )						      <
<     {}							      <
< 							      <
<     // Find any unmatched lines at this point in the new file <
<     // are inserts.					      <
< 							      <
<     unsigned boInserts;					      <
<     for (boInserts = n;					      <
<          n < lines[1].size () && lines[1][n].l == ~0;	      <
<          n += 1						      <
<         )						      <
<     {}							      <
< 							      <
<     // We've got deleted line(s) from boDeletes .. o.	      <
<     // We've got deleted line(s) from boInserts .. n.	      <
< 							      <
<     unsigned nDeletes = o - boDeletes;			      <
<     unsigned nInserts = n - boInserts;			      <
< 							      <
<     // We've got...					      <
< 							      <
<     if (nDeletes && nInserts) {				      <
< 							      <
<       // ... deletes and inserts.			      <
< 							      <
<       switch (diffFormat) {				      <
<       case Default:					      <
<       case Normal:					      <
<         if (1 < nDeletes && 1 < nInserts) {		      <
<           fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, <
<         } else if (1 < nDeletes) {			      <
<           fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, bo <
<         } else if (1 < nInserts) {			      <
<           fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boIns <
<         } 						      <
<         for (unsigned l = boDeletes; l < o; l += 1) {	      <
<           fprintf (stdout, "< %s", lines[0][l].line->c_str () <
<         }						      <
<         fprintf (stderr, "---\n");			      <
<         for (unsigned l = boInserts; l < n; l += 1) {	      <
<           fprintf (stdout, "> %s", lines[1][l].line->c_str () <
<         }						      <
<         break;						      <
< 							      <
<       case Unified:					      <
<         for (unsigned l = boDeletes; l < o; l += 1) {	      <
<           fprintf (stdout, "-%s", lines[0][l].line->c_str ()) <
<         }						      <
<         for (unsigned l = boInserts; l < n; l += 1) {	      <
<           fprintf (stdout, "+%s", lines[1][l].line->c_str ()) <
<         }						      <
<         break;						      <
<       }							      <
<     } else if (nDeletes) {				      <
< 							      <
<       //  ... just deletes.				      <
< 							      <
<       switch (diffFormat) {				      <
<       case Default:					      <
<       case Normal:					      <
<         if (1 < nDeletes) {				      <
<           fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n) <
<         } else {					      <
<           fprintf (stdout, "%dd%d\n", boDeletes + 1, n);      <
<         }						      <
<         for (unsigned l = boDeletes; l < o; l += 1) {	      <
<           fprintf (stdout, "< %s", lines[0][l].line->c_str () <
<         }						      <
<         break;						      <
<       case Unified:					      <
<         for (unsigned l = boDeletes; l < o; l += 1) {	      <
<           fprintf (stdout, "-%s", lines[0][l].line->c_str ()) <
<         }						      <
<         break;						      <
<       }							      <
<     } else if (nInserts) {				      <
< 							      <
<       //  ... just inserts.				      <
< 							      <
<       switch (diffFormat) {				      <
<       case Default:					      <
<       case Normal:					      <
<         if (1 < nInserts) {				      <
<           fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n) <
<         } else {					      <
<           fprintf (stdout, "%da%d\n", o, boInserts + 1);      <
<         }						      <
<         for (unsigned l = boInserts; l < n; l += 1) {	      <
<           fprintf (stdout, "> %s", lines[1][l].line->c_str () <
<         }						      <
<         break;						      <
<       case Unified:					      <
<         for (unsigned l = boInserts; l < n; l += 1) {	      <
<           fprintf (stdout, "+%s", lines[1][l].line->c_str ()) <
<         }						      <
<         break;						      <
<       }							      <
<     }							      <
< 							      <
<     // When we get here, we're dealing with matching lines.   <
< 							      <
<     switch (diffFormat) {				      <
<     case Default:					      <
<     case Normal:					      <
<       break;						      <
<     case Unified:					      <
<       fprintf (stdout, " %s", lines[0][o].line->c_str ());    <
<       break;						      <
<     }								    }
<     o += 1;						      <
<     n += 1;						      <
<   }								  }
< }								}
---
> sdiff: sdiff.cpp:1858: void pass6y(): Assertion `lines[0][o].line == lines[1][n].line' failed.
> #include <algorithm>                                          <
> using std::find;                                              <
> #include <string>                                               #include <string>
> using std::string;                                              using std::string;
> #include <list>                                                 #include <list>
> using std::list;                                                using std::list;
> #include <map>                                                  #include <map>
> using std::map;                                                 using std::map;
> #include <vector>                                               #include <vector>
> using std::vector;                                              using std::vector;
> #include <stdio.h>                                              #include <stdio.h>
>                                                               > 
>                                                               > struct Line : public string {
>                                                               >   Line (string _text) :
>                                                               >     text (_text)
# ../sdiff -y dif.3.cpp dif.4.cpp >& dif.3.4.diff-y.test
# dif.3.4.diff-y ---------------------------------------------------------------
1,747c1,747
< #include <algorithm>						#include <algorithm>
< using std::find;						using std::find;
< #include <string>						#include <string>
< using std::string;						using std::string;
< #include <list>							#include <list>
< using std::list;						using std::list;
< #include <map>							#include <map>
< using std::map;							using std::map;
< #include <vector>						#include <vector>
< using std::vector;						using std::vector;
< #include <stdio.h>						#include <stdio.h>
< 
< enum DiffFormat {						enum DiffFormat {
<   Default,							  Default,
< 
<   Context,							  Context,
<   EdScript,							  EdScript,
<   IfThenElse,							  IfThenElse,
<   Normal,							  Normal,
<   RCS,								  RCS,
<   SideBySide,							  SideBySide,
<   Unified							  Unified
< };								};
< 
< DiffFormat diffFormat = Unified;				DiffFormat diffFormat = Unified;
< 
< int optVerbose = 1;						int optVerbose = 1;
< 
< struct Line : public string {					struct Line : public string {
<   Line (string _text) :						  Line (string _text) :
<     string (_text)						    string (_text)
<   {								  {
<   }								  }
<   ~Line () {							  ~Line () {
<     copies[0].erase (copies[0].begin (), copies[0].end ());	    copies[0].erase (copies[0].begin (), copies[0].end ());
<     copies[1].erase (copies[1].begin (), copies[1].end ());	    copies[1].erase (copies[1].begin (), copies[1].end ());
<   }								  }
<   void Dump (FILE *out) {					  void Dump (FILE *out) {
<     fprintf (out, "{{ ");					    fprintf (out, "{{ ");
<     for (list<unsigned>::iterator i = copies[0].begin (); i !	    for (list<unsigned>::iterator i = copies[0].begin (); i !
<       fprintf (out, "%u ", *i);					      fprintf (out, "%u ", *i);
<     }								    }
<     fprintf (out, "},{ ");					    fprintf (out, "},{ ");
<     for (list<unsigned>::iterator i = copies[1].begin (); i !	    for (list<unsigned>::iterator i = copies[1].begin (); i !
<       fprintf (out, "%u ", *i);					      fprintf (out, "%u ", *i);
<     }								    }
<     fprintf (out, "}}\t%s", c_str ());				    fprintf (out, "}}\t%s", c_str ());
<   }								  }
<   list<unsigned> copies[2];					  list<unsigned> copies[2];
< };								};
< 
< struct LinePtr {						struct LinePtr {
<   LinePtr (Line *_line) :					  LinePtr (Line *_line) :
<     line (_line),						    line (_line),
<     l (~0u)							    l (~0u)
<   {								  {
<   }								  }
<   void Dump (FILE *out) {					  void Dump (FILE *out) {
<     fprintf (out, "[%d] ", l);					    fprintf (out, "[%d] ", l);
<     line->Dump (out);						    line->Dump (out);
<   }								  }
<   Line *line;							  Line *line;
<   unsigned l;							  unsigned l;
< };								};
< 
< typedef map<string, Line *> MapStringToLinePtr;			typedef map<string, Line *> MapStringToLinePtr;
< typedef vector<LinePtr> VectorLinePtr;				typedef vector<LinePtr> VectorLinePtr;
< 
< char *ARGV0 = "dif2";						char *ARGV0 = "dif2";
< 
< int main (int argc, char *argv[])				int main (int argc, char *argv[])
< {								{
<   char const *files[2] = { 0, 0 };				  char const *files[2] = { 0, 0 };
< 
<   MapStringToLinePtr table;					  MapStringToLinePtr table;
<   VectorLinePtr lines[2];					  VectorLinePtr lines[2];
< 
<   unsigned nTotalMatchedBlocks = 0;				  unsigned nTotalMatchedBlocks = 0;
<   unsigned nMatchedBlocks = 0;					  unsigned nMatchedBlocks = 0;
<   unsigned nTotalMatchedLines = 0;				  unsigned nTotalMatchedLines = 0;
<   unsigned nMatchedLines = 0;					  unsigned nMatchedLines = 0;
< 
<   // Read the old [0] file, and the new [1] file.		  // Read the old [0] file, and the new [1] file.
< 
<   for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {	  for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
<     files[n] = argv[a];						    files[n] = argv[a];
< 
<     if (FILE *f = fopen (files[n], "r")) {			    if (FILE *f = fopen (files[n], "r")) {
<       if (0 < optVerbose) {					      if (0 < optVerbose) {
<         fprintf (stderr, "# Reading %s...", files[n]);		        fprintf (stderr, "# Reading %s...", files[n]);
<       }								      }
< 
<       char buffer[1024];					      char buffer[1024];
<       unsigned nUniq = 0;					      unsigned nUniq = 0;
< 
<       while (fgets (buffer, sizeof (buffer), f)) {		      while (fgets (buffer, sizeof (buffer), f)) {
<         string text (buffer);					        string text (buffer);
< 
<         Line *line = table[text];				        Line *line = table[text];
< 
<         if (!line) {						        if (!line) {
<           table[text] = line = new Line (text);			          table[text] = line = new Line (text);
<           nUniq += 1;						          nUniq += 1;
<         }							        }
<         line->copies[n].push_back (lines[n].size ());		        line->copies[n].push_back (lines[n].size ());
<         lines[n].push_back (line);				        lines[n].push_back (line);
<       }								      }
< 
<       if (0 < optVerbose) {					      if (0 < optVerbose) {
<         fprintf (stderr, " %u lines, %u unique.\n", lines[n].	        fprintf (stderr, " %u lines, %u unique.\n", lines[n].
<       }								      }
<     } else {							    } else {
<       fprintf (stderr, "%s: Unable to open %s!  Exiting....\n	      fprintf (stderr, "%s: Unable to open %s!  Exiting....\n
<       perror (ARGV0);						      perror (ARGV0);
<       exit (1);							      exit (1);
<     }								    }
<   }								  }
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     printf ("# Total unique lines = %d\n", table.size ());	    printf ("# Total unique lines = %d\n", table.size ());
<   }								  }
< 
<   // map<int, int> counts;					  // map<int, int> counts;
<   // for (MapStringToLinePtr::iterator i = table.begin (); i 	  // for (MapStringToLinePtr::iterator i = table.begin (); i 
<   //   Line *l = i->second;					  //   Line *l = i->second;
<   //   counts[l->counts[0].size () + l->counts[1].size ()] +=	  //   counts[l->counts[0].size () + l->counts[1].size ()] +=
<   // }								  // }
<   // for (map<int, int>::iterator i = counts.begin (); i != c	  // for (map<int, int>::iterator i = counts.begin (); i != c
<   //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s	  //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s
<   // }								  // }
< 
<   // Perform pass #1, in which we find all explicit matches a	  // Perform pass #1, in which we find all explicit matches a
<   // the unique lines.  For every unique line that appears th	  // the unique lines.  For every unique line that appears th
<   // number of times in both files, we declare the lines to m	  // number of times in both files, we declare the lines to m
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass 1 (finding matches amongst uniqu	    fprintf (stderr, "# Pass 1 (finding matches amongst uniqu
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   for (MapStringToLinePtr::iterator i = table.begin (); i != 	  for (MapStringToLinePtr::iterator i = table.begin (); i != 
<     Line *l = i->second;					    Line *l = i->second;
< 
<     // If the number of old and new lines match, then we decl	    // If the number of old and new lines match, then we decl
<     // they are (all) the same line.  Note, it isn't possible	    // they are (all) the same line.  Note, it isn't possible
<     // numbers of both files to be 0.				    // numbers of both files to be 0.
< 
<     // (In the original algorithm, we only recognized a match	    // (In the original algorithm, we only recognized a match
<     // if there was exactly 1 copy for each file.)		    // if there was exactly 1 copy for each file.)
< 
<     if (l->copies[0].size () == l->copies[1].size ()) {		    if (l->copies[0].size () == l->copies[1].size ()) {
<       nMatchedLines += 1;					      nMatchedLines += 1;
< 
<       // For each matched line in the new file, mark it with 	      // For each matched line in the new file, mark it with 
<       // corresponding line (number) in the old file.		      // corresponding line (number) in the old file.
< 
<       while (!l->copies[0].empty ()) {				      while (!l->copies[0].empty ()) {
<         unsigned o = l->copies[0].front ();			        unsigned o = l->copies[0].front ();
<         unsigned n = l->copies[1].front ();			        unsigned n = l->copies[1].front ();
< 
<         // Match up the pair.					        // Match up the pair.
< 
<         lines[0][o].l = n;					        lines[0][o].l = n;
<         lines[1][n].l = o;					        lines[1][n].l = o;
< 
<         // Remove the matched line numbers from the lists.	        // Remove the matched line numbers from the lists.
< 
<         l->copies[0].pop_front ();				        l->copies[0].pop_front ();
<         l->copies[1].pop_front ();				        l->copies[1].pop_front ();
<       }								      }
<     }								    }
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, " found %u matched lines (%u total).\n",	    fprintf (stderr, " found %u matched lines (%u total).\n",
< 
<     if (1 < optVerbose) {					    if (1 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< 
<   // Perform Pass #2, in which we attempt to 'widen' blocks o	  // Perform Pass #2, in which we attempt to 'widen' blocks o
<   // lines, by appending lines which are the same in both fil	  // lines, by appending lines which are the same in both fil
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #2 (spreading matches down)...")	    fprintf (stderr, "# Pass #2 (spreading matches down)...")
<   }								  }
< 
<   nMatchedBlocks = 0;						  nMatchedBlocks = 0;
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Starting at the top of the old file,...			  // Starting at the top of the old file,...
< 
<   for (unsigned o = 0; o < lines[0].size (); o += 1) {		  for (unsigned o = 0; o < lines[0].size (); o += 1) {
< 
<     // ... skip any currently unmatched lines...		    // ... skip any currently unmatched lines...
< 
<     if (lines[0][o].l == ~0) {					    if (lines[0][o].l == ~0) {
<       continue;							      continue;
<     }								    }
< 
<     // ... until we find an [already] matched line.  Then, sk	    // ... until we find an [already] matched line.  Then, sk
<     // the set of 1 or more matched lines, until we reach any	    // the set of 1 or more matched lines, until we reach any
<     // following, still-unmatched line.				    // following, still-unmatched line.
< 
<     unsigned n;							    unsigned n;
<     do {							    do {
<       n = lines[0][o].l + 1;					      n = lines[0][o].l + 1;
<       o += 1;							      o += 1;
<     } while (o < lines[0].size () && lines[0][o].l != ~0);	    } while (o < lines[0].size () && lines[0][o].l != ~0);
< 
<     // Now, o - 1 is the line number of the last matched old 	    // Now, o - 1 is the line number of the last matched old 
<     // n - 1 is the line number of the last matched new line.	    // n - 1 is the line number of the last matched new line.
<     // to add new old and new lines, if they match.		    // to add new old and new lines, if they match.
< 
<     // Finally, attempt to add unmatched lines to the preceed	    // Finally, attempt to add unmatched lines to the preceed
<     // matched set.						    // matched set.
< 
<     for (; o < lines[0].size () && lines[0][o].l == ~0; o += 	    for (; o < lines[0].size () && lines[0][o].l == ~0; o += 
< 
<       // If the [next] pair of old and new lines aren't the s	      // If the [next] pair of old and new lines aren't the s
< 
<       if (lines[0][o].line != lines[1][n].line) {		      if (lines[0][o].line != lines[1][n].line) {
<         break;							        break;
<       }								      }
< 
<       // Match up the pair.					      // Match up the pair.
< 
<       lines[0][o].l = n;					      lines[0][o].l = n;
<       lines[1][n].l = o;					      lines[1][n].l = o;
< 
<       // Remove the matched line numbers form the lists.	      // Remove the matched line numbers form the lists.
< 
<       Line *line = lines[0][o].line;				      Line *line = lines[0][o].line;
<       list<unsigned> &oldCopies = line->copies[0];		      list<unsigned> &oldCopies = line->copies[0];
<       list<unsigned>::iterator oL = find (oldCopies.begin (),	      list<unsigned>::iterator oL = find (oldCopies.begin (),
<       if (oL != oldCopies.end ()) {				      if (oL != oldCopies.end ()) {
<         oldCopies.erase (oL);					        oldCopies.erase (oL);
<       }								      }
<       list<unsigned> &newCopies = line->copies[0];		      list<unsigned> &newCopies = line->copies[0];
<       list<unsigned>::iterator nL = find (newCopies.begin (),	      list<unsigned>::iterator nL = find (newCopies.begin (),
<       if (nL != newCopies.end ()) {				      if (nL != newCopies.end ()) {
<         newCopies.erase (nL);					        newCopies.erase (nL);
<       }								      }
< 
<       nMatchedLines += 1;					      nMatchedLines += 1;
<     }								    }
<     nMatchedBlocks += 1;					    nMatchedBlocks += 1;
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
<   nTotalMatchedBlocks += nMatchedBlocks;			  nTotalMatchedBlocks += nMatchedBlocks;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr,						    fprintf (stderr,
<              " found %u/%u matched lines/blocks (%u/%u totals	             " found %u/%u matched lines/blocks (%u/%u totals
<              nMatchedLines,					             nMatchedLines,
<              nMatchedBlocks,					             nMatchedBlocks,
<              nTotalMatchedLines,				             nTotalMatchedLines,
<              nTotalMatchedBlocks				             nTotalMatchedBlocks
<             );							            );
<     if (1 < optVerbose) {					    if (1 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< 
<   // Perform Pass #3, in which we attempt to 'widen' blocks o	  // Perform Pass #3, in which we attempt to 'widen' blocks o
<   // lines, by prepending lines which are the same in both fi	  // lines, by prepending lines which are the same in both fi
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #3 (spreading matches up)...");	    fprintf (stderr, "# Pass #3 (spreading matches up)...");
<   }								  }
< 
<   nMatchedBlocks = 0;						  nMatchedBlocks = 0;
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Starting at the bottom of the old file,...			  // Starting at the bottom of the old file,...
< 
<   for (int o = lines[0].size (); 0 <= o; o -= 1) {		  for (int o = lines[0].size (); 0 <= o; o -= 1) {
< 
<     // ... skip any currently unmatched lines...		    // ... skip any currently unmatched lines...
< 
<     if (lines[0][o].l == ~0) {					    if (lines[0][o].l == ~0) {
<       continue;							      continue;
<     }								    }
< 
<     // ... until we find an [already] matched line.  Then, sk	    // ... until we find an [already] matched line.  Then, sk
<     // the set of 1 or more matched lines, until we reach any	    // the set of 1 or more matched lines, until we reach any
<     // following, still-unmatched line.				    // following, still-unmatched line.
< 
<     unsigned n;							    unsigned n;
<     do {							    do {
<       n = lines[0][o].l - 1;					      n = lines[0][o].l - 1;
<       o -= 1;							      o -= 1;
<     } while (0 <= o && lines[0][o].l != ~0);			    } while (0 <= o && lines[0][o].l != ~0);
< 
<     // Now, o + 1 is the line number of the last matched old 	    // Now, o + 1 is the line number of the last matched old 
<     // n + 1 is the line number of the last matched new line.	    // n + 1 is the line number of the last matched new line.
<     // to add new old and new lines, if they match.		    // to add new old and new lines, if they match.
< 
<     // Finally, attempt to add unmatched lines to the preceed	    // Finally, attempt to add unmatched lines to the preceed
<     // matched set.						    // matched set.
< 
<     for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {	    for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
< 
<       // If the [next] pair of old and new lines aren't the s	      // If the [next] pair of old and new lines aren't the s
< 
<       if (lines[0][o].line != lines[1][n].line) {		      if (lines[0][o].line != lines[1][n].line) {
<         break;							        break;
<       }								      }
< 
<       // Match up the pair.					      // Match up the pair.
< 
<       lines[0][o].l = n;					      lines[0][o].l = n;
<       lines[1][n].l = o;					      lines[1][n].l = o;
< 
<       // Remove the matched line numbers form the lists.	      // Remove the matched line numbers form the lists.
< 
<       Line *line = lines[0][o].line;				      Line *line = lines[0][o].line;
<       list<unsigned> &oldCopies = line->copies[0];		      list<unsigned> &oldCopies = line->copies[0];
<       list<unsigned>::iterator oL = find (oldCopies.begin (),	      list<unsigned>::iterator oL = find (oldCopies.begin (),
<       if (oL != oldCopies.end ()) {				      if (oL != oldCopies.end ()) {
<         oldCopies.erase (oL);					        oldCopies.erase (oL);
<       }								      }
<       list<unsigned> &newCopies = line->copies[0];		      list<unsigned> &newCopies = line->copies[0];
<       list<unsigned>::iterator nL = find (newCopies.begin (),	      list<unsigned>::iterator nL = find (newCopies.begin (),
<       if (nL != newCopies.end ()) {				      if (nL != newCopies.end ()) {
<         newCopies.erase (nL);					        newCopies.erase (nL);
<       }								      }
< 
<       nMatchedLines += 1;					      nMatchedLines += 1;
<     }								    }
<     nMatchedBlocks += 1;					    nMatchedBlocks += 1;
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr,						    fprintf (stderr,
<              " found %u/%u matched lines/blocks (%u/%u totals	             " found %u/%u matched lines/blocks (%u/%u totals
<              nMatchedLines,					             nMatchedLines,
<              nMatchedBlocks,					             nMatchedBlocks,
<              nTotalMatchedLines,				             nTotalMatchedLines,
<              nTotalMatchedBlocks				             nTotalMatchedBlocks
<             );							            );
< 
<     if (1 < optVerbose) {					    if (1 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< 
<   // Perform pass #4, in which we find any remaining matches 	  // Perform pass #4, in which we find any remaining matches 
<   // the unique lines.  For every unique line that has more t	  // the unique lines.  For every unique line that has more t
<   // copy in both files, we declare the copies to match.	  // copy in both files, we declare the copies to match.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass 4 (finding remaining matches amo	    fprintf (stderr, "# Pass 4 (finding remaining matches amo
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   for (MapStringToLinePtr::iterator i = table.begin (); i != 	  for (MapStringToLinePtr::iterator i = table.begin (); i != 
<     Line *l = i->second;					    Line *l = i->second;
< 
<     // If there's more than 1 matching old and new lines, the	    // If there's more than 1 matching old and new lines, the
<     // declare that each pair are (all) the same line.		    // declare that each pair are (all) the same line.
< 
<     // (In the original algorithm, we only recognized a match	    // (In the original algorithm, we only recognized a match
<     // if there was exactly 1 copy for each file.)		    // if there was exactly 1 copy for each file.)
< 
<     while (0 < l->copies[0].size () && 0 < l->copies[1].size 	    while (0 < l->copies[0].size () && 0 < l->copies[1].size 
<       nMatchedLines += 1;					      nMatchedLines += 1;
< 
<       // For each matched line in the new file, mark it with 	      // For each matched line in the new file, mark it with 
<       // corresponding line (number) in the old file.		      // corresponding line (number) in the old file.
< 
<       unsigned o = l->copies[0].front ();			      unsigned o = l->copies[0].front ();
<       unsigned n = l->copies[1].front ();			      unsigned n = l->copies[1].front ();
< 
<       // Match up the pair.					      // Match up the pair.
< 
<       lines[0][o].l = n;					      lines[0][o].l = n;
<       lines[1][n].l = o;					      lines[1][n].l = o;
< 
<       // Remove the matched line numbers from the lists.	      // Remove the matched line numbers from the lists.
< 
<       l->copies[0].pop_front ();				      l->copies[0].pop_front ();
<       l->copies[1].pop_front ();				      l->copies[1].pop_front ();
<     }								    }
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, " found %u matched lines (%u total).\n",	    fprintf (stderr, " found %u matched lines (%u total).\n",
< 
<     if (1 < optVerbose) {					    if (1 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< 
<   // Perform Pass #5, in which we look for blocks which match	  // Perform Pass #5, in which we look for blocks which match
<   // the result of a move (their not in their original positi	  // the result of a move (their not in their original positi
<   // these, we'll unmatch the blocks, turning them into a del	  // these, we'll unmatch the blocks, turning them into a del
<   // an insert.							  // an insert.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #5 (unmatching block moves)...\n	    fprintf (stderr, "# Pass #5 (unmatching block moves)...\n
<   }								  }
< 
<   nMatchedBlocks = 0;						  nMatchedBlocks = 0;
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Starting at the top of both files,...			  // Starting at the top of both files,...
< 
<   unsigned o = 0;						  unsigned o = 0;
<   unsigned n = 0;						  unsigned n = 0;
< 
<   while (o < lines[0].size () || n < lines[1].size ()) {	  while (o < lines[0].size () || n < lines[1].size ()) {
< 
<     // Skip any unmatched lines at this point in the old file	    // Skip any unmatched lines at this point in the old file
<     // are deletes.						    // are deletes.
< 
<     //    Old     New						    //    Old     New
<     //   +---+							    //   +---+
<     // 0 | a |							    // 0 | a |
<     //   +---+   +---+						    //   +---+   +---+
<     //         0 | b |						    //         0 | b |
<     //   +---+   +---+						    //   +---+   +---+
<     // 1 | c | 1 | c |						    // 1 | c | 1 | c |
<     //   +---+   +---+						    //   +---+   +---+
<     //         2 | z |						    //         2 | z |
<     //   +---+   +---+						    //   +---+   +---+
<     // 2 | d | 3 | d |						    // 2 | d | 3 | d |
<     //   +---+   +---+						    //   +---+   +---+
< 
<     while (o < lines[0].size () && lines[0][o].l == ~0) {	    while (o < lines[0].size () && lines[0][o].l == ~0) {
<       o += 1;							      o += 1;
<     }								    }
< 
<     // Skip any unmatched lines at this point in the new file	    // Skip any unmatched lines at this point in the new file
<     // are inserts.						    // are inserts.
< 
<     while (n < lines[1].size () && lines[1][n].l == ~0) {	    while (n < lines[1].size () && lines[1][n].l == ~0) {
<       n += 1;							      n += 1;
<     }								    }
< 
<     // When we get here, we know that we're dealing with matc	    // When we get here, we know that we're dealing with matc
<     // lines (or the end of one or both files).  We're done w	    // lines (or the end of one or both files).  We're done w
<     // pass, if we've reached the end of either file.		    // pass, if we've reached the end of either file.
< 
<     if (lines[0].size () <= o || lines[1].size () <= n) {	    if (lines[0].size () <= o || lines[1].size () <= n) {
<       break;							      break;
<     }								    }
< 
<     // We now know that we've got a pair of matching lines, t	    // We now know that we've got a pair of matching lines, t
<     // of a matching block.  If the new file's line number is	    // of a matching block.  If the new file's line number is
<     // expect, then the matched pair is unmoved, and we can s	    // expect, then the matched pair is unmoved, and we can s
<     // the pair.  (If this is really the start of a block of 	    // the pair.  (If this is really the start of a block of 
<     // 1 lines, we'll handle it one pair at a time.)		    // 1 lines, we'll handle it one pair at a time.)
< 
<     if (lines[0][o].l == n) {					    if (lines[0][o].l == n) {
<       o += 1;							      o += 1;
<       n += 1;							      n += 1;
<       continue;							      continue;
<     }								    }
< 
<     // If, on the other hand, we don't expect this [new] line	    // If, on the other hand, we don't expect this [new] line
<     // then this matching block has been moved.  We need to t	    // then this matching block has been moved.  We need to t
<     // matched pair into an *unmatched* pair, one of deletes,	    // matched pair into an *unmatched* pair, one of deletes,
<     // of inserts.  First, though, we need to know how big th	    // of inserts.  First, though, we need to know how big th
<     // is, and how far it was moved....				    // is, and how far it was moved....
< 
<     // Remember where we were when we started.			    // Remember where we were when we started.
< 
<     unsigned oOld = o;						    unsigned oOld = o;
<     unsigned nOld = n;						    unsigned nOld = n;
< 
<     // Remember where the block came from.			    // Remember where the block came from.
< 
<     unsigned nNew = lines[0][o].l;				    unsigned nNew = lines[0][o].l;
< 
<     // Find the end of this matched pair.			    // Find the end of this matched pair.
< 
<     for (n = nNew; o < lines[0].size () && n < lines[1].size 	    for (n = nNew; o < lines[0].size () && n < lines[1].size 
<       if (lines[0][o].l != n) {					      if (lines[0][o].l != n) {
<         break;							        break;
<       }								      }
<     }								    }
< 
<     // When we get here:					    // When we get here:
<     // * oOld..o is the old file's block,			    // * oOld..o is the old file's block,
<     // * nNew..n is the new file's *moved* block, and		    // * nNew..n is the new file's *moved* block, and
<     // * nOld is where we originally expected the new block f	    // * nOld is where we originally expected the new block f
<  								 
<     // We can now calculate the length of the block...		    // We can now calculate the length of the block...
<     								    
<     unsigned bSize = o - oOld;  // (or n - nNew)		    unsigned bSize = o - oOld;  // (or n - nNew)
< 
<     // ... and we can calculate how far the block moved:	    // ... and we can calculate how far the block moved:
< 
<     unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;	    unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
< 
<     // The larger of the two will become our delete, and the 	    // The larger of the two will become our delete, and the 
<     // will become our insert.					    // will become our insert.
< 
<     //    Old     New						    //    Old     New
<     //   +---+   +---+						    //   +---+   +---+
<     // 0 | a | 0 | b |						    // 0 | a | 0 | b |
<     //   +---+ 1 | b |						    //   +---+ 1 | b |
<     // 1 | b |   +---+						    // 1 | b |   +---+
<     // 2 | b | 2 | a |						    // 2 | b | 2 | a |
<     //   +---+   +---+						    //   +---+   +---+
<     // 3 | c | 3 | c |						    // 3 | c | 3 | c |
<     //   +---+   +---+						    //   +---+   +---+
< 
<     // (1) Delete a@0, insert a@2, or				    // (1) Delete a@0, insert a@2, or
<     // (2) insert bb@0, delete bb@1?				    // (2) insert bb@0, delete bb@1?
< 
<     // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and	    // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and
<     // (of a) is 2-0 or 2, the size of b@0.  We choose to del	    // (of a) is 2-0 or 2, the size of b@0.  We choose to del
<     // and reinsert a@2.					    // and reinsert a@2.
< 
<     // if (bSize <= bMove) {					    // if (bSize <= bMove) {
<       for (unsigned a = oOld; a < o; a += 1) {			      for (unsigned a = oOld; a < o; a += 1) {
<         lines[0][a].l = ~0;					        lines[0][a].l = ~0;
<       }								      }
<       for (unsigned d = nNew; d < n; d += 1) {			      for (unsigned d = nNew; d < n; d += 1) {
<         lines[1][d].l = ~0;					        lines[1][d].l = ~0;
<       }								      }
<     // } else {							    // } else {
<       // for (unsigned a = oOld; a < o; a += 1) {		      // for (unsigned a = oOld; a < o; a += 1) {
<       //   lines[0][a].l = ~0;					      //   lines[0][a].l = ~0;
<       // }							      // }
<       // for (unsigned d = nNew; d < n; d += 1) {		      // for (unsigned d = nNew; d < n; d += 1) {
<       //   lines[1][d].l = ~0;					      //   lines[1][d].l = ~0;
<       // }							      // }
<     // }							    // }
< 
<     // Continue from where we left off.				    // Continue from where we left off.
< 
<     n = nOld;							    n = nOld;
<   }								  }
<   nTotalMatchedLines -= nMatchedLines;				  nTotalMatchedLines -= nMatchedLines;
<   nTotalMatchedBlocks -= nMatchedBlocks;			  nTotalMatchedBlocks -= nMatchedBlocks;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr,						    fprintf (stderr,
<              " found %u/%u matched lines/blocks (%u/%u totals	             " found %u/%u matched lines/blocks (%u/%u totals
<              nMatchedLines,					             nMatchedLines,
<              nMatchedBlocks,					             nMatchedBlocks,
<              nTotalMatchedLines,				             nTotalMatchedLines,
<              nTotalMatchedBlocks				             nTotalMatchedBlocks
<             );							            );
< 
<     if (1 < optVerbose) {					    if (1 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< 
<   // Perform Pass #6, in which we create the desired output.	  // Perform Pass #6, in which we create the desired output.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #6 (walking the differences)...\	    fprintf (stderr, "# Pass #6 (walking the differences)...\
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Write the header.						  // Write the header.
< 
<   switch (diffFormat) {						  switch (diffFormat) {
<   case Default:							  case Default:
<   case Normal:							  case Normal:
<     break;							    break;
<   case Unified:							  case Unified:
<     fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00	    fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00
<     fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00	    fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00
<     fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (),	    fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (),
<     break;							    break;
<   }								  }
< 
<   // Starting at the top of both files,...			  // Starting at the top of both files,...
< 
<   o = 0;							  o = 0;
<   n = 0;							  n = 0;
< 
<   while (o < lines[0].size () || n < lines[1].size ()) {	  while (o < lines[0].size () || n < lines[1].size ()) {
< 
<     // Find any unmatched lines at this point in the old file	    // Find any unmatched lines at this point in the old file
<     // are deletes.						    // are deletes.
< 
<     unsigned boDeletes;						    unsigned boDeletes;
<     for (boDeletes = o;						    for (boDeletes = o;
<          o < lines[0].size () && lines[0][o].l == ~0;		         o < lines[0].size () && lines[0][o].l == ~0;
<          o += 1							         o += 1
<         )							        )
<     {}								    {}
< 
<     // Find any unmatched lines at this point in the new file	    // Find any unmatched lines at this point in the new file
<     // are inserts.						    // are inserts.
< 
<     unsigned boInserts;						    unsigned boInserts;
<     for (boInserts = n;						    for (boInserts = n;
<          n < lines[1].size () && lines[1][n].l == ~0;		         n < lines[1].size () && lines[1][n].l == ~0;
<          n += 1							         n += 1
<         )							        )
<     {}								    {}
< 
<     // We've got deleted line(s) from boDeletes .. o.		    // We've got deleted line(s) from boDeletes .. o.
<     // We've got deleted line(s) from boInserts .. n.		    // We've got deleted line(s) from boInserts .. n.
< 
<     unsigned nDeletes = o - boDeletes;				    unsigned nDeletes = o - boDeletes;
<     unsigned nInserts = n - boInserts;				    unsigned nInserts = n - boInserts;
< 
<     // We've got...						    // We've got...
< 
<     if (nDeletes && nInserts) {					    if (nDeletes && nInserts) {
< 
<       // ... deletes and inserts.				      // ... deletes and inserts.
< 
<       switch (diffFormat) {					      switch (diffFormat) {
<       case Default:						      case Default:
<       case Normal:						      case Normal:
<         if (1 < nDeletes && 1 < nInserts) {			        if (1 < nDeletes && 1 < nInserts) {
<           fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o,	          fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o,
<         } else if (1 < nDeletes) {				        } else if (1 < nDeletes) {
<           fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, bo	          fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, bo
<         } else if (1 < nInserts) {				        } else if (1 < nInserts) {
<           fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boIns	          fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boIns
<         } 							        } 
<         for (unsigned l = boDeletes; l < o; l += 1) {		        for (unsigned l = boDeletes; l < o; l += 1) {
<           fprintf (stdout, "< %s", lines[0][l].line->c_str ()	          fprintf (stdout, "< %s", lines[0][l].line->c_str ()
<         }							        }
<         fprintf (stderr, "---\n");				        fprintf (stderr, "---\n");
<         for (unsigned l = boInserts; l < n; l += 1) {		        for (unsigned l = boInserts; l < n; l += 1) {
<           fprintf (stdout, "> %s", lines[1][l].line->c_str ()	          fprintf (stdout, "> %s", lines[1][l].line->c_str ()
<         }							        }
<         break;							        break;
< 
<       case Unified:						      case Unified:
<         for (unsigned l = boDeletes; l < o; l += 1) {		        for (unsigned l = boDeletes; l < o; l += 1) {
<           fprintf (stdout, "-%s", lines[0][l].line->c_str ())	          fprintf (stdout, "-%s", lines[0][l].line->c_str ())
<         }							        }
<         for (unsigned l = boInserts; l < n; l += 1) {		        for (unsigned l = boInserts; l < n; l += 1) {
<           fprintf (stdout, "+%s", lines[1][l].line->c_str ())	          fprintf (stdout, "+%s", lines[1][l].line->c_str ())
<         }							        }
<         break;							        break;
<       }								      }
<     } else if (nDeletes) {					    } else if (nDeletes) {
< 
<       //  ... just deletes.					      //  ... just deletes.
< 
<       switch (diffFormat) {					      switch (diffFormat) {
<       case Default:						      case Default:
<       case Normal:						      case Normal:
<         if (1 < nDeletes) {					        if (1 < nDeletes) {
<           fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n)	          fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n)
<         } else {						        } else {
<           fprintf (stdout, "%dd%d\n", boDeletes + 1, n);	          fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
<         }							        }
<         for (unsigned l = boDeletes; l < o; l += 1) {		        for (unsigned l = boDeletes; l < o; l += 1) {
<           fprintf (stdout, "< %s", lines[0][l].line->c_str ()	          fprintf (stdout, "< %s", lines[0][l].line->c_str ()
<         }							        }
<         break;							        break;
<       case Unified:						      case Unified:
<         for (unsigned l = boDeletes; l < o; l += 1) {		        for (unsigned l = boDeletes; l < o; l += 1) {
<           fprintf (stdout, "-%s", lines[0][l].line->c_str ())	          fprintf (stdout, "-%s", lines[0][l].line->c_str ())
<         }							        }
<         break;							        break;
<       }								      }
<     } else if (nInserts) {					    } else if (nInserts) {
< 
<       //  ... just inserts.					      //  ... just inserts.
< 
<       switch (diffFormat) {					      switch (diffFormat) {
<       case Default:						      case Default:
<       case Normal:						      case Normal:
<         if (1 < nInserts) {					        if (1 < nInserts) {
<           fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n)	          fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n)
<         } else {						        } else {
<           fprintf (stdout, "%da%d\n", o, boInserts + 1);	          fprintf (stdout, "%da%d\n", o, boInserts + 1);
<         }							        }
<         for (unsigned l = boInserts; l < n; l += 1) {		        for (unsigned l = boInserts; l < n; l += 1) {
<           fprintf (stdout, "> %s", lines[1][l].line->c_str ()	          fprintf (stdout, "> %s", lines[1][l].line->c_str ()
<         }							        }
<         break;							        break;
<       case Unified:						      case Unified:
<         for (unsigned l = boInserts; l < n; l += 1) {		        for (unsigned l = boInserts; l < n; l += 1) {
<           fprintf (stdout, "+%s", lines[1][l].line->c_str ())	          fprintf (stdout, "+%s", lines[1][l].line->c_str ())
<         }							        }
<         break;							        break;
<       }								      }
<     }								    }
< 
<     // When we get here, we're dealing with matching lines.	    // When we get here, we're dealing with matching lines.
< 
<     switch (diffFormat) {					    switch (diffFormat) {
<     case Default:						    case Default:
<     case Normal:						    case Normal:
<       break;							      break;
<     case Unified:						    case Unified:
<       fprintf (stdout, " %s", lines[0][o].line->c_str ());	      fprintf (stdout, " %s", lines[0][o].line->c_str ());
<       break;							      break;
<     }								    }
<     o += 1;							    o += 1;
<     n += 1;							    n += 1;
<   }								  }
< }								}
---
> #include <algorithm>                                            #include <algorithm>
> using std::find;                                                using std::find;
> #include <string>                                               #include <string>
> using std::string;                                              using std::string;
> #include <list>                                                 #include <list>
> using std::list;                                                using std::list;
> #include <map>                                                  #include <map>
> using std::map;                                                 using std::map;
> #include <vector>                                               #include <vector>
> using std::vector;                                              using std::vector;
> #include <stdio.h>                                              #include <stdio.h>
>                                                                 
> enum DiffFormat {                                               enum DiffFormat {
>   Default,                                                        Default,
>                                                                 
>   Context,                                                        Context,
>   EdScript,                                                       EdScript,
>   IfThenElse,                                                     IfThenElse,
>   Normal,                                                         Normal,
>   RCS,                                                            RCS,
>   SideBySide,                                                     SideBySide,
>   Unified                                                         Unified
> };                                                              };
>                                                                 
> DiffFormat diffFormat = Unified;                                DiffFormat diffFormat = Unified;
>                                                                 
> int optVerbose = 1;                                             int optVerbose = 1;
>                                                                 
> struct Line : public string {                                   struct Line : public string {
>   Line (string _text) :                                           Line (string _text) :
>     string (_text)                                                  string (_text)
>   {                                                               {
>   }                                                               }
>   ~Line () {                                                      ~Line () {
>     copies[0].erase (copies[0].begin (), copies[0].end ());         copies[0].erase (copies[0].begin (), copies[0].end ());
>     copies[1].erase (copies[1].begin (), copies[1].end ());         copies[1].erase (copies[1].begin (), copies[1].end ());
>   }                                                               }
>   void Dump (FILE *out) {                                         void Dump (FILE *out) {
>     fprintf (out, "{{ ");                                           fprintf (out, "{{ ");
>     for (list<unsigned>::iterator i = copies[0].begin (); i !       for (list<unsigned>::iterator i = copies[0].begin (); i !
>       fprintf (out, "%u ", *i);                                       fprintf (out, "%u ", *i);
>     }                                                               }
>     fprintf (out, "},{ ");                                          fprintf (out, "},{ ");
>     for (list<unsigned>::iterator i = copies[1].begin (); i !       for (list<unsigned>::iterator i = copies[1].begin (); i !
>       fprintf (out, "%u ", *i);                                       fprintf (out, "%u ", *i);
>     }                                                               }
>     fprintf (out, "}}\t%s", c_str ());                              fprintf (out, "}}\t%s", c_str ());
>   }                                                               }
>   list<unsigned> copies[2];                                       list<unsigned> copies[2];
> };                                                              };
>                                                                 
> struct LinePtr {                                                struct LinePtr {
>   LinePtr (Line *_line) :                                         LinePtr (Line *_line) :
>     line (_line),                                                   line (_line),
>     l (~0u)                                                         l (~0u)
>   {                                                               {
>   }                                                               }
>   void Dump (FILE *out) {                                         void Dump (FILE *out) {
>     fprintf (out, "[%d] ", l);                                      fprintf (out, "[%d] ", l);
>     line->Dump (out);                                               line->Dump (out);
>   }                                                               }
>   Line *line;                                                     Line *line;
>   unsigned l;                                                     unsigned l;
> };                                                              };
>                                                                 
> typedef map<string, Line *> MapStringToLinePtr;                 typedef map<string, Line *> MapStringToLinePtr;
> typedef vector<LinePtr> VectorLinePtr;                          typedef vector<LinePtr> VectorLinePtr;
>                                                                 
> char *ARGV0 = "dif2";                                           char *ARGV0 = "dif2";
>                                                                 
> int main (int argc, char *argv[])                               int main (int argc, char *argv[])
> {                                                               {
>   char const *files[2] = { 0, 0 };                                char const *files[2] = { 0, 0 };
>                                                                 
>   MapStringToLinePtr table;                                       MapStringToLinePtr table;
>   VectorLinePtr lines[2];                                         VectorLinePtr lines[2];
>                                                                 
>   unsigned nTotalMatchedBlocks = 0;                               unsigned nTotalMatchedBlocks = 0;
>   unsigned nMatchedBlocks = 0;                                    unsigned nMatchedBlocks = 0;
>   unsigned nTotalMatchedLines = 0;                                unsigned nTotalMatchedLines = 0;
>   unsigned nMatchedLines = 0;                                     unsigned nMatchedLines = 0;
>                                                                 
>   // Read the old [0] file, and the new [1] file.                 // Read the old [0] file, and the new [1] file.
>                                                                 
>   for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {     for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
>     files[n] = argv[a];                                             files[n] = argv[a];
>                                                                 
>     if (FILE *f = fopen (files[n], "r")) {                          if (FILE *f = fopen (files[n], "r")) {
>       if (0 < optVerbose) {                                           if (0 < optVerbose) {
>         fprintf (stderr, "# Reading %s...", files[n]);                  fprintf (stderr, "# Reading %s...", files[n]);
>       }                                                               }
>                                                                 
>       char buffer[1024];                                              char buffer[1024];
>       unsigned nUniq = 0;                                             unsigned nUniq = 0;
>                                                                 
>       while (fgets (buffer, sizeof (buffer), f)) {                    while (fgets (buffer, sizeof (buffer), f)) {
>         string text (buffer);                                           string text (buffer);
>                                                                 
>         Line *line = table[text];                                       Line *line = table[text];
>                                                                 
>         if (!line) {                                                    if (!line) {
>           table[text] = line = new Line (text);                           table[text] = line = new Line (text);
>           nUniq += 1;                                                     nUniq += 1;
>         }                                                               }
>         line->copies[n].push_back (lines[n].size ());                   line->copies[n].push_back (lines[n].size ());
>         lines[n].push_back (line);                                      lines[n].push_back (line);
>       }                                                               }
>                                                                 
>       if (0 < optVerbose) {                                           if (0 < optVerbose) {
>         fprintf (stderr, " %u lines, %u unique.\n", lines[n].           fprintf (stderr, " %u lines, %u unique.\n", lines[n].
>       }                                                               }
>     } else {                                                        } else {
>       fprintf (stderr, "%s: Unable to open %s!  Exiting....\n         fprintf (stderr, "%s: Unable to open %s!  Exiting....\n
>       perror (ARGV0);                                                 perror (ARGV0);
>       exit (1);                                                       exit (1);
>     }                                                               }
>   }                                                               }
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     printf ("# Total unique lines = %d\n", table.size ());          printf ("# Total unique lines = %d\n", table.size ());
>   }                                                               }
>                                                                 
>   // map<int, int> counts;                                        // map<int, int> counts;
>   // for (MapStringToLinePtr::iterator i = table.begin (); i      // for (MapStringToLinePtr::iterator i = table.begin (); i 
>   //   Line *l = i->second;                                       //   Line *l = i->second;
>   //   counts[l->counts[0].size () + l->counts[1].size ()] +=     //   counts[l->counts[0].size () + l->counts[1].size ()] +=
>   // }                                                            // }
>   // for (map<int, int>::iterator i = counts.begin (); i != c     // for (map<int, int>::iterator i = counts.begin (); i != c
>   //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s     //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s
>   // }                                                            // }
>                                                                 
>   // Perform pass #1, in which we find all explicit matches a     // Perform pass #1, in which we find all explicit matches a
>   // the unique lines.  For every unique line that appears th     // the unique lines.  For every unique line that appears th
>   // number of times in both files, we declare the lines to m     // number of times in both files, we declare the lines to m
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Pass 1 (finding matches amongst uniqu       fprintf (stderr, "# Pass 1 (finding matches amongst uniqu
>   }                                                               }
>                                                                 
>   nMatchedLines = 0;                                              nMatchedLines = 0;
>                                                                 
>   for (MapStringToLinePtr::iterator i = table.begin (); i !=      for (MapStringToLinePtr::iterator i = table.begin (); i != 
>     Line *l = i->second;                                            Line *l = i->second;
>                                                                 
>     // If the number of old and new lines match, then we decl       // If the number of old and new lines match, then we decl
>     // they are (all) the same line.  Note, it isn't possible       // they are (all) the same line.  Note, it isn't possible
>     // numbers of both files to be 0.                               // numbers of both files to be 0.
>                                                                 
>     // (In the original algorithm, we only recognized a match       // (In the original algorithm, we only recognized a match
>     // if there was exactly 1 copy for each file.)                  // if there was exactly 1 copy for each file.)
>                                                                 
>     if (l->copies[0].size () == l->copies[1].size ()) {             if (l->copies[0].size () == l->copies[1].size ()) {
>       nMatchedLines += 1;                                             nMatchedLines += 1;
>                                                                 
>       // For each matched line in the new file, mark it with          // For each matched line in the new file, mark it with 
>       // corresponding line (number) in the old file.                 // corresponding line (number) in the old file.
>                                                                 
>       while (!l->copies[0].empty ()) {                                while (!l->copies[0].empty ()) {
>         unsigned o = l->copies[0].front ();                             unsigned o = l->copies[0].front ();
>         unsigned n = l->copies[1].front ();                             unsigned n = l->copies[1].front ();
>                                                                 
>         // Match up the pair.                                           // Match up the pair.
>                                                                 
>         lines[0][o].l = n;                                              lines[0][o].l = n;
>         lines[1][n].l = o;                                              lines[1][n].l = o;
>                                                                 
>         // Remove the matched line numbers from the lists.              // Remove the matched line numbers from the lists.
>                                                                 
>         l->copies[0].pop_front ();                                      l->copies[0].pop_front ();
>         l->copies[1].pop_front ();                                      l->copies[1].pop_front ();
>       }                                                               }
>     }                                                               }
>   }                                                               }
>   nTotalMatchedLines += nMatchedLines;                            nTotalMatchedLines += nMatchedLines;
>                                                                 
>   // Let's see the intermediate results.                          // Let's see the intermediate results.
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, " found %u matched lines (%u total).\n",       fprintf (stderr, " found %u matched lines (%u total).\n",
>                                                                 
>     if (1 < optVerbose) {                                           if (1 < optVerbose) {
>       for (int f = 0; f < 2; f += 1) {                                for (int f = 0; f < 2; f += 1) {
>         fprintf (stderr, "# file #%d\n", f + 1);                        fprintf (stderr, "# file #%d\n", f + 1);
>         for (int l = 0; l < lines[f].size (); l += 1) {                 for (int l = 0; l < lines[f].size (); l += 1) {
>           fprintf (stderr, "#   [%d] ", l);                               fprintf (stderr, "#   [%d] ", l);
>           lines[f][l].Dump (stderr);                                      lines[f][l].Dump (stderr);
>         }                                                               }
>       }                                                               }
>     }                                                               }
>   }                                                               }
>                                                                 
>   // Perform Pass #2, in which we attempt to 'widen' blocks o     // Perform Pass #2, in which we attempt to 'widen' blocks o
>   // lines, by appending lines which are the same in both fil     // lines, by appending lines which are the same in both fil
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Pass #2 (spreading matches down)...")       fprintf (stderr, "# Pass #2 (spreading matches down)...")
>   }                                                               }
>                                                                 
>   nMatchedBlocks = 0;                                             nMatchedBlocks = 0;
>   nMatchedLines = 0;                                              nMatchedLines = 0;
>                                                                 
>   // Starting at the top of the old file,...                      // Starting at the top of the old file,...
>                                                                 
>   for (unsigned o = 0; o < lines[0].size (); o += 1) {            for (unsigned o = 0; o < lines[0].size (); o += 1) {
>                                                                 
>     // ... skip any currently unmatched lines...                    // ... skip any currently unmatched lines...
>                                                                 
>     if (lines[0][o].l == ~0) {                                      if (lines[0][o].l == ~0) {
>       continue;                                                       continue;
>     }                                                               }
>                                                                 
>     // ... until we find an [already] matched line.  Then, sk       // ... until we find an [already] matched line.  Then, sk
>     // the set of 1 or more matched lines, until we reach any       // the set of 1 or more matched lines, until we reach any
>     // following, still-unmatched line.                             // following, still-unmatched line.
>                                                                 
>     unsigned n;                                                     unsigned n;
>     do {                                                            do {
>       n = lines[0][o].l + 1;                                          n = lines[0][o].l + 1;
>       o += 1;                                                         o += 1;
>     } while (o < lines[0].size () && lines[0][o].l != ~0);          } while (o < lines[0].size () && lines[0][o].l != ~0);
>                                                                 
>     // Now, o - 1 is the line number of the last matched old        // Now, o - 1 is the line number of the last matched old 
>     // n - 1 is the line number of the last matched new line.       // n - 1 is the line number of the last matched new line.
>     // to add new old and new lines, if they match.                 // to add new old and new lines, if they match.
>                                                                 
>     // Finally, attempt to add unmatched lines to the preceed       // Finally, attempt to add unmatched lines to the preceed
>     // matched set.                                                 // matched set.
>                                                                 
>     for (; o < lines[0].size () && lines[0][o].l == ~0; o +=        for (; o < lines[0].size () && lines[0][o].l == ~0; o += 
>                                                                 
>       // If the [next] pair of old and new lines aren't the s         // If the [next] pair of old and new lines aren't the s
>                                                                 
>       if (lines[0][o].line != lines[1][n].line) {                     if (lines[0][o].line != lines[1][n].line) {
>         break;                                                          break;
>       }                                                               }
>                                                                 
>       // Match up the pair.                                           // Match up the pair.
>                                                                 
>       lines[0][o].l = n;                                              lines[0][o].l = n;
>       lines[1][n].l = o;                                              lines[1][n].l = o;
>                                                                 
>       // Remove the matched line numbers form the lists.              // Remove the matched line numbers form the lists.
>                                                                 
>       Line *line = lines[0][o].line;                                  Line *line = lines[0][o].line;
>       list<unsigned> &oldCopies = line->copies[0];                    list<unsigned> &oldCopies = line->copies[0];
>       list<unsigned>::iterator oL = find (oldCopies.begin (),         list<unsigned>::iterator oL = find (oldCopies.begin (),
>       if (oL != oldCopies.end ()) {                                   if (oL != oldCopies.end ()) {
>         oldCopies.erase (oL);                                           oldCopies.erase (oL);
>       }                                                               }
>       list<unsigned> &newCopies = line->copies[0];                    list<unsigned> &newCopies = line->copies[0];
>       list<unsigned>::iterator nL = find (newCopies.begin (),         list<unsigned>::iterator nL = find (newCopies.begin (),
>       if (nL != newCopies.end ()) {                                   if (nL != newCopies.end ()) {
>         newCopies.erase (nL);                                           newCopies.erase (nL);
>       }                                                               }
>                                                                 
>       nMatchedLines += 1;                                             nMatchedLines += 1;
>     }                                                               }
>     nMatchedBlocks += 1;                                            nMatchedBlocks += 1;
>   }                                                               }
>   nTotalMatchedLines += nMatchedLines;                            nTotalMatchedLines += nMatchedLines;
>   nTotalMatchedBlocks += nMatchedBlocks;                          nTotalMatchedBlocks += nMatchedBlocks;
>                                                                 
>   // Let's see the intermediate results.                          // Let's see the intermediate results.
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr,                                                fprintf (stderr,
>              " found %u/%u matched lines/blocks (%u/%u totals                " found %u/%u matched lines/blocks (%u/%u totals
>              nMatchedLines,                                                  nMatchedLines,
>              nMatchedBlocks,                                                 nMatchedBlocks,
>              nTotalMatchedLines,                                             nTotalMatchedLines,
>              nTotalMatchedBlocks                                             nTotalMatchedBlocks
>             );                                                              );
>     if (1 < optVerbose) {                                           if (1 < optVerbose) {
>       for (int f = 0; f < 2; f += 1) {                                for (int f = 0; f < 2; f += 1) {
>         fprintf (stderr, "# file #%d\n", f + 1);                        fprintf (stderr, "# file #%d\n", f + 1);
>         for (int l = 0; l < lines[f].size (); l += 1) {                 for (int l = 0; l < lines[f].size (); l += 1) {
>           fprintf (stderr, "#   [%d] ", l);                               fprintf (stderr, "#   [%d] ", l);
>           lines[f][l].Dump (stderr);                                      lines[f][l].Dump (stderr);
>         }                                                               }
>       }                                                               }
>     }                                                               }
>   }                                                               }
>                                                                 
>   // Perform Pass #3, in which we attempt to 'widen' blocks o     // Perform Pass #3, in which we attempt to 'widen' blocks o
>   // lines, by prepending lines which are the same in both fi     // lines, by prepending lines which are the same in both fi
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Pass #3 (spreading matches up)...");        fprintf (stderr, "# Pass #3 (spreading matches up)...");
>   }                                                               }
>                                                                 
>   nMatchedBlocks = 0;                                             nMatchedBlocks = 0;
>   nMatchedLines = 0;                                              nMatchedLines = 0;
>                                                                 
>   // Starting at the bottom of the old file,...                   // Starting at the bottom of the old file,...
>                                                                 
>   for (int o = lines[0].size (); 0 <= o; o -= 1) {                for (int o = lines[0].size (); 0 <= o; o -= 1) {
>                                                                 
>     // ... skip any currently unmatched lines...                    // ... skip any currently unmatched lines...
>                                                                 
>     if (lines[0][o].l == ~0) {                                      if (lines[0][o].l == ~0) {
>       continue;                                                       continue;
>     }                                                               }
>                                                                 
>     // ... until we find an [already] matched line.  Then, sk       // ... until we find an [already] matched line.  Then, sk
>     // the set of 1 or more matched lines, until we reach any       // the set of 1 or more matched lines, until we reach any
>     // following, still-unmatched line.                             // following, still-unmatched line.
>                                                                 
>     unsigned n;                                                     unsigned n;
>     do {                                                            do {
>       n = lines[0][o].l - 1;                                          n = lines[0][o].l - 1;
>       o -= 1;                                                         o -= 1;
>     } while (0 <= o && lines[0][o].l != ~0);                        } while (0 <= o && lines[0][o].l != ~0);
>                                                                 
>     // Now, o + 1 is the line number of the last matched old        // Now, o + 1 is the line number of the last matched old 
>     // n + 1 is the line number of the last matched new line.       // n + 1 is the line number of the last matched new line.
>     // to add new old and new lines, if they match.                 // to add new old and new lines, if they match.
>                                                                 
>     // Finally, attempt to add unmatched lines to the preceed       // Finally, attempt to add unmatched lines to the preceed
>     // matched set.                                                 // matched set.
>                                                                 
>     for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {         for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
>                                                                 
>       // If the [next] pair of old and new lines aren't the s         // If the [next] pair of old and new lines aren't the s
>                                                                 
>       if (lines[0][o].line != lines[1][n].line) {                     if (lines[0][o].line != lines[1][n].line) {
>         break;                                                          break;
>       }                                                               }
>                                                                 
>       // Match up the pair.                                           // Match up the pair.
>                                                                 
>       lines[0][o].l = n;                                              lines[0][o].l = n;
>       lines[1][n].l = o;                                              lines[1][n].l = o;
>                                                                 
>       // Remove the matched line numbers form the lists.              // Remove the matched line numbers form the lists.
>                                                                 
>       Line *line = lines[0][o].line;                                  Line *line = lines[0][o].line;
>       list<unsigned> &oldCopies = line->copies[0];                    list<unsigned> &oldCopies = line->copies[0];
>       list<unsigned>::iterator oL = find (oldCopies.begin (),         list<unsigned>::iterator oL = find (oldCopies.begin (),
>       if (oL != oldCopies.end ()) {                                   if (oL != oldCopies.end ()) {
>         oldCopies.erase (oL);                                           oldCopies.erase (oL);
>       }                                                               }
>       list<unsigned> &newCopies = line->copies[0];                    list<unsigned> &newCopies = line->copies[0];
>       list<unsigned>::iterator nL = find (newCopies.begin (),         list<unsigned>::iterator nL = find (newCopies.begin (),
>       if (nL != newCopies.end ()) {                                   if (nL != newCopies.end ()) {
>         newCopies.erase (nL);                                           newCopies.erase (nL);
>       }                                                               }
>                                                                 
>       nMatchedLines += 1;                                             nMatchedLines += 1;
>     }                                                               }
>     nMatchedBlocks += 1;                                            nMatchedBlocks += 1;
>   }                                                               }
>   nTotalMatchedLines += nMatchedLines;                            nTotalMatchedLines += nMatchedLines;
>                                                                 
>   // Let's see the intermediate results.                          // Let's see the intermediate results.
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr,                                                fprintf (stderr,
>              " found %u/%u matched lines/blocks (%u/%u totals                " found %u/%u matched lines/blocks (%u/%u totals
>              nMatchedLines,                                                  nMatchedLines,
>              nMatchedBlocks,                                                 nMatchedBlocks,
>              nTotalMatchedLines,                                             nTotalMatchedLines,
>              nTotalMatchedBlocks                                             nTotalMatchedBlocks
>             );                                                              );
>                                                                 
>     if (1 < optVerbose) {                                           if (1 < optVerbose) {
>       for (int f = 0; f < 2; f += 1) {                                for (int f = 0; f < 2; f += 1) {
>         fprintf (stderr, "# file #%d\n", f + 1);                        fprintf (stderr, "# file #%d\n", f + 1);
>         for (int l = 0; l < lines[f].size (); l += 1) {                 for (int l = 0; l < lines[f].size (); l += 1) {
>           fprintf (stderr, "#   [%d] ", l);                               fprintf (stderr, "#   [%d] ", l);
>           lines[f][l].Dump (stderr);                                      lines[f][l].Dump (stderr);
>         }                                                               }
>       }                                                               }
>     }                                                               }
>   }                                                               }
>                                                                 
>   // Perform pass #4, in which we find any remaining matches      // Perform pass #4, in which we find any remaining matches 
>   // the unique lines.  For every unique line that has more t     // the unique lines.  For every unique line that has more t
>   // copy in both files, we declare the copies to match.          // copy in both files, we declare the copies to match.
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Pass 4 (finding remaining matches amo       fprintf (stderr, "# Pass 4 (finding remaining matches amo
>   }                                                               }
>                                                                 
>   nMatchedLines = 0;                                              nMatchedLines = 0;
>                                                                 
>   for (MapStringToLinePtr::iterator i = table.begin (); i !=      for (MapStringToLinePtr::iterator i = table.begin (); i != 
>     Line *l = i->second;                                            Line *l = i->second;
>                                                                 
>     // If there's more than 1 matching old and new lines, the       // If there's more than 1 matching old and new lines, the
>     // declare that each pair are (all) the same line.              // declare that each pair are (all) the same line.
>                                                                 
>     // (In the original algorithm, we only recognized a match       // (In the original algorithm, we only recognized a match
>     // if there was exactly 1 copy for each file.)                  // if there was exactly 1 copy for each file.)
>                                                                 
>     while (0 < l->copies[0].size () && 0 < l->copies[1].size        while (0 < l->copies[0].size () && 0 < l->copies[1].size 
>       nMatchedLines += 1;                                             nMatchedLines += 1;
>                                                                 
>       // For each matched line in the new file, mark it with          // For each matched line in the new file, mark it with 
>       // corresponding line (number) in the old file.                 // corresponding line (number) in the old file.
>                                                                 
>       unsigned o = l->copies[0].front ();                             unsigned o = l->copies[0].front ();
>       unsigned n = l->copies[1].front ();                             unsigned n = l->copies[1].front ();
>                                                                 
>       // Match up the pair.                                           // Match up the pair.
>                                                                 
>       lines[0][o].l = n;                                              lines[0][o].l = n;
>       lines[1][n].l = o;                                              lines[1][n].l = o;
>                                                                 
>       // Remove the matched line numbers from the lists.              // Remove the matched line numbers from the lists.
>                                                                 
>       l->copies[0].pop_front ();                                      l->copies[0].pop_front ();
>       l->copies[1].pop_front ();                                      l->copies[1].pop_front ();
>     }                                                               }
>   }                                                               }
>   nTotalMatchedLines += nMatchedLines;                            nTotalMatchedLines += nMatchedLines;
>                                                                 
>   // Let's see the intermediate results.                          // Let's see the intermediate results.
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, " found %u matched lines (%u total).\n",       fprintf (stderr, " found %u matched lines (%u total).\n",
>                                                                 
>     if (1 < optVerbose) {                                           if (1 < optVerbose) {
>       for (int f = 0; f < 2; f += 1) {                                for (int f = 0; f < 2; f += 1) {
>         fprintf (stderr, "# file #%d\n", f + 1);                        fprintf (stderr, "# file #%d\n", f + 1);
>         for (int l = 0; l < lines[f].size (); l += 1) {                 for (int l = 0; l < lines[f].size (); l += 1) {
>           fprintf (stderr, "#   [%d] ", l);                               fprintf (stderr, "#   [%d] ", l);
>           lines[f][l].Dump (stderr);                                      lines[f][l].Dump (stderr);
>         }                                                               }
>       }                                                               }
>     }                                                               }
>   }                                                               }
>                                                                 
>   // Perform Pass #5, in which we look for blocks which match     // Perform Pass #5, in which we look for blocks which match
>   // the result of a move (their not in their original positi     // the result of a move (their not in their original positi
>   // these, we'll unmatch the blocks, turning them into a del     // these, we'll unmatch the blocks, turning them into a del
>   // an insert.                                                   // an insert.
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Pass #5 (unmatching block moves)...\n       fprintf (stderr, "# Pass #5 (unmatching block moves)...\n
>   }                                                               }
>                                                                 
>   nMatchedBlocks = 0;                                             nMatchedBlocks = 0;
>   nMatchedLines = 0;                                              nMatchedLines = 0;
>                                                                 
>   // Starting at the top of both files,...                        // Starting at the top of both files,...
>                                                                 
>   unsigned o = 0;                                                 unsigned o = 0;
>   unsigned n = 0;                                                 unsigned n = 0;
>                                                                 
>   while (o < lines[0].size () || n < lines[1].size ()) {          while (o < lines[0].size () || n < lines[1].size ()) {
>                                                                 
>     // Skip any unmatched lines at this point in the old file       // Skip any unmatched lines at this point in the old file
>     // are deletes.                                                 // are deletes.
>                                                                 
>     //    Old     New                                               //    Old     New
>     //   +---+                                                      //   +---+
>     // 0 | a |                                                      // 0 | a |
>     //   +---+   +---+                                              //   +---+   +---+
>     //         0 | b |                                              //         0 | b |
>     //   +---+   +---+                                              //   +---+   +---+
>     // 1 | c | 1 | c |                                              // 1 | c | 1 | c |
>     //   +---+   +---+                                              //   +---+   +---+
>     //         2 | z |                                              //         2 | z |
>     //   +---+   +---+                                              //   +---+   +---+
>     // 2 | d | 3 | d |                                              // 2 | d | 3 | d |
>     //   +---+   +---+                                              //   +---+   +---+
>                                                                 
>     while (o < lines[0].size () && lines[0][o].l == ~0) {           while (o < lines[0].size () && lines[0][o].l == ~0) {
>       o += 1;                                                         o += 1;
>     }                                                               }
>                                                                 
>     // Skip any unmatched lines at this point in the new file       // Skip any unmatched lines at this point in the new file
>     // are inserts.                                                 // are inserts.
>                                                                 
>     while (n < lines[1].size () && lines[1][n].l == ~0) {           while (n < lines[1].size () && lines[1][n].l == ~0) {
>       n += 1;                                                         n += 1;
>     }                                                               }
>                                                                 
>     // When we get here, we know that we're dealing with matc       // When we get here, we know that we're dealing with matc
>     // lines (or the end of one or both files).  We're done w       // lines (or the end of one or both files).  We're done w
>     // pass, if we've reached the end of either file.               // pass, if we've reached the end of either file.
>                                                                 
>     if (lines[0].size () <= o || lines[1].size () <= n) {           if (lines[0].size () <= o || lines[1].size () <= n) {
>       break;                                                          break;
>     }                                                               }
>                                                                 
>     // We now know that we've got a pair of matching lines, t       // We now know that we've got a pair of matching lines, t
>     // of a matching block.  If the new file's line number is       // of a matching block.  If the new file's line number is
>     // expect, then the matched pair is unmoved, and we can s       // expect, then the matched pair is unmoved, and we can s
>     // the pair.  (If this is really the start of a block of        // the pair.  (If this is really the start of a block of 
>     // 1 lines, we'll handle it one pair at a time.)                // 1 lines, we'll handle it one pair at a time.)
>                                                                 
>     if (lines[0][o].l == n) {                                       if (lines[0][o].l == n) {
>       o += 1;                                                         o += 1;
>       n += 1;                                                         n += 1;
>       continue;                                                       continue;
>     }                                                               }
>                                                                 
>     // If, on the other hand, we don't expect this [new] line       // If, on the other hand, we don't expect this [new] line
>     // then this matching block has been moved.  We need to t       // then this matching block has been moved.  We need to t
>     // matched pair into an *unmatched* pair, one of deletes,       // matched pair into an *unmatched* pair, one of deletes,
>     // of inserts.  First, though, we need to know how big th       // of inserts.  First, though, we need to know how big th
>     // is, and how far it was moved....                             // is, and how far it was moved....
>                                                                 
>     // Remember where we were when we started.                      // Remember where we were when we started.
>                                                                 
>     unsigned oOld = o;                                              unsigned oOld = o;
>     unsigned nOld = n;                                              unsigned nOld = n;
>                                                                 
>     // Remember where the block came from.                          // Remember where the block came from.
>                                                                 
>     unsigned nNew = lines[0][o].l;                                  unsigned nNew = lines[0][o].l;
>                                                                 
>     // Find the end of this matched pair.                           // Find the end of this matched pair.
>                                                                 
>     for (n = nNew; o < lines[0].size () && n < lines[1].size        for (n = nNew; o < lines[0].size () && n < lines[1].size 
>       if (lines[0][o].l != n) {                                       if (lines[0][o].l != n) {
>         break;                                                          break;
>       }                                                               }
>     }                                                               }
>                                                                 
>     // When we get here:                                            // When we get here:
>     // * oOld..o is the old file's block,                           // * oOld..o is the old file's block,
>     // * nNew..n is the new file's *moved* block, and               // * nNew..n is the new file's *moved* block, and
>     // * nOld is where we originally expected the new block f       // * nOld is where we originally expected the new block f
>                                                                  
>     // We can now calculate the length of the block...              // We can now calculate the length of the block...
>                                                                     
>     unsigned bSize = o - oOld;  // (or n - nNew)                    unsigned bSize = o - oOld;  // (or n - nNew)
>                                                                 
>     // ... and we can calculate how far the block moved:            // ... and we can calculate how far the block moved:
>                                                                 
>     unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;       unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
>                                                                 
>     // The larger of the two will become our delete, and the        // The larger of the two will become our delete, and the 
>     // will become our insert.                                      // will become our insert.
>                                                                 
>     //    Old     New                                               //    Old     New
>     //   +---+   +---+                                              //   +---+   +---+
>     // 0 | a | 0 | b |                                              // 0 | a | 0 | b |
>     //   +---+ 1 | b |                                              //   +---+ 1 | b |
>     // 1 | b |   +---+                                              // 1 | b |   +---+
>     // 2 | b | 2 | a |                                              // 2 | b | 2 | a |
>     //   +---+   +---+                                              //   +---+   +---+
>     // 3 | c | 3 | c |                                              // 3 | c | 3 | c |
>     //   +---+   +---+                                              //   +---+   +---+
>                                                                 
>     // (1) Delete a@0, insert a@2, or                               // (1) Delete a@0, insert a@2, or
>     // (2) insert bb@0, delete bb@1?                                // (2) insert bb@0, delete bb@1?
>                                                                 
>     // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and       // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and
>     // (of a) is 2-0 or 2, the size of b@0.  We choose to del       // (of a) is 2-0 or 2, the size of b@0.  We choose to del
>     // and reinsert a@2.                                            // and reinsert a@2.
>                                                                 
>     // if (bSize <= bMove) {                                        // if (bSize <= bMove) {
>       for (unsigned a = oOld; a < o; a += 1) {                        for (unsigned a = oOld; a < o; a += 1) {
>         lines[0][a].l = ~0;                                             lines[0][a].l = ~0;
>       }                                                               }
>       for (unsigned d = nNew; d < n; d += 1) {                        for (unsigned d = nNew; d < n; d += 1) {
>         lines[1][d].l = ~0;                                             lines[1][d].l = ~0;
>       }                                                               }
>     // } else {                                                     // } else {
>       // for (unsigned a = oOld; a < o; a += 1) {                     // for (unsigned a = oOld; a < o; a += 1) {
>       //   lines[0][a].l = ~0;                                        //   lines[0][a].l = ~0;
>       // }                                                            // }
>       // for (unsigned d = nNew; d < n; d += 1) {                     // for (unsigned d = nNew; d < n; d += 1) {
>       //   lines[1][d].l = ~0;                                        //   lines[1][d].l = ~0;
>       // }                                                            // }
>     // }                                                            // }
>                                                                 
>     // Continue from where we left off.                             // Continue from where we left off.
>                                                                 
>     n = nOld;                                                       n = nOld;
>   }                                                               }
>   nTotalMatchedLines -= nMatchedLines;                            nTotalMatchedLines -= nMatchedLines;
>   nTotalMatchedBlocks -= nMatchedBlocks;                          nTotalMatchedBlocks -= nMatchedBlocks;
>                                                                 
>   // Let's see the intermediate results.                          // Let's see the intermediate results.
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr,                                                fprintf (stderr,
>              " found %u/%u matched lines/blocks (%u/%u totals                " found %u/%u matched lines/blocks (%u/%u totals
>              nMatchedLines,                                                  nMatchedLines,
>              nMatchedBlocks,                                                 nMatchedBlocks,
>              nTotalMatchedLines,                                             nTotalMatchedLines,
>              nTotalMatchedBlocks                                             nTotalMatchedBlocks
>             );                                                              );
>                                                                 
>     if (1 < optVerbose) {                                           if (1 < optVerbose) {
>       for (int f = 0; f < 2; f += 1) {                                for (int f = 0; f < 2; f += 1) {
>         fprintf (stderr, "# file #%d\n", f + 1);                        fprintf (stderr, "# file #%d\n", f + 1);
>         for (int l = 0; l < lines[f].size (); l += 1) {                 for (int l = 0; l < lines[f].size (); l += 1) {
>           fprintf (stderr, "#   [%d] ", l);                               fprintf (stderr, "#   [%d] ", l);
>           lines[f][l].Dump (stderr);                                      lines[f][l].Dump (stderr);
>         }                                                               }
>       }                                                               }
>     }                                                               }
>   }                                                               }
>                                                                 
>   // Perform Pass #6, in which we create the desired output.      // Perform Pass #6, in which we create the desired output.
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Pass #6 (walking the differences)...\       fprintf (stderr, "# Pass #6 (walking the differences)...\
>   }                                                               }
>                                                                 
>   nMatchedLines = 0;                                              nMatchedLines = 0;
>                                                                 
>   // Write the header.                                            // Write the header.
>                                                                 
>   switch (diffFormat) {                                           switch (diffFormat) {
>   case Default:                                                   case Default:
>   case Normal:                                                    case Normal:
>     break;                                                          break;
>   case Unified:                                                   case Unified:
>     fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00       fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00
>     fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00       fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00
>     fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (),       fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (),
>     break;                                                          break;
>   }                                                               }
>                                                                 
>   // Starting at the top of both files,...                        // Starting at the top of both files,...
>                                                                 
>   o = 0;                                                          o = 0;
>   n = 0;                                                          n = 0;
>                                                                 
>   while (o < lines[0].size () || n < lines[1].size ()) {          while (o < lines[0].size () || n < lines[1].size ()) {
>                                                                 
>     // Find any unmatched lines at this point in the old file       // Find any unmatched lines at this point in the old file
>     // are deletes.                                                 // are deletes.
>                                                                 
>     unsigned boDeletes;                                             unsigned boDeletes;
>     for (boDeletes = o;                                             for (boDeletes = o;
>          o < lines[0].size () && lines[0][o].l == ~0;                    o < lines[0].size () && lines[0][o].l == ~0;
>          o += 1                                                          o += 1
>         )                                                               )
>     {}                                                              {}
>                                                                 
>     // Find any unmatched lines at this point in the new file       // Find any unmatched lines at this point in the new file
>     // are inserts.                                                 // are inserts.
>                                                                 
>     unsigned boInserts;                                             unsigned boInserts;
>     for (boInserts = n;                                             for (boInserts = n;
>          n < lines[1].size () && lines[1][n].l == ~0;                    n < lines[1].size () && lines[1][n].l == ~0;
>          n += 1                                                          n += 1
>         )                                                               )
>     {}                                                              {}
>                                                                 
>     // We've got deleted line(s) from boDeletes .. o.               // We've got deleted line(s) from boDeletes .. o.
>     // We've got deleted line(s) from boInserts .. n.               // We've got deleted line(s) from boInserts .. n.
>                                                                 
>     unsigned nDeletes = o - boDeletes;                              unsigned nDeletes = o - boDeletes;
>     unsigned nInserts = n - boInserts;                              unsigned nInserts = n - boInserts;
>                                                                 
>     // We've got...                                                 // We've got...
>                                                                 
>     if (nDeletes && nInserts) {                                     if (nDeletes && nInserts) {
>                                                                 
>       // ... deletes and inserts.                                     // ... deletes and inserts.
>                                                                 
>       switch (diffFormat) {                                           switch (diffFormat) {
>       case Default:                                                   case Default:
>       case Normal:                                                    case Normal:
>         if (1 < nDeletes && 1 < nInserts) {                             if (1 < nDeletes && 1 < nInserts) {
>           fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o,             fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o,
>         } else if (1 < nDeletes) {                                      } else if (1 < nDeletes) {
>           fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, bo             fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, bo
>         } else if (1 < nInserts) {                                      } else if (1 < nInserts) {
>           fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boIns             fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boIns
>         }                                                               } 
>         for (unsigned l = boDeletes; l < o; l += 1) {                   for (unsigned l = boDeletes; l < o; l += 1) {
>           fprintf (stdout, "< %s", lines[0][l].line->c_str ()             fprintf (stdout, "< %s", lines[0][l].line->c_str ()
>         }                                                               }
>         fprintf (stderr, "---\n");                                      fprintf (stderr, "---\n");
>         for (unsigned l = boInserts; l < n; l += 1) {                   for (unsigned l = boInserts; l < n; l += 1) {
>           fprintf (stdout, "> %s", lines[1][l].line->c_str ()             fprintf (stdout, "> %s", lines[1][l].line->c_str ()
>         }                                                               }
>         break;                                                          break;
>                                                                 
>       case Unified:                                                   case Unified:
>         for (unsigned l = boDeletes; l < o; l += 1) {                   for (unsigned l = boDeletes; l < o; l += 1) {
>           fprintf (stdout, "-%s", lines[0][l].line->c_str ())             fprintf (stdout, "-%s", lines[0][l].line->c_str ())
>         }                                                               }
>         for (unsigned l = boInserts; l < n; l += 1) {                   for (unsigned l = boInserts; l < n; l += 1) {
>           fprintf (stdout, "+%s", lines[1][l].line->c_str ())             fprintf (stdout, "+%s", lines[1][l].line->c_str ())
>         }                                                               }
>         break;                                                          break;
>       }                                                               }
>     } else if (nDeletes) {                                          } else if (nDeletes) {
>                                                                 
>       //  ... just deletes.                                           //  ... just deletes.
>                                                                 
>       switch (diffFormat) {                                           switch (diffFormat) {
>       case Default:                                                   case Default:
>       case Normal:                                                    case Normal:
>         if (1 < nDeletes) {                                             if (1 < nDeletes) {
>           fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n)             fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n)
>         } else {                                                        } else {
>           fprintf (stdout, "%dd%d\n", boDeletes + 1, n);                  fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
>         }                                                               }
>         for (unsigned l = boDeletes; l < o; l += 1) {                   for (unsigned l = boDeletes; l < o; l += 1) {
>           fprintf (stdout, "< %s", lines[0][l].line->c_str ()             fprintf (stdout, "< %s", lines[0][l].line->c_str ()
>         }                                                               }
>         break;                                                          break;
>       case Unified:                                                   case Unified:
>         for (unsigned l = boDeletes; l < o; l += 1) {                   for (unsigned l = boDeletes; l < o; l += 1) {
>           fprintf (stdout, "-%s", lines[0][l].line->c_str ())             fprintf (stdout, "-%s", lines[0][l].line->c_str ())
>         }                                                               }
>         break;                                                          break;
>       }                                                               }
>     } else if (nInserts) {                                          } else if (nInserts) {
>                                                                 
>       //  ... just inserts.                                           //  ... just inserts.
>                                                                 
>       switch (diffFormat) {                                           switch (diffFormat) {
>       case Default:                                                   case Default:
>       case Normal:                                                    case Normal:
>         if (1 < nInserts) {                                             if (1 < nInserts) {
>           fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n)             fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n)
>         } else {                                                        } else {
>           fprintf (stdout, "%da%d\n", o, boInserts + 1);                  fprintf (stdout, "%da%d\n", o, boInserts + 1);
>         }                                                               }
>         for (unsigned l = boInserts; l < n; l += 1) {                   for (unsigned l = boInserts; l < n; l += 1) {
>           fprintf (stdout, "> %s", lines[1][l].line->c_str ()             fprintf (stdout, "> %s", lines[1][l].line->c_str ()
>         }                                                               }
>         break;                                                          break;
>       case Unified:                                                   case Unified:
>         for (unsigned l = boInserts; l < n; l += 1) {                   for (unsigned l = boInserts; l < n; l += 1) {
>           fprintf (stdout, "+%s", lines[1][l].line->c_str ())             fprintf (stdout, "+%s", lines[1][l].line->c_str ())
>         }                                                               }
>         break;                                                          break;
>       }                                                               }
>     }                                                               }
>                                                                 
>     // When we get here, we're dealing with matching lines.         // When we get here, we're dealing with matching lines.
>                                                                 
>     switch (diffFormat) {                                           switch (diffFormat) {
>     case Default:                                                   case Default:
>     case Normal:                                                    case Normal:
>       break;                                                          break;
>     case Unified:                                                   case Unified:
>       fprintf (stdout, " %s", lines[0][o].line->c_str ());            fprintf (stdout, " %s", lines[0][o].line->c_str ());
>       break;                                                          break;
>     }                                                               }
>     o += 1;                                                         o += 1;
>     n += 1;                                                         n += 1;
>   }                                                               }
> }                                                               }
# ../sdiff -y dif.4.cpp dif.3.cpp >& dif.4.3.diff-y.test
# dif.4.3.diff-y ---------------------------------------------------------------
1,747c1,747
< #include <algorithm>						#include <algorithm>
< using std::find;						using std::find;
< #include <string>						#include <string>
< using std::string;						using std::string;
< #include <list>							#include <list>
< using std::list;						using std::list;
< #include <map>							#include <map>
< using std::map;							using std::map;
< #include <vector>						#include <vector>
< using std::vector;						using std::vector;
< #include <stdio.h>						#include <stdio.h>
< 
< enum DiffFormat {						enum DiffFormat {
<   Default,							  Default,
< 
<   Context,							  Context,
<   EdScript,							  EdScript,
<   IfThenElse,							  IfThenElse,
<   Normal,							  Normal,
<   RCS,								  RCS,
<   SideBySide,							  SideBySide,
<   Unified							  Unified
< };								};
< 
< DiffFormat diffFormat = Unified;				DiffFormat diffFormat = Unified;
< 
< int optVerbose = 1;						int optVerbose = 1;
< 
< struct Line : public string {					struct Line : public string {
<   Line (string _text) :						  Line (string _text) :
<     string (_text)						    string (_text)
<   {								  {
<   }								  }
<   ~Line () {							  ~Line () {
<     copies[0].erase (copies[0].begin (), copies[0].end ());	    copies[0].erase (copies[0].begin (), copies[0].end ());
<     copies[1].erase (copies[1].begin (), copies[1].end ());	    copies[1].erase (copies[1].begin (), copies[1].end ());
<   }								  }
<   void Dump (FILE *out) {					  void Dump (FILE *out) {
<     fprintf (out, "{{ ");					    fprintf (out, "{{ ");
<     for (list<unsigned>::iterator i = copies[0].begin (); i !	    for (list<unsigned>::iterator i = copies[0].begin (); i !
<       fprintf (out, "%u ", *i);					      fprintf (out, "%u ", *i);
<     }								    }
<     fprintf (out, "},{ ");					    fprintf (out, "},{ ");
<     for (list<unsigned>::iterator i = copies[1].begin (); i !	    for (list<unsigned>::iterator i = copies[1].begin (); i !
<       fprintf (out, "%u ", *i);					      fprintf (out, "%u ", *i);
<     }								    }
<     fprintf (out, "}}\t%s", c_str ());				    fprintf (out, "}}\t%s", c_str ());
<   }								  }
<   list<unsigned> copies[2];					  list<unsigned> copies[2];
< };								};
< 
< struct LinePtr {						struct LinePtr {
<   LinePtr (Line *_line) :					  LinePtr (Line *_line) :
<     line (_line),						    line (_line),
<     l (~0u)							    l (~0u)
<   {								  {
<   }								  }
<   void Dump (FILE *out) {					  void Dump (FILE *out) {
<     fprintf (out, "[%d] ", l);					    fprintf (out, "[%d] ", l);
<     line->Dump (out);						    line->Dump (out);
<   }								  }
<   Line *line;							  Line *line;
<   unsigned l;							  unsigned l;
< };								};
< 
< typedef map<string, Line *> MapStringToLinePtr;			typedef map<string, Line *> MapStringToLinePtr;
< typedef vector<LinePtr> VectorLinePtr;				typedef vector<LinePtr> VectorLinePtr;
< 
< char *ARGV0 = "dif2";						char *ARGV0 = "dif2";
< 
< int main (int argc, char *argv[])				int main (int argc, char *argv[])
< {								{
<   char const *files[2] = { 0, 0 };				  char const *files[2] = { 0, 0 };
< 
<   MapStringToLinePtr table;					  MapStringToLinePtr table;
<   VectorLinePtr lines[2];					  VectorLinePtr lines[2];
< 
<   unsigned nTotalMatchedBlocks = 0;				  unsigned nTotalMatchedBlocks = 0;
<   unsigned nMatchedBlocks = 0;					  unsigned nMatchedBlocks = 0;
<   unsigned nTotalMatchedLines = 0;				  unsigned nTotalMatchedLines = 0;
<   unsigned nMatchedLines = 0;					  unsigned nMatchedLines = 0;
< 
<   // Read the old [0] file, and the new [1] file.		  // Read the old [0] file, and the new [1] file.
< 
<   for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {	  for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
<     files[n] = argv[a];						    files[n] = argv[a];
< 
<     if (FILE *f = fopen (files[n], "r")) {			    if (FILE *f = fopen (files[n], "r")) {
<       if (0 < optVerbose) {					      if (0 < optVerbose) {
<         fprintf (stderr, "# Reading %s...", files[n]);		        fprintf (stderr, "# Reading %s...", files[n]);
<       }								      }
< 
<       char buffer[1024];					      char buffer[1024];
<       unsigned nUniq = 0;					      unsigned nUniq = 0;
< 
<       while (fgets (buffer, sizeof (buffer), f)) {		      while (fgets (buffer, sizeof (buffer), f)) {
<         string text (buffer);					        string text (buffer);
< 
<         Line *line = table[text];				        Line *line = table[text];
< 
<         if (!line) {						        if (!line) {
<           table[text] = line = new Line (text);			          table[text] = line = new Line (text);
<           nUniq += 1;						          nUniq += 1;
<         }							        }
<         line->copies[n].push_back (lines[n].size ());		        line->copies[n].push_back (lines[n].size ());
<         lines[n].push_back (line);				        lines[n].push_back (line);
<       }								      }
< 
<       if (0 < optVerbose) {					      if (0 < optVerbose) {
<         fprintf (stderr, " %u lines, %u unique.\n", lines[n].	        fprintf (stderr, " %u lines, %u unique.\n", lines[n].
<       }								      }
<     } else {							    } else {
<       fprintf (stderr, "%s: Unable to open %s!  Exiting....\n	      fprintf (stderr, "%s: Unable to open %s!  Exiting....\n
<       perror (ARGV0);						      perror (ARGV0);
<       exit (1);							      exit (1);
<     }								    }
<   }								  }
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     printf ("# Total unique lines = %d\n", table.size ());	    printf ("# Total unique lines = %d\n", table.size ());
<   }								  }
< 
<   // map<int, int> counts;					  // map<int, int> counts;
<   // for (MapStringToLinePtr::iterator i = table.begin (); i 	  // for (MapStringToLinePtr::iterator i = table.begin (); i 
<   //   Line *l = i->second;					  //   Line *l = i->second;
<   //   counts[l->counts[0].size () + l->counts[1].size ()] +=	  //   counts[l->counts[0].size () + l->counts[1].size ()] +=
<   // }								  // }
<   // for (map<int, int>::iterator i = counts.begin (); i != c	  // for (map<int, int>::iterator i = counts.begin (); i != c
<   //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s	  //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s
<   // }								  // }
< 
<   // Perform pass #1, in which we find all explicit matches a	  // Perform pass #1, in which we find all explicit matches a
<   // the unique lines.  For every unique line that appears th	  // the unique lines.  For every unique line that appears th
<   // number of times in both files, we declare the lines to m	  // number of times in both files, we declare the lines to m
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass 1 (finding matches amongst uniqu	    fprintf (stderr, "# Pass 1 (finding matches amongst uniqu
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   for (MapStringToLinePtr::iterator i = table.begin (); i != 	  for (MapStringToLinePtr::iterator i = table.begin (); i != 
<     Line *l = i->second;					    Line *l = i->second;
< 
<     // If the number of old and new lines match, then we decl	    // If the number of old and new lines match, then we decl
<     // they are (all) the same line.  Note, it isn't possible	    // they are (all) the same line.  Note, it isn't possible
<     // numbers of both files to be 0.				    // numbers of both files to be 0.
< 
<     // (In the original algorithm, we only recognized a match	    // (In the original algorithm, we only recognized a match
<     // if there was exactly 1 copy for each file.)		    // if there was exactly 1 copy for each file.)
< 
<     if (l->copies[0].size () == l->copies[1].size ()) {		    if (l->copies[0].size () == l->copies[1].size ()) {
<       nMatchedLines += 1;					      nMatchedLines += 1;
< 
<       // For each matched line in the new file, mark it with 	      // For each matched line in the new file, mark it with 
<       // corresponding line (number) in the old file.		      // corresponding line (number) in the old file.
< 
<       while (!l->copies[0].empty ()) {				      while (!l->copies[0].empty ()) {
<         unsigned o = l->copies[0].front ();			        unsigned o = l->copies[0].front ();
<         unsigned n = l->copies[1].front ();			        unsigned n = l->copies[1].front ();
< 
<         // Match up the pair.					        // Match up the pair.
< 
<         lines[0][o].l = n;					        lines[0][o].l = n;
<         lines[1][n].l = o;					        lines[1][n].l = o;
< 
<         // Remove the matched line numbers from the lists.	        // Remove the matched line numbers from the lists.
< 
<         l->copies[0].pop_front ();				        l->copies[0].pop_front ();
<         l->copies[1].pop_front ();				        l->copies[1].pop_front ();
<       }								      }
<     }								    }
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, " found %u matched lines (%u total).\n",	    fprintf (stderr, " found %u matched lines (%u total).\n",
< 
<     if (1 < optVerbose) {					    if (1 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< 
<   // Perform Pass #2, in which we attempt to 'widen' blocks o	  // Perform Pass #2, in which we attempt to 'widen' blocks o
<   // lines, by appending lines which are the same in both fil	  // lines, by appending lines which are the same in both fil
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #2 (spreading matches down)...")	    fprintf (stderr, "# Pass #2 (spreading matches down)...")
<   }								  }
< 
<   nMatchedBlocks = 0;						  nMatchedBlocks = 0;
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Starting at the top of the old file,...			  // Starting at the top of the old file,...
< 
<   for (unsigned o = 0; o < lines[0].size (); o += 1) {		  for (unsigned o = 0; o < lines[0].size (); o += 1) {
< 
<     // ... skip any currently unmatched lines...		    // ... skip any currently unmatched lines...
< 
<     if (lines[0][o].l == ~0) {					    if (lines[0][o].l == ~0) {
<       continue;							      continue;
<     }								    }
< 
<     // ... until we find an [already] matched line.  Then, sk	    // ... until we find an [already] matched line.  Then, sk
<     // the set of 1 or more matched lines, until we reach any	    // the set of 1 or more matched lines, until we reach any
<     // following, still-unmatched line.				    // following, still-unmatched line.
< 
<     unsigned n;							    unsigned n;
<     do {							    do {
<       n = lines[0][o].l + 1;					      n = lines[0][o].l + 1;
<       o += 1;							      o += 1;
<     } while (o < lines[0].size () && lines[0][o].l != ~0);	    } while (o < lines[0].size () && lines[0][o].l != ~0);
< 
<     // Now, o - 1 is the line number of the last matched old 	    // Now, o - 1 is the line number of the last matched old 
<     // n - 1 is the line number of the last matched new line.	    // n - 1 is the line number of the last matched new line.
<     // to add new old and new lines, if they match.		    // to add new old and new lines, if they match.
< 
<     // Finally, attempt to add unmatched lines to the preceed	    // Finally, attempt to add unmatched lines to the preceed
<     // matched set.						    // matched set.
< 
<     for (; o < lines[0].size () && lines[0][o].l == ~0; o += 	    for (; o < lines[0].size () && lines[0][o].l == ~0; o += 
< 
<       // If the [next] pair of old and new lines aren't the s	      // If the [next] pair of old and new lines aren't the s
< 
<       if (lines[0][o].line != lines[1][n].line) {		      if (lines[0][o].line != lines[1][n].line) {
<         break;							        break;
<       }								      }
< 
<       // Match up the pair.					      // Match up the pair.
< 
<       lines[0][o].l = n;					      lines[0][o].l = n;
<       lines[1][n].l = o;					      lines[1][n].l = o;
< 
<       // Remove the matched line numbers form the lists.	      // Remove the matched line numbers form the lists.
< 
<       Line *line = lines[0][o].line;				      Line *line = lines[0][o].line;
<       list<unsigned> &oldCopies = line->copies[0];		      list<unsigned> &oldCopies = line->copies[0];
<       list<unsigned>::iterator oL = find (oldCopies.begin (),	      list<unsigned>::iterator oL = find (oldCopies.begin (),
<       if (oL != oldCopies.end ()) {				      if (oL != oldCopies.end ()) {
<         oldCopies.erase (oL);					        oldCopies.erase (oL);
<       }								      }
<       list<unsigned> &newCopies = line->copies[0];		      list<unsigned> &newCopies = line->copies[0];
<       list<unsigned>::iterator nL = find (newCopies.begin (),	      list<unsigned>::iterator nL = find (newCopies.begin (),
<       if (nL != newCopies.end ()) {				      if (nL != newCopies.end ()) {
<         newCopies.erase (nL);					        newCopies.erase (nL);
<       }								      }
< 
<       nMatchedLines += 1;					      nMatchedLines += 1;
<     }								    }
<     nMatchedBlocks += 1;					    nMatchedBlocks += 1;
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
<   nTotalMatchedBlocks += nMatchedBlocks;			  nTotalMatchedBlocks += nMatchedBlocks;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr,						    fprintf (stderr,
<              " found %u/%u matched lines/blocks (%u/%u totals	             " found %u/%u matched lines/blocks (%u/%u totals
<              nMatchedLines,					             nMatchedLines,
<              nMatchedBlocks,					             nMatchedBlocks,
<              nTotalMatchedLines,				             nTotalMatchedLines,
<              nTotalMatchedBlocks				             nTotalMatchedBlocks
<             );							            );
<     if (1 < optVerbose) {					    if (1 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< 
<   // Perform Pass #3, in which we attempt to 'widen' blocks o	  // Perform Pass #3, in which we attempt to 'widen' blocks o
<   // lines, by prepending lines which are the same in both fi	  // lines, by prepending lines which are the same in both fi
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #3 (spreading matches up)...");	    fprintf (stderr, "# Pass #3 (spreading matches up)...");
<   }								  }
< 
<   nMatchedBlocks = 0;						  nMatchedBlocks = 0;
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Starting at the bottom of the old file,...			  // Starting at the bottom of the old file,...
< 
<   for (int o = lines[0].size (); 0 <= o; o -= 1) {		  for (int o = lines[0].size (); 0 <= o; o -= 1) {
< 
<     // ... skip any currently unmatched lines...		    // ... skip any currently unmatched lines...
< 
<     if (lines[0][o].l == ~0) {					    if (lines[0][o].l == ~0) {
<       continue;							      continue;
<     }								    }
< 
<     // ... until we find an [already] matched line.  Then, sk	    // ... until we find an [already] matched line.  Then, sk
<     // the set of 1 or more matched lines, until we reach any	    // the set of 1 or more matched lines, until we reach any
<     // following, still-unmatched line.				    // following, still-unmatched line.
< 
<     unsigned n;							    unsigned n;
<     do {							    do {
<       n = lines[0][o].l - 1;					      n = lines[0][o].l - 1;
<       o -= 1;							      o -= 1;
<     } while (0 <= o && lines[0][o].l != ~0);			    } while (0 <= o && lines[0][o].l != ~0);
< 
<     // Now, o + 1 is the line number of the last matched old 	    // Now, o + 1 is the line number of the last matched old 
<     // n + 1 is the line number of the last matched new line.	    // n + 1 is the line number of the last matched new line.
<     // to add new old and new lines, if they match.		    // to add new old and new lines, if they match.
< 
<     // Finally, attempt to add unmatched lines to the preceed	    // Finally, attempt to add unmatched lines to the preceed
<     // matched set.						    // matched set.
< 
<     for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {	    for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
< 
<       // If the [next] pair of old and new lines aren't the s	      // If the [next] pair of old and new lines aren't the s
< 
<       if (lines[0][o].line != lines[1][n].line) {		      if (lines[0][o].line != lines[1][n].line) {
<         break;							        break;
<       }								      }
< 
<       // Match up the pair.					      // Match up the pair.
< 
<       lines[0][o].l = n;					      lines[0][o].l = n;
<       lines[1][n].l = o;					      lines[1][n].l = o;
< 
<       // Remove the matched line numbers form the lists.	      // Remove the matched line numbers form the lists.
< 
<       Line *line = lines[0][o].line;				      Line *line = lines[0][o].line;
<       list<unsigned> &oldCopies = line->copies[0];		      list<unsigned> &oldCopies = line->copies[0];
<       list<unsigned>::iterator oL = find (oldCopies.begin (),	      list<unsigned>::iterator oL = find (oldCopies.begin (),
<       if (oL != oldCopies.end ()) {				      if (oL != oldCopies.end ()) {
<         oldCopies.erase (oL);					        oldCopies.erase (oL);
<       }								      }
<       list<unsigned> &newCopies = line->copies[0];		      list<unsigned> &newCopies = line->copies[0];
<       list<unsigned>::iterator nL = find (newCopies.begin (),	      list<unsigned>::iterator nL = find (newCopies.begin (),
<       if (nL != newCopies.end ()) {				      if (nL != newCopies.end ()) {
<         newCopies.erase (nL);					        newCopies.erase (nL);
<       }								      }
< 
<       nMatchedLines += 1;					      nMatchedLines += 1;
<     }								    }
<     nMatchedBlocks += 1;					    nMatchedBlocks += 1;
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr,						    fprintf (stderr,
<              " found %u/%u matched lines/blocks (%u/%u totals	             " found %u/%u matched lines/blocks (%u/%u totals
<              nMatchedLines,					             nMatchedLines,
<              nMatchedBlocks,					             nMatchedBlocks,
<              nTotalMatchedLines,				             nTotalMatchedLines,
<              nTotalMatchedBlocks				             nTotalMatchedBlocks
<             );							            );
< 
<     if (1 < optVerbose) {					    if (1 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< 
<   // Perform pass #4, in which we find any remaining matches 	  // Perform pass #4, in which we find any remaining matches 
<   // the unique lines.  For every unique line that has more t	  // the unique lines.  For every unique line that has more t
<   // copy in both files, we declare the copies to match.	  // copy in both files, we declare the copies to match.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass 4 (finding remaining matches amo	    fprintf (stderr, "# Pass 4 (finding remaining matches amo
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   for (MapStringToLinePtr::iterator i = table.begin (); i != 	  for (MapStringToLinePtr::iterator i = table.begin (); i != 
<     Line *l = i->second;					    Line *l = i->second;
< 
<     // If there's more than 1 matching old and new lines, the	    // If there's more than 1 matching old and new lines, the
<     // declare that each pair are (all) the same line.		    // declare that each pair are (all) the same line.
< 
<     // (In the original algorithm, we only recognized a match	    // (In the original algorithm, we only recognized a match
<     // if there was exactly 1 copy for each file.)		    // if there was exactly 1 copy for each file.)
< 
<     while (0 < l->copies[0].size () && 0 < l->copies[1].size 	    while (0 < l->copies[0].size () && 0 < l->copies[1].size 
<       nMatchedLines += 1;					      nMatchedLines += 1;
< 
<       // For each matched line in the new file, mark it with 	      // For each matched line in the new file, mark it with 
<       // corresponding line (number) in the old file.		      // corresponding line (number) in the old file.
< 
<       unsigned o = l->copies[0].front ();			      unsigned o = l->copies[0].front ();
<       unsigned n = l->copies[1].front ();			      unsigned n = l->copies[1].front ();
< 
<       // Match up the pair.					      // Match up the pair.
< 
<       lines[0][o].l = n;					      lines[0][o].l = n;
<       lines[1][n].l = o;					      lines[1][n].l = o;
< 
<       // Remove the matched line numbers from the lists.	      // Remove the matched line numbers from the lists.
< 
<       l->copies[0].pop_front ();				      l->copies[0].pop_front ();
<       l->copies[1].pop_front ();				      l->copies[1].pop_front ();
<     }								    }
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, " found %u matched lines (%u total).\n",	    fprintf (stderr, " found %u matched lines (%u total).\n",
< 
<     if (1 < optVerbose) {					    if (1 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< 
<   // Perform Pass #5, in which we look for blocks which match	  // Perform Pass #5, in which we look for blocks which match
<   // the result of a move (their not in their original positi	  // the result of a move (their not in their original positi
<   // these, we'll unmatch the blocks, turning them into a del	  // these, we'll unmatch the blocks, turning them into a del
<   // an insert.							  // an insert.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #5 (unmatching block moves)...\n	    fprintf (stderr, "# Pass #5 (unmatching block moves)...\n
<   }								  }
< 
<   nMatchedBlocks = 0;						  nMatchedBlocks = 0;
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Starting at the top of both files,...			  // Starting at the top of both files,...
< 
<   unsigned o = 0;						  unsigned o = 0;
<   unsigned n = 0;						  unsigned n = 0;
< 
<   while (o < lines[0].size () || n < lines[1].size ()) {	  while (o < lines[0].size () || n < lines[1].size ()) {
< 
<     // Skip any unmatched lines at this point in the old file	    // Skip any unmatched lines at this point in the old file
<     // are deletes.						    // are deletes.
< 
<     //    Old     New						    //    Old     New
<     //   +---+							    //   +---+
<     // 0 | a |							    // 0 | a |
<     //   +---+   +---+						    //   +---+   +---+
<     //         0 | b |						    //         0 | b |
<     //   +---+   +---+						    //   +---+   +---+
<     // 1 | c | 1 | c |						    // 1 | c | 1 | c |
<     //   +---+   +---+						    //   +---+   +---+
<     //         2 | z |						    //         2 | z |
<     //   +---+   +---+						    //   +---+   +---+
<     // 2 | d | 3 | d |						    // 2 | d | 3 | d |
<     //   +---+   +---+						    //   +---+   +---+
< 
<     while (o < lines[0].size () && lines[0][o].l == ~0) {	    while (o < lines[0].size () && lines[0][o].l == ~0) {
<       o += 1;							      o += 1;
<     }								    }
< 
<     // Skip any unmatched lines at this point in the new file	    // Skip any unmatched lines at this point in the new file
<     // are inserts.						    // are inserts.
< 
<     while (n < lines[1].size () && lines[1][n].l == ~0) {	    while (n < lines[1].size () && lines[1][n].l == ~0) {
<       n += 1;							      n += 1;
<     }								    }
< 
<     // When we get here, we know that we're dealing with matc	    // When we get here, we know that we're dealing with matc
<     // lines (or the end of one or both files).  We're done w	    // lines (or the end of one or both files).  We're done w
<     // pass, if we've reached the end of either file.		    // pass, if we've reached the end of either file.
< 
<     if (lines[0].size () <= o || lines[1].size () <= n) {	    if (lines[0].size () <= o || lines[1].size () <= n) {
<       break;							      break;
<     }								    }
< 
<     // We now know that we've got a pair of matching lines, t	    // We now know that we've got a pair of matching lines, t
<     // of a matching block.  If the new file's line number is	    // of a matching block.  If the new file's line number is
<     // expect, then the matched pair is unmoved, and we can s	    // expect, then the matched pair is unmoved, and we can s
<     // the pair.  (If this is really the start of a block of 	    // the pair.  (If this is really the start of a block of 
<     // 1 lines, we'll handle it one pair at a time.)		    // 1 lines, we'll handle it one pair at a time.)
< 
<     if (lines[0][o].l == n) {					    if (lines[0][o].l == n) {
<       o += 1;							      o += 1;
<       n += 1;							      n += 1;
<       continue;							      continue;
<     }								    }
< 
<     // If, on the other hand, we don't expect this [new] line	    // If, on the other hand, we don't expect this [new] line
<     // then this matching block has been moved.  We need to t	    // then this matching block has been moved.  We need to t
<     // matched pair into an *unmatched* pair, one of deletes,	    // matched pair into an *unmatched* pair, one of deletes,
<     // of inserts.  First, though, we need to know how big th	    // of inserts.  First, though, we need to know how big th
<     // is, and how far it was moved....				    // is, and how far it was moved....
< 
<     // Remember where we were when we started.			    // Remember where we were when we started.
< 
<     unsigned oOld = o;						    unsigned oOld = o;
<     unsigned nOld = n;						    unsigned nOld = n;
< 
<     // Remember where the block came from.			    // Remember where the block came from.
< 
<     unsigned nNew = lines[0][o].l;				    unsigned nNew = lines[0][o].l;
< 
<     // Find the end of this matched pair.			    // Find the end of this matched pair.
< 
<     for (n = nNew; o < lines[0].size () && n < lines[1].size 	    for (n = nNew; o < lines[0].size () && n < lines[1].size 
<       if (lines[0][o].l != n) {					      if (lines[0][o].l != n) {
<         break;							        break;
<       }								      }
<     }								    }
< 
<     // When we get here:					    // When we get here:
<     // * oOld..o is the old file's block,			    // * oOld..o is the old file's block,
<     // * nNew..n is the new file's *moved* block, and		    // * nNew..n is the new file's *moved* block, and
<     // * nOld is where we originally expected the new block f	    // * nOld is where we originally expected the new block f
<  								 
<     // We can now calculate the length of the block...		    // We can now calculate the length of the block...
<     								    
<     unsigned bSize = o - oOld;  // (or n - nNew)		    unsigned bSize = o - oOld;  // (or n - nNew)
< 
<     // ... and we can calculate how far the block moved:	    // ... and we can calculate how far the block moved:
< 
<     unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;	    unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
< 
<     // The larger of the two will become our delete, and the 	    // The larger of the two will become our delete, and the 
<     // will become our insert.					    // will become our insert.
< 
<     //    Old     New						    //    Old     New
<     //   +---+   +---+						    //   +---+   +---+
<     // 0 | a | 0 | b |						    // 0 | a | 0 | b |
<     //   +---+ 1 | b |						    //   +---+ 1 | b |
<     // 1 | b |   +---+						    // 1 | b |   +---+
<     // 2 | b | 2 | a |						    // 2 | b | 2 | a |
<     //   +---+   +---+						    //   +---+   +---+
<     // 3 | c | 3 | c |						    // 3 | c | 3 | c |
<     //   +---+   +---+						    //   +---+   +---+
< 
<     // (1) Delete a@0, insert a@2, or				    // (1) Delete a@0, insert a@2, or
<     // (2) insert bb@0, delete bb@1?				    // (2) insert bb@0, delete bb@1?
< 
<     // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and	    // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and
<     // (of a) is 2-0 or 2, the size of b@0.  We choose to del	    // (of a) is 2-0 or 2, the size of b@0.  We choose to del
<     // and reinsert a@2.					    // and reinsert a@2.
< 
<     // if (bSize <= bMove) {					    // if (bSize <= bMove) {
<       for (unsigned a = oOld; a < o; a += 1) {			      for (unsigned a = oOld; a < o; a += 1) {
<         lines[0][a].l = ~0;					        lines[0][a].l = ~0;
<       }								      }
<       for (unsigned d = nNew; d < n; d += 1) {			      for (unsigned d = nNew; d < n; d += 1) {
<         lines[1][d].l = ~0;					        lines[1][d].l = ~0;
<       }								      }
<     // } else {							    // } else {
<       // for (unsigned a = oOld; a < o; a += 1) {		      // for (unsigned a = oOld; a < o; a += 1) {
<       //   lines[0][a].l = ~0;					      //   lines[0][a].l = ~0;
<       // }							      // }
<       // for (unsigned d = nNew; d < n; d += 1) {		      // for (unsigned d = nNew; d < n; d += 1) {
<       //   lines[1][d].l = ~0;					      //   lines[1][d].l = ~0;
<       // }							      // }
<     // }							    // }
< 
<     // Continue from where we left off.				    // Continue from where we left off.
< 
<     n = nOld;							    n = nOld;
<   }								  }
<   nTotalMatchedLines -= nMatchedLines;				  nTotalMatchedLines -= nMatchedLines;
<   nTotalMatchedBlocks -= nMatchedBlocks;			  nTotalMatchedBlocks -= nMatchedBlocks;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr,						    fprintf (stderr,
<              " found %u/%u matched lines/blocks (%u/%u totals	             " found %u/%u matched lines/blocks (%u/%u totals
<              nMatchedLines,					             nMatchedLines,
<              nMatchedBlocks,					             nMatchedBlocks,
<              nTotalMatchedLines,				             nTotalMatchedLines,
<              nTotalMatchedBlocks				             nTotalMatchedBlocks
<             );							            );
< 
<     if (1 < optVerbose) {					    if (1 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< 
<   // Perform Pass #6, in which we create the desired output.	  // Perform Pass #6, in which we create the desired output.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #6 (walking the differences)...\	    fprintf (stderr, "# Pass #6 (walking the differences)...\
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Write the header.						  // Write the header.
< 
<   switch (diffFormat) {						  switch (diffFormat) {
<   case Default:							  case Default:
<   case Normal:							  case Normal:
<     break;							    break;
<   case Unified:							  case Unified:
<     fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00	    fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00
<     fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00	    fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00
<     fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (),	    fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (),
<     break;							    break;
<   }								  }
< 
<   // Starting at the top of both files,...			  // Starting at the top of both files,...
< 
<   o = 0;							  o = 0;
<   n = 0;							  n = 0;
< 
<   while (o < lines[0].size () || n < lines[1].size ()) {	  while (o < lines[0].size () || n < lines[1].size ()) {
< 
<     // Find any unmatched lines at this point in the old file	    // Find any unmatched lines at this point in the old file
<     // are deletes.						    // are deletes.
< 
<     unsigned boDeletes;						    unsigned boDeletes;
<     for (boDeletes = o;						    for (boDeletes = o;
<          o < lines[0].size () && lines[0][o].l == ~0;		         o < lines[0].size () && lines[0][o].l == ~0;
<          o += 1							         o += 1
<         )							        )
<     {}								    {}
< 
<     // Find any unmatched lines at this point in the new file	    // Find any unmatched lines at this point in the new file
<     // are inserts.						    // are inserts.
< 
<     unsigned boInserts;						    unsigned boInserts;
<     for (boInserts = n;						    for (boInserts = n;
<          n < lines[1].size () && lines[1][n].l == ~0;		         n < lines[1].size () && lines[1][n].l == ~0;
<          n += 1							         n += 1
<         )							        )
<     {}								    {}
< 
<     // We've got deleted line(s) from boDeletes .. o.		    // We've got deleted line(s) from boDeletes .. o.
<     // We've got deleted line(s) from boInserts .. n.		    // We've got deleted line(s) from boInserts .. n.
< 
<     unsigned nDeletes = o - boDeletes;				    unsigned nDeletes = o - boDeletes;
<     unsigned nInserts = n - boInserts;				    unsigned nInserts = n - boInserts;
< 
<     // We've got...						    // We've got...
< 
<     if (nDeletes && nInserts) {					    if (nDeletes && nInserts) {
< 
<       // ... deletes and inserts.				      // ... deletes and inserts.
< 
<       switch (diffFormat) {					      switch (diffFormat) {
<       case Default:						      case Default:
<       case Normal:						      case Normal:
<         if (1 < nDeletes && 1 < nInserts) {			        if (1 < nDeletes && 1 < nInserts) {
<           fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o,	          fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o,
<         } else if (1 < nDeletes) {				        } else if (1 < nDeletes) {
<           fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, bo	          fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, bo
<         } else if (1 < nInserts) {				        } else if (1 < nInserts) {
<           fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boIns	          fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boIns
<         } 							        } 
<         for (unsigned l = boDeletes; l < o; l += 1) {		        for (unsigned l = boDeletes; l < o; l += 1) {
<           fprintf (stdout, "< %s", lines[0][l].line->c_str ()	          fprintf (stdout, "< %s", lines[0][l].line->c_str ()
<         }							        }
<         fprintf (stderr, "---\n");				        fprintf (stderr, "---\n");
<         for (unsigned l = boInserts; l < n; l += 1) {		        for (unsigned l = boInserts; l < n; l += 1) {
<           fprintf (stdout, "> %s", lines[1][l].line->c_str ()	          fprintf (stdout, "> %s", lines[1][l].line->c_str ()
<         }							        }
<         break;							        break;
< 
<       case Unified:						      case Unified:
<         for (unsigned l = boDeletes; l < o; l += 1) {		        for (unsigned l = boDeletes; l < o; l += 1) {
<           fprintf (stdout, "-%s", lines[0][l].line->c_str ())	          fprintf (stdout, "-%s", lines[0][l].line->c_str ())
<         }							        }
<         for (unsigned l = boInserts; l < n; l += 1) {		        for (unsigned l = boInserts; l < n; l += 1) {
<           fprintf (stdout, "+%s", lines[1][l].line->c_str ())	          fprintf (stdout, "+%s", lines[1][l].line->c_str ())
<         }							        }
<         break;							        break;
<       }								      }
<     } else if (nDeletes) {					    } else if (nDeletes) {
< 
<       //  ... just deletes.					      //  ... just deletes.
< 
<       switch (diffFormat) {					      switch (diffFormat) {
<       case Default:						      case Default:
<       case Normal:						      case Normal:
<         if (1 < nDeletes) {					        if (1 < nDeletes) {
<           fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n)	          fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n)
<         } else {						        } else {
<           fprintf (stdout, "%dd%d\n", boDeletes + 1, n);	          fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
<         }							        }
<         for (unsigned l = boDeletes; l < o; l += 1) {		        for (unsigned l = boDeletes; l < o; l += 1) {
<           fprintf (stdout, "< %s", lines[0][l].line->c_str ()	          fprintf (stdout, "< %s", lines[0][l].line->c_str ()
<         }							        }
<         break;							        break;
<       case Unified:						      case Unified:
<         for (unsigned l = boDeletes; l < o; l += 1) {		        for (unsigned l = boDeletes; l < o; l += 1) {
<           fprintf (stdout, "-%s", lines[0][l].line->c_str ())	          fprintf (stdout, "-%s", lines[0][l].line->c_str ())
<         }							        }
<         break;							        break;
<       }								      }
<     } else if (nInserts) {					    } else if (nInserts) {
< 
<       //  ... just inserts.					      //  ... just inserts.
< 
<       switch (diffFormat) {					      switch (diffFormat) {
<       case Default:						      case Default:
<       case Normal:						      case Normal:
<         if (1 < nInserts) {					        if (1 < nInserts) {
<           fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n)	          fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n)
<         } else {						        } else {
<           fprintf (stdout, "%da%d\n", o, boInserts + 1);	          fprintf (stdout, "%da%d\n", o, boInserts + 1);
<         }							        }
<         for (unsigned l = boInserts; l < n; l += 1) {		        for (unsigned l = boInserts; l < n; l += 1) {
<           fprintf (stdout, "> %s", lines[1][l].line->c_str ()	          fprintf (stdout, "> %s", lines[1][l].line->c_str ()
<         }							        }
<         break;							        break;
<       case Unified:						      case Unified:
<         for (unsigned l = boInserts; l < n; l += 1) {		        for (unsigned l = boInserts; l < n; l += 1) {
<           fprintf (stdout, "+%s", lines[1][l].line->c_str ())	          fprintf (stdout, "+%s", lines[1][l].line->c_str ())
<         }							        }
<         break;							        break;
<       }								      }
<     }								    }
< 
<     // When we get here, we're dealing with matching lines.	    // When we get here, we're dealing with matching lines.
< 
<     switch (diffFormat) {					    switch (diffFormat) {
<     case Default:						    case Default:
<     case Normal:						    case Normal:
<       break;							      break;
<     case Unified:						    case Unified:
<       fprintf (stdout, " %s", lines[0][o].line->c_str ());	      fprintf (stdout, " %s", lines[0][o].line->c_str ());
<       break;							      break;
<     }								    }
<     o += 1;							    o += 1;
<     n += 1;							    n += 1;
<   }								  }
< }								}
---
> #include <algorithm>                                            #include <algorithm>
> using std::find;                                                using std::find;
> #include <string>                                               #include <string>
> using std::string;                                              using std::string;
> #include <list>                                                 #include <list>
> using std::list;                                                using std::list;
> #include <map>                                                  #include <map>
> using std::map;                                                 using std::map;
> #include <vector>                                               #include <vector>
> using std::vector;                                              using std::vector;
> #include <stdio.h>                                              #include <stdio.h>
>                                                                 
> enum DiffFormat {                                               enum DiffFormat {
>   Default,                                                        Default,
>                                                                 
>   Context,                                                        Context,
>   EdScript,                                                       EdScript,
>   IfThenElse,                                                     IfThenElse,
>   Normal,                                                         Normal,
>   RCS,                                                            RCS,
>   SideBySide,                                                     SideBySide,
>   Unified                                                         Unified
> };                                                              };
>                                                                 
> DiffFormat diffFormat = Unified;                                DiffFormat diffFormat = Unified;
>                                                                 
> int optVerbose = 1;                                             int optVerbose = 1;
>                                                                 
> struct Line : public string {                                   struct Line : public string {
>   Line (string _text) :                                           Line (string _text) :
>     string (_text)                                                  string (_text)
>   {                                                               {
>   }                                                               }
>   ~Line () {                                                      ~Line () {
>     copies[0].erase (copies[0].begin (), copies[0].end ());         copies[0].erase (copies[0].begin (), copies[0].end ());
>     copies[1].erase (copies[1].begin (), copies[1].end ());         copies[1].erase (copies[1].begin (), copies[1].end ());
>   }                                                               }
>   void Dump (FILE *out) {                                         void Dump (FILE *out) {
>     fprintf (out, "{{ ");                                           fprintf (out, "{{ ");
>     for (list<unsigned>::iterator i = copies[0].begin (); i !       for (list<unsigned>::iterator i = copies[0].begin (); i !
>       fprintf (out, "%u ", *i);                                       fprintf (out, "%u ", *i);
>     }                                                               }
>     fprintf (out, "},{ ");                                          fprintf (out, "},{ ");
>     for (list<unsigned>::iterator i = copies[1].begin (); i !       for (list<unsigned>::iterator i = copies[1].begin (); i !
>       fprintf (out, "%u ", *i);                                       fprintf (out, "%u ", *i);
>     }                                                               }
>     fprintf (out, "}}\t%s", c_str ());                              fprintf (out, "}}\t%s", c_str ());
>   }                                                               }
>   list<unsigned> copies[2];                                       list<unsigned> copies[2];
> };                                                              };
>                                                                 
> struct LinePtr {                                                struct LinePtr {
>   LinePtr (Line *_line) :                                         LinePtr (Line *_line) :
>     line (_line),                                                   line (_line),
>     l (~0u)                                                         l (~0u)
>   {                                                               {
>   }                                                               }
>   void Dump (FILE *out) {                                         void Dump (FILE *out) {
>     fprintf (out, "[%d] ", l);                                      fprintf (out, "[%d] ", l);
>     line->Dump (out);                                               line->Dump (out);
>   }                                                               }
>   Line *line;                                                     Line *line;
>   unsigned l;                                                     unsigned l;
> };                                                              };
>                                                                 
> typedef map<string, Line *> MapStringToLinePtr;                 typedef map<string, Line *> MapStringToLinePtr;
> typedef vector<LinePtr> VectorLinePtr;                          typedef vector<LinePtr> VectorLinePtr;
>                                                                 
> char *ARGV0 = "dif2";                                           char *ARGV0 = "dif2";
>                                                                 
> int main (int argc, char *argv[])                               int main (int argc, char *argv[])
> {                                                               {
>   char const *files[2] = { 0, 0 };                                char const *files[2] = { 0, 0 };
>                                                                 
>   MapStringToLinePtr table;                                       MapStringToLinePtr table;
>   VectorLinePtr lines[2];                                         VectorLinePtr lines[2];
>                                                                 
>   unsigned nTotalMatchedBlocks = 0;                               unsigned nTotalMatchedBlocks = 0;
>   unsigned nMatchedBlocks = 0;                                    unsigned nMatchedBlocks = 0;
>   unsigned nTotalMatchedLines = 0;                                unsigned nTotalMatchedLines = 0;
>   unsigned nMatchedLines = 0;                                     unsigned nMatchedLines = 0;
>                                                                 
>   // Read the old [0] file, and the new [1] file.                 // Read the old [0] file, and the new [1] file.
>                                                                 
>   for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {     for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
>     files[n] = argv[a];                                             files[n] = argv[a];
>                                                                 
>     if (FILE *f = fopen (files[n], "r")) {                          if (FILE *f = fopen (files[n], "r")) {
>       if (0 < optVerbose) {                                           if (0 < optVerbose) {
>         fprintf (stderr, "# Reading %s...", files[n]);                  fprintf (stderr, "# Reading %s...", files[n]);
>       }                                                               }
>                                                                 
>       char buffer[1024];                                              char buffer[1024];
>       unsigned nUniq = 0;                                             unsigned nUniq = 0;
>                                                                 
>       while (fgets (buffer, sizeof (buffer), f)) {                    while (fgets (buffer, sizeof (buffer), f)) {
>         string text (buffer);                                           string text (buffer);
>                                                                 
>         Line *line = table[text];                                       Line *line = table[text];
>                                                                 
>         if (!line) {                                                    if (!line) {
>           table[text] = line = new Line (text);                           table[text] = line = new Line (text);
>           nUniq += 1;                                                     nUniq += 1;
>         }                                                               }
>         line->copies[n].push_back (lines[n].size ());                   line->copies[n].push_back (lines[n].size ());
>         lines[n].push_back (line);                                      lines[n].push_back (line);
>       }                                                               }
>                                                                 
>       if (0 < optVerbose) {                                           if (0 < optVerbose) {
>         fprintf (stderr, " %u lines, %u unique.\n", lines[n].           fprintf (stderr, " %u lines, %u unique.\n", lines[n].
>       }                                                               }
>     } else {                                                        } else {
>       fprintf (stderr, "%s: Unable to open %s!  Exiting....\n         fprintf (stderr, "%s: Unable to open %s!  Exiting....\n
>       perror (ARGV0);                                                 perror (ARGV0);
>       exit (1);                                                       exit (1);
>     }                                                               }
>   }                                                               }
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     printf ("# Total unique lines = %d\n", table.size ());          printf ("# Total unique lines = %d\n", table.size ());
>   }                                                               }
>                                                                 
>   // map<int, int> counts;                                        // map<int, int> counts;
>   // for (MapStringToLinePtr::iterator i = table.begin (); i      // for (MapStringToLinePtr::iterator i = table.begin (); i 
>   //   Line *l = i->second;                                       //   Line *l = i->second;
>   //   counts[l->counts[0].size () + l->counts[1].size ()] +=     //   counts[l->counts[0].size () + l->counts[1].size ()] +=
>   // }                                                            // }
>   // for (map<int, int>::iterator i = counts.begin (); i != c     // for (map<int, int>::iterator i = counts.begin (); i != c
>   //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s     //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s
>   // }                                                            // }
>                                                                 
>   // Perform pass #1, in which we find all explicit matches a     // Perform pass #1, in which we find all explicit matches a
>   // the unique lines.  For every unique line that appears th     // the unique lines.  For every unique line that appears th
>   // number of times in both files, we declare the lines to m     // number of times in both files, we declare the lines to m
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Pass 1 (finding matches amongst uniqu       fprintf (stderr, "# Pass 1 (finding matches amongst uniqu
>   }                                                               }
>                                                                 
>   nMatchedLines = 0;                                              nMatchedLines = 0;
>                                                                 
>   for (MapStringToLinePtr::iterator i = table.begin (); i !=      for (MapStringToLinePtr::iterator i = table.begin (); i != 
>     Line *l = i->second;                                            Line *l = i->second;
>                                                                 
>     // If the number of old and new lines match, then we decl       // If the number of old and new lines match, then we decl
>     // they are (all) the same line.  Note, it isn't possible       // they are (all) the same line.  Note, it isn't possible
>     // numbers of both files to be 0.                               // numbers of both files to be 0.
>                                                                 
>     // (In the original algorithm, we only recognized a match       // (In the original algorithm, we only recognized a match
>     // if there was exactly 1 copy for each file.)                  // if there was exactly 1 copy for each file.)
>                                                                 
>     if (l->copies[0].size () == l->copies[1].size ()) {             if (l->copies[0].size () == l->copies[1].size ()) {
>       nMatchedLines += 1;                                             nMatchedLines += 1;
>                                                                 
>       // For each matched line in the new file, mark it with          // For each matched line in the new file, mark it with 
>       // corresponding line (number) in the old file.                 // corresponding line (number) in the old file.
>                                                                 
>       while (!l->copies[0].empty ()) {                                while (!l->copies[0].empty ()) {
>         unsigned o = l->copies[0].front ();                             unsigned o = l->copies[0].front ();
>         unsigned n = l->copies[1].front ();                             unsigned n = l->copies[1].front ();
>                                                                 
>         // Match up the pair.                                           // Match up the pair.
>                                                                 
>         lines[0][o].l = n;                                              lines[0][o].l = n;
>         lines[1][n].l = o;                                              lines[1][n].l = o;
>                                                                 
>         // Remove the matched line numbers from the lists.              // Remove the matched line numbers from the lists.
>                                                                 
>         l->copies[0].pop_front ();                                      l->copies[0].pop_front ();
>         l->copies[1].pop_front ();                                      l->copies[1].pop_front ();
>       }                                                               }
>     }                                                               }
>   }                                                               }
>   nTotalMatchedLines += nMatchedLines;                            nTotalMatchedLines += nMatchedLines;
>                                                                 
>   // Let's see the intermediate results.                          // Let's see the intermediate results.
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, " found %u matched lines (%u total).\n",       fprintf (stderr, " found %u matched lines (%u total).\n",
>                                                                 
>     if (1 < optVerbose) {                                           if (1 < optVerbose) {
>       for (int f = 0; f < 2; f += 1) {                                for (int f = 0; f < 2; f += 1) {
>         fprintf (stderr, "# file #%d\n", f + 1);                        fprintf (stderr, "# file #%d\n", f + 1);
>         for (int l = 0; l < lines[f].size (); l += 1) {                 for (int l = 0; l < lines[f].size (); l += 1) {
>           fprintf (stderr, "#   [%d] ", l);                               fprintf (stderr, "#   [%d] ", l);
>           lines[f][l].Dump (stderr);                                      lines[f][l].Dump (stderr);
>         }                                                               }
>       }                                                               }
>     }                                                               }
>   }                                                               }
>                                                                 
>   // Perform Pass #2, in which we attempt to 'widen' blocks o     // Perform Pass #2, in which we attempt to 'widen' blocks o
>   // lines, by appending lines which are the same in both fil     // lines, by appending lines which are the same in both fil
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Pass #2 (spreading matches down)...")       fprintf (stderr, "# Pass #2 (spreading matches down)...")
>   }                                                               }
>                                                                 
>   nMatchedBlocks = 0;                                             nMatchedBlocks = 0;
>   nMatchedLines = 0;                                              nMatchedLines = 0;
>                                                                 
>   // Starting at the top of the old file,...                      // Starting at the top of the old file,...
>                                                                 
>   for (unsigned o = 0; o < lines[0].size (); o += 1) {            for (unsigned o = 0; o < lines[0].size (); o += 1) {
>                                                                 
>     // ... skip any currently unmatched lines...                    // ... skip any currently unmatched lines...
>                                                                 
>     if (lines[0][o].l == ~0) {                                      if (lines[0][o].l == ~0) {
>       continue;                                                       continue;
>     }                                                               }
>                                                                 
>     // ... until we find an [already] matched line.  Then, sk       // ... until we find an [already] matched line.  Then, sk
>     // the set of 1 or more matched lines, until we reach any       // the set of 1 or more matched lines, until we reach any
>     // following, still-unmatched line.                             // following, still-unmatched line.
>                                                                 
>     unsigned n;                                                     unsigned n;
>     do {                                                            do {
>       n = lines[0][o].l + 1;                                          n = lines[0][o].l + 1;
>       o += 1;                                                         o += 1;
>     } while (o < lines[0].size () && lines[0][o].l != ~0);          } while (o < lines[0].size () && lines[0][o].l != ~0);
>                                                                 
>     // Now, o - 1 is the line number of the last matched old        // Now, o - 1 is the line number of the last matched old 
>     // n - 1 is the line number of the last matched new line.       // n - 1 is the line number of the last matched new line.
>     // to add new old and new lines, if they match.                 // to add new old and new lines, if they match.
>                                                                 
>     // Finally, attempt to add unmatched lines to the preceed       // Finally, attempt to add unmatched lines to the preceed
>     // matched set.                                                 // matched set.
>                                                                 
>     for (; o < lines[0].size () && lines[0][o].l == ~0; o +=        for (; o < lines[0].size () && lines[0][o].l == ~0; o += 
>                                                                 
>       // If the [next] pair of old and new lines aren't the s         // If the [next] pair of old and new lines aren't the s
>                                                                 
>       if (lines[0][o].line != lines[1][n].line) {                     if (lines[0][o].line != lines[1][n].line) {
>         break;                                                          break;
>       }                                                               }
>                                                                 
>       // Match up the pair.                                           // Match up the pair.
>                                                                 
>       lines[0][o].l = n;                                              lines[0][o].l = n;
>       lines[1][n].l = o;                                              lines[1][n].l = o;
>                                                                 
>       // Remove the matched line numbers form the lists.              // Remove the matched line numbers form the lists.
>                                                                 
>       Line *line = lines[0][o].line;                                  Line *line = lines[0][o].line;
>       list<unsigned> &oldCopies = line->copies[0];                    list<unsigned> &oldCopies = line->copies[0];
>       list<unsigned>::iterator oL = find (oldCopies.begin (),         list<unsigned>::iterator oL = find (oldCopies.begin (),
>       if (oL != oldCopies.end ()) {                                   if (oL != oldCopies.end ()) {
>         oldCopies.erase (oL);                                           oldCopies.erase (oL);
>       }                                                               }
>       list<unsigned> &newCopies = line->copies[0];                    list<unsigned> &newCopies = line->copies[0];
>       list<unsigned>::iterator nL = find (newCopies.begin (),         list<unsigned>::iterator nL = find (newCopies.begin (),
>       if (nL != newCopies.end ()) {                                   if (nL != newCopies.end ()) {
>         newCopies.erase (nL);                                           newCopies.erase (nL);
>       }                                                               }
>                                                                 
>       nMatchedLines += 1;                                             nMatchedLines += 1;
>     }                                                               }
>     nMatchedBlocks += 1;                                            nMatchedBlocks += 1;
>   }                                                               }
>   nTotalMatchedLines += nMatchedLines;                            nTotalMatchedLines += nMatchedLines;
>   nTotalMatchedBlocks += nMatchedBlocks;                          nTotalMatchedBlocks += nMatchedBlocks;
>                                                                 
>   // Let's see the intermediate results.                          // Let's see the intermediate results.
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr,                                                fprintf (stderr,
>              " found %u/%u matched lines/blocks (%u/%u totals                " found %u/%u matched lines/blocks (%u/%u totals
>              nMatchedLines,                                                  nMatchedLines,
>              nMatchedBlocks,                                                 nMatchedBlocks,
>              nTotalMatchedLines,                                             nTotalMatchedLines,
>              nTotalMatchedBlocks                                             nTotalMatchedBlocks
>             );                                                              );
>     if (1 < optVerbose) {                                           if (1 < optVerbose) {
>       for (int f = 0; f < 2; f += 1) {                                for (int f = 0; f < 2; f += 1) {
>         fprintf (stderr, "# file #%d\n", f + 1);                        fprintf (stderr, "# file #%d\n", f + 1);
>         for (int l = 0; l < lines[f].size (); l += 1) {                 for (int l = 0; l < lines[f].size (); l += 1) {
>           fprintf (stderr, "#   [%d] ", l);                               fprintf (stderr, "#   [%d] ", l);
>           lines[f][l].Dump (stderr);                                      lines[f][l].Dump (stderr);
>         }                                                               }
>       }                                                               }
>     }                                                               }
>   }                                                               }
>                                                                 
>   // Perform Pass #3, in which we attempt to 'widen' blocks o     // Perform Pass #3, in which we attempt to 'widen' blocks o
>   // lines, by prepending lines which are the same in both fi     // lines, by prepending lines which are the same in both fi
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Pass #3 (spreading matches up)...");        fprintf (stderr, "# Pass #3 (spreading matches up)...");
>   }                                                               }
>                                                                 
>   nMatchedBlocks = 0;                                             nMatchedBlocks = 0;
>   nMatchedLines = 0;                                              nMatchedLines = 0;
>                                                                 
>   // Starting at the bottom of the old file,...                   // Starting at the bottom of the old file,...
>                                                                 
>   for (int o = lines[0].size (); 0 <= o; o -= 1) {                for (int o = lines[0].size (); 0 <= o; o -= 1) {
>                                                                 
>     // ... skip any currently unmatched lines...                    // ... skip any currently unmatched lines...
>                                                                 
>     if (lines[0][o].l == ~0) {                                      if (lines[0][o].l == ~0) {
>       continue;                                                       continue;
>     }                                                               }
>                                                                 
>     // ... until we find an [already] matched line.  Then, sk       // ... until we find an [already] matched line.  Then, sk
>     // the set of 1 or more matched lines, until we reach any       // the set of 1 or more matched lines, until we reach any
>     // following, still-unmatched line.                             // following, still-unmatched line.
>                                                                 
>     unsigned n;                                                     unsigned n;
>     do {                                                            do {
>       n = lines[0][o].l - 1;                                          n = lines[0][o].l - 1;
>       o -= 1;                                                         o -= 1;
>     } while (0 <= o && lines[0][o].l != ~0);                        } while (0 <= o && lines[0][o].l != ~0);
>                                                                 
>     // Now, o + 1 is the line number of the last matched old        // Now, o + 1 is the line number of the last matched old 
>     // n + 1 is the line number of the last matched new line.       // n + 1 is the line number of the last matched new line.
>     // to add new old and new lines, if they match.                 // to add new old and new lines, if they match.
>                                                                 
>     // Finally, attempt to add unmatched lines to the preceed       // Finally, attempt to add unmatched lines to the preceed
>     // matched set.                                                 // matched set.
>                                                                 
>     for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {         for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
>                                                                 
>       // If the [next] pair of old and new lines aren't the s         // If the [next] pair of old and new lines aren't the s
>                                                                 
>       if (lines[0][o].line != lines[1][n].line) {                     if (lines[0][o].line != lines[1][n].line) {
>         break;                                                          break;
>       }                                                               }
>                                                                 
>       // Match up the pair.                                           // Match up the pair.
>                                                                 
>       lines[0][o].l = n;                                              lines[0][o].l = n;
>       lines[1][n].l = o;                                              lines[1][n].l = o;
>                                                                 
>       // Remove the matched line numbers form the lists.              // Remove the matched line numbers form the lists.
>                                                                 
>       Line *line = lines[0][o].line;                                  Line *line = lines[0][o].line;
>       list<unsigned> &oldCopies = line->copies[0];                    list<unsigned> &oldCopies = line->copies[0];
>       list<unsigned>::iterator oL = find (oldCopies.begin (),         list<unsigned>::iterator oL = find (oldCopies.begin (),
>       if (oL != oldCopies.end ()) {                                   if (oL != oldCopies.end ()) {
>         oldCopies.erase (oL);                                           oldCopies.erase (oL);
>       }                                                               }
>       list<unsigned> &newCopies = line->copies[0];                    list<unsigned> &newCopies = line->copies[0];
>       list<unsigned>::iterator nL = find (newCopies.begin (),         list<unsigned>::iterator nL = find (newCopies.begin (),
>       if (nL != newCopies.end ()) {                                   if (nL != newCopies.end ()) {
>         newCopies.erase (nL);                                           newCopies.erase (nL);
>       }                                                               }
>                                                                 
>       nMatchedLines += 1;                                             nMatchedLines += 1;
>     }                                                               }
>     nMatchedBlocks += 1;                                            nMatchedBlocks += 1;
>   }                                                               }
>   nTotalMatchedLines += nMatchedLines;                            nTotalMatchedLines += nMatchedLines;
>                                                                 
>   // Let's see the intermediate results.                          // Let's see the intermediate results.
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr,                                                fprintf (stderr,
>              " found %u/%u matched lines/blocks (%u/%u totals                " found %u/%u matched lines/blocks (%u/%u totals
>              nMatchedLines,                                                  nMatchedLines,
>              nMatchedBlocks,                                                 nMatchedBlocks,
>              nTotalMatchedLines,                                             nTotalMatchedLines,
>              nTotalMatchedBlocks                                             nTotalMatchedBlocks
>             );                                                              );
>                                                                 
>     if (1 < optVerbose) {                                           if (1 < optVerbose) {
>       for (int f = 0; f < 2; f += 1) {                                for (int f = 0; f < 2; f += 1) {
>         fprintf (stderr, "# file #%d\n", f + 1);                        fprintf (stderr, "# file #%d\n", f + 1);
>         for (int l = 0; l < lines[f].size (); l += 1) {                 for (int l = 0; l < lines[f].size (); l += 1) {
>           fprintf (stderr, "#   [%d] ", l);                               fprintf (stderr, "#   [%d] ", l);
>           lines[f][l].Dump (stderr);                                      lines[f][l].Dump (stderr);
>         }                                                               }
>       }                                                               }
>     }                                                               }
>   }                                                               }
>                                                                 
>   // Perform pass #4, in which we find any remaining matches      // Perform pass #4, in which we find any remaining matches 
>   // the unique lines.  For every unique line that has more t     // the unique lines.  For every unique line that has more t
>   // copy in both files, we declare the copies to match.          // copy in both files, we declare the copies to match.
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Pass 4 (finding remaining matches amo       fprintf (stderr, "# Pass 4 (finding remaining matches amo
>   }                                                               }
>                                                                 
>   nMatchedLines = 0;                                              nMatchedLines = 0;
>                                                                 
>   for (MapStringToLinePtr::iterator i = table.begin (); i !=      for (MapStringToLinePtr::iterator i = table.begin (); i != 
>     Line *l = i->second;                                            Line *l = i->second;
>                                                                 
>     // If there's more than 1 matching old and new lines, the       // If there's more than 1 matching old and new lines, the
>     // declare that each pair are (all) the same line.              // declare that each pair are (all) the same line.
>                                                                 
>     // (In the original algorithm, we only recognized a match       // (In the original algorithm, we only recognized a match
>     // if there was exactly 1 copy for each file.)                  // if there was exactly 1 copy for each file.)
>                                                                 
>     while (0 < l->copies[0].size () && 0 < l->copies[1].size        while (0 < l->copies[0].size () && 0 < l->copies[1].size 
>       nMatchedLines += 1;                                             nMatchedLines += 1;
>                                                                 
>       // For each matched line in the new file, mark it with          // For each matched line in the new file, mark it with 
>       // corresponding line (number) in the old file.                 // corresponding line (number) in the old file.
>                                                                 
>       unsigned o = l->copies[0].front ();                             unsigned o = l->copies[0].front ();
>       unsigned n = l->copies[1].front ();                             unsigned n = l->copies[1].front ();
>                                                                 
>       // Match up the pair.                                           // Match up the pair.
>                                                                 
>       lines[0][o].l = n;                                              lines[0][o].l = n;
>       lines[1][n].l = o;                                              lines[1][n].l = o;
>                                                                 
>       // Remove the matched line numbers from the lists.              // Remove the matched line numbers from the lists.
>                                                                 
>       l->copies[0].pop_front ();                                      l->copies[0].pop_front ();
>       l->copies[1].pop_front ();                                      l->copies[1].pop_front ();
>     }                                                               }
>   }                                                               }
>   nTotalMatchedLines += nMatchedLines;                            nTotalMatchedLines += nMatchedLines;
>                                                                 
>   // Let's see the intermediate results.                          // Let's see the intermediate results.
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, " found %u matched lines (%u total).\n",       fprintf (stderr, " found %u matched lines (%u total).\n",
>                                                                 
>     if (1 < optVerbose) {                                           if (1 < optVerbose) {
>       for (int f = 0; f < 2; f += 1) {                                for (int f = 0; f < 2; f += 1) {
>         fprintf (stderr, "# file #%d\n", f + 1);                        fprintf (stderr, "# file #%d\n", f + 1);
>         for (int l = 0; l < lines[f].size (); l += 1) {                 for (int l = 0; l < lines[f].size (); l += 1) {
>           fprintf (stderr, "#   [%d] ", l);                               fprintf (stderr, "#   [%d] ", l);
>           lines[f][l].Dump (stderr);                                      lines[f][l].Dump (stderr);
>         }                                                               }
>       }                                                               }
>     }                                                               }
>   }                                                               }
>                                                                 
>   // Perform Pass #5, in which we look for blocks which match     // Perform Pass #5, in which we look for blocks which match
>   // the result of a move (their not in their original positi     // the result of a move (their not in their original positi
>   // these, we'll unmatch the blocks, turning them into a del     // these, we'll unmatch the blocks, turning them into a del
>   // an insert.                                                   // an insert.
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Pass #5 (unmatching block moves)...\n       fprintf (stderr, "# Pass #5 (unmatching block moves)...\n
>   }                                                               }
>                                                                 
>   nMatchedBlocks = 0;                                             nMatchedBlocks = 0;
>   nMatchedLines = 0;                                              nMatchedLines = 0;
>                                                                 
>   // Starting at the top of both files,...                        // Starting at the top of both files,...
>                                                                 
>   unsigned o = 0;                                                 unsigned o = 0;
>   unsigned n = 0;                                                 unsigned n = 0;
>                                                                 
>   while (o < lines[0].size () || n < lines[1].size ()) {          while (o < lines[0].size () || n < lines[1].size ()) {
>                                                                 
>     // Skip any unmatched lines at this point in the old file       // Skip any unmatched lines at this point in the old file
>     // are deletes.                                                 // are deletes.
>                                                                 
>     //    Old     New                                               //    Old     New
>     //   +---+                                                      //   +---+
>     // 0 | a |                                                      // 0 | a |
>     //   +---+   +---+                                              //   +---+   +---+
>     //         0 | b |                                              //         0 | b |
>     //   +---+   +---+                                              //   +---+   +---+
>     // 1 | c | 1 | c |                                              // 1 | c | 1 | c |
>     //   +---+   +---+                                              //   +---+   +---+
>     //         2 | z |                                              //         2 | z |
>     //   +---+   +---+                                              //   +---+   +---+
>     // 2 | d | 3 | d |                                              // 2 | d | 3 | d |
>     //   +---+   +---+                                              //   +---+   +---+
>                                                                 
>     while (o < lines[0].size () && lines[0][o].l == ~0) {           while (o < lines[0].size () && lines[0][o].l == ~0) {
>       o += 1;                                                         o += 1;
>     }                                                               }
>                                                                 
>     // Skip any unmatched lines at this point in the new file       // Skip any unmatched lines at this point in the new file
>     // are inserts.                                                 // are inserts.
>                                                                 
>     while (n < lines[1].size () && lines[1][n].l == ~0) {           while (n < lines[1].size () && lines[1][n].l == ~0) {
>       n += 1;                                                         n += 1;
>     }                                                               }
>                                                                 
>     // When we get here, we know that we're dealing with matc       // When we get here, we know that we're dealing with matc
>     // lines (or the end of one or both files).  We're done w       // lines (or the end of one or both files).  We're done w
>     // pass, if we've reached the end of either file.               // pass, if we've reached the end of either file.
>                                                                 
>     if (lines[0].size () <= o || lines[1].size () <= n) {           if (lines[0].size () <= o || lines[1].size () <= n) {
>       break;                                                          break;
>     }                                                               }
>                                                                 
>     // We now know that we've got a pair of matching lines, t       // We now know that we've got a pair of matching lines, t
>     // of a matching block.  If the new file's line number is       // of a matching block.  If the new file's line number is
>     // expect, then the matched pair is unmoved, and we can s       // expect, then the matched pair is unmoved, and we can s
>     // the pair.  (If this is really the start of a block of        // the pair.  (If this is really the start of a block of 
>     // 1 lines, we'll handle it one pair at a time.)                // 1 lines, we'll handle it one pair at a time.)
>                                                                 
>     if (lines[0][o].l == n) {                                       if (lines[0][o].l == n) {
>       o += 1;                                                         o += 1;
>       n += 1;                                                         n += 1;
>       continue;                                                       continue;
>     }                                                               }
>                                                                 
>     // If, on the other hand, we don't expect this [new] line       // If, on the other hand, we don't expect this [new] line
>     // then this matching block has been moved.  We need to t       // then this matching block has been moved.  We need to t
>     // matched pair into an *unmatched* pair, one of deletes,       // matched pair into an *unmatched* pair, one of deletes,
>     // of inserts.  First, though, we need to know how big th       // of inserts.  First, though, we need to know how big th
>     // is, and how far it was moved....                             // is, and how far it was moved....
>                                                                 
>     // Remember where we were when we started.                      // Remember where we were when we started.
>                                                                 
>     unsigned oOld = o;                                              unsigned oOld = o;
>     unsigned nOld = n;                                              unsigned nOld = n;
>                                                                 
>     // Remember where the block came from.                          // Remember where the block came from.
>                                                                 
>     unsigned nNew = lines[0][o].l;                                  unsigned nNew = lines[0][o].l;
>                                                                 
>     // Find the end of this matched pair.                           // Find the end of this matched pair.
>                                                                 
>     for (n = nNew; o < lines[0].size () && n < lines[1].size        for (n = nNew; o < lines[0].size () && n < lines[1].size 
>       if (lines[0][o].l != n) {                                       if (lines[0][o].l != n) {
>         break;                                                          break;
>       }                                                               }
>     }                                                               }
>                                                                 
>     // When we get here:                                            // When we get here:
>     // * oOld..o is the old file's block,                           // * oOld..o is the old file's block,
>     // * nNew..n is the new file's *moved* block, and               // * nNew..n is the new file's *moved* block, and
>     // * nOld is where we originally expected the new block f       // * nOld is where we originally expected the new block f
>                                                                  
>     // We can now calculate the length of the block...              // We can now calculate the length of the block...
>                                                                     
>     unsigned bSize = o - oOld;  // (or n - nNew)                    unsigned bSize = o - oOld;  // (or n - nNew)
>                                                                 
>     // ... and we can calculate how far the block moved:            // ... and we can calculate how far the block moved:
>                                                                 
>     unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;       unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
>                                                                 
>     // The larger of the two will become our delete, and the        // The larger of the two will become our delete, and the 
>     // will become our insert.                                      // will become our insert.
>                                                                 
>     //    Old     New                                               //    Old     New
>     //   +---+   +---+                                              //   +---+   +---+
>     // 0 | a | 0 | b |                                              // 0 | a | 0 | b |
>     //   +---+ 1 | b |                                              //   +---+ 1 | b |
>     // 1 | b |   +---+                                              // 1 | b |   +---+
>     // 2 | b | 2 | a |                                              // 2 | b | 2 | a |
>     //   +---+   +---+                                              //   +---+   +---+
>     // 3 | c | 3 | c |                                              // 3 | c | 3 | c |
>     //   +---+   +---+                                              //   +---+   +---+
>                                                                 
>     // (1) Delete a@0, insert a@2, or                               // (1) Delete a@0, insert a@2, or
>     // (2) insert bb@0, delete bb@1?                                // (2) insert bb@0, delete bb@1?
>                                                                 
>     // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and       // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and
>     // (of a) is 2-0 or 2, the size of b@0.  We choose to del       // (of a) is 2-0 or 2, the size of b@0.  We choose to del
>     // and reinsert a@2.                                            // and reinsert a@2.
>                                                                 
>     // if (bSize <= bMove) {                                        // if (bSize <= bMove) {
>       for (unsigned a = oOld; a < o; a += 1) {                        for (unsigned a = oOld; a < o; a += 1) {
>         lines[0][a].l = ~0;                                             lines[0][a].l = ~0;
>       }                                                               }
>       for (unsigned d = nNew; d < n; d += 1) {                        for (unsigned d = nNew; d < n; d += 1) {
>         lines[1][d].l = ~0;                                             lines[1][d].l = ~0;
>       }                                                               }
>     // } else {                                                     // } else {
>       // for (unsigned a = oOld; a < o; a += 1) {                     // for (unsigned a = oOld; a < o; a += 1) {
>       //   lines[0][a].l = ~0;                                        //   lines[0][a].l = ~0;
>       // }                                                            // }
>       // for (unsigned d = nNew; d < n; d += 1) {                     // for (unsigned d = nNew; d < n; d += 1) {
>       //   lines[1][d].l = ~0;                                        //   lines[1][d].l = ~0;
>       // }                                                            // }
>     // }                                                            // }
>                                                                 
>     // Continue from where we left off.                             // Continue from where we left off.
>                                                                 
>     n = nOld;                                                       n = nOld;
>   }                                                               }
>   nTotalMatchedLines -= nMatchedLines;                            nTotalMatchedLines -= nMatchedLines;
>   nTotalMatchedBlocks -= nMatchedBlocks;                          nTotalMatchedBlocks -= nMatchedBlocks;
>                                                                 
>   // Let's see the intermediate results.                          // Let's see the intermediate results.
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr,                                                fprintf (stderr,
>              " found %u/%u matched lines/blocks (%u/%u totals                " found %u/%u matched lines/blocks (%u/%u totals
>              nMatchedLines,                                                  nMatchedLines,
>              nMatchedBlocks,                                                 nMatchedBlocks,
>              nTotalMatchedLines,                                             nTotalMatchedLines,
>              nTotalMatchedBlocks                                             nTotalMatchedBlocks
>             );                                                              );
>                                                                 
>     if (1 < optVerbose) {                                           if (1 < optVerbose) {
>       for (int f = 0; f < 2; f += 1) {                                for (int f = 0; f < 2; f += 1) {
>         fprintf (stderr, "# file #%d\n", f + 1);                        fprintf (stderr, "# file #%d\n", f + 1);
>         for (int l = 0; l < lines[f].size (); l += 1) {                 for (int l = 0; l < lines[f].size (); l += 1) {
>           fprintf (stderr, "#   [%d] ", l);                               fprintf (stderr, "#   [%d] ", l);
>           lines[f][l].Dump (stderr);                                      lines[f][l].Dump (stderr);
>         }                                                               }
>       }                                                               }
>     }                                                               }
>   }                                                               }
>                                                                 
>   // Perform Pass #6, in which we create the desired output.      // Perform Pass #6, in which we create the desired output.
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Pass #6 (walking the differences)...\       fprintf (stderr, "# Pass #6 (walking the differences)...\
>   }                                                               }
>                                                                 
>   nMatchedLines = 0;                                              nMatchedLines = 0;
>                                                                 
>   // Write the header.                                            // Write the header.
>                                                                 
>   switch (diffFormat) {                                           switch (diffFormat) {
>   case Default:                                                   case Default:
>   case Normal:                                                    case Normal:
>     break;                                                          break;
>   case Unified:                                                   case Unified:
>     fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00       fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00
>     fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00       fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00
>     fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (),       fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (),
>     break;                                                          break;
>   }                                                               }
>                                                                 
>   // Starting at the top of both files,...                        // Starting at the top of both files,...
>                                                                 
>   o = 0;                                                          o = 0;
>   n = 0;                                                          n = 0;
>                                                                 
>   while (o < lines[0].size () || n < lines[1].size ()) {          while (o < lines[0].size () || n < lines[1].size ()) {
>                                                                 
>     // Find any unmatched lines at this point in the old file       // Find any unmatched lines at this point in the old file
>     // are deletes.                                                 // are deletes.
>                                                                 
>     unsigned boDeletes;                                             unsigned boDeletes;
>     for (boDeletes = o;                                             for (boDeletes = o;
>          o < lines[0].size () && lines[0][o].l == ~0;                    o < lines[0].size () && lines[0][o].l == ~0;
>          o += 1                                                          o += 1
>         )                                                               )
>     {}                                                              {}
>                                                                 
>     // Find any unmatched lines at this point in the new file       // Find any unmatched lines at this point in the new file
>     // are inserts.                                                 // are inserts.
>                                                                 
>     unsigned boInserts;                                             unsigned boInserts;
>     for (boInserts = n;                                             for (boInserts = n;
>          n < lines[1].size () && lines[1][n].l == ~0;                    n < lines[1].size () && lines[1][n].l == ~0;
>          n += 1                                                          n += 1
>         )                                                               )
>     {}                                                              {}
>                                                                 
>     // We've got deleted line(s) from boDeletes .. o.               // We've got deleted line(s) from boDeletes .. o.
>     // We've got deleted line(s) from boInserts .. n.               // We've got deleted line(s) from boInserts .. n.
>                                                                 
>     unsigned nDeletes = o - boDeletes;                              unsigned nDeletes = o - boDeletes;
>     unsigned nInserts = n - boInserts;                              unsigned nInserts = n - boInserts;
>                                                                 
>     // We've got...                                                 // We've got...
>                                                                 
>     if (nDeletes && nInserts) {                                     if (nDeletes && nInserts) {
>                                                                 
>       // ... deletes and inserts.                                     // ... deletes and inserts.
>                                                                 
>       switch (diffFormat) {                                           switch (diffFormat) {
>       case Default:                                                   case Default:
>       case Normal:                                                    case Normal:
>         if (1 < nDeletes && 1 < nInserts) {                             if (1 < nDeletes && 1 < nInserts) {
>           fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o,             fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o,
>         } else if (1 < nDeletes) {                                      } else if (1 < nDeletes) {
>           fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, bo             fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, bo
>         } else if (1 < nInserts) {                                      } else if (1 < nInserts) {
>           fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boIns             fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boIns
>         }                                                               } 
>         for (unsigned l = boDeletes; l < o; l += 1) {                   for (unsigned l = boDeletes; l < o; l += 1) {
>           fprintf (stdout, "< %s", lines[0][l].line->c_str ()             fprintf (stdout, "< %s", lines[0][l].line->c_str ()
>         }                                                               }
>         fprintf (stderr, "---\n");                                      fprintf (stderr, "---\n");
>         for (unsigned l = boInserts; l < n; l += 1) {                   for (unsigned l = boInserts; l < n; l += 1) {
>           fprintf (stdout, "> %s", lines[1][l].line->c_str ()             fprintf (stdout, "> %s", lines[1][l].line->c_str ()
>         }                                                               }
>         break;                                                          break;
>                                                                 
>       case Unified:                                                   case Unified:
>         for (unsigned l = boDeletes; l < o; l += 1) {                   for (unsigned l = boDeletes; l < o; l += 1) {
>           fprintf (stdout, "-%s", lines[0][l].line->c_str ())             fprintf (stdout, "-%s", lines[0][l].line->c_str ())
>         }                                                               }
>         for (unsigned l = boInserts; l < n; l += 1) {                   for (unsigned l = boInserts; l < n; l += 1) {
>           fprintf (stdout, "+%s", lines[1][l].line->c_str ())             fprintf (stdout, "+%s", lines[1][l].line->c_str ())
>         }                                                               }
>         break;                                                          break;
>       }                                                               }
>     } else if (nDeletes) {                                          } else if (nDeletes) {
>                                                                 
>       //  ... just deletes.                                           //  ... just deletes.
>                                                                 
>       switch (diffFormat) {                                           switch (diffFormat) {
>       case Default:                                                   case Default:
>       case Normal:                                                    case Normal:
>         if (1 < nDeletes) {                                             if (1 < nDeletes) {
>           fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n)             fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n)
>         } else {                                                        } else {
>           fprintf (stdout, "%dd%d\n", boDeletes + 1, n);                  fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
>         }                                                               }
>         for (unsigned l = boDeletes; l < o; l += 1) {                   for (unsigned l = boDeletes; l < o; l += 1) {
>           fprintf (stdout, "< %s", lines[0][l].line->c_str ()             fprintf (stdout, "< %s", lines[0][l].line->c_str ()
>         }                                                               }
>         break;                                                          break;
>       case Unified:                                                   case Unified:
>         for (unsigned l = boDeletes; l < o; l += 1) {                   for (unsigned l = boDeletes; l < o; l += 1) {
>           fprintf (stdout, "-%s", lines[0][l].line->c_str ())             fprintf (stdout, "-%s", lines[0][l].line->c_str ())
>         }                                                               }
>         break;                                                          break;
>       }                                                               }
>     } else if (nInserts) {                                          } else if (nInserts) {
>                                                                 
>       //  ... just inserts.                                           //  ... just inserts.
>                                                                 
>       switch (diffFormat) {                                           switch (diffFormat) {
>       case Default:                                                   case Default:
>       case Normal:                                                    case Normal:
>         if (1 < nInserts) {                                             if (1 < nInserts) {
>           fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n)             fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n)
>         } else {                                                        } else {
>           fprintf (stdout, "%da%d\n", o, boInserts + 1);                  fprintf (stdout, "%da%d\n", o, boInserts + 1);
>         }                                                               }
>         for (unsigned l = boInserts; l < n; l += 1) {                   for (unsigned l = boInserts; l < n; l += 1) {
>           fprintf (stdout, "> %s", lines[1][l].line->c_str ()             fprintf (stdout, "> %s", lines[1][l].line->c_str ()
>         }                                                               }
>         break;                                                          break;
>       case Unified:                                                   case Unified:
>         for (unsigned l = boInserts; l < n; l += 1) {                   for (unsigned l = boInserts; l < n; l += 1) {
>           fprintf (stdout, "+%s", lines[1][l].line->c_str ())             fprintf (stdout, "+%s", lines[1][l].line->c_str ())
>         }                                                               }
>         break;                                                          break;
>       }                                                               }
>     }                                                               }
>                                                                 
>     // When we get here, we're dealing with matching lines.         // When we get here, we're dealing with matching lines.
>                                                                 
>     switch (diffFormat) {                                           switch (diffFormat) {
>     case Default:                                                   case Default:
>     case Normal:                                                    case Normal:
>       break;                                                          break;
>     case Unified:                                                   case Unified:
>       fprintf (stdout, " %s", lines[0][o].line->c_str ());            fprintf (stdout, " %s", lines[0][o].line->c_str ());
>       break;                                                          break;
>     }                                                               }
>     o += 1;                                                         o += 1;
>     n += 1;                                                         n += 1;
>   }                                                               }
> }                                                               }
# ../sdiff -y dif.4.cpp dif.5.cpp >& dif.4.5.diff-y.test
# dif.4.5.diff-y ---------------------------------------------------------------
1,777c1,1142
< #include <algorithm>						#include <algorithm>
< using std::find;						using std::find;
< #include <string>						#include <string>
< using std::string;						using std::string;
< #include <list>							#include <list>
< using std::list;						using std::list;
< #include <map>							#include <map>
< using std::map;							using std::map;
< #include <vector>						#include <vector>
< using std::vector;						using std::vector;
< #include <stdio.h>						#include <stdio.h>
< 
< enum DiffFormat {						enum DiffFormat {
<   Default,							  Default,
< 
<   Context,							  Context,
<   EdScript,							  EdScript,
<   IfThenElse,							  IfThenElse,
<   Normal,							  Normal,
<   RCS,								  RCS,
<   SideBySide,							  SideBySide,
<   Unified							  Unified
< };								};
< 
< DiffFormat diffFormat = Unified;			      |	DiffFormat diffFormat = Context;
< 							      >	unsigned optCopyContext = 3;
< 
< int optVerbose = 1;						int optVerbose = 1;
< 
< struct Line : public string {					struct Line : public string {
<   Line (string _text) :						  Line (string _text) :
<     string (_text)						    string (_text)
<   {								  {
<   }								  }
<   ~Line () {							  ~Line () {
<     copies[0].erase (copies[0].begin (), copies[0].end ());	    copies[0].erase (copies[0].begin (), copies[0].end ());
<     copies[1].erase (copies[1].begin (), copies[1].end ());	    copies[1].erase (copies[1].begin (), copies[1].end ());
<   }								  }
<   void Dump (FILE *out) {					  void Dump (FILE *out) {
<     fprintf (out, "{{ ");					    fprintf (out, "{{ ");
<     for (list<unsigned>::iterator i = copies[0].begin (); i !	    for (list<unsigned>::iterator i = copies[0].begin (); i !
<       fprintf (out, "%u ", *i);					      fprintf (out, "%u ", *i);
<     }								    }
<     fprintf (out, "},{ ");					    fprintf (out, "},{ ");
<     for (list<unsigned>::iterator i = copies[1].begin (); i !	    for (list<unsigned>::iterator i = copies[1].begin (); i !
<       fprintf (out, "%u ", *i);					      fprintf (out, "%u ", *i);
<     }								    }
<     fprintf (out, "}}\t%s", c_str ());				    fprintf (out, "}}\t%s", c_str ());
<   }								  }
<   list<unsigned> copies[2];					  list<unsigned> copies[2];
< };								};
< 
< struct LinePtr {						struct LinePtr {
<   LinePtr (Line *_line) :					  LinePtr (Line *_line) :
<     line (_line),						    line (_line),
<     l (~0u)							    l (~0u)
<   {								  {
<   }								  }
<   void Dump (FILE *out) {					  void Dump (FILE *out) {
<     fprintf (out, "[%d] ", l);					    fprintf (out, "[%d] ", l);
<     line->Dump (out);						    line->Dump (out);
<   }								  }
<   Line *line;							  Line *line;
<   unsigned l;							  unsigned l;
< };								};
< 
< typedef map<string, Line *> MapStringToLinePtr;			typedef map<string, Line *> MapStringToLinePtr;
< typedef vector<LinePtr> VectorLinePtr;				typedef vector<LinePtr> VectorLinePtr;
< 
< char *ARGV0 = "dif2";					      |	// Our name.
< 
< int main (int argc, char *argv[])			      |	char *ARGV0 = "dif3";
< {							      |
<   char const *files[2] = { 0, 0 };			      |	// The 'symbol' (line) table.
< 							      >
< 							      >	MapStringToLinePtr table;
< 							      >
< 							      >	// The names of the 2 files to be diff'd.
< 							      >
< 							      >	char const *files[2] = { 0, 0 };
< 							      >
< 							      >	// The lines of the 2 files to be diff'd.
< 							      >
< 							      >	VectorLinePtr lines[2];
< 
<   MapStringToLinePtr table;				      |	// Miscellaneous metrics.
<   VectorLinePtr lines[2];				      <
< 
<   unsigned nTotalMatchedBlocks = 0;			      |	unsigned nTotalMatchedBlocks = 0;
<   unsigned nMatchedBlocks = 0;				      |	unsigned nMatchedBlocks = 0;
<   unsigned nTotalMatchedLines = 0;			      |	unsigned nTotalMatchedLines = 0;
<   unsigned nMatchedLines = 0;				      |	unsigned nMatchedLines = 0;
< 
< 							      >	void pass1 ();
< 							      >	void pass2 ();
< 							      >	void pass3 ();
< 							      >	void pass4 ();
< 							      >	void pass5 ();
< 							      >	void pass6 ();
< 							      >
< 							      >	int main (int argc, char *argv[])
< 							      >	{
<   // Read the old [0] file, and the new [1] file.		  // Read the old [0] file, and the new [1] file.
< 
<   for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {	  for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
<     files[n] = argv[a];						    files[n] = argv[a];
< 
<     if (FILE *f = fopen (files[n], "r")) {			    if (FILE *f = fopen (files[n], "r")) {
<       if (0 < optVerbose) {					      if (0 < optVerbose) {
<         fprintf (stderr, "# Reading %s...", files[n]);		        fprintf (stderr, "# Reading %s...", files[n]);
<       }								      }
< 
<       char buffer[1024];					      char buffer[1024];
<       unsigned nUniq = 0;					      unsigned nUniq = 0;
< 
<       while (fgets (buffer, sizeof (buffer), f)) {		      while (fgets (buffer, sizeof (buffer), f)) {
<         string text (buffer);					        string text (buffer);
< 
<         Line *line = table[text];				        Line *line = table[text];
< 
<         if (!line) {						        if (!line) {
<           table[text] = line = new Line (text);			          table[text] = line = new Line (text);
<           nUniq += 1;						          nUniq += 1;
<         }							        }
<         line->copies[n].push_back (lines[n].size ());		        line->copies[n].push_back (lines[n].size ());
<         lines[n].push_back (line);				        lines[n].push_back (line);
<       }								      }
< 
<       if (0 < optVerbose) {					      if (0 < optVerbose) {
<         fprintf (stderr, " %u lines, %u unique.\n", lines[n].	        fprintf (stderr, " %u lines, %u unique.\n", lines[n].
<       }								      }
<     } else {							    } else {
<       fprintf (stderr, "%s: Unable to open %s!  Exiting....\n	      fprintf (stderr, "%s: Unable to open %s!  Exiting....\n
<       perror (ARGV0);						      perror (ARGV0);
<       exit (1);							      exit (1);
<     }								    }
<   }								  }
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     printf ("# Total unique lines = %d\n", table.size ());    |	    fprintf (stderr, "# Total unique lines = %d\n", table.siz
<   }								  }
< 
<   // map<int, int> counts;					  // map<int, int> counts;
<   // for (MapStringToLinePtr::iterator i = table.begin (); i 	  // for (MapStringToLinePtr::iterator i = table.begin (); i 
<   //   Line *l = i->second;					  //   Line *l = i->second;
<   //   counts[l->counts[0].size () + l->counts[1].size ()] +=	  //   counts[l->counts[0].size () + l->counts[1].size ()] +=
<   // }								  // }
<   // for (map<int, int>::iterator i = counts.begin (); i != c	  // for (map<int, int>::iterator i = counts.begin (); i != c
<   //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s	  //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s
<   // }								  // }
< 
<   // Perform pass #1, in which we find all explicit matches a |	  pass1 ();
<   // the unique lines.  For every unique line that appears th |	  pass2 ();
<   // number of times in both files, we declare the lines to m |	  pass3 ();
< 							      >	  pass4 ();
< 							      >	  pass5 ();
< 							      >	  pass6 ();
< 
< 							      >	  return 0;
< 							      >	}
< 							      >
< 							      >	// Perform pass #1, in which we find all explicit matches amo
< 							      >	// unique lines.  For every unique line that appears the same
< 							      >	// of times in both files, we declare the lines to match.
< 							      >
< 							      >	void pass1 ()
< 							      >	{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass 1 (finding matches amongst uniqu	    fprintf (stderr, "# Pass 1 (finding matches amongst uniqu
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   for (MapStringToLinePtr::iterator i = table.begin (); i != 	  for (MapStringToLinePtr::iterator i = table.begin (); i != 
<     Line *l = i->second;					    Line *l = i->second;
< 
<     // If the number of old and new lines match, then we decl	    // If the number of old and new lines match, then we decl
<     // they are (all) the same line.  Note, it isn't possible	    // they are (all) the same line.  Note, it isn't possible
<     // numbers of both files to be 0.				    // numbers of both files to be 0.
< 
<     // (In the original algorithm, we only recognized a match	    // (In the original algorithm, we only recognized a match
<     // if there was exactly 1 copy for each file.)		    // if there was exactly 1 copy for each file.)
< 
<     if (l->copies[0].size () == l->copies[1].size ()) {		    if (l->copies[0].size () == l->copies[1].size ()) {
<       nMatchedLines += 1;					      nMatchedLines += 1;
< 
<       // For each matched line in the new file, mark it with 	      // For each matched line in the new file, mark it with 
<       // corresponding line (number) in the old file.		      // corresponding line (number) in the old file.
< 
<       while (!l->copies[0].empty ()) {				      while (!l->copies[0].empty ()) {
<         unsigned o = l->copies[0].front ();			        unsigned o = l->copies[0].front ();
<         unsigned n = l->copies[1].front ();			        unsigned n = l->copies[1].front ();
< 
<         // Match up the pair.					        // Match up the pair.
< 
<         lines[0][o].l = n;					        lines[0][o].l = n;
<         lines[1][n].l = o;					        lines[1][n].l = o;
< 
<         // Remove the matched line numbers from the lists.	        // Remove the matched line numbers from the lists.
< 
<         l->copies[0].pop_front ();				        l->copies[0].pop_front ();
<         l->copies[1].pop_front ();				        l->copies[1].pop_front ();
<       }								      }
<     }								    }
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, " found %u matched lines (%u total).\n",	    fprintf (stderr, " found %u matched lines (%u total).\n",
< 
<     if (1 < optVerbose) {					    if (1 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< 							      >	}
< 
<   // Perform Pass #2, in which we attempt to 'widen' blocks o |	// Perform Pass #2, in which we attempt to 'widen' blocks of 
<   // lines, by appending lines which are the same in both fil |	// lines, by appending lines which are the same in both files
< 
< 							      >	void pass2 ()
< 							      >	{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #2 (spreading matches down)...")	    fprintf (stderr, "# Pass #2 (spreading matches down)...")
<   }								  }
< 
<   nMatchedBlocks = 0;						  nMatchedBlocks = 0;
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Starting at the top of the old file,...			  // Starting at the top of the old file,...
< 
<   for (unsigned o = 0; o < lines[0].size (); o += 1) {		  for (unsigned o = 0; o < lines[0].size (); o += 1) {
< 
<     // ... skip any currently unmatched lines...		    // ... skip any currently unmatched lines...
< 
<     if (lines[0][o].l == ~0) {					    if (lines[0][o].l == ~0) {
<       continue;							      continue;
<     }								    }
< 
<     // ... until we find an [already] matched line.  Then, sk	    // ... until we find an [already] matched line.  Then, sk
<     // the set of 1 or more matched lines, until we reach any	    // the set of 1 or more matched lines, until we reach any
<     // following, still-unmatched line.				    // following, still-unmatched line.
< 
<     unsigned n;							    unsigned n;
<     do {							    do {
<       n = lines[0][o].l + 1;					      n = lines[0][o].l + 1;
<       o += 1;							      o += 1;
<     } while (o < lines[0].size () && lines[0][o].l != ~0);	    } while (o < lines[0].size () && lines[0][o].l != ~0);
< 
<     // Now, o - 1 is the line number of the last matched old 	    // Now, o - 1 is the line number of the last matched old 
<     // n - 1 is the line number of the last matched new line.	    // n - 1 is the line number of the last matched new line.
<     // to add new old and new lines, if they match.		    // to add new old and new lines, if they match.
< 
<     // Finally, attempt to add unmatched lines to the preceed	    // Finally, attempt to add unmatched lines to the preceed
<     // matched set.						    // matched set.
< 
<     for (; o < lines[0].size () && lines[0][o].l == ~0; o += 	    for (; o < lines[0].size () && lines[0][o].l == ~0; o += 
< 
<       // If the [next] pair of old and new lines aren't the s	      // If the [next] pair of old and new lines aren't the s
< 
<       if (lines[0][o].line != lines[1][n].line) {		      if (lines[0][o].line != lines[1][n].line) {
<         break;							        break;
<       }								      }
< 
<       // Match up the pair.					      // Match up the pair.
< 
<       lines[0][o].l = n;					      lines[0][o].l = n;
<       lines[1][n].l = o;					      lines[1][n].l = o;
< 
<       // Remove the matched line numbers form the lists.	      // Remove the matched line numbers form the lists.
< 
<       Line *line = lines[0][o].line;				      Line *line = lines[0][o].line;
<       list<unsigned> &oldCopies = line->copies[0];		      list<unsigned> &oldCopies = line->copies[0];
<       list<unsigned>::iterator oL = find (oldCopies.begin (),	      list<unsigned>::iterator oL = find (oldCopies.begin (),
<       if (oL != oldCopies.end ()) {				      if (oL != oldCopies.end ()) {
<         oldCopies.erase (oL);					        oldCopies.erase (oL);
<       }								      }
<       list<unsigned> &newCopies = line->copies[0];		      list<unsigned> &newCopies = line->copies[0];
<       list<unsigned>::iterator nL = find (newCopies.begin (),	      list<unsigned>::iterator nL = find (newCopies.begin (),
<       if (nL != newCopies.end ()) {				      if (nL != newCopies.end ()) {
<         newCopies.erase (nL);					        newCopies.erase (nL);
<       }								      }
< 
<       nMatchedLines += 1;					      nMatchedLines += 1;
<     }								    }
<     nMatchedBlocks += 1;					    nMatchedBlocks += 1;
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
<   nTotalMatchedBlocks += nMatchedBlocks;			  nTotalMatchedBlocks += nMatchedBlocks;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr,						    fprintf (stderr,
<              " found %u/%u matched lines/blocks (%u/%u totals	             " found %u/%u matched lines/blocks (%u/%u totals
<              nMatchedLines,					             nMatchedLines,
<              nMatchedBlocks,					             nMatchedBlocks,
<              nTotalMatchedLines,				             nTotalMatchedLines,
<              nTotalMatchedBlocks				             nTotalMatchedBlocks
<             );							            );
<     if (1 < optVerbose) {					    if (1 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< 							      >	}
< 
<   // Perform Pass #3, in which we attempt to 'widen' blocks o |	// Perform Pass #3, in which we attempt to 'widen' blocks of 
<   // lines, by prepending lines which are the same in both fi |	// lines, by prepending lines which are the same in both file
< 
< 							      >	void pass3 ()
< 							      >	{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #3 (spreading matches up)...");	    fprintf (stderr, "# Pass #3 (spreading matches up)...");
<   }								  }
< 
<   nMatchedBlocks = 0;						  nMatchedBlocks = 0;
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Starting at the bottom of the old file,...			  // Starting at the bottom of the old file,...
< 
<   for (int o = lines[0].size (); 0 <= o; o -= 1) {		  for (int o = lines[0].size (); 0 <= o; o -= 1) {
< 
<     // ... skip any currently unmatched lines...		    // ... skip any currently unmatched lines...
< 
<     if (lines[0][o].l == ~0) {					    if (lines[0][o].l == ~0) {
<       continue;							      continue;
<     }								    }
< 
<     // ... until we find an [already] matched line.  Then, sk	    // ... until we find an [already] matched line.  Then, sk
<     // the set of 1 or more matched lines, until we reach any	    // the set of 1 or more matched lines, until we reach any
<     // following, still-unmatched line.				    // following, still-unmatched line.
< 
<     unsigned n;							    unsigned n;
<     do {							    do {
<       n = lines[0][o].l - 1;					      n = lines[0][o].l - 1;
<       o -= 1;							      o -= 1;
<     } while (0 <= o && lines[0][o].l != ~0);			    } while (0 <= o && lines[0][o].l != ~0);
< 
<     // Now, o + 1 is the line number of the last matched old 	    // Now, o + 1 is the line number of the last matched old 
<     // n + 1 is the line number of the last matched new line.	    // n + 1 is the line number of the last matched new line.
<     // to add new old and new lines, if they match.		    // to add new old and new lines, if they match.
< 
<     // Finally, attempt to add unmatched lines to the preceed	    // Finally, attempt to add unmatched lines to the preceed
<     // matched set.						    // matched set.
< 
<     for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {	    for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
< 
<       // If the [next] pair of old and new lines aren't the s	      // If the [next] pair of old and new lines aren't the s
< 
<       if (lines[0][o].line != lines[1][n].line) {		      if (lines[0][o].line != lines[1][n].line) {
<         break;							        break;
<       }								      }
< 
<       // Match up the pair.					      // Match up the pair.
< 
<       lines[0][o].l = n;					      lines[0][o].l = n;
<       lines[1][n].l = o;					      lines[1][n].l = o;
< 
<       // Remove the matched line numbers form the lists.	      // Remove the matched line numbers form the lists.
< 
<       Line *line = lines[0][o].line;				      Line *line = lines[0][o].line;
<       list<unsigned> &oldCopies = line->copies[0];		      list<unsigned> &oldCopies = line->copies[0];
<       list<unsigned>::iterator oL = find (oldCopies.begin (),	      list<unsigned>::iterator oL = find (oldCopies.begin (),
<       if (oL != oldCopies.end ()) {				      if (oL != oldCopies.end ()) {
<         oldCopies.erase (oL);					        oldCopies.erase (oL);
<       }								      }
<       list<unsigned> &newCopies = line->copies[0];		      list<unsigned> &newCopies = line->copies[0];
<       list<unsigned>::iterator nL = find (newCopies.begin (),	      list<unsigned>::iterator nL = find (newCopies.begin (),
<       if (nL != newCopies.end ()) {				      if (nL != newCopies.end ()) {
<         newCopies.erase (nL);					        newCopies.erase (nL);
<       }								      }
< 
<       nMatchedLines += 1;					      nMatchedLines += 1;
<     }								    }
<     nMatchedBlocks += 1;					    nMatchedBlocks += 1;
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr,						    fprintf (stderr,
<              " found %u/%u matched lines/blocks (%u/%u totals	             " found %u/%u matched lines/blocks (%u/%u totals
<              nMatchedLines,					             nMatchedLines,
<              nMatchedBlocks,					             nMatchedBlocks,
<              nTotalMatchedLines,				             nTotalMatchedLines,
<              nTotalMatchedBlocks				             nTotalMatchedBlocks
<             );							            );
< 
<     if (1 < optVerbose) {					    if (1 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< 							      >	}
< 
<   // Perform pass #4, in which we find any remaining matches  |	// Perform pass #4, in which we find any remaining matches am
<   // the unique lines.  For every unique line that has more t |	// unique lines.  For every unique line that has more than 1 
<   // copy in both files, we declare the copies to match.      |	// both files, we declare the copies to match.
< 
< 							      >	void pass4 ()
< 							      >	{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass 4 (finding remaining matches amo	    fprintf (stderr, "# Pass 4 (finding remaining matches amo
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   for (MapStringToLinePtr::iterator i = table.begin (); i != 	  for (MapStringToLinePtr::iterator i = table.begin (); i != 
<     Line *l = i->second;					    Line *l = i->second;
< 
<     // If there's more than 1 matching old and new lines, the	    // If there's more than 1 matching old and new lines, the
<     // declare that each pair are (all) the same line.		    // declare that each pair are (all) the same line.
< 
<     // (In the original algorithm, we only recognized a match	    // (In the original algorithm, we only recognized a match
<     // if there was exactly 1 copy for each file.)		    // if there was exactly 1 copy for each file.)
< 
<     while (0 < l->copies[0].size () && 0 < l->copies[1].size 	    while (0 < l->copies[0].size () && 0 < l->copies[1].size 
<       nMatchedLines += 1;					      nMatchedLines += 1;
< 
<       // For each matched line in the new file, mark it with 	      // For each matched line in the new file, mark it with 
<       // corresponding line (number) in the old file.		      // corresponding line (number) in the old file.
< 
<       unsigned o = l->copies[0].front ();			      unsigned o = l->copies[0].front ();
<       unsigned n = l->copies[1].front ();			      unsigned n = l->copies[1].front ();
< 
<       // Match up the pair.					      // Match up the pair.
< 
<       lines[0][o].l = n;					      lines[0][o].l = n;
<       lines[1][n].l = o;					      lines[1][n].l = o;
< 
<       // Remove the matched line numbers from the lists.	      // Remove the matched line numbers from the lists.
< 
<       l->copies[0].pop_front ();				      l->copies[0].pop_front ();
<       l->copies[1].pop_front ();				      l->copies[1].pop_front ();
<     }								    }
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, " found %u matched lines (%u total).\n",	    fprintf (stderr, " found %u matched lines (%u total).\n",
< 
<     if (1 < optVerbose) {					    if (1 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< 							      >	}
< 
<   // Perform Pass #5, in which we look for blocks which match |	// Perform Pass #5, in which we look for blocks which match, 
<   // the result of a move (their not in their original positi |	// the result of a move (their not in their original position
<   // these, we'll unmatch the blocks, turning them into a del |	// these, we'll unmatch the blocks, turning them into a delet
<   // an insert.						      |	// insert.
< 
< 							      >	void pass5 ()
< 							      >	{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #5 (unmatching block moves)...\n	    fprintf (stderr, "# Pass #5 (unmatching block moves)...\n
<   }								  }
< 
<   nMatchedBlocks = 0;						  nMatchedBlocks = 0;
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Starting at the top of both files,...			  // Starting at the top of both files,...
< 
<   unsigned o = 0;						  unsigned o = 0;
<   unsigned n = 0;						  unsigned n = 0;
< 
<   while (o < lines[0].size () || n < lines[1].size ()) {	  while (o < lines[0].size () || n < lines[1].size ()) {
< 
<     // Skip any unmatched lines at this point in the old file	    // Skip any unmatched lines at this point in the old file
<     // are deletes.						    // are deletes.
< 
<     //    Old     New						    //    Old     New
<     //   +---+							    //   +---+
<     // 0 | a |							    // 0 | a |
<     //   +---+   +---+						    //   +---+   +---+
<     //         0 | b |						    //         0 | b |
<     //   +---+   +---+						    //   +---+   +---+
<     // 1 | c | 1 | c |						    // 1 | c | 1 | c |
<     //   +---+   +---+						    //   +---+   +---+
<     //         2 | z |						    //         2 | z |
<     //   +---+   +---+						    //   +---+   +---+
<     // 2 | d | 3 | d |						    // 2 | d | 3 | d |
<     //   +---+   +---+						    //   +---+   +---+
< 
<     while (o < lines[0].size () && lines[0][o].l == ~0) {	    while (o < lines[0].size () && lines[0][o].l == ~0) {
<       o += 1;							      o += 1;
<     }								    }
< 
<     // Skip any unmatched lines at this point in the new file	    // Skip any unmatched lines at this point in the new file
<     // are inserts.						    // are inserts.
< 
<     while (n < lines[1].size () && lines[1][n].l == ~0) {	    while (n < lines[1].size () && lines[1][n].l == ~0) {
<       n += 1;							      n += 1;
<     }								    }
< 
<     // When we get here, we know that we're dealing with matc	    // When we get here, we know that we're dealing with matc
<     // lines (or the end of one or both files).  We're done w	    // lines (or the end of one or both files).  We're done w
<     // pass, if we've reached the end of either file.		    // pass, if we've reached the end of either file.
< 
<     if (lines[0].size () <= o || lines[1].size () <= n) {	    if (lines[0].size () <= o || lines[1].size () <= n) {
<       break;							      break;
<     }								    }
< 
<     // We now know that we've got a pair of matching lines, t	    // We now know that we've got a pair of matching lines, t
<     // of a matching block.  If the new file's line number is	    // of a matching block.  If the new file's line number is
<     // expect, then the matched pair is unmoved, and we can s	    // expect, then the matched pair is unmoved, and we can s
<     // the pair.  (If this is really the start of a block of 	    // the pair.  (If this is really the start of a block of 
<     // 1 lines, we'll handle it one pair at a time.)		    // 1 lines, we'll handle it one pair at a time.)
< 
<     if (lines[0][o].l == n) {					    if (lines[0][o].l == n) {
<       o += 1;							      o += 1;
<       n += 1;							      n += 1;
<       continue;							      continue;
<     }								    }
< 
<     // If, on the other hand, we don't expect this [new] line	    // If, on the other hand, we don't expect this [new] line
<     // then this matching block has been moved.  We need to t	    // then this matching block has been moved.  We need to t
<     // matched pair into an *unmatched* pair, one of deletes,	    // matched pair into an *unmatched* pair, one of deletes,
<     // of inserts.  First, though, we need to know how big th	    // of inserts.  First, though, we need to know how big th
<     // is, and how far it was moved....				    // is, and how far it was moved....
< 
<     // Remember where we were when we started.			    // Remember where we were when we started.
< 
<     unsigned oOld = o;						    unsigned oOld = o;
<     unsigned nOld = n;						    unsigned nOld = n;
< 
<     // Remember where the block came from.			    // Remember where the block came from.
< 
<     unsigned nNew = lines[0][o].l;				    unsigned nNew = lines[0][o].l;
< 
<     // Find the end of this matched pair.			    // Find the end of this matched pair.
< 
<     for (n = nNew; o < lines[0].size () && n < lines[1].size 	    for (n = nNew; o < lines[0].size () && n < lines[1].size 
<       if (lines[0][o].l != n) {					      if (lines[0][o].l != n) {
<         break;							        break;
<       }								      }
<     }								    }
< 
<     // When we get here:					    // When we get here:
<     // * oOld..o is the old file's block,			    // * oOld..o is the old file's block,
<     // * nNew..n is the new file's *moved* block, and		    // * nNew..n is the new file's *moved* block, and
<     // * nOld is where we originally expected the new block f	    // * nOld is where we originally expected the new block f
<  								 
<     // We can now calculate the length of the block...		    // We can now calculate the length of the block...
<     								    
<     unsigned bSize = o - oOld;  // (or n - nNew)		    unsigned bSize = o - oOld;  // (or n - nNew)
< 
<     // ... and we can calculate how far the block moved:	    // ... and we can calculate how far the block moved:
< 
<     unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;	    unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
< 
<     // The larger of the two will become our delete, and the 	    // The larger of the two will become our delete, and the 
<     // will become our insert.					    // will become our insert.
< 
<     //    Old     New						    //    Old     New
<     //   +---+   +---+						    //   +---+   +---+
<     // 0 | a | 0 | b |						    // 0 | a | 0 | b |
<     //   +---+ 1 | b |						    //   +---+ 1 | b |
<     // 1 | b |   +---+						    // 1 | b |   +---+
<     // 2 | b | 2 | a |						    // 2 | b | 2 | a |
<     //   +---+   +---+						    //   +---+   +---+
<     // 3 | c | 3 | c |						    // 3 | c | 3 | c |
<     //   +---+   +---+						    //   +---+   +---+
< 
<     // (1) Delete a@0, insert a@2, or				    // (1) Delete a@0, insert a@2, or
<     // (2) insert bb@0, delete bb@1?				    // (2) insert bb@0, delete bb@1?
< 
<     // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and	    // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and
<     // (of a) is 2-0 or 2, the size of b@0.  We choose to del	    // (of a) is 2-0 or 2, the size of b@0.  We choose to del
<     // and reinsert a@2.					    // and reinsert a@2.
< 
<     // if (bSize <= bMove) {					    // if (bSize <= bMove) {
<       for (unsigned a = oOld; a < o; a += 1) {			      for (unsigned a = oOld; a < o; a += 1) {
<         lines[0][a].l = ~0;					        lines[0][a].l = ~0;
<       }								      }
<       for (unsigned d = nNew; d < n; d += 1) {			      for (unsigned d = nNew; d < n; d += 1) {
<         lines[1][d].l = ~0;					        lines[1][d].l = ~0;
<       }								      }
<     // } else {							    // } else {
<       // for (unsigned a = oOld; a < o; a += 1) {		      // for (unsigned a = oOld; a < o; a += 1) {
<       //   lines[0][a].l = ~0;					      //   lines[0][a].l = ~0;
<       // }							      // }
<       // for (unsigned d = nNew; d < n; d += 1) {		      // for (unsigned d = nNew; d < n; d += 1) {
<       //   lines[1][d].l = ~0;					      //   lines[1][d].l = ~0;
<       // }							      // }
<     // }							    // }
< 
<     // Continue from where we left off.				    // Continue from where we left off.
< 
<     n = nOld;							    n = nOld;
<   }								  }
<   nTotalMatchedLines -= nMatchedLines;				  nTotalMatchedLines -= nMatchedLines;
<   nTotalMatchedBlocks -= nMatchedBlocks;			  nTotalMatchedBlocks -= nMatchedBlocks;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr,						    fprintf (stderr,
<              " found %u/%u matched lines/blocks (%u/%u totals	             " found %u/%u matched lines/blocks (%u/%u totals
<              nMatchedLines,					             nMatchedLines,
<              nMatchedBlocks,					             nMatchedBlocks,
<              nTotalMatchedLines,				             nTotalMatchedLines,
<              nTotalMatchedBlocks				             nTotalMatchedBlocks
<             );							            );
< 
<     if (1 < optVerbose) {					    if (1 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< 							      >	}
< 
<   // Perform Pass #6, in which we create the desired output.  |	// Perform Pass #6, in which we create the desired output.
< 
<   if (0 < optVerbose) {					      |	void pass6c ();
<     fprintf (stderr, "# Pass #6 (walking the differences)...\ |	void pass6e ();
<   }							      |	void pass6i ();
< 							      >	void pass6n ();
< 							      >	void pass6r ();
< 							      >	void pass6s ();
< 							      >	void pass6u ();
< 
<   nMatchedLines = 0;					      |	void pass6 ()
< 							      |	{
<   // Write the header.					      <
< 
<   switch (diffFormat) {						  switch (diffFormat) {
<   case Default:						      |	  case Context:
< 							      >	    pass6c ();
< 							      >	    break;
< 							      >
< 							      >	  case EdScript:
< 							      >	    pass6e ();
< 							      >	    break;
< 							      >
< 							      >	  case IfThenElse:
< 							      >	    pass6i ();
< 							      >	    break;
< 							      >
<   case Normal:							  case Normal:
< 							      >	    pass6n ();
<     break;							    break;
< 							      >
< 							      >	  case RCS:
< 							      >	    pass6r ();
< 							      >	    break;
< 							      >
< 							      >	  case SideBySide:
< 							      >	    pass6s ();
< 							      >	    break;
< 							      >
<   case Unified:							  case Unified:
<     fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00 |	    pass6u ();
<     fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00 |	    break;
<     fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), |
< 							      >	  case Default:
< 							      >	  default:
< 							      >	    pass6c ();
<     break;							    break;
<   }								  }
< 							      >	}
< 							      >
< 							      >	template<typename T> T min (T l, T r) {
< 							      >	  if (l < r) {
< 							      >	    return l;
< 							      >	  }
< 							      >	  return r;
< 							      >	}
< 							      >
< 							      >	template<typename T> T max (T l, T r) {
< 							      >	  if (l < r) {
< 							      >	    return r;
< 							      >	  }
< 							      >	  return l;
< 							      >	}
< 							      >
< 							      >	void pass6c () {
< 							      >	  if (0 < optVerbose) {
< 							      >	    fprintf (stderr, "# Pass #6u (walking the differences)...
< 							      >	  }
< 							      >
< 							      >	  nMatchedLines = 0;
< 							      >
< 							      >	  // Write the header.
< 							      >
< 							      >	  fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:0
< 							      >	  fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:0
< 
<   // Starting at the top of both files,...			  // Starting at the top of both files,...
< 
<   o = 0;						      |	  unsigned o = 0;
<   n = 0;						      |	  unsigned n = 0;
< 
<   while (o < lines[0].size () || n < lines[1].size ()) {	  while (o < lines[0].size () || n < lines[1].size ()) {
< 
<     // Find any unmatched lines at this point in the old file	    // Find any unmatched lines at this point in the old file
<     // are deletes.						    // are deletes.
< 
<     unsigned boDeletes;						    unsigned boDeletes;
<     for (boDeletes = o;						    for (boDeletes = o;
<          o < lines[0].size () && lines[0][o].l == ~0;		         o < lines[0].size () && lines[0][o].l == ~0;
<          o += 1							         o += 1
<         )							        )
<     {}								    {}
< 
<     // Find any unmatched lines at this point in the new file	    // Find any unmatched lines at this point in the new file
<     // are inserts.						    // are inserts.
< 
<     unsigned boInserts;						    unsigned boInserts;
<     for (boInserts = n;						    for (boInserts = n;
<          n < lines[1].size () && lines[1][n].l == ~0;		         n < lines[1].size () && lines[1][n].l == ~0;
<          n += 1							         n += 1
<         )							        )
<     {}								    {}
< 
<     // We've got deleted line(s) from boDeletes .. o.		    // We've got deleted line(s) from boDeletes .. o.
<     // We've got deleted line(s) from boInserts .. n.		    // We've got deleted line(s) from boInserts .. n.
< 
<     unsigned nDeletes = o - boDeletes;				    unsigned nDeletes = o - boDeletes;
<     unsigned nInserts = n - boInserts;				    unsigned nInserts = n - boInserts;
< 
<     // We've got...					      |	    // Have we got anything?
< 
<     if (nDeletes && nInserts) {				      |	    if (nDeletes || nInserts) {
< 							      >	      int boOldWindow = max (0, int (boDeletes) - int(optCopy
< 							      >	      int eoOldWindow = min (int (lines[0].size ()), int(o) +
< 
<       // ... deletes and inserts.			      |	      int boNewWindow = max (0, int (boInserts) - int (optCop
< 							      >	      int eoNewWindow = min (int (lines[1].size ()), int(n) +
< 							      >
< 							      >	      fprintf (stdout, "***************\n*** %d,%d ****", boO
< 							      >	      for (unsigned l = boOldWindow; l < boDeletes; l += 1) {
< 							      >	        fprintf (stdout, "  %s", lines[0][l].line->c_str ());
< 							      >	      }
< 							      >
< 							      >	      // We've got...
< 							      >
< 							      >	      if (nDeletes && nInserts) {
< 							      >
< 							      >	        // ... deletes and inserts.
< 
<       switch (diffFormat) {				      <
<       case Default:					      <
<       case Normal:					      <
<         if (1 < nDeletes && 1 < nInserts) {		      <
---
> #include <algorithm>                                            #include <algorithm>
> using std::find;                                                using std::find;
> #include <string>                                               #include <string>
> using std::string;                                              using std::string;
> #include <list>                                                 #include <list>
> using std::list;                                                using std::list;
> #include <map>                                                  #include <map>
> using std::map;                                                 using std::map;
> #include <vector>                                               #include <vector>
> using std::vector;                                              using std::vector;
> #include <stdio.h>                                              #include <stdio.h>
>                                                                 
> enum DiffFormat {                                               enum DiffFormat {
>   Default,                                                        Default,
>                                                                 
>   Context,                                                        Context,
>   EdScript,                                                       EdScript,
>   IfThenElse,                                                     IfThenElse,
>   Normal,                                                         Normal,
>   RCS,                                                            RCS,
>   SideBySide,                                                     SideBySide,
>   Unified                                                         Unified
> };                                                              };
>                                                                 
> DiffFormat diffFormat = Unified;                              | DiffFormat diffFormat = Context;
>                                                               > unsigned optCopyContext = 3;
>                                                                 
> int optVerbose = 1;                                             int optVerbose = 1;
>                                                                 
> struct Line : public string {                                   struct Line : public string {
>   Line (string _text) :                                           Line (string _text) :
>     string (_text)                                                  string (_text)
>   {                                                               {
>   }                                                               }
>   ~Line () {                                                      ~Line () {
>     copies[0].erase (copies[0].begin (), copies[0].end ());         copies[0].erase (copies[0].begin (), copies[0].end ());
>     copies[1].erase (copies[1].begin (), copies[1].end ());         copies[1].erase (copies[1].begin (), copies[1].end ());
>   }                                                               }
>   void Dump (FILE *out) {                                         void Dump (FILE *out) {
>     fprintf (out, "{{ ");                                           fprintf (out, "{{ ");
>     for (list<unsigned>::iterator i = copies[0].begin (); i !       for (list<unsigned>::iterator i = copies[0].begin (); i !
>       fprintf (out, "%u ", *i);                                       fprintf (out, "%u ", *i);
>     }                                                               }
>     fprintf (out, "},{ ");                                          fprintf (out, "},{ ");
>     for (list<unsigned>::iterator i = copies[1].begin (); i !       for (list<unsigned>::iterator i = copies[1].begin (); i !
>       fprintf (out, "%u ", *i);                                       fprintf (out, "%u ", *i);
>     }                                                               }
>     fprintf (out, "}}\t%s", c_str ());                              fprintf (out, "}}\t%s", c_str ());
>   }                                                               }
>   list<unsigned> copies[2];                                       list<unsigned> copies[2];
> };                                                              };
>                                                                 
> struct LinePtr {                                                struct LinePtr {
>   LinePtr (Line *_line) :                                         LinePtr (Line *_line) :
>     line (_line),                                                   line (_line),
>     l (~0u)                                                         l (~0u)
>   {                                                               {
>   }                                                               }
>   void Dump (FILE *out) {                                         void Dump (FILE *out) {
>     fprintf (out, "[%d] ", l);                                      fprintf (out, "[%d] ", l);
>     line->Dump (out);                                               line->Dump (out);
>   }                                                               }
>   Line *line;                                                     Line *line;
>   unsigned l;                                                     unsigned l;
> };                                                              };
>                                                                 
> typedef map<string, Line *> MapStringToLinePtr;                 typedef map<string, Line *> MapStringToLinePtr;
> typedef vector<LinePtr> VectorLinePtr;                          typedef vector<LinePtr> VectorLinePtr;
>                                                                 
> char *ARGV0 = "dif2";                                         | // Our name.
>                                                               <
> int main (int argc, char *argv[])                             <
> {                                                             <
>   char const *files[2] = { 0, 0 };                            <
>                                                                 
>   MapStringToLinePtr table;                                   | char *ARGV0 = "dif3";
>   VectorLinePtr lines[2];                                     <
>                                                                 
>   unsigned nTotalMatchedBlocks = 0;                           | // The 'symbol' (line) table.
>   unsigned nMatchedBlocks = 0;                                <
>   unsigned nTotalMatchedLines = 0;                            <
>   unsigned nMatchedLines = 0;                                 <
>                                                                 
>   // Read the old [0] file, and the new [1] file.             | MapStringToLinePtr table;
>                                                               <
>   for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) { <
>     files[n] = argv[a];                                       <
>                                                               <
>     if (FILE *f = fopen (files[n], "r")) {                    <
>       if (0 < optVerbose) {                                   <
>         fprintf (stderr, "# Reading %s...", files[n]);        <
>       }                                                       <
>                                                               <
>       char buffer[1024];                                      <
>       unsigned nUniq = 0;                                     <
>                                                               <
>       while (fgets (buffer, sizeof (buffer), f)) {            <
>         string text (buffer);                                 <
>                                                               <
>         Line *line = table[text];                             <
>                                                               <
>         if (!line) {                                          <
>           table[text] = line = new Line (text);               <
>           nUniq += 1;                                         <
>         }                                                     <
>         line->copies[n].push_back (lines[n].size ());         <
>         lines[n].push_back (line);                            <
>       }                                                       <
>                                                               <
>       if (0 < optVerbose) {                                   <
>         fprintf (stderr, " %u lines, %u unique.\n", lines[n]. <
>       }                                                       <
>     } else {                                                  <
>       fprintf (stderr, "%s: Unable to open %s!  Exiting....\n <
>       perror (ARGV0);                                         <
>       exit (1);                                               <
>     }                                                         <
>   }                                                           <
>                                                               <
>   if (0 < optVerbose) {                                       <
>     printf ("# Total unique lines = %d\n", table.size ());    <
>   }                                                           <
>                                                               <
>   // map<int, int> counts;                                    <
>   // for (MapStringToLinePtr::iterator i = table.begin (); i  <
>   //   Line *l = i->second;                                   <
>   //   counts[l->counts[0].size () + l->counts[1].size ()] += <
>   // }                                                        <
>   // for (map<int, int>::iterator i = counts.begin (); i != c <
>   //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s <
>   // }                                                        <
>                                                               <
>   // Perform pass #1, in which we find all explicit matches a <
>   // the unique lines.  For every unique line that appears th <
>   // number of times in both files, we declare the lines to m <
>                                                                 
>   if (0 < optVerbose) {                                       | // The names of the 2 files to be diff'd.
>     fprintf (stderr, "# Pass 1 (finding matches amongst uniqu <
>   }                                                           <
>                                                               <
>   nMatchedLines = 0;                                          <
>                                                               <
>   for (MapStringToLinePtr::iterator i = table.begin (); i !=  <
>     Line *l = i->second;                                      <
>                                                               <
>     // If the number of old and new lines match, then we decl <
>     // they are (all) the same line.  Note, it isn't possible <
>     // numbers of both files to be 0.                         <
>                                                               <
>     // (In the original algorithm, we only recognized a match <
>     // if there was exactly 1 copy for each file.)            <
>                                                               <
>     if (l->copies[0].size () == l->copies[1].size ()) {       <
>       nMatchedLines += 1;                                     <
>                                                               <
>       // For each matched line in the new file, mark it with  <
>       // corresponding line (number) in the old file.         <
>                                                               <
>       while (!l->copies[0].empty ()) {                        <
>         unsigned o = l->copies[0].front ();                   <
>         unsigned n = l->copies[1].front ();                   <
>                                                               <
>         // Match up the pair.                                 <
>                                                               <
>         lines[0][o].l = n;                                    <
>         lines[1][n].l = o;                                    <
>                                                               <
>         // Remove the matched line numbers from the lists.    <
>                                                               <
>         l->copies[0].pop_front ();                            <
>         l->copies[1].pop_front ();                            <
>       }                                                       <
>     }                                                         <
>   }                                                           <
>   nTotalMatchedLines += nMatchedLines;                        <
>                                                               <
>   // Let's see the intermediate results.                      <
>                                                               <
>   if (0 < optVerbose) {                                       <
>     fprintf (stderr, " found %u matched lines (%u total).\n", <
>                                                               <
>     if (1 < optVerbose) {                                     <
>       for (int f = 0; f < 2; f += 1) {                        <
>         fprintf (stderr, "# file #%d\n", f + 1);              <
>         for (int l = 0; l < lines[f].size (); l += 1) {       <
>           fprintf (stderr, "#   [%d] ", l);                   <
>           lines[f][l].Dump (stderr);                          <
>         }                                                     <
>       }                                                       <
>     }                                                         <
>   }                                                           <
>                                                                 
>   // Perform Pass #2, in which we attempt to 'widen' blocks o | char const *files[2] = { 0, 0 };
>   // lines, by appending lines which are the same in both fil <
>                                                                 
>   if (0 < optVerbose) {                                       | // The lines of the 2 files to be diff'd.
>     fprintf (stderr, "# Pass #2 (spreading matches down)...") <
>   }                                                           <
>                                                               <
>   nMatchedBlocks = 0;                                         <
>   nMatchedLines = 0;                                          <
>                                                               <
>   // Starting at the top of the old file,...                  <
>                                                               <
>   for (unsigned o = 0; o < lines[0].size (); o += 1) {        <
>                                                               <
>     // ... skip any currently unmatched lines...              <
>                                                               <
>     if (lines[0][o].l == ~0) {                                <
>       continue;                                               <
>     }                                                         <
>                                                               <
>     // ... until we find an [already] matched line.  Then, sk <
>     // the set of 1 or more matched lines, until we reach any <
>     // following, still-unmatched line.                       <
>                                                               <
>     unsigned n;                                               <
>     do {                                                      <
>       n = lines[0][o].l + 1;                                  <
>       o += 1;                                                 <
>     } while (o < lines[0].size () && lines[0][o].l != ~0);    <
>                                                               <
>     // Now, o - 1 is the line number of the last matched old  <
>     // n - 1 is the line number of the last matched new line. <
>     // to add new old and new lines, if they match.           <
>                                                               <
>     // Finally, attempt to add unmatched lines to the preceed <
>     // matched set.                                           <
>                                                               <
>     for (; o < lines[0].size () && lines[0][o].l == ~0; o +=  <
>                                                               <
>       // If the [next] pair of old and new lines aren't the s <
>                                                               <
>       if (lines[0][o].line != lines[1][n].line) {             <
>         break;                                                <
>       }                                                       <
>                                                               <
>       // Match up the pair.                                   <
>                                                               <
>       lines[0][o].l = n;                                      <
>       lines[1][n].l = o;                                      <
>                                                               <
>       // Remove the matched line numbers form the lists.      <
>                                                               <
>       Line *line = lines[0][o].line;                          <
>       list<unsigned> &oldCopies = line->copies[0];            <
>       list<unsigned>::iterator oL = find (oldCopies.begin (), <
>       if (oL != oldCopies.end ()) {                           <
>         oldCopies.erase (oL);                                 <
>       }                                                       <
>       list<unsigned> &newCopies = line->copies[0];            <
>       list<unsigned>::iterator nL = find (newCopies.begin (), <
>       if (nL != newCopies.end ()) {                           <
>         newCopies.erase (nL);                                 <
>       }                                                       <
>                                                               <
>       nMatchedLines += 1;                                     <
>     }                                                         <
>     nMatchedBlocks += 1;                                      <
>   }                                                           <
>   nTotalMatchedLines += nMatchedLines;                        <
>   nTotalMatchedBlocks += nMatchedBlocks;                      <
>                                                               <
>   // Let's see the intermediate results.                      <
>                                                               <
>   if (0 < optVerbose) {                                       <
>     fprintf (stderr,                                          <
>              " found %u/%u matched lines/blocks (%u/%u totals <
>              nMatchedLines,                                   <
>              nMatchedBlocks,                                  <
>              nTotalMatchedLines,                              <
>              nTotalMatchedBlocks                              <
>             );                                                <
>     if (1 < optVerbose) {                                     <
>       for (int f = 0; f < 2; f += 1) {                        <
>         fprintf (stderr, "# file #%d\n", f + 1);              <
>         for (int l = 0; l < lines[f].size (); l += 1) {       <
>           fprintf (stderr, "#   [%d] ", l);                   <
>           lines[f][l].Dump (stderr);                          <
>         }                                                     <
>       }                                                       <
>     }                                                         <
>   }                                                           <
>                                                                 
>   // Perform Pass #3, in which we attempt to 'widen' blocks o | VectorLinePtr lines[2];
>   // lines, by prepending lines which are the same in both fi <
>                                                                 
>   if (0 < optVerbose) {                                       | // Miscellaneous metrics.
>     fprintf (stderr, "# Pass #3 (spreading matches up)...");  <
>   }                                                           <
>                                                               <
>   nMatchedBlocks = 0;                                         <
>   nMatchedLines = 0;                                          <
>                                                               <
>   // Starting at the bottom of the old file,...               <
>                                                               <
>   for (int o = lines[0].size (); 0 <= o; o -= 1) {            <
>                                                               <
>     // ... skip any currently unmatched lines...              <
>                                                               <
>     if (lines[0][o].l == ~0) {                                <
>       continue;                                               <
>     }                                                         <
>                                                               <
>     // ... until we find an [already] matched line.  Then, sk <
>     // the set of 1 or more matched lines, until we reach any <
>     // following, still-unmatched line.                       <
>                                                               <
>     unsigned n;                                               <
>     do {                                                      <
>       n = lines[0][o].l - 1;                                  <
>       o -= 1;                                                 <
>     } while (0 <= o && lines[0][o].l != ~0);                  <
>                                                               <
>     // Now, o + 1 is the line number of the last matched old  <
>     // n + 1 is the line number of the last matched new line. <
>     // to add new old and new lines, if they match.           <
>                                                               <
>     // Finally, attempt to add unmatched lines to the preceed <
>     // matched set.                                           <
>                                                               <
>     for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {   <
>                                                               <
>       // If the [next] pair of old and new lines aren't the s <
>                                                               <
>       if (lines[0][o].line != lines[1][n].line) {             <
>         break;                                                <
>       }                                                       <
>                                                               <
>       // Match up the pair.                                   <
>                                                               <
>       lines[0][o].l = n;                                      <
>       lines[1][n].l = o;                                      <
>                                                               <
>       // Remove the matched line numbers form the lists.      <
>                                                               <
>       Line *line = lines[0][o].line;                          <
>       list<unsigned> &oldCopies = line->copies[0];            <
>       list<unsigned>::iterator oL = find (oldCopies.begin (), <
>       if (oL != oldCopies.end ()) {                           <
>         oldCopies.erase (oL);                                 <
>       }                                                       <
>       list<unsigned> &newCopies = line->copies[0];            <
>       list<unsigned>::iterator nL = find (newCopies.begin (), <
>       if (nL != newCopies.end ()) {                           <
>         newCopies.erase (nL);                                 <
>       }                                                       <
>                                                               <
>       nMatchedLines += 1;                                     <
>     }                                                         <
>     nMatchedBlocks += 1;                                      <
>   }                                                           <
>   nTotalMatchedLines += nMatchedLines;                        <
>                                                               <
>   // Let's see the intermediate results.                      <
>                                                               <
>   if (0 < optVerbose) {                                       <
>     fprintf (stderr,                                          <
>              " found %u/%u matched lines/blocks (%u/%u totals <
>              nMatchedLines,                                   <
>              nMatchedBlocks,                                  <
>              nTotalMatchedLines,                              <
>              nTotalMatchedBlocks                              <
>             );                                                <
>                                                               <
>     if (1 < optVerbose) {                                     <
>       for (int f = 0; f < 2; f += 1) {                        <
>         fprintf (stderr, "# file #%d\n", f + 1);              <
>         for (int l = 0; l < lines[f].size (); l += 1) {       <
>           fprintf (stderr, "#   [%d] ", l);                   <
>           lines[f][l].Dump (stderr);                          <
>         }                                                     <
>       }                                                       <
>     }                                                         <
>   }                                                           <
>                                                                 
>   // Perform pass #4, in which we find any remaining matches  | unsigned nTotalMatchedBlocks = 0;
>   // the unique lines.  For every unique line that has more t | unsigned nMatchedBlocks = 0;
>   // copy in both files, we declare the copies to match.      | unsigned nTotalMatchedLines = 0;
>                                                               > unsigned nMatchedLines = 0;
>                                                                 
>   if (0 < optVerbose) {                                       | void pass1 ();
>     fprintf (stderr, "# Pass 4 (finding remaining matches amo | void pass2 ();
>   }                                                           | void pass3 ();
>                                                               | void pass4 ();
>   nMatchedLines = 0;                                          | void pass5 ();
>                                                               | void pass6 ();
>   for (MapStringToLinePtr::iterator i = table.begin (); i !=  | 
>     Line *l = i->second;                                      | int main (int argc, char *argv[])
>                                                               | {
>     // If there's more than 1 matching old and new lines, the |   // Read the old [0] file, and the new [1] file.
>     // declare that each pair are (all) the same line.        | 
>                                                               |   for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
>     // (In the original algorithm, we only recognized a match |     files[n] = argv[a];
>     // if there was exactly 1 copy for each file.)            | 
>                                                               |     if (FILE *f = fopen (files[n], "r")) {
>     while (0 < l->copies[0].size () && 0 < l->copies[1].size  |       if (0 < optVerbose) {
>       nMatchedLines += 1;                                     |         fprintf (stderr, "# Reading %s...", files[n]);
>                                                               |       }
>       // For each matched line in the new file, mark it with  | 
>       // corresponding line (number) in the old file.         |       char buffer[1024];
>                                                               |       unsigned nUniq = 0;
>       unsigned o = l->copies[0].front ();                     | 
>       unsigned n = l->copies[1].front ();                     |       while (fgets (buffer, sizeof (buffer), f)) {
>                                                               |         string text (buffer);
>       // Match up the pair.                                   | 
>                                                               |         Line *line = table[text];
>       lines[0][o].l = n;                                      | 
>       lines[1][n].l = o;                                      |         if (!line) {
>                                                               |           table[text] = line = new Line (text);
>       // Remove the matched line numbers from the lists.      |           nUniq += 1;
>                                                               |         }
>       l->copies[0].pop_front ();                              |         line->copies[n].push_back (lines[n].size ());
>       l->copies[1].pop_front ();                              |         lines[n].push_back (line);
>     }                                                         |       }
>   }                                                           | 
>   nTotalMatchedLines += nMatchedLines;                        |       if (0 < optVerbose) {
>                                                               |         fprintf (stderr, " %u lines, %u unique.\n", lines[n].
>   // Let's see the intermediate results.                      |       }
>                                                               |     } else {
>   if (0 < optVerbose) {                                       |       fprintf (stderr, "%s: Unable to open %s!  Exiting....\n
>     fprintf (stderr, " found %u matched lines (%u total).\n", |       perror (ARGV0);
>                                                               |       exit (1);
>     if (1 < optVerbose) {                                     |     }
>       for (int f = 0; f < 2; f += 1) {                        |   }
>         fprintf (stderr, "# file #%d\n", f + 1);              | 
>         for (int l = 0; l < lines[f].size (); l += 1) {       |   if (0 < optVerbose) {
>           fprintf (stderr, "#   [%d] ", l);                   |     fprintf (stderr, "# Total unique lines = %d\n", table.siz
>           lines[f][l].Dump (stderr);                          |   }
>         }                                                     | 
>       }                                                       |   // map<int, int> counts;
>     }                                                         |   // for (MapStringToLinePtr::iterator i = table.begin (); i 
>   }                                                           |   //   Line *l = i->second;
>                                                               >   //   counts[l->counts[0].size () + l->counts[1].size ()] +=
>                                                               >   // }
>                                                               >   // for (map<int, int>::iterator i = counts.begin (); i != c
>                                                               >   //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s
>                                                               >   // }
>                                                               > 
>                                                               >   pass1 ();
>                                                               >   pass2 ();
>                                                               >   pass3 ();
>                                                               >   pass4 ();
>                                                               >   pass5 ();
>                                                               >   pass6 ();
>                                                                 
>   // Perform Pass #5, in which we look for blocks which match |   return 0;
>   // the result of a move (their not in their original positi | }
>   // these, we'll unmatch the blocks, turning them into a del <
>   // an insert.                                               <
>                                                                 
>   if (0 < optVerbose) {                                       | // Perform pass #1, in which we find all explicit matches amo
>     fprintf (stderr, "# Pass #5 (unmatching block moves)...\n | // unique lines.  For every unique line that appears the same
>   }                                                           | // of times in both files, we declare the lines to match.
>                                                               <
>   nMatchedBlocks = 0;                                         <
>   nMatchedLines = 0;                                          <
>                                                               <
>   // Starting at the top of both files,...                    <
>                                                               <
>   unsigned o = 0;                                             <
>   unsigned n = 0;                                             <
>                                                               <
>   while (o < lines[0].size () || n < lines[1].size ()) {      <
>                                                               <
>     // Skip any unmatched lines at this point in the old file <
>     // are deletes.                                           <
>                                                               <
>     //    Old     New                                         <
>     //   +---+                                                <
>     // 0 | a |                                                <
>     //   +---+   +---+                                        <
>     //         0 | b |                                        <
>     //   +---+   +---+                                        <
>     // 1 | c | 1 | c |                                        <
>     //   +---+   +---+                                        <
>     //         2 | z |                                        <
>     //   +---+   +---+                                        <
>     // 2 | d | 3 | d |                                        <
>     //   +---+   +---+                                        <
>                                                               <
>     while (o < lines[0].size () && lines[0][o].l == ~0) {     <
>       o += 1;                                                 <
>     }                                                         <
>                                                               <
>     // Skip any unmatched lines at this point in the new file <
>     // are inserts.                                           <
>                                                               <
>     while (n < lines[1].size () && lines[1][n].l == ~0) {     <
>       n += 1;                                                 <
>     }                                                         <
>                                                               <
>     // When we get here, we know that we're dealing with matc <
>     // lines (or the end of one or both files).  We're done w <
>     // pass, if we've reached the end of either file.         <
>                                                               <
>     if (lines[0].size () <= o || lines[1].size () <= n) {     <
>       break;                                                  <
>     }                                                         <
>                                                               <
>     // We now know that we've got a pair of matching lines, t <
>     // of a matching block.  If the new file's line number is <
>     // expect, then the matched pair is unmoved, and we can s <
>     // the pair.  (If this is really the start of a block of  <
>     // 1 lines, we'll handle it one pair at a time.)          <
>                                                               <
>     if (lines[0][o].l == n) {                                 <
>       o += 1;                                                 <
>       n += 1;                                                 <
>       continue;                                               <
>     }                                                         <
>                                                               <
>     // If, on the other hand, we don't expect this [new] line <
>     // then this matching block has been moved.  We need to t <
>     // matched pair into an *unmatched* pair, one of deletes, <
>     // of inserts.  First, though, we need to know how big th <
>     // is, and how far it was moved....                       <
>                                                               <
>     // Remember where we were when we started.                <
>                                                               <
>     unsigned oOld = o;                                        <
>     unsigned nOld = n;                                        <
>                                                               <
>     // Remember where the block came from.                    <
>                                                               <
>     unsigned nNew = lines[0][o].l;                            <
>                                                               <
>     // Find the end of this matched pair.                     <
>                                                               <
>     for (n = nNew; o < lines[0].size () && n < lines[1].size  <
>       if (lines[0][o].l != n) {                               <
>         break;                                                <
>       }                                                       <
>     }                                                         <
>                                                               <
>     // When we get here:                                      <
>     // * oOld..o is the old file's block,                     <
>     // * nNew..n is the new file's *moved* block, and         <
>     // * nOld is where we originally expected the new block f <
>                                                               <
>     // We can now calculate the length of the block...        <
>                                                               <
>     unsigned bSize = o - oOld;  // (or n - nNew)              <
>                                                               <
>     // ... and we can calculate how far the block moved:      <
>                                                               <
>     unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew; <
>                                                               <
>     // The larger of the two will become our delete, and the  <
>     // will become our insert.                                <
>                                                               <
>     //    Old     New                                         <
>     //   +---+   +---+                                        <
>     // 0 | a | 0 | b |                                        <
>     //   +---+ 1 | b |                                        <
>     // 1 | b |   +---+                                        <
>     // 2 | b | 2 | a |                                        <
>     //   +---+   +---+                                        <
>     // 3 | c | 3 | c |                                        <
>     //   +---+   +---+                                        <
>                                                               <
>     // (1) Delete a@0, insert a@2, or                         <
>     // (2) insert bb@0, delete bb@1?                          <
>                                                               <
>     // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and <
>     // (of a) is 2-0 or 2, the size of b@0.  We choose to del <
>     // and reinsert a@2.                                      <
>                                                               <
>     // if (bSize <= bMove) {                                  <
>       for (unsigned a = oOld; a < o; a += 1) {                <
>         lines[0][a].l = ~0;                                   <
>       }                                                       <
>       for (unsigned d = nNew; d < n; d += 1) {                <
>         lines[1][d].l = ~0;                                   <
>       }                                                       <
>     // } else {                                               <
>       // for (unsigned a = oOld; a < o; a += 1) {             <
>       //   lines[0][a].l = ~0;                                <
>       // }                                                    <
>       // for (unsigned d = nNew; d < n; d += 1) {             <
>       //   lines[1][d].l = ~0;                                <
>       // }                                                    <
>     // }                                                      <
>                                                               <
>     // Continue from where we left off.                       <
>                                                               <
>     n = nOld;                                                 <
>   }                                                           <
>   nTotalMatchedLines -= nMatchedLines;                        <
>   nTotalMatchedBlocks -= nMatchedBlocks;                      <
>                                                               <
>   // Let's see the intermediate results.                      <
>                                                               <
>   if (0 < optVerbose) {                                       <
>     fprintf (stderr,                                          <
>              " found %u/%u matched lines/blocks (%u/%u totals <
>              nMatchedLines,                                   <
>              nMatchedBlocks,                                  <
>              nTotalMatchedLines,                              <
>              nTotalMatchedBlocks                              <
>             );                                                <
>                                                               <
>     if (1 < optVerbose) {                                     <
>       for (int f = 0; f < 2; f += 1) {                        <
>         fprintf (stderr, "# file #%d\n", f + 1);              <
>         for (int l = 0; l < lines[f].size (); l += 1) {       <
>           fprintf (stderr, "#   [%d] ", l);                   <
>           lines[f][l].Dump (stderr);                          <
>         }                                                     <
>       }                                                       <
>     }                                                         <
>   }                                                           <
>                                                                 
>   // Perform Pass #6, in which we create the desired output.  | void pass1 ()
>                                                               > {
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr, "# Pass 1 (finding matches amongst uniqu
>                                                               >   }
>                                                               > 
>                                                               >   nMatchedLines = 0;
>                                                               > 
>                                                               >   for (MapStringToLinePtr::iterator i = table.begin (); i != 
>                                                               >     Line *l = i->second;
>                                                               > 
>                                                               >     // If the number of old and new lines match, then we decl
>                                                               >     // they are (all) the same line.  Note, it isn't possible
>                                                               >     // numbers of both files to be 0.
>                                                               > 
>                                                               >     // (In the original algorithm, we only recognized a match
>                                                               >     // if there was exactly 1 copy for each file.)
>                                                               > 
>                                                               >     if (l->copies[0].size () == l->copies[1].size ()) {
>                                                               >       nMatchedLines += 1;
>                                                               > 
>                                                               >       // For each matched line in the new file, mark it with 
>                                                               >       // corresponding line (number) in the old file.
>                                                               > 
>                                                               >       while (!l->copies[0].empty ()) {
>                                                               >         unsigned o = l->copies[0].front ();
>                                                               >         unsigned n = l->copies[1].front ();
>                                                               > 
>                                                               >         // Match up the pair.
>                                                               > 
>                                                               >         lines[0][o].l = n;
>                                                               >         lines[1][n].l = o;
>                                                               > 
>                                                               >         // Remove the matched line numbers from the lists.
>                                                               > 
>                                                               >         l->copies[0].pop_front ();
>                                                               >         l->copies[1].pop_front ();
>                                                               >       }
>                                                               >     }
>                                                               >   }
>                                                               >   nTotalMatchedLines += nMatchedLines;
>                                                               > 
>                                                               >   // Let's see the intermediate results.
>                                                               > 
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr, " found %u matched lines (%u total).\n",
>                                                               > 
>                                                               >     if (1 < optVerbose) {
>                                                               >       for (int f = 0; f < 2; f += 1) {
>                                                               >         fprintf (stderr, "# file #%d\n", f + 1);
>                                                               >         for (int l = 0; l < lines[f].size (); l += 1) {
>                                                               >           fprintf (stderr, "#   [%d] ", l);
>                                                               >           lines[f][l].Dump (stderr);
>                                                               >         }
>                                                               >       }
>                                                               >     }
>                                                               >   }
>                                                               > }
>                                                                 
>   if (0 < optVerbose) {                                       | // Perform Pass #2, in which we attempt to 'widen' blocks of 
>     fprintf (stderr, "# Pass #6 (walking the differences)...\ | // lines, by appending lines which are the same in both files
>   }                                                           <
>                                                                 
>   nMatchedLines = 0;                                          | void pass2 ()
>                                                               > {
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr, "# Pass #2 (spreading matches down)...")
>                                                               >   }
>                                                               > 
>                                                               >   nMatchedBlocks = 0;
>                                                               >   nMatchedLines = 0;
>                                                               > 
>                                                               >   // Starting at the top of the old file,...
>                                                               > 
>                                                               >   for (unsigned o = 0; o < lines[0].size (); o += 1) {
>                                                               > 
>                                                               >     // ... skip any currently unmatched lines...
>                                                               > 
>                                                               >     if (lines[0][o].l == ~0) {
>                                                               >       continue;
>                                                               >     }
>                                                               > 
>                                                               >     // ... until we find an [already] matched line.  Then, sk
>                                                               >     // the set of 1 or more matched lines, until we reach any
>                                                               >     // following, still-unmatched line.
>                                                               > 
>                                                               >     unsigned n;
>                                                               >     do {
>                                                               >       n = lines[0][o].l + 1;
>                                                               >       o += 1;
>                                                               >     } while (o < lines[0].size () && lines[0][o].l != ~0);
>                                                               > 
>                                                               >     // Now, o - 1 is the line number of the last matched old 
>                                                               >     // n - 1 is the line number of the last matched new line.
>                                                               >     // to add new old and new lines, if they match.
>                                                               > 
>                                                               >     // Finally, attempt to add unmatched lines to the preceed
>                                                               >     // matched set.
>                                                               > 
>                                                               >     for (; o < lines[0].size () && lines[0][o].l == ~0; o += 
>                                                               > 
>                                                               >       // If the [next] pair of old and new lines aren't the s
>                                                               > 
>                                                               >       if (lines[0][o].line != lines[1][n].line) {
>                                                               >         break;
>                                                               >       }
>                                                               > 
>                                                               >       // Match up the pair.
>                                                               > 
>                                                               >       lines[0][o].l = n;
>                                                               >       lines[1][n].l = o;
>                                                               > 
>                                                               >       // Remove the matched line numbers form the lists.
>                                                               > 
>                                                               >       Line *line = lines[0][o].line;
>                                                               >       list<unsigned> &oldCopies = line->copies[0];
>                                                               >       list<unsigned>::iterator oL = find (oldCopies.begin (),
>                                                               >       if (oL != oldCopies.end ()) {
>                                                               >         oldCopies.erase (oL);
>                                                               >       }
>                                                               >       list<unsigned> &newCopies = line->copies[0];
>                                                               >       list<unsigned>::iterator nL = find (newCopies.begin (),
>                                                               >       if (nL != newCopies.end ()) {
>                                                               >         newCopies.erase (nL);
>                                                               >       }
>                                                               > 
>                                                               >       nMatchedLines += 1;
>                                                               >     }
>                                                               >     nMatchedBlocks += 1;
>                                                               >   }
>                                                               >   nTotalMatchedLines += nMatchedLines;
>                                                               >   nTotalMatchedBlocks += nMatchedBlocks;
>                                                               > 
>                                                               >   // Let's see the intermediate results.
>                                                               > 
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr,
>                                                               >              " found %u/%u matched lines/blocks (%u/%u totals
>                                                               >              nMatchedLines,
>                                                               >              nMatchedBlocks,
>                                                               >              nTotalMatchedLines,
>                                                               >              nTotalMatchedBlocks
>                                                               >             );
>                                                               >     if (1 < optVerbose) {
>                                                               >       for (int f = 0; f < 2; f += 1) {
>                                                               >         fprintf (stderr, "# file #%d\n", f + 1);
>                                                               >         for (int l = 0; l < lines[f].size (); l += 1) {
>                                                               >           fprintf (stderr, "#   [%d] ", l);
>                                                               >           lines[f][l].Dump (stderr);
>                                                               >         }
>                                                               >       }
>                                                               >     }
>                                                               >   }
>                                                               > }
>                                                                 
>   // Write the header.                                        | // Perform Pass #3, in which we attempt to 'widen' blocks of 
>                                                               | // lines, by prepending lines which are the same in both file
>   switch (diffFormat) {                                       <
>   case Default:                                               <
>   case Normal:                                                <
>     break;                                                    <
>   case Unified:                                               <
>     fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00 <
>     fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00 <
>     fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), <
>     break;                                                    <
>   }                                                           <
>                                                                 
>   // Starting at the top of both files,...                    | void pass3 ()
>                                                               > {
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr, "# Pass #3 (spreading matches up)...");
>                                                               >   }
>                                                               > 
>                                                               >   nMatchedBlocks = 0;
>                                                               >   nMatchedLines = 0;
>                                                               > 
>                                                               >   // Starting at the bottom of the old file,...
>                                                               > 
>                                                               >   for (int o = lines[0].size (); 0 <= o; o -= 1) {
>                                                               > 
>                                                               >     // ... skip any currently unmatched lines...
>                                                               > 
>                                                               >     if (lines[0][o].l == ~0) {
>                                                               >       continue;
>                                                               >     }
>                                                               > 
>                                                               >     // ... until we find an [already] matched line.  Then, sk
>                                                               >     // the set of 1 or more matched lines, until we reach any
>                                                               >     // following, still-unmatched line.
>                                                               > 
>                                                               >     unsigned n;
>                                                               >     do {
>                                                               >       n = lines[0][o].l - 1;
>                                                               >       o -= 1;
>                                                               >     } while (0 <= o && lines[0][o].l != ~0);
>                                                               > 
>                                                               >     // Now, o + 1 is the line number of the last matched old 
>                                                               >     // n + 1 is the line number of the last matched new line.
>                                                               >     // to add new old and new lines, if they match.
>                                                               > 
>                                                               >     // Finally, attempt to add unmatched lines to the preceed
>                                                               >     // matched set.
>                                                               > 
>                                                               >     for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
>                                                               > 
>                                                               >       // If the [next] pair of old and new lines aren't the s
>                                                               > 
>                                                               >       if (lines[0][o].line != lines[1][n].line) {
>                                                               >         break;
>                                                               >       }
>                                                               > 
>                                                               >       // Match up the pair.
>                                                               > 
>                                                               >       lines[0][o].l = n;
>                                                               >       lines[1][n].l = o;
>                                                               > 
>                                                               >       // Remove the matched line numbers form the lists.
>                                                               > 
>                                                               >       Line *line = lines[0][o].line;
>                                                               >       list<unsigned> &oldCopies = line->copies[0];
>                                                               >       list<unsigned>::iterator oL = find (oldCopies.begin (),
>                                                               >       if (oL != oldCopies.end ()) {
>                                                               >         oldCopies.erase (oL);
>                                                               >       }
>                                                               >       list<unsigned> &newCopies = line->copies[0];
>                                                               >       list<unsigned>::iterator nL = find (newCopies.begin (),
>                                                               >       if (nL != newCopies.end ()) {
>                                                               >         newCopies.erase (nL);
>                                                               >       }
>                                                               > 
>                                                               >       nMatchedLines += 1;
>                                                               >     }
>                                                               >     nMatchedBlocks += 1;
>                                                               >   }
>                                                               >   nTotalMatchedLines += nMatchedLines;
>                                                               > 
>                                                               >   // Let's see the intermediate results.
>                                                               > 
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr,
>                                                               >              " found %u/%u matched lines/blocks (%u/%u totals
>                                                               >              nMatchedLines,
>                                                               >              nMatchedBlocks,
>                                                               >              nTotalMatchedLines,
>                                                               >              nTotalMatchedBlocks
>                                                               >             );
>                                                               > 
>                                                               >     if (1 < optVerbose) {
>                                                               >       for (int f = 0; f < 2; f += 1) {
>                                                               >         fprintf (stderr, "# file #%d\n", f + 1);
>                                                               >         for (int l = 0; l < lines[f].size (); l += 1) {
>                                                               >           fprintf (stderr, "#   [%d] ", l);
>                                                               >           lines[f][l].Dump (stderr);
>                                                               >         }
>                                                               >       }
>                                                               >     }
>                                                               >   }
>                                                               > }
>                                                                 
>   o = 0;                                                      | // Perform pass #4, in which we find any remaining matches am
>   n = 0;                                                      | // unique lines.  For every unique line that has more than 1 
>                                                               > // both files, we declare the copies to match.
>                                                                 
>   while (o < lines[0].size () || n < lines[1].size ()) {      | void pass4 ()
>                                                               > {
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr, "# Pass 4 (finding remaining matches amo
>                                                               >   }
>                                                               > 
>                                                               >   nMatchedLines = 0;
>                                                               > 
>                                                               >   for (MapStringToLinePtr::iterator i = table.begin (); i != 
>                                                               >     Line *l = i->second;
>                                                               > 
>                                                               >     // If there's more than 1 matching old and new lines, the
>                                                               >     // declare that each pair are (all) the same line.
>                                                               > 
>                                                               >     // (In the original algorithm, we only recognized a match
>                                                               >     // if there was exactly 1 copy for each file.)
>                                                               > 
>                                                               >     while (0 < l->copies[0].size () && 0 < l->copies[1].size 
>                                                               >       nMatchedLines += 1;
>                                                               > 
>                                                               >       // For each matched line in the new file, mark it with 
>                                                               >       // corresponding line (number) in the old file.
>                                                               > 
>                                                               >       unsigned o = l->copies[0].front ();
>                                                               >       unsigned n = l->copies[1].front ();
>                                                               > 
>                                                               >       // Match up the pair.
>                                                               > 
>                                                               >       lines[0][o].l = n;
>                                                               >       lines[1][n].l = o;
>                                                               > 
>                                                               >       // Remove the matched line numbers from the lists.
>                                                               > 
>                                                               >       l->copies[0].pop_front ();
>                                                               >       l->copies[1].pop_front ();
>                                                               >     }
>                                                               >   }
>                                                               >   nTotalMatchedLines += nMatchedLines;
>                                                               > 
>                                                               >   // Let's see the intermediate results.
>                                                               > 
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr, " found %u matched lines (%u total).\n",
>                                                               > 
>                                                               >     if (1 < optVerbose) {
>                                                               >       for (int f = 0; f < 2; f += 1) {
>                                                               >         fprintf (stderr, "# file #%d\n", f + 1);
>                                                               >         for (int l = 0; l < lines[f].size (); l += 1) {
>                                                               >           fprintf (stderr, "#   [%d] ", l);
>                                                               >           lines[f][l].Dump (stderr);
>                                                               >         }
>                                                               >       }
>                                                               >     }
>                                                               >   }
>                                                               > }
>                                                                 
>     // Find any unmatched lines at this point in the old file | // Perform Pass #5, in which we look for blocks which match, 
>     // are deletes.                                           | // the result of a move (their not in their original position
>                                                               > // these, we'll unmatch the blocks, turning them into a delet
>                                                               > // insert.
>                                                                 
>     unsigned boDeletes;                                       | void pass5 ()
>     for (boDeletes = o;                                       | {
>          o < lines[0].size () && lines[0][o].l == ~0;         |   if (0 < optVerbose) {
>          o += 1                                               |     fprintf (stderr, "# Pass #5 (unmatching block moves)...\n
>         )                                                     |   }
>     {}                                                        | 
>                                                               >   nMatchedBlocks = 0;
>                                                               >   nMatchedLines = 0;
>                                                               > 
>                                                               >   // Starting at the top of both files,...
>                                                               > 
>                                                               >   unsigned o = 0;
>                                                               >   unsigned n = 0;
>                                                               > 
>                                                               >   while (o < lines[0].size () || n < lines[1].size ()) {
>                                                               > 
>                                                               >     // Skip any unmatched lines at this point in the old file
>                                                               >     // are deletes.
>                                                               > 
>                                                               >     //    Old     New
>                                                               >     //   +---+
>                                                               >     // 0 | a |
>                                                               >     //   +---+   +---+
>                                                               >     //         0 | b |
>                                                               >     //   +---+   +---+
>                                                               >     // 1 | c | 1 | c |
>                                                               >     //   +---+   +---+
>                                                               >     //         2 | z |
>                                                               >     //   +---+   +---+
>                                                               >     // 2 | d | 3 | d |
>                                                               >     //   +---+   +---+
>                                                               > 
>                                                               >     while (o < lines[0].size () && lines[0][o].l == ~0) {
>                                                               >       o += 1;
>                                                               >     }
>                                                               > 
>                                                               >     // Skip any unmatched lines at this point in the new file
>                                                               >     // are inserts.
>                                                               > 
>                                                               >     while (n < lines[1].size () && lines[1][n].l == ~0) {
>                                                               >       n += 1;
>                                                               >     }
>                                                               > 
>                                                               >     // When we get here, we know that we're dealing with matc
>                                                               >     // lines (or the end of one or both files).  We're done w
>                                                               >     // pass, if we've reached the end of either file.
>                                                               > 
>                                                               >     if (lines[0].size () <= o || lines[1].size () <= n) {
>                                                               >       break;
>                                                               >     }
>                                                               > 
>                                                               >     // We now know that we've got a pair of matching lines, t
>                                                               >     // of a matching block.  If the new file's line number is
>                                                               >     // expect, then the matched pair is unmoved, and we can s
>                                                               >     // the pair.  (If this is really the start of a block of 
>                                                               >     // 1 lines, we'll handle it one pair at a time.)
>                                                               > 
>                                                               >     if (lines[0][o].l == n) {
>                                                               >       o += 1;
>                                                               >       n += 1;
>                                                               >       continue;
>                                                               >     }
>                                                               > 
>                                                               >     // If, on the other hand, we don't expect this [new] line
>                                                               >     // then this matching block has been moved.  We need to t
>                                                               >     // matched pair into an *unmatched* pair, one of deletes,
>                                                               >     // of inserts.  First, though, we need to know how big th
>                                                               >     // is, and how far it was moved....
>                                                               > 
>                                                               >     // Remember where we were when we started.
>                                                               > 
>                                                               >     unsigned oOld = o;
>                                                               >     unsigned nOld = n;
>                                                               > 
>                                                               >     // Remember where the block came from.
>                                                               > 
>                                                               >     unsigned nNew = lines[0][o].l;
>                                                               > 
>                                                               >     // Find the end of this matched pair.
>                                                               > 
>                                                               >     for (n = nNew; o < lines[0].size () && n < lines[1].size 
>                                                               >       if (lines[0][o].l != n) {
>                                                               >         break;
>                                                               >       }
>                                                               >     }
>                                                               > 
>                                                               >     // When we get here:
>                                                               >     // * oOld..o is the old file's block,
>                                                               >     // * nNew..n is the new file's *moved* block, and
>                                                               >     // * nOld is where we originally expected the new block f
>                                                               >  
>                                                               >     // We can now calculate the length of the block...
>                                                               >     
>                                                               >     unsigned bSize = o - oOld;  // (or n - nNew)
>                                                               > 
>                                                               >     // ... and we can calculate how far the block moved:
>                                                               > 
>                                                               >     unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
>                                                               > 
>                                                               >     // The larger of the two will become our delete, and the 
>                                                               >     // will become our insert.
>                                                               > 
>                                                               >     //    Old     New
>                                                               >     //   +---+   +---+
>                                                               >     // 0 | a | 0 | b |
>                                                               >     //   +---+ 1 | b |
>                                                               >     // 1 | b |   +---+
>                                                               >     // 2 | b | 2 | a |
>                                                               >     //   +---+   +---+
>                                                               >     // 3 | c | 3 | c |
>                                                               >     //   +---+   +---+
>                                                               > 
>                                                               >     // (1) Delete a@0, insert a@2, or
>                                                               >     // (2) insert bb@0, delete bb@1?
>                                                               > 
>                                                               >     // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and
>                                                               >     // (of a) is 2-0 or 2, the size of b@0.  We choose to del
>                                                               >     // and reinsert a@2.
>                                                               > 
>                                                               >     // if (bSize <= bMove) {
>                                                               >       for (unsigned a = oOld; a < o; a += 1) {
>                                                               >         lines[0][a].l = ~0;
>                                                               >       }
>                                                               >       for (unsigned d = nNew; d < n; d += 1) {
>                                                               >         lines[1][d].l = ~0;
>                                                               >       }
>                                                               >     // } else {
>                                                               >       // for (unsigned a = oOld; a < o; a += 1) {
>                                                               >       //   lines[0][a].l = ~0;
>                                                               >       // }
>                                                               >       // for (unsigned d = nNew; d < n; d += 1) {
>                                                               >       //   lines[1][d].l = ~0;
>                                                               >       // }
>                                                               >     // }
>                                                               > 
>                                                               >     // Continue from where we left off.
>                                                               > 
>                                                               >     n = nOld;
>                                                               >   }
>                                                               >   nTotalMatchedLines -= nMatchedLines;
>                                                               >   nTotalMatchedBlocks -= nMatchedBlocks;
>                                                               > 
>                                                               >   // Let's see the intermediate results.
>                                                               > 
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr,
>                                                               >              " found %u/%u matched lines/blocks (%u/%u totals
>                                                               >              nMatchedLines,
>                                                               >              nMatchedBlocks,
>                                                               >              nTotalMatchedLines,
>                                                               >              nTotalMatchedBlocks
>                                                               >             );
>                                                               > 
>                                                               >     if (1 < optVerbose) {
>                                                               >       for (int f = 0; f < 2; f += 1) {
>                                                               >         fprintf (stderr, "# file #%d\n", f + 1);
>                                                               >         for (int l = 0; l < lines[f].size (); l += 1) {
>                                                               >           fprintf (stderr, "#   [%d] ", l);
>                                                               >           lines[f][l].Dump (stderr);
>                                                               >         }
>                                                               >       }
>                                                               >     }
>                                                               >   }
>                                                               > }
>                                                                 
>     // Find any unmatched lines at this point in the new file | // Perform Pass #6, in which we create the desired output.
>     // are inserts.                                           <
>                                                                 
>     unsigned boInserts;                                       | void pass6c ();
>     for (boInserts = n;                                       | void pass6e ();
>          n < lines[1].size () && lines[1][n].l == ~0;         | void pass6i ();
>          n += 1                                               | void pass6n ();
>         )                                                     | void pass6r ();
>     {}                                                        | void pass6s ();
>                                                               > void pass6u ();
>                                                                 
>     // We've got deleted line(s) from boDeletes .. o.         | void pass6 ()
>     // We've got deleted line(s) from boInserts .. n.         | {
>                                                               > 
>                                                               >   switch (diffFormat) {
>                                                               >   case Context:
>                                                               >     pass6c ();
>                                                               >     break;
>                                                                 
>     unsigned nDeletes = o - boDeletes;                        |   case EdScript:
>     unsigned nInserts = n - boInserts;                        |     pass6e ();
>                                                               >     break;
>                                                                 
>     // We've got...                                           |   case IfThenElse:
>                                                               >     pass6i ();
>                                                               >     break;
>                                                                 
>     if (nDeletes && nInserts) {                               |   case Normal:
>                                                               >     pass6n ();
>                                                               >     break;
>                                                                 
>       // ... deletes and inserts.                             |   case RCS:
>                                                               >     pass6r ();
>                                                               >     break;
>                                                                 
>       switch (diffFormat) {                                   |   case SideBySide:
>       case Default:                                           |     pass6s ();
>       case Normal:                                            |     break;
>         if (1 < nDeletes && 1 < nInserts) {                   <
779c1144
<         } else if (1 < nDeletes) {			      <
---
>         } else if (1 < nDeletes) {                            <
781c1146
<         } else if (1 < nInserts) {			      <
---
>         } else if (1 < nInserts) {                            <
783,788c1148,1153
<         } 						      <
<         for (unsigned l = boDeletes; l < o; l += 1) {		        for (unsigned l = boDeletes; l < o; l += 1) {
<           fprintf (stdout, "< %s", lines[0][l].line->c_str () |	          fprintf (stdout, "! %s", lines[0][l].line->c_str ()
<         }						      <
<         fprintf (stderr, "---\n");			      <
<         for (unsigned l = boInserts; l < n; l += 1) {	      <
---
>         }                                                     <
>         for (unsigned l = boDeletes; l < o; l += 1) {         <
>           fprintf (stdout, "< %s", lines[0][l].line->c_str () <
>         }                                                     <
>         fprintf (stderr, "---\n");                            <
>         for (unsigned l = boInserts; l < n; l += 1) {         <
790,920c1155,1184
<         }							        }
<         break;						      |	      } else if (nDeletes) {
< 							      >
< 							      >	        //  ... just deletes.
< 
<       case Unified:					      <
<         for (unsigned l = boDeletes; l < o; l += 1) {		        for (unsigned l = boDeletes; l < o; l += 1) {
<           fprintf (stdout, "-%s", lines[0][l].line->c_str ()) |	          fprintf (stdout, "- %s", lines[0][l].line->c_str ()
< 							      >	        }
< 							      >	      }
< 							      >
< 							      >	      for (unsigned l = o; l < eoOldWindow; l += 1) {
< 							      >	        fprintf (stdout, "  %s", lines[0][l].line->c_str ());
< 							      >	      }
< 							      >	      fprintf (stdout, "--- %d,%d ----", boNewWindow, eoNewWi
< 							      >	      for (unsigned l = boNewWindow; l < boInserts; l += 1) {
< 							      >	        fprintf (stdout, "  %s", lines[1][l].line->c_str ());
< 							      >	      }
< 							      >
< 							      >	      // We've got...
< 							      >
< 							      >	      if (nDeletes && nInserts) {
< 							      >
< 							      >	        // ... deletes and inserts.
< 							      >
< 							      >	        for (unsigned l = boInserts; l < n; l += 1) {
< 							      >	          fprintf (stdout, "! %s", lines[1][l].line->c_str ()
<         }							        }
< 							      >	      } else if (nInserts) {
< 							      >
< 							      >	        //  ... just inserts.
< 							      >
<         for (unsigned l = boInserts; l < n; l += 1) {		        for (unsigned l = boInserts; l < n; l += 1) {
<           fprintf (stdout, "+%s", lines[1][l].line->c_str ()) |	          fprintf (stdout, "+ %s", lines[1][l].line->c_str ()
<         }							        }
<         break;						      |	      }
< 							      >
< 							      >	      for (unsigned l = n; l < eoNewWindow; l += 1) {
< 							      >	        fprintf (stdout, "  %s", lines[1][l].line->c_str ());
< 							      >	      }
< 							      >	    }
< 							      >
< 							      >	    // When we get here, we're dealing with matching lines.
< 							      >
< 							      >	    o += 1;
< 							      >	    n += 1;
< 							      >	  }
< 							      >	}
< 							      >
< 							      >	void pass6e () {
< 							      >	}
< 							      >
< 							      >	void pass6i () {
< 							      >	}
< 							      >
< 							      >	void pass6n ()
< 							      >	{
< 							      >	  if (0 < optVerbose) {
< 							      >	    fprintf (stderr, "# Pass #6n (walking the differences)...
< 							      >	  }
< 							      >
< 							      >	  nMatchedLines = 0;
< 							      >
< 							      >	  // Write the header.  (None for normal.)
< 							      >
< 							      >	  // Starting at the top of both files,...
< 							      >
< 							      >	  unsigned o = 0;
< 							      >	  unsigned n = 0;
< 							      >
< 							      >	  while (o < lines[0].size () || n < lines[1].size ()) {
< 							      >
< 							      >	    // Find any unmatched lines at this point in the old file
< 							      >	    // are deletes.
< 							      >
< 							      >	    unsigned boDeletes;
< 							      >	    for (boDeletes = o;
< 							      >	         o < lines[0].size () && lines[0][o].l == ~0;
< 							      >	         o += 1
< 							      >	        )
< 							      >	    {}
< 							      >
< 							      >	    // Find any unmatched lines at this point in the new file
< 							      >	    // are inserts.
< 							      >
< 							      >	    unsigned boInserts;
< 							      >	    for (boInserts = n;
< 							      >	         n < lines[1].size () && lines[1][n].l == ~0;
< 							      >	         n += 1
< 							      >	        )
< 							      >	    {}
< 							      >
< 							      >	    // We've got deleted line(s) from boDeletes .. o.
< 							      >	    // We've got deleted line(s) from boInserts .. n.
< 							      >
< 							      >	    unsigned nDeletes = o - boDeletes;
< 							      >	    unsigned nInserts = n - boInserts;
< 							      >
< 							      >	    // We've got...
< 							      >
< 							      >	    if (nDeletes && nInserts) {
< 							      >
< 							      >	      // ... deletes and inserts.
< 							      >
< 							      >	      if (1 < nDeletes && 1 < nInserts) {
< 							      >	        fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, b
< 							      >	      } else if (1 < nDeletes) {
< 							      >	        fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boIn
< 							      >	      } else if (1 < nInserts) {
< 							      >	        fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInser
< 							      >	      } 
< 							      >	      for (unsigned l = boDeletes; l < o; l += 1) {
< 							      >	        fprintf (stdout, "< %s", lines[0][l].line->c_str ());
< 							      >	      }
< 							      >	      fprintf (stderr, "---\n");
< 							      >	      for (unsigned l = boInserts; l < n; l += 1) {
< 							      >	        fprintf (stdout, "> %s", lines[1][l].line->c_str ());
<       }								      }
<     } else if (nDeletes) {					    } else if (nDeletes) {
< 
<       //  ... just deletes.					      //  ... just deletes.
< 
<       switch (diffFormat) {				      |	      if (1 < nDeletes) {
<       case Default:					      |	        fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
<       case Normal:					      |	      } else {
<         if (1 < nDeletes) {				      |	        fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
<           fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n) |	      }
<         } else {					      |	      for (unsigned l = boDeletes; l < o; l += 1) {
<           fprintf (stdout, "%dd%d\n", boDeletes + 1, n);      |	        fprintf (stdout, "< %s", lines[0][l].line->c_str ());
<         }						      <
<         for (unsigned l = boDeletes; l < o; l += 1) {	      <
---
>         }                                                     <
>         break;                                                <
>                                                                 
>       case Unified:                                           |   case Unified:
>         for (unsigned l = boDeletes; l < o; l += 1) {         |     pass6u ();
>           fprintf (stdout, "-%s", lines[0][l].line->c_str ()) |     break;
>         }                                                     <
>         for (unsigned l = boInserts; l < n; l += 1) {         <
>           fprintf (stdout, "+%s", lines[1][l].line->c_str ()) <
>         }                                                     <
>         break;                                                <
>       }                                                       <
>     } else if (nDeletes) {                                    <
>                                                                 
>       //  ... just deletes.                                   |   case Default:
>                                                               >   default:
>                                                               >     pass6c ();
>                                                               >     break;
>                                                               >   }
>                                                               > }
>                                                                 
>       switch (diffFormat) {                                   | template<typename T> T min (T l, T r) {
>       case Default:                                           |   if (l < r) {
>       case Normal:                                            |     return l;
>         if (1 < nDeletes) {                                   |   }
>           fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n) |   return r;
>         } else {                                              | }
>           fprintf (stdout, "%dd%d\n", boDeletes + 1, n);      <
>         }                                                     <
>         for (unsigned l = boDeletes; l < o; l += 1) {         <
922,925c1186,1189
<         }						      <
<         break;						      <
<       case Unified:					      <
<         for (unsigned l = boDeletes; l < o; l += 1) {	      <
---
>         }                                                     <
>         break;                                                <
>       case Unified:                                           <
>         for (unsigned l = boDeletes; l < o; l += 1) {         <
927,942c1191,1211
<         }						      <
<         break;						      <
<       }								      }
<     } else if (nInserts) {					    } else if (nInserts) {
< 
<       //  ... just inserts.					      //  ... just inserts.
< 
<       switch (diffFormat) {				      |	      if (1 < nInserts) {
<       case Default:					      |	        fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
<       case Normal:					      |	      } else {
<         if (1 < nInserts) {				      |	        fprintf (stdout, "%da%d\n", o, boInserts + 1);
<           fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n) |	      }
<         } else {					      |	      for (unsigned l = boInserts; l < n; l += 1) {
<           fprintf (stdout, "%da%d\n", o, boInserts + 1);      |	        fprintf (stdout, "> %s", lines[1][l].line->c_str ());
<         }						      <
<         for (unsigned l = boInserts; l < n; l += 1) {	      <
---
>         }                                                     <
>         break;                                                <
>       }                                                       <
>     } else if (nInserts) {                                    <
>                                                                 
>       //  ... just inserts.                                   | template<typename T> T max (T l, T r) {
>                                                               >   if (l < r) {
>                                                               >     return r;
>                                                               >   }
>                                                               >   return l;
>                                                               > }
>                                                                 
>       switch (diffFormat) {                                   | void pass6c () {
>       case Default:                                           |   if (0 < optVerbose) {
>       case Normal:                                            |     fprintf (stderr, "# Pass #6u (walking the differences)...
>         if (1 < nInserts) {                                   |   }
>           fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n) <
>         } else {                                              <
>           fprintf (stdout, "%da%d\n", o, boInserts + 1);      <
>         }                                                     <
>         for (unsigned l = boInserts; l < n; l += 1) {         <
944,947c1213,1216
<         }						      <
<         break;						      <
<       case Unified:					      <
<         for (unsigned l = boInserts; l < n; l += 1) {	      <
---
>         }                                                     <
>         break;                                                <
>       case Unified:                                           <
>         for (unsigned l = boInserts; l < n; l += 1) {         <
949,1048c1218,1522
<         }						      <
<         break;						      <
<       }								      }
<     }								    }
< 
<     // When we get here, we're dealing with matching lines.	    // When we get here, we're dealing with matching lines.
< 
<     switch (diffFormat) {				      |	    o += 1;
<     case Default:					      |	    n += 1;
<     case Normal:					      |	  }
<       break;						      |	}
<     case Unified:					      |
<       fprintf (stdout, " %s", lines[0][o].line->c_str ());    |	void pass6r () {
<       break;						      |	}
< 							      >
< 							      >	void pass6s () {
< 							      >	}
< 							      >
< 							      >	void pass6u ()
< 							      >	{
< 							      >	  if (0 < optVerbose) {
< 							      >	    fprintf (stderr, "# Pass #6u (walking the differences)...
< 							      >	  }
< 							      >
< 							      >	  nMatchedLines = 0;
< 							      >
< 							      >	  // Write the header.
< 							      >
< 							      >	  fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:0
< 							      >	  fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:0
< 							      >	  fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), l
< 							      >
< 							      >	  // Starting at the top of both files,...
< 							      >
< 							      >	  unsigned o = 0;
< 							      >	  unsigned n = 0;
< 							      >
< 							      >	  while (o < lines[0].size () || n < lines[1].size ()) {
< 							      >
< 							      >	    // Find any unmatched lines at this point in the old file
< 							      >	    // are deletes.
< 							      >
< 							      >	    unsigned boDeletes;
< 							      >	    for (boDeletes = o;
< 							      >	         o < lines[0].size () && lines[0][o].l == ~0;
< 							      >	         o += 1
< 							      >	        )
< 							      >	    {}
< 							      >
< 							      >	    // Find any unmatched lines at this point in the new file
< 							      >	    // are inserts.
< 							      >
< 							      >	    unsigned boInserts;
< 							      >	    for (boInserts = n;
< 							      >	         n < lines[1].size () && lines[1][n].l == ~0;
< 							      >	         n += 1
< 							      >	        )
< 							      >	    {}
< 							      >
< 							      >	    // We've got deleted line(s) from boDeletes .. o.
< 							      >	    // We've got deleted line(s) from boInserts .. n.
< 							      >
< 							      >	    unsigned nDeletes = o - boDeletes;
< 							      >	    unsigned nInserts = n - boInserts;
< 							      >
< 							      >	    // We've got...
< 							      >
< 							      >	    if (nDeletes && nInserts) {
< 							      >
< 							      >	      // ... deletes and inserts.
< 							      >
< 							      >	      for (unsigned l = boDeletes; l < o; l += 1) {
< 							      >	        fprintf (stdout, "-%s", lines[0][l].line->c_str ());
< 							      >	      }
< 							      >	      for (unsigned l = boInserts; l < n; l += 1) {
< 							      >	        fprintf (stdout, "+%s", lines[1][l].line->c_str ());
< 							      >	      }
< 							      >	    } else if (nDeletes) {
< 							      >
< 							      >	      //  ... just deletes.
< 							      >
< 							      >	      for (unsigned l = boDeletes; l < o; l += 1) {
< 							      >	        fprintf (stdout, "-%s", lines[0][l].line->c_str ());
< 							      >	      }
< 							      >	    } else if (nInserts) {
< 							      >
< 							      >	      //  ... just inserts.
< 							      >
< 							      >	      for (unsigned l = boInserts; l < n; l += 1) {
< 							      >	        fprintf (stdout, "+%s", lines[1][l].line->c_str ());
< 							      >	      }
<     }								    }
< 							      >
< 							      >	    // When we get here, we're dealing with matching lines.
< 							      >
< 							      >	    fprintf (stdout, " %s", lines[0][o].line->c_str ());
<     o += 1;							    o += 1;
<     n += 1;							    n += 1;
<   }								  }
< }								}
---
>         }                                                     <
>         break;                                                <
>       }                                                       <
>     }                                                         <
>                                                                 
>     // When we get here, we're dealing with matching lines.   |   nMatchedLines = 0;
>                                                                 
>     switch (diffFormat) {                                     |   // Write the header.
>     case Default:                                             | 
>     case Normal:                                              |   fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:0
>       break;                                                  |   fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:0
>     case Unified:                                             | 
>       fprintf (stdout, " %s", lines[0][o].line->c_str ());    |   // Starting at the top of both files,...
>       break;                                                  | 
>                                                               >   unsigned o = 0;
>                                                               >   unsigned n = 0;
>                                                               > 
>                                                               >   while (o < lines[0].size () || n < lines[1].size ()) {
>                                                               > 
>                                                               >     // Find any unmatched lines at this point in the old file
>                                                               >     // are deletes.
>                                                               > 
>                                                               >     unsigned boDeletes;
>                                                               >     for (boDeletes = o;
>                                                               >          o < lines[0].size () && lines[0][o].l == ~0;
>                                                               >          o += 1
>                                                               >         )
>                                                               >     {}
>                                                               > 
>                                                               >     // Find any unmatched lines at this point in the new file
>                                                               >     // are inserts.
>                                                               > 
>                                                               >     unsigned boInserts;
>                                                               >     for (boInserts = n;
>                                                               >          n < lines[1].size () && lines[1][n].l == ~0;
>                                                               >          n += 1
>                                                               >         )
>                                                               >     {}
>                                                               > 
>                                                               >     // We've got deleted line(s) from boDeletes .. o.
>                                                               >     // We've got deleted line(s) from boInserts .. n.
>                                                               > 
>                                                               >     unsigned nDeletes = o - boDeletes;
>                                                               >     unsigned nInserts = n - boInserts;
>                                                               > 
>                                                               >     // Have we got anything?
>                                                               > 
>                                                               >     if (nDeletes || nInserts) {
>                                                               >       int boOldWindow = max (0, int (boDeletes) - int(optCopy
>                                                               >       int eoOldWindow = min (int (lines[0].size ()), int(o) +
>                                                               > 
>                                                               >       int boNewWindow = max (0, int (boInserts) - int (optCop
>                                                               >       int eoNewWindow = min (int (lines[1].size ()), int(n) +
>                                                               > 
>                                                               >       fprintf (stdout, "***************\n*** %d,%d ****", boO
>                                                               >       for (unsigned l = boOldWindow; l < boDeletes; l += 1) {
>                                                               >         fprintf (stdout, "  %s", lines[0][l].line->c_str ());
>                                                               >       }
>                                                               > 
>                                                               >       // We've got...
>                                                               > 
>                                                               >       if (nDeletes && nInserts) {
>                                                               > 
>                                                               >         // ... deletes and inserts.
>                                                               > 
>                                                               >         for (unsigned l = boDeletes; l < o; l += 1) {
>                                                               >           fprintf (stdout, "! %s", lines[0][l].line->c_str ()
>                                                               >         }
>                                                               >       } else if (nDeletes) {
>                                                               > 
>                                                               >         //  ... just deletes.
>                                                               > 
>                                                               >         for (unsigned l = boDeletes; l < o; l += 1) {
>                                                               >           fprintf (stdout, "- %s", lines[0][l].line->c_str ()
>                                                               >         }
>                                                               >       }
>                                                               > 
>                                                               >       for (unsigned l = o; l < eoOldWindow; l += 1) {
>                                                               >         fprintf (stdout, "  %s", lines[0][l].line->c_str ());
>                                                               >       }
>                                                               >       fprintf (stdout, "--- %d,%d ----", boNewWindow, eoNewWi
>                                                               >       for (unsigned l = boNewWindow; l < boInserts; l += 1) {
>                                                               >         fprintf (stdout, "  %s", lines[1][l].line->c_str ());
>                                                               >       }
>                                                               > 
>                                                               >       // We've got...
>                                                               > 
>                                                               >       if (nDeletes && nInserts) {
>                                                               > 
>                                                               >         // ... deletes and inserts.
>                                                               > 
>                                                               >         for (unsigned l = boInserts; l < n; l += 1) {
>                                                               >           fprintf (stdout, "! %s", lines[1][l].line->c_str ()
>                                                               >         }
>                                                               >       } else if (nInserts) {
>                                                               > 
>                                                               >         //  ... just inserts.
>                                                               > 
>                                                               >         for (unsigned l = boInserts; l < n; l += 1) {
>                                                               >           fprintf (stdout, "+ %s", lines[1][l].line->c_str ()
>                                                               >         }
>                                                               >       }
>                                                               > 
>                                                               >       for (unsigned l = n; l < eoNewWindow; l += 1) {
>                                                               >         fprintf (stdout, "  %s", lines[1][l].line->c_str ());
>                                                               >       }
>                                                               >     }
>                                                               > 
>                                                               >     // When we get here, we're dealing with matching lines.
>                                                               > 
>                                                               >     o += 1;
>                                                               >     n += 1;
>                                                               >   }
>                                                               > }
>                                                               > 
>                                                               > void pass6e () {
>                                                               > }
>                                                               > 
>                                                               > void pass6i () {
>                                                               > }
>                                                               > 
>                                                               > void pass6n ()
>                                                               > {
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr, "# Pass #6n (walking the differences)...
>                                                               >   }
>                                                               > 
>                                                               >   nMatchedLines = 0;
>                                                               > 
>                                                               >   // Write the header.  (None for normal.)
>                                                               > 
>                                                               >   // Starting at the top of both files,...
>                                                               > 
>                                                               >   unsigned o = 0;
>                                                               >   unsigned n = 0;
>                                                               > 
>                                                               >   while (o < lines[0].size () || n < lines[1].size ()) {
>                                                               > 
>                                                               >     // Find any unmatched lines at this point in the old file
>                                                               >     // are deletes.
>                                                               > 
>                                                               >     unsigned boDeletes;
>                                                               >     for (boDeletes = o;
>                                                               >          o < lines[0].size () && lines[0][o].l == ~0;
>                                                               >          o += 1
>                                                               >         )
>                                                               >     {}
>                                                               > 
>                                                               >     // Find any unmatched lines at this point in the new file
>                                                               >     // are inserts.
>                                                               > 
>                                                               >     unsigned boInserts;
>                                                               >     for (boInserts = n;
>                                                               >          n < lines[1].size () && lines[1][n].l == ~0;
>                                                               >          n += 1
>                                                               >         )
>                                                               >     {}
>                                                               > 
>                                                               >     // We've got deleted line(s) from boDeletes .. o.
>                                                               >     // We've got deleted line(s) from boInserts .. n.
>                                                               > 
>                                                               >     unsigned nDeletes = o - boDeletes;
>                                                               >     unsigned nInserts = n - boInserts;
>                                                               > 
>                                                               >     // We've got...
>                                                               > 
>                                                               >     if (nDeletes && nInserts) {
>                                                               > 
>                                                               >       // ... deletes and inserts.
>                                                               > 
>                                                               >       if (1 < nDeletes && 1 < nInserts) {
>                                                               >         fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, b
>                                                               >       } else if (1 < nDeletes) {
>                                                               >         fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boIn
>                                                               >       } else if (1 < nInserts) {
>                                                               >         fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInser
>                                                               >       } 
>                                                               >       for (unsigned l = boDeletes; l < o; l += 1) {
>                                                               >         fprintf (stdout, "< %s", lines[0][l].line->c_str ());
>                                                               >       }
>                                                               >       fprintf (stderr, "---\n");
>                                                               >       for (unsigned l = boInserts; l < n; l += 1) {
>                                                               >         fprintf (stdout, "> %s", lines[1][l].line->c_str ());
>                                                               >       }
>                                                               >     } else if (nDeletes) {
>                                                               > 
>                                                               >       //  ... just deletes.
>                                                               > 
>                                                               >       if (1 < nDeletes) {
>                                                               >         fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
>                                                               >       } else {
>                                                               >         fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
>                                                               >       }
>                                                               >       for (unsigned l = boDeletes; l < o; l += 1) {
>                                                               >         fprintf (stdout, "< %s", lines[0][l].line->c_str ());
>                                                               >       }
>                                                               >     } else if (nInserts) {
>                                                               > 
>                                                               >       //  ... just inserts.
>                                                               > 
>                                                               >       if (1 < nInserts) {
>                                                               >         fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
>                                                               >       } else {
>                                                               >         fprintf (stdout, "%da%d\n", o, boInserts + 1);
>                                                               >       }
>                                                               >       for (unsigned l = boInserts; l < n; l += 1) {
>                                                               >         fprintf (stdout, "> %s", lines[1][l].line->c_str ());
>                                                               >       }
>     }                                                               }
>                                                               > 
>                                                               >     // When we get here, we're dealing with matching lines.
>                                                               > 
>                                                               >     o += 1;
>                                                               >     n += 1;
>                                                               >   }
>                                                               > }
>                                                               > 
>                                                               > void pass6r () {
>                                                               > }
>                                                               > 
>                                                               > void pass6s () {
>                                                               > }
>                                                               > 
>                                                               > void pass6u ()
>                                                               > {
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr, "# Pass #6u (walking the differences)...
>                                                               >   }
>                                                               > 
>                                                               >   nMatchedLines = 0;
>                                                               > 
>                                                               >   // Write the header.
>                                                               > 
>                                                               >   fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:0
>                                                               >   fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:0
>                                                               >   fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), l
>                                                               > 
>                                                               >   // Starting at the top of both files,...
>                                                               > 
>                                                               >   unsigned o = 0;
>                                                               >   unsigned n = 0;
>                                                               > 
>                                                               >   while (o < lines[0].size () || n < lines[1].size ()) {
>                                                               > 
>                                                               >     // Find any unmatched lines at this point in the old file
>                                                               >     // are deletes.
>                                                               > 
>                                                               >     unsigned boDeletes;
>                                                               >     for (boDeletes = o;
>                                                               >          o < lines[0].size () && lines[0][o].l == ~0;
>                                                               >          o += 1
>                                                               >         )
>                                                               >     {}
>                                                               > 
>                                                               >     // Find any unmatched lines at this point in the new file
>                                                               >     // are inserts.
>                                                               > 
>                                                               >     unsigned boInserts;
>                                                               >     for (boInserts = n;
>                                                               >          n < lines[1].size () && lines[1][n].l == ~0;
>                                                               >          n += 1
>                                                               >         )
>                                                               >     {}
>                                                               > 
>                                                               >     // We've got deleted line(s) from boDeletes .. o.
>                                                               >     // We've got deleted line(s) from boInserts .. n.
>                                                               > 
>                                                               >     unsigned nDeletes = o - boDeletes;
>                                                               >     unsigned nInserts = n - boInserts;
>                                                               > 
>                                                               >     // We've got...
>                                                               > 
>                                                               >     if (nDeletes && nInserts) {
>                                                               > 
>                                                               >       // ... deletes and inserts.
>                                                               > 
>                                                               >       for (unsigned l = boDeletes; l < o; l += 1) {
>                                                               >         fprintf (stdout, "-%s", lines[0][l].line->c_str ());
>                                                               >       }
>                                                               >       for (unsigned l = boInserts; l < n; l += 1) {
>                                                               >         fprintf (stdout, "+%s", lines[1][l].line->c_str ());
>                                                               >       }
>                                                               >     } else if (nDeletes) {
>                                                               > 
>                                                               >       //  ... just deletes.
>                                                               > 
>                                                               >       for (unsigned l = boDeletes; l < o; l += 1) {
>                                                               >         fprintf (stdout, "-%s", lines[0][l].line->c_str ());
>                                                               >       }
>                                                               >     } else if (nInserts) {
>                                                               > 
>                                                               >       //  ... just inserts.
>                                                               > 
>                                                               >       for (unsigned l = boInserts; l < n; l += 1) {
>                                                               >         fprintf (stdout, "+%s", lines[1][l].line->c_str ());
>                                                               >       }
>                                                               >     }
>                                                               > 
>                                                               >     // When we get here, we're dealing with matching lines.
>                                                               > 
>                                                               >     fprintf (stdout, " %s", lines[0][o].line->c_str ());
>     o += 1;                                                         o += 1;
>     n += 1;                                                         n += 1;
>   }                                                               }
> }                                                               }
# ../sdiff -y dif.5.cpp dif.4.cpp >& dif.5.4.diff-y.test
# dif.5.4.diff-y ---------------------------------------------------------------
1,160c1,170
< #include <algorithm>						#include <algorithm>
< using std::find;						using std::find;
< #include <string>						#include <string>
< using std::string;						using std::string;
< #include <list>							#include <list>
< using std::list;						using std::list;
< #include <map>							#include <map>
< using std::map;							using std::map;
< #include <vector>						#include <vector>
< using std::vector;						using std::vector;
< #include <stdio.h>						#include <stdio.h>
< 
< enum DiffFormat {						enum DiffFormat {
<   Default,							  Default,
< 
<   Context,							  Context,
<   EdScript,							  EdScript,
<   IfThenElse,							  IfThenElse,
<   Normal,							  Normal,
<   RCS,								  RCS,
<   SideBySide,							  SideBySide,
<   Unified							  Unified
< };								};
< 
< DiffFormat diffFormat = Context;			      |	DiffFormat diffFormat = Unified;
< unsigned optCopyContext = 3;				      <
< 
< int optVerbose = 1;						int optVerbose = 1;
< 
< struct Line : public string {					struct Line : public string {
<   Line (string _text) :						  Line (string _text) :
<     string (_text)						    string (_text)
<   {								  {
<   }								  }
<   ~Line () {							  ~Line () {
<     copies[0].erase (copies[0].begin (), copies[0].end ());	    copies[0].erase (copies[0].begin (), copies[0].end ());
<     copies[1].erase (copies[1].begin (), copies[1].end ());	    copies[1].erase (copies[1].begin (), copies[1].end ());
<   }								  }
<   void Dump (FILE *out) {					  void Dump (FILE *out) {
<     fprintf (out, "{{ ");					    fprintf (out, "{{ ");
<     for (list<unsigned>::iterator i = copies[0].begin (); i !	    for (list<unsigned>::iterator i = copies[0].begin (); i !
<       fprintf (out, "%u ", *i);					      fprintf (out, "%u ", *i);
<     }								    }
<     fprintf (out, "},{ ");					    fprintf (out, "},{ ");
<     for (list<unsigned>::iterator i = copies[1].begin (); i !	    for (list<unsigned>::iterator i = copies[1].begin (); i !
<       fprintf (out, "%u ", *i);					      fprintf (out, "%u ", *i);
<     }								    }
<     fprintf (out, "}}\t%s", c_str ());				    fprintf (out, "}}\t%s", c_str ());
<   }								  }
<   list<unsigned> copies[2];					  list<unsigned> copies[2];
< };								};
< 
< struct LinePtr {						struct LinePtr {
<   LinePtr (Line *_line) :					  LinePtr (Line *_line) :
<     line (_line),						    line (_line),
<     l (~0u)							    l (~0u)
<   {								  {
<   }								  }
<   void Dump (FILE *out) {					  void Dump (FILE *out) {
<     fprintf (out, "[%d] ", l);					    fprintf (out, "[%d] ", l);
<     line->Dump (out);						    line->Dump (out);
<   }								  }
<   Line *line;							  Line *line;
<   unsigned l;							  unsigned l;
< };								};
< 
< typedef map<string, Line *> MapStringToLinePtr;			typedef map<string, Line *> MapStringToLinePtr;
< typedef vector<LinePtr> VectorLinePtr;				typedef vector<LinePtr> VectorLinePtr;
< 
< // Our name.						      |	char *ARGV0 = "dif2";
< 
< char *ARGV0 = "dif3";					      |	int main (int argc, char *argv[])
< 							      |	{
< // The 'symbol' (line) table.				      |	  char const *files[2] = { 0, 0 };
< 							      <
< MapStringToLinePtr table;				      <
< 							      <
< // The names of the 2 files to be diff'd.		      <
< 							      <
< char const *files[2] = { 0, 0 };			      <
< 							      <
< // The lines of the 2 files to be diff'd.		      <
< 							      <
< VectorLinePtr lines[2];					      <
< 							      <
< // Miscellaneous metrics.				      <
< 
< unsigned nTotalMatchedBlocks = 0;			      |	  MapStringToLinePtr table;
< unsigned nMatchedBlocks = 0;				      |	  VectorLinePtr lines[2];
< unsigned nTotalMatchedLines = 0;			      <
< unsigned nMatchedLines = 0;				      <
< 
< void pass1 ();						      |	  unsigned nTotalMatchedBlocks = 0;
< void pass2 ();						      |	  unsigned nMatchedBlocks = 0;
< void pass3 ();						      |	  unsigned nTotalMatchedLines = 0;
< void pass4 ();						      |	  unsigned nMatchedLines = 0;
< void pass5 ();						      <
< void pass6 ();						      <
< 
< int main (int argc, char *argv[])			      <
< {							      <
<   // Read the old [0] file, and the new [1] file.		  // Read the old [0] file, and the new [1] file.
< 
<   for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {	  for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
<     files[n] = argv[a];						    files[n] = argv[a];
< 
<     if (FILE *f = fopen (files[n], "r")) {			    if (FILE *f = fopen (files[n], "r")) {
<       if (0 < optVerbose) {					      if (0 < optVerbose) {
<         fprintf (stderr, "# Reading %s...", files[n]);		        fprintf (stderr, "# Reading %s...", files[n]);
<       }								      }
< 
<       char buffer[1024];					      char buffer[1024];
<       unsigned nUniq = 0;					      unsigned nUniq = 0;
< 
<       while (fgets (buffer, sizeof (buffer), f)) {		      while (fgets (buffer, sizeof (buffer), f)) {
<         string text (buffer);					        string text (buffer);
< 
<         Line *line = table[text];				        Line *line = table[text];
< 
<         if (!line) {						        if (!line) {
<           table[text] = line = new Line (text);			          table[text] = line = new Line (text);
<           nUniq += 1;						          nUniq += 1;
<         }							        }
<         line->copies[n].push_back (lines[n].size ());		        line->copies[n].push_back (lines[n].size ());
<         lines[n].push_back (line);				        lines[n].push_back (line);
<       }								      }
< 
<       if (0 < optVerbose) {					      if (0 < optVerbose) {
<         fprintf (stderr, " %u lines, %u unique.\n", lines[n].	        fprintf (stderr, " %u lines, %u unique.\n", lines[n].
<       }								      }
<     } else {							    } else {
<       fprintf (stderr, "%s: Unable to open %s!  Exiting....\n	      fprintf (stderr, "%s: Unable to open %s!  Exiting....\n
<       perror (ARGV0);						      perror (ARGV0);
<       exit (1);							      exit (1);
<     }								    }
<   }								  }
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Total unique lines = %d\n", table.siz |	    printf ("# Total unique lines = %d\n", table.size ());
<   }								  }
< 
<   // map<int, int> counts;					  // map<int, int> counts;
<   // for (MapStringToLinePtr::iterator i = table.begin (); i 	  // for (MapStringToLinePtr::iterator i = table.begin (); i 
<   //   Line *l = i->second;					  //   Line *l = i->second;
<   //   counts[l->counts[0].size () + l->counts[1].size ()] +=	  //   counts[l->counts[0].size () + l->counts[1].size ()] +=
<   // }								  // }
<   // for (map<int, int>::iterator i = counts.begin (); i != c	  // for (map<int, int>::iterator i = counts.begin (); i != c
<   //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s	  //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s
<   // }								  // }
< 
<   pass1 ();						      |	  // Perform pass #1, in which we find all explicit matches a
<   pass2 ();						      |	  // the unique lines.  For every unique line that appears th
<   pass3 ();						      |	  // number of times in both files, we declare the lines to m
<   pass4 ();						      <
<   pass5 ();						      <
<   pass6 ();						      <
< 
<   return 0;						      <
< }							      <
< 							      <
---
> #include <algorithm>                                            #include <algorithm>
> using std::find;                                                using std::find;
> #include <string>                                               #include <string>
> using std::string;                                              using std::string;
> #include <list>                                                 #include <list>
> using std::list;                                                using std::list;
> #include <map>                                                  #include <map>
> using std::map;                                                 using std::map;
> #include <vector>                                               #include <vector>
> using std::vector;                                              using std::vector;
> #include <stdio.h>                                              #include <stdio.h>
>                                                                 
> enum DiffFormat {                                               enum DiffFormat {
>   Default,                                                        Default,
>                                                                 
>   Context,                                                        Context,
>   EdScript,                                                       EdScript,
>   IfThenElse,                                                     IfThenElse,
>   Normal,                                                         Normal,
>   RCS,                                                            RCS,
>   SideBySide,                                                     SideBySide,
>   Unified                                                         Unified
> };                                                              };
>                                                                 
> DiffFormat diffFormat = Context;                              | DiffFormat diffFormat = Unified;
> unsigned optCopyContext = 3;                                  <
>                                                                 
> int optVerbose = 1;                                             int optVerbose = 1;
>                                                                 
> struct Line : public string {                                   struct Line : public string {
>   Line (string _text) :                                           Line (string _text) :
>     string (_text)                                                  string (_text)
>   {                                                               {
>   }                                                               }
>   ~Line () {                                                      ~Line () {
>     copies[0].erase (copies[0].begin (), copies[0].end ());         copies[0].erase (copies[0].begin (), copies[0].end ());
>     copies[1].erase (copies[1].begin (), copies[1].end ());         copies[1].erase (copies[1].begin (), copies[1].end ());
>   }                                                               }
>   void Dump (FILE *out) {                                         void Dump (FILE *out) {
>     fprintf (out, "{{ ");                                           fprintf (out, "{{ ");
>     for (list<unsigned>::iterator i = copies[0].begin (); i !       for (list<unsigned>::iterator i = copies[0].begin (); i !
>       fprintf (out, "%u ", *i);                                       fprintf (out, "%u ", *i);
>     }                                                               }
>     fprintf (out, "},{ ");                                          fprintf (out, "},{ ");
>     for (list<unsigned>::iterator i = copies[1].begin (); i !       for (list<unsigned>::iterator i = copies[1].begin (); i !
>       fprintf (out, "%u ", *i);                                       fprintf (out, "%u ", *i);
>     }                                                               }
>     fprintf (out, "}}\t%s", c_str ());                              fprintf (out, "}}\t%s", c_str ());
>   }                                                               }
>   list<unsigned> copies[2];                                       list<unsigned> copies[2];
> };                                                              };
>                                                                 
> struct LinePtr {                                                struct LinePtr {
>   LinePtr (Line *_line) :                                         LinePtr (Line *_line) :
>     line (_line),                                                   line (_line),
>     l (~0u)                                                         l (~0u)
>   {                                                               {
>   }                                                               }
>   void Dump (FILE *out) {                                         void Dump (FILE *out) {
>     fprintf (out, "[%d] ", l);                                      fprintf (out, "[%d] ", l);
>     line->Dump (out);                                               line->Dump (out);
>   }                                                               }
>   Line *line;                                                     Line *line;
>   unsigned l;                                                     unsigned l;
> };                                                              };
>                                                                 
> typedef map<string, Line *> MapStringToLinePtr;                 typedef map<string, Line *> MapStringToLinePtr;
> typedef vector<LinePtr> VectorLinePtr;                          typedef vector<LinePtr> VectorLinePtr;
>                                                                 
> // Our name.                                                  | char *ARGV0 = "dif2";
>                                                               <
> char *ARGV0 = "dif3";                                         <
>                                                               <
> // The 'symbol' (line) table.                                 <
>                                                               <
> MapStringToLinePtr table;                                     <
>                                                               <
> // The names of the 2 files to be diff'd.                     <
>                                                               <
> char const *files[2] = { 0, 0 };                              <
>                                                               <
> // The lines of the 2 files to be diff'd.                     <
>                                                               <
> VectorLinePtr lines[2];                                       <
>                                                               <
> // Miscellaneous metrics.                                     <
>                                                               <
> unsigned nTotalMatchedBlocks = 0;                             <
> unsigned nMatchedBlocks = 0;                                  <
> unsigned nTotalMatchedLines = 0;                              <
> unsigned nMatchedLines = 0;                                   <
>                                                               <
> void pass1 ();                                                <
> void pass2 ();                                                <
> void pass3 ();                                                <
> void pass4 ();                                                <
> void pass5 ();                                                <
> void pass6 ();                                                <
>                                                                 
> int main (int argc, char *argv[])                               int main (int argc, char *argv[])
> {                                                               {
>                                                               >   char const *files[2] = { 0, 0 };
>                                                               > 
>                                                               >   MapStringToLinePtr table;
>                                                               >   VectorLinePtr lines[2];
>                                                               > 
>                                                               >   unsigned nTotalMatchedBlocks = 0;
>                                                               >   unsigned nMatchedBlocks = 0;
>                                                               >   unsigned nTotalMatchedLines = 0;
>                                                               >   unsigned nMatchedLines = 0;
>                                                               > 
>   // Read the old [0] file, and the new [1] file.                 // Read the old [0] file, and the new [1] file.
>                                                                 
>   for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {     for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
>     files[n] = argv[a];                                             files[n] = argv[a];
>                                                                 
>     if (FILE *f = fopen (files[n], "r")) {                          if (FILE *f = fopen (files[n], "r")) {
>       if (0 < optVerbose) {                                           if (0 < optVerbose) {
>         fprintf (stderr, "# Reading %s...", files[n]);                  fprintf (stderr, "# Reading %s...", files[n]);
>       }                                                               }
>                                                                 
>       char buffer[1024];                                              char buffer[1024];
>       unsigned nUniq = 0;                                             unsigned nUniq = 0;
>                                                                 
>       while (fgets (buffer, sizeof (buffer), f)) {                    while (fgets (buffer, sizeof (buffer), f)) {
>         string text (buffer);                                           string text (buffer);
>                                                                 
>         Line *line = table[text];                                       Line *line = table[text];
>                                                                 
>         if (!line) {                                                    if (!line) {
>           table[text] = line = new Line (text);                           table[text] = line = new Line (text);
>           nUniq += 1;                                                     nUniq += 1;
>         }                                                               }
>         line->copies[n].push_back (lines[n].size ());                   line->copies[n].push_back (lines[n].size ());
>         lines[n].push_back (line);                                      lines[n].push_back (line);
>       }                                                               }
>                                                                 
>       if (0 < optVerbose) {                                           if (0 < optVerbose) {
>         fprintf (stderr, " %u lines, %u unique.\n", lines[n].           fprintf (stderr, " %u lines, %u unique.\n", lines[n].
>       }                                                               }
>     } else {                                                        } else {
>       fprintf (stderr, "%s: Unable to open %s!  Exiting....\n         fprintf (stderr, "%s: Unable to open %s!  Exiting....\n
>       perror (ARGV0);                                                 perror (ARGV0);
>       exit (1);                                                       exit (1);
>     }                                                               }
>   }                                                               }
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Total unique lines = %d\n", table.siz |     printf ("# Total unique lines = %d\n", table.size ());
>   }                                                               }
>                                                                 
>   // map<int, int> counts;                                        // map<int, int> counts;
>   // for (MapStringToLinePtr::iterator i = table.begin (); i      // for (MapStringToLinePtr::iterator i = table.begin (); i 
>   //   Line *l = i->second;                                       //   Line *l = i->second;
>   //   counts[l->counts[0].size () + l->counts[1].size ()] +=     //   counts[l->counts[0].size () + l->counts[1].size ()] +=
>   // }                                                            // }
>   // for (map<int, int>::iterator i = counts.begin (); i != c     // for (map<int, int>::iterator i = counts.begin (); i != c
>   //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s     //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s
>   // }                                                            // }
>                                                                 
>   pass1 ();                                                   |   // Perform pass #1, in which we find all explicit matches a
>   pass2 ();                                                   |   // the unique lines.  For every unique line that appears th
>   pass3 ();                                                   |   // number of times in both files, we declare the lines to m
>   pass4 ();                                                   | 
>   pass5 ();                                                   <
>   pass6 ();                                                   <
>                                                               <
>   return 0;                                                   <
> }                                                             <
>                                                               <
164,756c174,772
< 							      <
< void pass1 ()						      <
< {							      <
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass 1 (finding matches amongst uniqu	    fprintf (stderr, "# Pass 1 (finding matches amongst uniqu
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   for (MapStringToLinePtr::iterator i = table.begin (); i != 	  for (MapStringToLinePtr::iterator i = table.begin (); i != 
<     Line *l = i->second;					    Line *l = i->second;
< 
<     // If the number of old and new lines match, then we decl	    // If the number of old and new lines match, then we decl
<     // they are (all) the same line.  Note, it isn't possible	    // they are (all) the same line.  Note, it isn't possible
<     // numbers of both files to be 0.				    // numbers of both files to be 0.
< 
<     // (In the original algorithm, we only recognized a match	    // (In the original algorithm, we only recognized a match
<     // if there was exactly 1 copy for each file.)		    // if there was exactly 1 copy for each file.)
< 
<     if (l->copies[0].size () == l->copies[1].size ()) {		    if (l->copies[0].size () == l->copies[1].size ()) {
<       nMatchedLines += 1;					      nMatchedLines += 1;
< 
<       // For each matched line in the new file, mark it with 	      // For each matched line in the new file, mark it with 
<       // corresponding line (number) in the old file.		      // corresponding line (number) in the old file.
< 
<       while (!l->copies[0].empty ()) {				      while (!l->copies[0].empty ()) {
<         unsigned o = l->copies[0].front ();			        unsigned o = l->copies[0].front ();
<         unsigned n = l->copies[1].front ();			        unsigned n = l->copies[1].front ();
< 
<         // Match up the pair.					        // Match up the pair.
< 
<         lines[0][o].l = n;					        lines[0][o].l = n;
<         lines[1][n].l = o;					        lines[1][n].l = o;
< 
<         // Remove the matched line numbers from the lists.	        // Remove the matched line numbers from the lists.
< 
<         l->copies[0].pop_front ();				        l->copies[0].pop_front ();
<         l->copies[1].pop_front ();				        l->copies[1].pop_front ();
<       }								      }
<     }								    }
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, " found %u matched lines (%u total).\n",	    fprintf (stderr, " found %u matched lines (%u total).\n",
< 
<     if (1 < optVerbose) {					    if (1 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< }							      <
< 
< // Perform Pass #2, in which we attempt to 'widen' blocks of  |	  // Perform Pass #2, in which we attempt to 'widen' blocks o
< // lines, by appending lines which are the same in both files |	  // lines, by appending lines which are the same in both fil
< 
< void pass2 ()						      <
< {							      <
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #2 (spreading matches down)...")	    fprintf (stderr, "# Pass #2 (spreading matches down)...")
<   }								  }
< 
<   nMatchedBlocks = 0;						  nMatchedBlocks = 0;
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Starting at the top of the old file,...			  // Starting at the top of the old file,...
< 
<   for (unsigned o = 0; o < lines[0].size (); o += 1) {		  for (unsigned o = 0; o < lines[0].size (); o += 1) {
< 
<     // ... skip any currently unmatched lines...		    // ... skip any currently unmatched lines...
< 
<     if (lines[0][o].l == ~0) {					    if (lines[0][o].l == ~0) {
<       continue;							      continue;
<     }								    }
< 
<     // ... until we find an [already] matched line.  Then, sk	    // ... until we find an [already] matched line.  Then, sk
<     // the set of 1 or more matched lines, until we reach any	    // the set of 1 or more matched lines, until we reach any
<     // following, still-unmatched line.				    // following, still-unmatched line.
< 
<     unsigned n;							    unsigned n;
<     do {							    do {
<       n = lines[0][o].l + 1;					      n = lines[0][o].l + 1;
<       o += 1;							      o += 1;
<     } while (o < lines[0].size () && lines[0][o].l != ~0);	    } while (o < lines[0].size () && lines[0][o].l != ~0);
< 
<     // Now, o - 1 is the line number of the last matched old 	    // Now, o - 1 is the line number of the last matched old 
<     // n - 1 is the line number of the last matched new line.	    // n - 1 is the line number of the last matched new line.
<     // to add new old and new lines, if they match.		    // to add new old and new lines, if they match.
< 
<     // Finally, attempt to add unmatched lines to the preceed	    // Finally, attempt to add unmatched lines to the preceed
<     // matched set.						    // matched set.
< 
<     for (; o < lines[0].size () && lines[0][o].l == ~0; o += 	    for (; o < lines[0].size () && lines[0][o].l == ~0; o += 
< 
<       // If the [next] pair of old and new lines aren't the s	      // If the [next] pair of old and new lines aren't the s
< 
<       if (lines[0][o].line != lines[1][n].line) {		      if (lines[0][o].line != lines[1][n].line) {
<         break;							        break;
<       }								      }
< 
<       // Match up the pair.					      // Match up the pair.
< 
<       lines[0][o].l = n;					      lines[0][o].l = n;
<       lines[1][n].l = o;					      lines[1][n].l = o;
< 
<       // Remove the matched line numbers form the lists.	      // Remove the matched line numbers form the lists.
< 
<       Line *line = lines[0][o].line;				      Line *line = lines[0][o].line;
<       list<unsigned> &oldCopies = line->copies[0];		      list<unsigned> &oldCopies = line->copies[0];
<       list<unsigned>::iterator oL = find (oldCopies.begin (),	      list<unsigned>::iterator oL = find (oldCopies.begin (),
<       if (oL != oldCopies.end ()) {				      if (oL != oldCopies.end ()) {
<         oldCopies.erase (oL);					        oldCopies.erase (oL);
<       }								      }
<       list<unsigned> &newCopies = line->copies[0];		      list<unsigned> &newCopies = line->copies[0];
<       list<unsigned>::iterator nL = find (newCopies.begin (),	      list<unsigned>::iterator nL = find (newCopies.begin (),
<       if (nL != newCopies.end ()) {				      if (nL != newCopies.end ()) {
<         newCopies.erase (nL);					        newCopies.erase (nL);
<       }								      }
< 
<       nMatchedLines += 1;					      nMatchedLines += 1;
<     }								    }
<     nMatchedBlocks += 1;					    nMatchedBlocks += 1;
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
<   nTotalMatchedBlocks += nMatchedBlocks;			  nTotalMatchedBlocks += nMatchedBlocks;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr,						    fprintf (stderr,
<              " found %u/%u matched lines/blocks (%u/%u totals	             " found %u/%u matched lines/blocks (%u/%u totals
<              nMatchedLines,					             nMatchedLines,
<              nMatchedBlocks,					             nMatchedBlocks,
<              nTotalMatchedLines,				             nTotalMatchedLines,
<              nTotalMatchedBlocks				             nTotalMatchedBlocks
<             );							            );
<     if (1 < optVerbose) {					    if (1 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< }							      <
< 
< // Perform Pass #3, in which we attempt to 'widen' blocks of  |	  // Perform Pass #3, in which we attempt to 'widen' blocks o
< // lines, by prepending lines which are the same in both file |	  // lines, by prepending lines which are the same in both fi
< 
< void pass3 ()						      <
< {							      <
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #3 (spreading matches up)...");	    fprintf (stderr, "# Pass #3 (spreading matches up)...");
<   }								  }
< 
<   nMatchedBlocks = 0;						  nMatchedBlocks = 0;
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Starting at the bottom of the old file,...			  // Starting at the bottom of the old file,...
< 
<   for (int o = lines[0].size (); 0 <= o; o -= 1) {		  for (int o = lines[0].size (); 0 <= o; o -= 1) {
< 
<     // ... skip any currently unmatched lines...		    // ... skip any currently unmatched lines...
< 
<     if (lines[0][o].l == ~0) {					    if (lines[0][o].l == ~0) {
<       continue;							      continue;
<     }								    }
< 
<     // ... until we find an [already] matched line.  Then, sk	    // ... until we find an [already] matched line.  Then, sk
<     // the set of 1 or more matched lines, until we reach any	    // the set of 1 or more matched lines, until we reach any
<     // following, still-unmatched line.				    // following, still-unmatched line.
< 
<     unsigned n;							    unsigned n;
<     do {							    do {
<       n = lines[0][o].l - 1;					      n = lines[0][o].l - 1;
<       o -= 1;							      o -= 1;
<     } while (0 <= o && lines[0][o].l != ~0);			    } while (0 <= o && lines[0][o].l != ~0);
< 
<     // Now, o + 1 is the line number of the last matched old 	    // Now, o + 1 is the line number of the last matched old 
<     // n + 1 is the line number of the last matched new line.	    // n + 1 is the line number of the last matched new line.
<     // to add new old and new lines, if they match.		    // to add new old and new lines, if they match.
< 
<     // Finally, attempt to add unmatched lines to the preceed	    // Finally, attempt to add unmatched lines to the preceed
<     // matched set.						    // matched set.
< 
<     for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {	    for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
< 
<       // If the [next] pair of old and new lines aren't the s	      // If the [next] pair of old and new lines aren't the s
< 
<       if (lines[0][o].line != lines[1][n].line) {		      if (lines[0][o].line != lines[1][n].line) {
<         break;							        break;
<       }								      }
< 
<       // Match up the pair.					      // Match up the pair.
< 
<       lines[0][o].l = n;					      lines[0][o].l = n;
<       lines[1][n].l = o;					      lines[1][n].l = o;
< 
<       // Remove the matched line numbers form the lists.	      // Remove the matched line numbers form the lists.
< 
<       Line *line = lines[0][o].line;				      Line *line = lines[0][o].line;
<       list<unsigned> &oldCopies = line->copies[0];		      list<unsigned> &oldCopies = line->copies[0];
<       list<unsigned>::iterator oL = find (oldCopies.begin (),	      list<unsigned>::iterator oL = find (oldCopies.begin (),
<       if (oL != oldCopies.end ()) {				      if (oL != oldCopies.end ()) {
<         oldCopies.erase (oL);					        oldCopies.erase (oL);
<       }								      }
<       list<unsigned> &newCopies = line->copies[0];		      list<unsigned> &newCopies = line->copies[0];
<       list<unsigned>::iterator nL = find (newCopies.begin (),	      list<unsigned>::iterator nL = find (newCopies.begin (),
<       if (nL != newCopies.end ()) {				      if (nL != newCopies.end ()) {
<         newCopies.erase (nL);					        newCopies.erase (nL);
<       }								      }
< 
<       nMatchedLines += 1;					      nMatchedLines += 1;
<     }								    }
<     nMatchedBlocks += 1;					    nMatchedBlocks += 1;
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr,						    fprintf (stderr,
<              " found %u/%u matched lines/blocks (%u/%u totals	             " found %u/%u matched lines/blocks (%u/%u totals
<              nMatchedLines,					             nMatchedLines,
<              nMatchedBlocks,					             nMatchedBlocks,
<              nTotalMatchedLines,				             nTotalMatchedLines,
<              nTotalMatchedBlocks				             nTotalMatchedBlocks
<             );							            );
< 
<     if (1 < optVerbose) {					    if (1 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< }							      <
< 
< // Perform pass #4, in which we find any remaining matches am |	  // Perform pass #4, in which we find any remaining matches 
< // unique lines.  For every unique line that has more than 1  |	  // the unique lines.  For every unique line that has more t
< // both files, we declare the copies to match.		      |	  // copy in both files, we declare the copies to match.
< 
< void pass4 ()						      <
< {							      <
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass 4 (finding remaining matches amo	    fprintf (stderr, "# Pass 4 (finding remaining matches amo
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   for (MapStringToLinePtr::iterator i = table.begin (); i != 	  for (MapStringToLinePtr::iterator i = table.begin (); i != 
<     Line *l = i->second;					    Line *l = i->second;
< 
<     // If there's more than 1 matching old and new lines, the	    // If there's more than 1 matching old and new lines, the
<     // declare that each pair are (all) the same line.		    // declare that each pair are (all) the same line.
< 
<     // (In the original algorithm, we only recognized a match	    // (In the original algorithm, we only recognized a match
<     // if there was exactly 1 copy for each file.)		    // if there was exactly 1 copy for each file.)
< 
<     while (0 < l->copies[0].size () && 0 < l->copies[1].size 	    while (0 < l->copies[0].size () && 0 < l->copies[1].size 
<       nMatchedLines += 1;					      nMatchedLines += 1;
< 
<       // For each matched line in the new file, mark it with 	      // For each matched line in the new file, mark it with 
<       // corresponding line (number) in the old file.		      // corresponding line (number) in the old file.
< 
<       unsigned o = l->copies[0].front ();			      unsigned o = l->copies[0].front ();
<       unsigned n = l->copies[1].front ();			      unsigned n = l->copies[1].front ();
< 
<       // Match up the pair.					      // Match up the pair.
< 
<       lines[0][o].l = n;					      lines[0][o].l = n;
<       lines[1][n].l = o;					      lines[1][n].l = o;
< 
<       // Remove the matched line numbers from the lists.	      // Remove the matched line numbers from the lists.
< 
<       l->copies[0].pop_front ();				      l->copies[0].pop_front ();
<       l->copies[1].pop_front ();				      l->copies[1].pop_front ();
<     }								    }
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, " found %u matched lines (%u total).\n",	    fprintf (stderr, " found %u matched lines (%u total).\n",
< 
<     if (1 < optVerbose) {					    if (1 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< }							      <
< 
< // Perform Pass #5, in which we look for blocks which match,  |	  // Perform Pass #5, in which we look for blocks which match
< // the result of a move (their not in their original position |	  // the result of a move (their not in their original positi
< // these, we'll unmatch the blocks, turning them into a delet |	  // these, we'll unmatch the blocks, turning them into a del
< // insert.						      |	  // an insert.
< 
< void pass5 ()						      <
< {							      <
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #5 (unmatching block moves)...\n	    fprintf (stderr, "# Pass #5 (unmatching block moves)...\n
<   }								  }
< 
<   nMatchedBlocks = 0;						  nMatchedBlocks = 0;
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Starting at the top of both files,...			  // Starting at the top of both files,...
< 
<   unsigned o = 0;						  unsigned o = 0;
<   unsigned n = 0;						  unsigned n = 0;
< 
<   while (o < lines[0].size () || n < lines[1].size ()) {	  while (o < lines[0].size () || n < lines[1].size ()) {
< 
<     // Skip any unmatched lines at this point in the old file	    // Skip any unmatched lines at this point in the old file
<     // are deletes.						    // are deletes.
< 
<     //    Old     New						    //    Old     New
<     //   +---+							    //   +---+
<     // 0 | a |							    // 0 | a |
<     //   +---+   +---+						    //   +---+   +---+
<     //         0 | b |						    //         0 | b |
<     //   +---+   +---+						    //   +---+   +---+
<     // 1 | c | 1 | c |						    // 1 | c | 1 | c |
<     //   +---+   +---+						    //   +---+   +---+
<     //         2 | z |						    //         2 | z |
<     //   +---+   +---+						    //   +---+   +---+
<     // 2 | d | 3 | d |						    // 2 | d | 3 | d |
<     //   +---+   +---+						    //   +---+   +---+
< 
<     while (o < lines[0].size () && lines[0][o].l == ~0) {	    while (o < lines[0].size () && lines[0][o].l == ~0) {
<       o += 1;							      o += 1;
<     }								    }
< 
<     // Skip any unmatched lines at this point in the new file	    // Skip any unmatched lines at this point in the new file
<     // are inserts.						    // are inserts.
< 
<     while (n < lines[1].size () && lines[1][n].l == ~0) {	    while (n < lines[1].size () && lines[1][n].l == ~0) {
<       n += 1;							      n += 1;
<     }								    }
< 
<     // When we get here, we know that we're dealing with matc	    // When we get here, we know that we're dealing with matc
<     // lines (or the end of one or both files).  We're done w	    // lines (or the end of one or both files).  We're done w
<     // pass, if we've reached the end of either file.		    // pass, if we've reached the end of either file.
< 
<     if (lines[0].size () <= o || lines[1].size () <= n) {	    if (lines[0].size () <= o || lines[1].size () <= n) {
<       break;							      break;
<     }								    }
< 
<     // We now know that we've got a pair of matching lines, t	    // We now know that we've got a pair of matching lines, t
<     // of a matching block.  If the new file's line number is	    // of a matching block.  If the new file's line number is
<     // expect, then the matched pair is unmoved, and we can s	    // expect, then the matched pair is unmoved, and we can s
<     // the pair.  (If this is really the start of a block of 	    // the pair.  (If this is really the start of a block of 
<     // 1 lines, we'll handle it one pair at a time.)		    // 1 lines, we'll handle it one pair at a time.)
< 
<     if (lines[0][o].l == n) {					    if (lines[0][o].l == n) {
<       o += 1;							      o += 1;
<       n += 1;							      n += 1;
<       continue;							      continue;
<     }								    }
< 
<     // If, on the other hand, we don't expect this [new] line	    // If, on the other hand, we don't expect this [new] line
<     // then this matching block has been moved.  We need to t	    // then this matching block has been moved.  We need to t
<     // matched pair into an *unmatched* pair, one of deletes,	    // matched pair into an *unmatched* pair, one of deletes,
<     // of inserts.  First, though, we need to know how big th	    // of inserts.  First, though, we need to know how big th
<     // is, and how far it was moved....				    // is, and how far it was moved....
< 
<     // Remember where we were when we started.			    // Remember where we were when we started.
< 
<     unsigned oOld = o;						    unsigned oOld = o;
<     unsigned nOld = n;						    unsigned nOld = n;
< 
<     // Remember where the block came from.			    // Remember where the block came from.
< 
<     unsigned nNew = lines[0][o].l;				    unsigned nNew = lines[0][o].l;
< 
<     // Find the end of this matched pair.			    // Find the end of this matched pair.
< 
<     for (n = nNew; o < lines[0].size () && n < lines[1].size 	    for (n = nNew; o < lines[0].size () && n < lines[1].size 
<       if (lines[0][o].l != n) {					      if (lines[0][o].l != n) {
<         break;							        break;
<       }								      }
<     }								    }
< 
<     // When we get here:					    // When we get here:
<     // * oOld..o is the old file's block,			    // * oOld..o is the old file's block,
<     // * nNew..n is the new file's *moved* block, and		    // * nNew..n is the new file's *moved* block, and
<     // * nOld is where we originally expected the new block f	    // * nOld is where we originally expected the new block f
<  								 
<     // We can now calculate the length of the block...		    // We can now calculate the length of the block...
<     								    
<     unsigned bSize = o - oOld;  // (or n - nNew)		    unsigned bSize = o - oOld;  // (or n - nNew)
< 
<     // ... and we can calculate how far the block moved:	    // ... and we can calculate how far the block moved:
< 
<     unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;	    unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
< 
<     // The larger of the two will become our delete, and the 	    // The larger of the two will become our delete, and the 
<     // will become our insert.					    // will become our insert.
< 
<     //    Old     New						    //    Old     New
<     //   +---+   +---+						    //   +---+   +---+
<     // 0 | a | 0 | b |						    // 0 | a | 0 | b |
<     //   +---+ 1 | b |						    //   +---+ 1 | b |
<     // 1 | b |   +---+						    // 1 | b |   +---+
<     // 2 | b | 2 | a |						    // 2 | b | 2 | a |
<     //   +---+   +---+						    //   +---+   +---+
<     // 3 | c | 3 | c |						    // 3 | c | 3 | c |
<     //   +---+   +---+						    //   +---+   +---+
< 
<     // (1) Delete a@0, insert a@2, or				    // (1) Delete a@0, insert a@2, or
<     // (2) insert bb@0, delete bb@1?				    // (2) insert bb@0, delete bb@1?
< 
<     // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and	    // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and
<     // (of a) is 2-0 or 2, the size of b@0.  We choose to del	    // (of a) is 2-0 or 2, the size of b@0.  We choose to del
<     // and reinsert a@2.					    // and reinsert a@2.
< 
<     // if (bSize <= bMove) {					    // if (bSize <= bMove) {
<       for (unsigned a = oOld; a < o; a += 1) {			      for (unsigned a = oOld; a < o; a += 1) {
<         lines[0][a].l = ~0;					        lines[0][a].l = ~0;
<       }								      }
<       for (unsigned d = nNew; d < n; d += 1) {			      for (unsigned d = nNew; d < n; d += 1) {
<         lines[1][d].l = ~0;					        lines[1][d].l = ~0;
<       }								      }
<     // } else {							    // } else {
<       // for (unsigned a = oOld; a < o; a += 1) {		      // for (unsigned a = oOld; a < o; a += 1) {
<       //   lines[0][a].l = ~0;					      //   lines[0][a].l = ~0;
<       // }							      // }
<       // for (unsigned d = nNew; d < n; d += 1) {		      // for (unsigned d = nNew; d < n; d += 1) {
<       //   lines[1][d].l = ~0;					      //   lines[1][d].l = ~0;
<       // }							      // }
<     // }							    // }
< 
<     // Continue from where we left off.				    // Continue from where we left off.
< 
<     n = nOld;							    n = nOld;
<   }								  }
<   nTotalMatchedLines -= nMatchedLines;				  nTotalMatchedLines -= nMatchedLines;
<   nTotalMatchedBlocks -= nMatchedBlocks;			  nTotalMatchedBlocks -= nMatchedBlocks;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr,						    fprintf (stderr,
<              " found %u/%u matched lines/blocks (%u/%u totals	             " found %u/%u matched lines/blocks (%u/%u totals
<              nMatchedLines,					             nMatchedLines,
<              nMatchedBlocks,					             nMatchedBlocks,
<              nTotalMatchedLines,				             nTotalMatchedLines,
<              nTotalMatchedBlocks				             nTotalMatchedBlocks
<             );							            );
< 
<     if (1 < optVerbose) {					    if (1 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< }							      <
< 							      <
< // Perform Pass #6, in which we create the desired output.    <
< 
< void pass6c ();						      |	  // Perform Pass #6, in which we create the desired output.
< void pass6e ();						      <
< void pass6i ();						      <
< void pass6n ();						      <
< void pass6r ();						      <
< void pass6s ();						      <
< void pass6u ();						      <
< 							      <
< void pass6 ()						      <
< {							      <
< 
<   switch (diffFormat) {					      |	  if (0 < optVerbose) {
<   case Context:						      |	    fprintf (stderr, "# Pass #6 (walking the differences)...\
<     pass6c ();						      |	  }
<     break;						      <
< 
<   case EdScript:					      |	  nMatchedLines = 0;
<     pass6e ();						      <
<     break;						      <
< 
<   case IfThenElse:					      |	  // Write the header.
<     pass6i ();						      <
<     break;						      <
< 
< 							      >	  switch (diffFormat) {
< 							      >	  case Default:
<   case Normal:							  case Normal:
<     pass6n ();						      <
<     break;							    break;
< 							      <
<   case RCS:						      <
<     pass6r ();						      <
<     break;						      <
< 							      <
<   case SideBySide:					      <
<     pass6s ();						      <
<     break;						      <
< 							      <
<   case Unified:							  case Unified:
<     pass6u ();						      |	    fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00
<     break;						      |	    fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00
< 							      |	    fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (),
<   case Default:						      <
<   default:						      <
<     pass6c ();						      <
<     break;							    break;
<   }								  }
< }							      <
< 							      <
< template<typename T> T min (T l, T r) {			      <
<   if (l < r) {						      <
<     return l;						      <
<   }							      <
<   return r;						      <
< }							      <
< 							      <
< template<typename T> T max (T l, T r) {			      <
<   if (l < r) {						      <
<     return r;						      <
<   }							      <
<   return l;						      <
< }							      <
< 							      <
< void pass6c () {					      <
<   if (0 < optVerbose) {					      <
<     fprintf (stderr, "# Pass #6u (walking the differences)... <
<   }							      <
< 							      <
<   nMatchedLines = 0;					      <
< 							      <
<   // Write the header.					      <
< 							      <
<   fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:0 <
<   fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:0 <
< 
<   // Starting at the top of both files,...			  // Starting at the top of both files,...
< 
<   unsigned o = 0;					      |	  o = 0;
<   unsigned n = 0;					      |	  n = 0;
< 
<   while (o < lines[0].size () || n < lines[1].size ()) {	  while (o < lines[0].size () || n < lines[1].size ()) {
< 
<     // Find any unmatched lines at this point in the old file	    // Find any unmatched lines at this point in the old file
<     // are deletes.						    // are deletes.
< 
<     unsigned boDeletes;						    unsigned boDeletes;
<     for (boDeletes = o;						    for (boDeletes = o;
<          o < lines[0].size () && lines[0][o].l == ~0;		         o < lines[0].size () && lines[0][o].l == ~0;
<          o += 1							         o += 1
<         )							        )
<     {}								    {}
< 
<     // Find any unmatched lines at this point in the new file	    // Find any unmatched lines at this point in the new file
<     // are inserts.						    // are inserts.
< 
<     unsigned boInserts;						    unsigned boInserts;
<     for (boInserts = n;						    for (boInserts = n;
<          n < lines[1].size () && lines[1][n].l == ~0;		         n < lines[1].size () && lines[1][n].l == ~0;
<          n += 1							         n += 1
<         )							        )
<     {}								    {}
< 
<     // We've got deleted line(s) from boDeletes .. o.		    // We've got deleted line(s) from boDeletes .. o.
<     // We've got deleted line(s) from boInserts .. n.		    // We've got deleted line(s) from boInserts .. n.
< 
<     unsigned nDeletes = o - boDeletes;				    unsigned nDeletes = o - boDeletes;
<     unsigned nInserts = n - boInserts;				    unsigned nInserts = n - boInserts;
< 
<     // Have we got anything?				      |	    // We've got...
< 							      <
<     if (nDeletes || nInserts) {				      <
---
>                                                               <
> void pass1 ()                                                 <
> {                                                             <
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Pass 1 (finding matches amongst uniqu       fprintf (stderr, "# Pass 1 (finding matches amongst uniqu
>   }                                                               }
>                                                                 
>   nMatchedLines = 0;                                              nMatchedLines = 0;
>                                                                 
>   for (MapStringToLinePtr::iterator i = table.begin (); i !=      for (MapStringToLinePtr::iterator i = table.begin (); i != 
>     Line *l = i->second;                                            Line *l = i->second;
>                                                                 
>     // If the number of old and new lines match, then we decl       // If the number of old and new lines match, then we decl
>     // they are (all) the same line.  Note, it isn't possible       // they are (all) the same line.  Note, it isn't possible
>     // numbers of both files to be 0.                               // numbers of both files to be 0.
>                                                                 
>     // (In the original algorithm, we only recognized a match       // (In the original algorithm, we only recognized a match
>     // if there was exactly 1 copy for each file.)                  // if there was exactly 1 copy for each file.)
>                                                                 
>     if (l->copies[0].size () == l->copies[1].size ()) {             if (l->copies[0].size () == l->copies[1].size ()) {
>       nMatchedLines += 1;                                             nMatchedLines += 1;
>                                                                 
>       // For each matched line in the new file, mark it with          // For each matched line in the new file, mark it with 
>       // corresponding line (number) in the old file.                 // corresponding line (number) in the old file.
>                                                                 
>       while (!l->copies[0].empty ()) {                                while (!l->copies[0].empty ()) {
>         unsigned o = l->copies[0].front ();                             unsigned o = l->copies[0].front ();
>         unsigned n = l->copies[1].front ();                             unsigned n = l->copies[1].front ();
>                                                                 
>         // Match up the pair.                                           // Match up the pair.
>                                                                 
>         lines[0][o].l = n;                                              lines[0][o].l = n;
>         lines[1][n].l = o;                                              lines[1][n].l = o;
>                                                                 
>         // Remove the matched line numbers from the lists.              // Remove the matched line numbers from the lists.
>                                                                 
>         l->copies[0].pop_front ();                                      l->copies[0].pop_front ();
>         l->copies[1].pop_front ();                                      l->copies[1].pop_front ();
>       }                                                               }
>     }                                                               }
>   }                                                               }
>   nTotalMatchedLines += nMatchedLines;                            nTotalMatchedLines += nMatchedLines;
>                                                                 
>   // Let's see the intermediate results.                          // Let's see the intermediate results.
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, " found %u matched lines (%u total).\n",       fprintf (stderr, " found %u matched lines (%u total).\n",
>                                                                 
>     if (1 < optVerbose) {                                           if (1 < optVerbose) {
>       for (int f = 0; f < 2; f += 1) {                                for (int f = 0; f < 2; f += 1) {
>         fprintf (stderr, "# file #%d\n", f + 1);                        fprintf (stderr, "# file #%d\n", f + 1);
>         for (int l = 0; l < lines[f].size (); l += 1) {                 for (int l = 0; l < lines[f].size (); l += 1) {
>           fprintf (stderr, "#   [%d] ", l);                               fprintf (stderr, "#   [%d] ", l);
>           lines[f][l].Dump (stderr);                                      lines[f][l].Dump (stderr);
>         }                                                               }
>       }                                                               }
>     }                                                               }
>   }                                                               }
> }                                                             | 
>                                                               |   // Perform Pass #2, in which we attempt to 'widen' blocks o
> // Perform Pass #2, in which we attempt to 'widen' blocks of  |   // lines, by appending lines which are the same in both fil
> // lines, by appending lines which are the same in both files | 
>                                                               <
> void pass2 ()                                                 <
> {                                                             <
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Pass #2 (spreading matches down)...")       fprintf (stderr, "# Pass #2 (spreading matches down)...")
>   }                                                               }
>                                                                 
>   nMatchedBlocks = 0;                                             nMatchedBlocks = 0;
>   nMatchedLines = 0;                                              nMatchedLines = 0;
>                                                                 
>   // Starting at the top of the old file,...                      // Starting at the top of the old file,...
>                                                                 
>   for (unsigned o = 0; o < lines[0].size (); o += 1) {            for (unsigned o = 0; o < lines[0].size (); o += 1) {
>                                                                 
>     // ... skip any currently unmatched lines...                    // ... skip any currently unmatched lines...
>                                                                 
>     if (lines[0][o].l == ~0) {                                      if (lines[0][o].l == ~0) {
>       continue;                                                       continue;
>     }                                                               }
>                                                                 
>     // ... until we find an [already] matched line.  Then, sk       // ... until we find an [already] matched line.  Then, sk
>     // the set of 1 or more matched lines, until we reach any       // the set of 1 or more matched lines, until we reach any
>     // following, still-unmatched line.                             // following, still-unmatched line.
>                                                                 
>     unsigned n;                                                     unsigned n;
>     do {                                                            do {
>       n = lines[0][o].l + 1;                                          n = lines[0][o].l + 1;
>       o += 1;                                                         o += 1;
>     } while (o < lines[0].size () && lines[0][o].l != ~0);          } while (o < lines[0].size () && lines[0][o].l != ~0);
>                                                                 
>     // Now, o - 1 is the line number of the last matched old        // Now, o - 1 is the line number of the last matched old 
>     // n - 1 is the line number of the last matched new line.       // n - 1 is the line number of the last matched new line.
>     // to add new old and new lines, if they match.                 // to add new old and new lines, if they match.
>                                                                 
>     // Finally, attempt to add unmatched lines to the preceed       // Finally, attempt to add unmatched lines to the preceed
>     // matched set.                                                 // matched set.
>                                                                 
>     for (; o < lines[0].size () && lines[0][o].l == ~0; o +=        for (; o < lines[0].size () && lines[0][o].l == ~0; o += 
>                                                                 
>       // If the [next] pair of old and new lines aren't the s         // If the [next] pair of old and new lines aren't the s
>                                                                 
>       if (lines[0][o].line != lines[1][n].line) {                     if (lines[0][o].line != lines[1][n].line) {
>         break;                                                          break;
>       }                                                               }
>                                                                 
>       // Match up the pair.                                           // Match up the pair.
>                                                                 
>       lines[0][o].l = n;                                              lines[0][o].l = n;
>       lines[1][n].l = o;                                              lines[1][n].l = o;
>                                                                 
>       // Remove the matched line numbers form the lists.              // Remove the matched line numbers form the lists.
>                                                                 
>       Line *line = lines[0][o].line;                                  Line *line = lines[0][o].line;
>       list<unsigned> &oldCopies = line->copies[0];                    list<unsigned> &oldCopies = line->copies[0];
>       list<unsigned>::iterator oL = find (oldCopies.begin (),         list<unsigned>::iterator oL = find (oldCopies.begin (),
>       if (oL != oldCopies.end ()) {                                   if (oL != oldCopies.end ()) {
>         oldCopies.erase (oL);                                           oldCopies.erase (oL);
>       }                                                               }
>       list<unsigned> &newCopies = line->copies[0];                    list<unsigned> &newCopies = line->copies[0];
>       list<unsigned>::iterator nL = find (newCopies.begin (),         list<unsigned>::iterator nL = find (newCopies.begin (),
>       if (nL != newCopies.end ()) {                                   if (nL != newCopies.end ()) {
>         newCopies.erase (nL);                                           newCopies.erase (nL);
>       }                                                               }
>                                                                 
>       nMatchedLines += 1;                                             nMatchedLines += 1;
>     }                                                               }
>     nMatchedBlocks += 1;                                            nMatchedBlocks += 1;
>   }                                                               }
>   nTotalMatchedLines += nMatchedLines;                            nTotalMatchedLines += nMatchedLines;
>   nTotalMatchedBlocks += nMatchedBlocks;                          nTotalMatchedBlocks += nMatchedBlocks;
>                                                                 
>   // Let's see the intermediate results.                          // Let's see the intermediate results.
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr,                                                fprintf (stderr,
>              " found %u/%u matched lines/blocks (%u/%u totals                " found %u/%u matched lines/blocks (%u/%u totals
>              nMatchedLines,                                                  nMatchedLines,
>              nMatchedBlocks,                                                 nMatchedBlocks,
>              nTotalMatchedLines,                                             nTotalMatchedLines,
>              nTotalMatchedBlocks                                             nTotalMatchedBlocks
>             );                                                              );
>     if (1 < optVerbose) {                                           if (1 < optVerbose) {
>       for (int f = 0; f < 2; f += 1) {                                for (int f = 0; f < 2; f += 1) {
>         fprintf (stderr, "# file #%d\n", f + 1);                        fprintf (stderr, "# file #%d\n", f + 1);
>         for (int l = 0; l < lines[f].size (); l += 1) {                 for (int l = 0; l < lines[f].size (); l += 1) {
>           fprintf (stderr, "#   [%d] ", l);                               fprintf (stderr, "#   [%d] ", l);
>           lines[f][l].Dump (stderr);                                      lines[f][l].Dump (stderr);
>         }                                                               }
>       }                                                               }
>     }                                                               }
>   }                                                               }
> }                                                             | 
>                                                               |   // Perform Pass #3, in which we attempt to 'widen' blocks o
> // Perform Pass #3, in which we attempt to 'widen' blocks of  |   // lines, by prepending lines which are the same in both fi
> // lines, by prepending lines which are the same in both file | 
>                                                               <
> void pass3 ()                                                 <
> {                                                             <
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Pass #3 (spreading matches up)...");        fprintf (stderr, "# Pass #3 (spreading matches up)...");
>   }                                                               }
>                                                                 
>   nMatchedBlocks = 0;                                             nMatchedBlocks = 0;
>   nMatchedLines = 0;                                              nMatchedLines = 0;
>                                                                 
>   // Starting at the bottom of the old file,...                   // Starting at the bottom of the old file,...
>                                                                 
>   for (int o = lines[0].size (); 0 <= o; o -= 1) {                for (int o = lines[0].size (); 0 <= o; o -= 1) {
>                                                                 
>     // ... skip any currently unmatched lines...                    // ... skip any currently unmatched lines...
>                                                                 
>     if (lines[0][o].l == ~0) {                                      if (lines[0][o].l == ~0) {
>       continue;                                                       continue;
>     }                                                               }
>                                                                 
>     // ... until we find an [already] matched line.  Then, sk       // ... until we find an [already] matched line.  Then, sk
>     // the set of 1 or more matched lines, until we reach any       // the set of 1 or more matched lines, until we reach any
>     // following, still-unmatched line.                             // following, still-unmatched line.
>                                                                 
>     unsigned n;                                                     unsigned n;
>     do {                                                            do {
>       n = lines[0][o].l - 1;                                          n = lines[0][o].l - 1;
>       o -= 1;                                                         o -= 1;
>     } while (0 <= o && lines[0][o].l != ~0);                        } while (0 <= o && lines[0][o].l != ~0);
>                                                                 
>     // Now, o + 1 is the line number of the last matched old        // Now, o + 1 is the line number of the last matched old 
>     // n + 1 is the line number of the last matched new line.       // n + 1 is the line number of the last matched new line.
>     // to add new old and new lines, if they match.                 // to add new old and new lines, if they match.
>                                                                 
>     // Finally, attempt to add unmatched lines to the preceed       // Finally, attempt to add unmatched lines to the preceed
>     // matched set.                                                 // matched set.
>                                                                 
>     for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {         for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
>                                                                 
>       // If the [next] pair of old and new lines aren't the s         // If the [next] pair of old and new lines aren't the s
>                                                                 
>       if (lines[0][o].line != lines[1][n].line) {                     if (lines[0][o].line != lines[1][n].line) {
>         break;                                                          break;
>       }                                                               }
>                                                                 
>       // Match up the pair.                                           // Match up the pair.
>                                                                 
>       lines[0][o].l = n;                                              lines[0][o].l = n;
>       lines[1][n].l = o;                                              lines[1][n].l = o;
>                                                                 
>       // Remove the matched line numbers form the lists.              // Remove the matched line numbers form the lists.
>                                                                 
>       Line *line = lines[0][o].line;                                  Line *line = lines[0][o].line;
>       list<unsigned> &oldCopies = line->copies[0];                    list<unsigned> &oldCopies = line->copies[0];
>       list<unsigned>::iterator oL = find (oldCopies.begin (),         list<unsigned>::iterator oL = find (oldCopies.begin (),
>       if (oL != oldCopies.end ()) {                                   if (oL != oldCopies.end ()) {
>         oldCopies.erase (oL);                                           oldCopies.erase (oL);
>       }                                                               }
>       list<unsigned> &newCopies = line->copies[0];                    list<unsigned> &newCopies = line->copies[0];
>       list<unsigned>::iterator nL = find (newCopies.begin (),         list<unsigned>::iterator nL = find (newCopies.begin (),
>       if (nL != newCopies.end ()) {                                   if (nL != newCopies.end ()) {
>         newCopies.erase (nL);                                           newCopies.erase (nL);
>       }                                                               }
>                                                                 
>       nMatchedLines += 1;                                             nMatchedLines += 1;
>     }                                                               }
>     nMatchedBlocks += 1;                                            nMatchedBlocks += 1;
>   }                                                               }
>   nTotalMatchedLines += nMatchedLines;                            nTotalMatchedLines += nMatchedLines;
>                                                                 
>   // Let's see the intermediate results.                          // Let's see the intermediate results.
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr,                                                fprintf (stderr,
>              " found %u/%u matched lines/blocks (%u/%u totals                " found %u/%u matched lines/blocks (%u/%u totals
>              nMatchedLines,                                                  nMatchedLines,
>              nMatchedBlocks,                                                 nMatchedBlocks,
>              nTotalMatchedLines,                                             nTotalMatchedLines,
>              nTotalMatchedBlocks                                             nTotalMatchedBlocks
>             );                                                              );
>                                                                 
>     if (1 < optVerbose) {                                           if (1 < optVerbose) {
>       for (int f = 0; f < 2; f += 1) {                                for (int f = 0; f < 2; f += 1) {
>         fprintf (stderr, "# file #%d\n", f + 1);                        fprintf (stderr, "# file #%d\n", f + 1);
>         for (int l = 0; l < lines[f].size (); l += 1) {                 for (int l = 0; l < lines[f].size (); l += 1) {
>           fprintf (stderr, "#   [%d] ", l);                               fprintf (stderr, "#   [%d] ", l);
>           lines[f][l].Dump (stderr);                                      lines[f][l].Dump (stderr);
>         }                                                               }
>       }                                                               }
>     }                                                               }
>   }                                                               }
> }                                                             | 
>                                                               |   // Perform pass #4, in which we find any remaining matches 
> // Perform pass #4, in which we find any remaining matches am |   // the unique lines.  For every unique line that has more t
> // unique lines.  For every unique line that has more than 1  |   // copy in both files, we declare the copies to match.
> // both files, we declare the copies to match.                | 
>                                                               <
> void pass4 ()                                                 <
> {                                                             <
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Pass 4 (finding remaining matches amo       fprintf (stderr, "# Pass 4 (finding remaining matches amo
>   }                                                               }
>                                                                 
>   nMatchedLines = 0;                                              nMatchedLines = 0;
>                                                                 
>   for (MapStringToLinePtr::iterator i = table.begin (); i !=      for (MapStringToLinePtr::iterator i = table.begin (); i != 
>     Line *l = i->second;                                            Line *l = i->second;
>                                                                 
>     // If there's more than 1 matching old and new lines, the       // If there's more than 1 matching old and new lines, the
>     // declare that each pair are (all) the same line.              // declare that each pair are (all) the same line.
>                                                                 
>     // (In the original algorithm, we only recognized a match       // (In the original algorithm, we only recognized a match
>     // if there was exactly 1 copy for each file.)                  // if there was exactly 1 copy for each file.)
>                                                                 
>     while (0 < l->copies[0].size () && 0 < l->copies[1].size        while (0 < l->copies[0].size () && 0 < l->copies[1].size 
>       nMatchedLines += 1;                                             nMatchedLines += 1;
>                                                                 
>       // For each matched line in the new file, mark it with          // For each matched line in the new file, mark it with 
>       // corresponding line (number) in the old file.                 // corresponding line (number) in the old file.
>                                                                 
>       unsigned o = l->copies[0].front ();                             unsigned o = l->copies[0].front ();
>       unsigned n = l->copies[1].front ();                             unsigned n = l->copies[1].front ();
>                                                                 
>       // Match up the pair.                                           // Match up the pair.
>                                                                 
>       lines[0][o].l = n;                                              lines[0][o].l = n;
>       lines[1][n].l = o;                                              lines[1][n].l = o;
>                                                                 
>       // Remove the matched line numbers from the lists.              // Remove the matched line numbers from the lists.
>                                                                 
>       l->copies[0].pop_front ();                                      l->copies[0].pop_front ();
>       l->copies[1].pop_front ();                                      l->copies[1].pop_front ();
>     }                                                               }
>   }                                                               }
>   nTotalMatchedLines += nMatchedLines;                            nTotalMatchedLines += nMatchedLines;
>                                                                 
>   // Let's see the intermediate results.                          // Let's see the intermediate results.
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, " found %u matched lines (%u total).\n",       fprintf (stderr, " found %u matched lines (%u total).\n",
>                                                                 
>     if (1 < optVerbose) {                                           if (1 < optVerbose) {
>       for (int f = 0; f < 2; f += 1) {                                for (int f = 0; f < 2; f += 1) {
>         fprintf (stderr, "# file #%d\n", f + 1);                        fprintf (stderr, "# file #%d\n", f + 1);
>         for (int l = 0; l < lines[f].size (); l += 1) {                 for (int l = 0; l < lines[f].size (); l += 1) {
>           fprintf (stderr, "#   [%d] ", l);                               fprintf (stderr, "#   [%d] ", l);
>           lines[f][l].Dump (stderr);                                      lines[f][l].Dump (stderr);
>         }                                                               }
>       }                                                               }
>     }                                                               }
>   }                                                               }
> }                                                             | 
>                                                               |   // Perform Pass #5, in which we look for blocks which match
> // Perform Pass #5, in which we look for blocks which match,  |   // the result of a move (their not in their original positi
> // the result of a move (their not in their original position |   // these, we'll unmatch the blocks, turning them into a del
> // these, we'll unmatch the blocks, turning them into a delet |   // an insert.
> // insert.                                                    | 
>                                                               <
> void pass5 ()                                                 <
> {                                                             <
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Pass #5 (unmatching block moves)...\n       fprintf (stderr, "# Pass #5 (unmatching block moves)...\n
>   }                                                               }
>                                                                 
>   nMatchedBlocks = 0;                                             nMatchedBlocks = 0;
>   nMatchedLines = 0;                                              nMatchedLines = 0;
>                                                                 
>   // Starting at the top of both files,...                        // Starting at the top of both files,...
>                                                                 
>   unsigned o = 0;                                                 unsigned o = 0;
>   unsigned n = 0;                                                 unsigned n = 0;
>                                                                 
>   while (o < lines[0].size () || n < lines[1].size ()) {          while (o < lines[0].size () || n < lines[1].size ()) {
>                                                                 
>     // Skip any unmatched lines at this point in the old file       // Skip any unmatched lines at this point in the old file
>     // are deletes.                                                 // are deletes.
>                                                                 
>     //    Old     New                                               //    Old     New
>     //   +---+                                                      //   +---+
>     // 0 | a |                                                      // 0 | a |
>     //   +---+   +---+                                              //   +---+   +---+
>     //         0 | b |                                              //         0 | b |
>     //   +---+   +---+                                              //   +---+   +---+
>     // 1 | c | 1 | c |                                              // 1 | c | 1 | c |
>     //   +---+   +---+                                              //   +---+   +---+
>     //         2 | z |                                              //         2 | z |
>     //   +---+   +---+                                              //   +---+   +---+
>     // 2 | d | 3 | d |                                              // 2 | d | 3 | d |
>     //   +---+   +---+                                              //   +---+   +---+
>                                                                 
>     while (o < lines[0].size () && lines[0][o].l == ~0) {           while (o < lines[0].size () && lines[0][o].l == ~0) {
>       o += 1;                                                         o += 1;
>     }                                                               }
>                                                                 
>     // Skip any unmatched lines at this point in the new file       // Skip any unmatched lines at this point in the new file
>     // are inserts.                                                 // are inserts.
>                                                                 
>     while (n < lines[1].size () && lines[1][n].l == ~0) {           while (n < lines[1].size () && lines[1][n].l == ~0) {
>       n += 1;                                                         n += 1;
>     }                                                               }
>                                                                 
>     // When we get here, we know that we're dealing with matc       // When we get here, we know that we're dealing with matc
>     // lines (or the end of one or both files).  We're done w       // lines (or the end of one or both files).  We're done w
>     // pass, if we've reached the end of either file.               // pass, if we've reached the end of either file.
>                                                                 
>     if (lines[0].size () <= o || lines[1].size () <= n) {           if (lines[0].size () <= o || lines[1].size () <= n) {
>       break;                                                          break;
>     }                                                               }
>                                                                 
>     // We now know that we've got a pair of matching lines, t       // We now know that we've got a pair of matching lines, t
>     // of a matching block.  If the new file's line number is       // of a matching block.  If the new file's line number is
>     // expect, then the matched pair is unmoved, and we can s       // expect, then the matched pair is unmoved, and we can s
>     // the pair.  (If this is really the start of a block of        // the pair.  (If this is really the start of a block of 
>     // 1 lines, we'll handle it one pair at a time.)                // 1 lines, we'll handle it one pair at a time.)
>                                                                 
>     if (lines[0][o].l == n) {                                       if (lines[0][o].l == n) {
>       o += 1;                                                         o += 1;
>       n += 1;                                                         n += 1;
>       continue;                                                       continue;
>     }                                                               }
>                                                                 
>     // If, on the other hand, we don't expect this [new] line       // If, on the other hand, we don't expect this [new] line
>     // then this matching block has been moved.  We need to t       // then this matching block has been moved.  We need to t
>     // matched pair into an *unmatched* pair, one of deletes,       // matched pair into an *unmatched* pair, one of deletes,
>     // of inserts.  First, though, we need to know how big th       // of inserts.  First, though, we need to know how big th
>     // is, and how far it was moved....                             // is, and how far it was moved....
>                                                                 
>     // Remember where we were when we started.                      // Remember where we were when we started.
>                                                                 
>     unsigned oOld = o;                                              unsigned oOld = o;
>     unsigned nOld = n;                                              unsigned nOld = n;
>                                                                 
>     // Remember where the block came from.                          // Remember where the block came from.
>                                                                 
>     unsigned nNew = lines[0][o].l;                                  unsigned nNew = lines[0][o].l;
>                                                                 
>     // Find the end of this matched pair.                           // Find the end of this matched pair.
>                                                                 
>     for (n = nNew; o < lines[0].size () && n < lines[1].size        for (n = nNew; o < lines[0].size () && n < lines[1].size 
>       if (lines[0][o].l != n) {                                       if (lines[0][o].l != n) {
>         break;                                                          break;
>       }                                                               }
>     }                                                               }
>                                                                 
>     // When we get here:                                            // When we get here:
>     // * oOld..o is the old file's block,                           // * oOld..o is the old file's block,
>     // * nNew..n is the new file's *moved* block, and               // * nNew..n is the new file's *moved* block, and
>     // * nOld is where we originally expected the new block f       // * nOld is where we originally expected the new block f
>                                                                  
>     // We can now calculate the length of the block...              // We can now calculate the length of the block...
>                                                                     
>     unsigned bSize = o - oOld;  // (or n - nNew)                    unsigned bSize = o - oOld;  // (or n - nNew)
>                                                                 
>     // ... and we can calculate how far the block moved:            // ... and we can calculate how far the block moved:
>                                                                 
>     unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;       unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
>                                                                 
>     // The larger of the two will become our delete, and the        // The larger of the two will become our delete, and the 
>     // will become our insert.                                      // will become our insert.
>                                                                 
>     //    Old     New                                               //    Old     New
>     //   +---+   +---+                                              //   +---+   +---+
>     // 0 | a | 0 | b |                                              // 0 | a | 0 | b |
>     //   +---+ 1 | b |                                              //   +---+ 1 | b |
>     // 1 | b |   +---+                                              // 1 | b |   +---+
>     // 2 | b | 2 | a |                                              // 2 | b | 2 | a |
>     //   +---+   +---+                                              //   +---+   +---+
>     // 3 | c | 3 | c |                                              // 3 | c | 3 | c |
>     //   +---+   +---+                                              //   +---+   +---+
>                                                                 
>     // (1) Delete a@0, insert a@2, or                               // (1) Delete a@0, insert a@2, or
>     // (2) insert bb@0, delete bb@1?                                // (2) insert bb@0, delete bb@1?
>                                                                 
>     // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and       // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and
>     // (of a) is 2-0 or 2, the size of b@0.  We choose to del       // (of a) is 2-0 or 2, the size of b@0.  We choose to del
>     // and reinsert a@2.                                            // and reinsert a@2.
>                                                                 
>     // if (bSize <= bMove) {                                        // if (bSize <= bMove) {
>       for (unsigned a = oOld; a < o; a += 1) {                        for (unsigned a = oOld; a < o; a += 1) {
>         lines[0][a].l = ~0;                                             lines[0][a].l = ~0;
>       }                                                               }
>       for (unsigned d = nNew; d < n; d += 1) {                        for (unsigned d = nNew; d < n; d += 1) {
>         lines[1][d].l = ~0;                                             lines[1][d].l = ~0;
>       }                                                               }
>     // } else {                                                     // } else {
>       // for (unsigned a = oOld; a < o; a += 1) {                     // for (unsigned a = oOld; a < o; a += 1) {
>       //   lines[0][a].l = ~0;                                        //   lines[0][a].l = ~0;
>       // }                                                            // }
>       // for (unsigned d = nNew; d < n; d += 1) {                     // for (unsigned d = nNew; d < n; d += 1) {
>       //   lines[1][d].l = ~0;                                        //   lines[1][d].l = ~0;
>       // }                                                            // }
>     // }                                                            // }
>                                                                 
>     // Continue from where we left off.                             // Continue from where we left off.
>                                                                 
>     n = nOld;                                                       n = nOld;
>   }                                                               }
>   nTotalMatchedLines -= nMatchedLines;                            nTotalMatchedLines -= nMatchedLines;
>   nTotalMatchedBlocks -= nMatchedBlocks;                          nTotalMatchedBlocks -= nMatchedBlocks;
>                                                                 
>   // Let's see the intermediate results.                          // Let's see the intermediate results.
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr,                                                fprintf (stderr,
>              " found %u/%u matched lines/blocks (%u/%u totals                " found %u/%u matched lines/blocks (%u/%u totals
>              nMatchedLines,                                                  nMatchedLines,
>              nMatchedBlocks,                                                 nMatchedBlocks,
>              nTotalMatchedLines,                                             nTotalMatchedLines,
>              nTotalMatchedBlocks                                             nTotalMatchedBlocks
>             );                                                              );
>                                                                 
>     if (1 < optVerbose) {                                           if (1 < optVerbose) {
>       for (int f = 0; f < 2; f += 1) {                                for (int f = 0; f < 2; f += 1) {
>         fprintf (stderr, "# file #%d\n", f + 1);                        fprintf (stderr, "# file #%d\n", f + 1);
>         for (int l = 0; l < lines[f].size (); l += 1) {                 for (int l = 0; l < lines[f].size (); l += 1) {
>           fprintf (stderr, "#   [%d] ", l);                               fprintf (stderr, "#   [%d] ", l);
>           lines[f][l].Dump (stderr);                                      lines[f][l].Dump (stderr);
>         }                                                               }
>       }                                                               }
>     }                                                               }
>   }                                                               }
> }                                                             | 
>                                                               |   // Perform Pass #6, in which we create the desired output.
> // Perform Pass #6, in which we create the desired output.    | 
>                                                               <
> void pass6c ();                                               <
> void pass6e ();                                               <
> void pass6i ();                                               <
> void pass6n ();                                               <
> void pass6r ();                                               <
> void pass6s ();                                               <
> void pass6u ();                                               <
>                                                               <
> void pass6 ()                                                 <
> {                                                             <
>                                                               <
>   switch (diffFormat) {                                       <
>   case Context:                                               <
>     pass6c ();                                                <
>     break;                                                    <
>                                                               <
>   case EdScript:                                              <
>     pass6e ();                                                <
>     break;                                                    <
>                                                               <
>   case IfThenElse:                                            <
>     pass6i ();                                                <
>     break;                                                    <
>                                                               <
>   case Normal:                                                <
>     pass6n ();                                                <
>     break;                                                    <
>                                                               <
>   case RCS:                                                   <
>     pass6r ();                                                <
>     break;                                                    <
>                                                               <
>   case SideBySide:                                            <
>     pass6s ();                                                <
>     break;                                                    <
>                                                               <
>   case Unified:                                               <
>     pass6u ();                                                <
>     break;                                                    <
>                                                               <
>   case Default:                                               <
>   default:                                                    <
>     pass6c ();                                                <
>     break;                                                    <
>   }                                                           <
> }                                                             <
>                                                               <
> template<typename T> T min (T l, T r) {                       <
>   if (l < r) {                                                <
>     return l;                                                 <
>   }                                                           <
>   return r;                                                   <
> }                                                             <
>                                                               <
> template<typename T> T max (T l, T r) {                       <
>   if (l < r) {                                                <
>     return r;                                                 <
>   }                                                           <
>   return l;                                                   <
> }                                                             <
>                                                               <
> void pass6c () {                                              <
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Pass #6u (walking the differences)... |     fprintf (stderr, "# Pass #6 (walking the differences)...\
>   }                                                           |   }
>                                                               | 
>   nMatchedLines = 0;                                              nMatchedLines = 0;
>                                                               | 
>   // Write the header.                                            // Write the header.
>                                                               | 
>   fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:0 |   switch (diffFormat) {
>   fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:0 |   case Default:
>                                                               |   case Normal:
>                                                               >     break;
>                                                               >   case Unified:
>                                                               >     fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00
>                                                               >     fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00
>                                                               >     fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (),
>                                                               >     break;
>                                                               >   }
>                                                               > 
>   // Starting at the top of both files,...                        // Starting at the top of both files,...
>                                                               | 
>   unsigned o = 0;                                             |   o = 0;
>   unsigned n = 0;                                             |   n = 0;
>                                                               | 
>   while (o < lines[0].size () || n < lines[1].size ()) {          while (o < lines[0].size () || n < lines[1].size ()) {
>                                                               | 
>     // Find any unmatched lines at this point in the old file       // Find any unmatched lines at this point in the old file
>     // are deletes.                                                 // are deletes.
>                                                               | 
>     unsigned boDeletes;                                             unsigned boDeletes;
>     for (boDeletes = o;                                             for (boDeletes = o;
>          o < lines[0].size () && lines[0][o].l == ~0;                    o < lines[0].size () && lines[0][o].l == ~0;
>          o += 1                                                          o += 1
>         )                                                               )
>     {}                                                              {}
>                                                               | 
>     // Find any unmatched lines at this point in the new file       // Find any unmatched lines at this point in the new file
>     // are inserts.                                                 // are inserts.
>                                                               | 
>     unsigned boInserts;                                             unsigned boInserts;
>     for (boInserts = n;                                             for (boInserts = n;
>          n < lines[1].size () && lines[1][n].l == ~0;                    n < lines[1].size () && lines[1][n].l == ~0;
>          n += 1                                                          n += 1
>         )                                                               )
>     {}                                                              {}
>                                                               | 
>     // We've got deleted line(s) from boDeletes .. o.               // We've got deleted line(s) from boDeletes .. o.
>     // We've got deleted line(s) from boInserts .. n.               // We've got deleted line(s) from boInserts .. n.
>                                                               | 
>     unsigned nDeletes = o - boDeletes;                              unsigned nDeletes = o - boDeletes;
>     unsigned nInserts = n - boInserts;                              unsigned nInserts = n - boInserts;
>                                                               | 
>     // Have we got anything?                                  <
>                                                               <
>     if (nDeletes || nInserts) {                               <
759c775
< 							      <
---
>                                                               <
762c778
< 							      <
---
>                                                               <
766,774c782,790
<       }							      <
< 							      <
<       // We've got...					      <
< 							      <
<       if (nDeletes && nInserts) {			      <
< 							      <
<         // ... deletes and inserts.			      <
< 
<         for (unsigned l = boDeletes; l < o; l += 1) {	      |	    if (nDeletes && nInserts) {
---
>       }                                                       <
>                                                               <
>       // We've got...                                         <
>                                                               <
>       if (nDeletes && nInserts) {                             <
>                                                               <
>         // ... deletes and inserts.                           <
>                                                               <
>         for (unsigned l = boDeletes; l < o; l += 1) {         <
776,796c792,802
<         }						      <
<       } else if (nDeletes) {				      <
< 
<         //  ... just deletes.				      |	      // ... deletes and inserts.
< 
< 							      >	      switch (diffFormat) {
< 							      >	      case Default:
< 							      >	      case Normal:
< 							      >	        if (1 < nDeletes && 1 < nInserts) {
< 							      >	          fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o,
< 							      >	        } else if (1 < nDeletes) {
< 							      >	          fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, bo
< 							      >	        } else if (1 < nInserts) {
< 							      >	          fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boIns
< 							      >	        } 
<         for (unsigned l = boDeletes; l < o; l += 1) {		        for (unsigned l = boDeletes; l < o; l += 1) {
<           fprintf (stdout, "- %s", lines[0][l].line->c_str () |	          fprintf (stdout, "< %s", lines[0][l].line->c_str ()
<         }							        }
<       }							      |	        fprintf (stderr, "---\n");
< 							      <
<       for (unsigned l = o; l < eoOldWindow; l += 1) {	      <
---
>         }                                                     <
>       } else if (nDeletes) {                                  <
>                                                               <
>         //  ... just deletes.                                 <
>                                                               <
>         for (unsigned l = boDeletes; l < o; l += 1) {         <
>           fprintf (stdout, "- %s", lines[0][l].line->c_str () <
>         }                                                     <
>       }                                                       <
>                                                               <
>       for (unsigned l = o; l < eoOldWindow; l += 1) {         <
798c804
<       }							      <
---
>       }                                                       <
802,826c808,828
<       }							      <
< 							      <
<       // We've got...					      <
< 							      <
<       if (nDeletes && nInserts) {			      <
< 							      <
<         // ... deletes and inserts.			      <
< 							      <
<         for (unsigned l = boInserts; l < n; l += 1) {		        for (unsigned l = boInserts; l < n; l += 1) {
<           fprintf (stdout, "! %s", lines[1][l].line->c_str () |	          fprintf (stdout, "> %s", lines[1][l].line->c_str ()
<         }							        }
<       } else if (nInserts) {				      |	        break;
< 							      <
<         //  ... just inserts.				      <
< 
< 							      >	      case Unified:
< 							      >	        for (unsigned l = boDeletes; l < o; l += 1) {
< 							      >	          fprintf (stdout, "-%s", lines[0][l].line->c_str ())
< 							      >	        }
<         for (unsigned l = boInserts; l < n; l += 1) {		        for (unsigned l = boInserts; l < n; l += 1) {
<           fprintf (stdout, "+ %s", lines[1][l].line->c_str () |	          fprintf (stdout, "+%s", lines[1][l].line->c_str ())
<         }							        }
<       }							      |	        break;
< 							      <
<       for (unsigned l = n; l < eoNewWindow; l += 1) {	      <
---
>       }                                                       <
>                                                               <
>       // We've got...                                         <
>                                                               <
>       if (nDeletes && nInserts) {                             <
>                                                               <
>         // ... deletes and inserts.                           <
>                                                               <
>         for (unsigned l = boInserts; l < n; l += 1) {         <
>           fprintf (stdout, "! %s", lines[1][l].line->c_str () <
>         }                                                     <
>       } else if (nInserts) {                                  <
>                                                               <
>         //  ... just inserts.                                 <
>                                                               <
>         for (unsigned l = boInserts; l < n; l += 1) {         <
>           fprintf (stdout, "+ %s", lines[1][l].line->c_str () <
>         }                                                     <
>       }                                                       <
>                                                               <
>       for (unsigned l = n; l < eoNewWindow; l += 1) {         <
828,830c830,832
<       }							      <
<     }							      <
< 							      <
---
>       }                                                       <
>     }                                                         <
>                                                               <
832,846c834,848
< 							      <
<     o += 1;						      <
<     n += 1;						      <
<   }							      <
< }							      <
< 							      <
< void pass6e () {					      <
< }							      <
< 							      <
< void pass6i () {					      <
< }							      <
< 							      <
< void pass6n ()						      <
< {							      <
<   if (0 < optVerbose) {					      <
---
>                                                               <
>     o += 1;                                                   <
>     n += 1;                                                   <
>   }                                                           <
> }                                                             <
>                                                               <
> void pass6e () {                                              <
> }                                                             <
>                                                               <
> void pass6i () {                                              <
> }                                                             <
>                                                               <
> void pass6n ()                                                <
> {                                                             <
>   if (0 < optVerbose) {                                       <
848,858c850,860
<   }							      <
< 							      <
<   nMatchedLines = 0;					      <
< 							      <
<   // Write the header.  (None for normal.)		      <
< 							      <
<   // Starting at the top of both files,...		      <
< 							      <
<   unsigned o = 0;					      <
<   unsigned n = 0;					      <
< 							      <
---
>   }                                                           <
>                                                               <
>   nMatchedLines = 0;                                          <
>                                                               <
>   // Write the header.  (None for normal.)                    <
>                                                               <
>   // Starting at the top of both files,...                    <
>                                                               <
>   unsigned o = 0;                                             <
>   unsigned n = 0;                                             <
>                                                               <
860c862
< 							      <
---
>                                                               <
862,870c864,872
<     // are deletes.					      <
< 							      <
<     unsigned boDeletes;					      <
<     for (boDeletes = o;					      <
<          o < lines[0].size () && lines[0][o].l == ~0;	      <
<          o += 1						      <
<         )						      <
<     {}							      <
< 							      <
---
>     // are deletes.                                           <
>                                                               <
>     unsigned boDeletes;                                       <
>     for (boDeletes = o;                                       <
>          o < lines[0].size () && lines[0][o].l == ~0;         <
>          o += 1                                               <
>         )                                                     <
>     {}                                                        <
>                                                               <
872,968c874,995
<     // are inserts.					      <
< 							      <
<     unsigned boInserts;					      <
<     for (boInserts = n;					      <
<          n < lines[1].size () && lines[1][n].l == ~0;	      <
<          n += 1						      <
<         )						      <
<     {}							      <
< 							      <
<     // We've got deleted line(s) from boDeletes .. o.	      <
<     // We've got deleted line(s) from boInserts .. n.	      <
< 							      <
<     unsigned nDeletes = o - boDeletes;			      <
<     unsigned nInserts = n - boInserts;			      <
< 							      <
<     // We've got...					      <
< 							      <
<     if (nDeletes && nInserts) {				      <
< 							      <
<       // ... deletes and inserts.			      <
< 							      <
<       if (1 < nDeletes && 1 < nInserts) {		      <
<         fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, b <
<       } else if (1 < nDeletes) {			      <
<         fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boIn <
<       } else if (1 < nInserts) {			      <
<         fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInser <
<       } 						      <
<       for (unsigned l = boDeletes; l < o; l += 1) {	      <
<         fprintf (stdout, "< %s", lines[0][l].line->c_str ()); <
<       }							      <
<       fprintf (stderr, "---\n");			      <
<       for (unsigned l = boInserts; l < n; l += 1) {	      <
<         fprintf (stdout, "> %s", lines[1][l].line->c_str ()); <
<       }								      }
<     } else if (nDeletes) {					    } else if (nDeletes) {
< 
<       //  ... just deletes.					      //  ... just deletes.
< 
<       if (1 < nDeletes) {				      |	      switch (diffFormat) {
<         fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);  |	      case Default:
<       } else {						      |	      case Normal:
<         fprintf (stdout, "%dd%d\n", boDeletes + 1, n);	      |	        if (1 < nDeletes) {
<       }							      |	          fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n)
<       for (unsigned l = boDeletes; l < o; l += 1) {	      |	        } else {
<         fprintf (stdout, "< %s", lines[0][l].line->c_str ()); |	          fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
< 							      >	        }
< 							      >	        for (unsigned l = boDeletes; l < o; l += 1) {
< 							      >	          fprintf (stdout, "< %s", lines[0][l].line->c_str ()
< 							      >	        }
< 							      >	        break;
< 							      >	      case Unified:
< 							      >	        for (unsigned l = boDeletes; l < o; l += 1) {
< 							      >	          fprintf (stdout, "-%s", lines[0][l].line->c_str ())
< 							      >	        }
< 							      >	        break;
<       }								      }
<     } else if (nInserts) {					    } else if (nInserts) {
< 
<       //  ... just inserts.					      //  ... just inserts.
< 
<       if (1 < nInserts) {				      |	      switch (diffFormat) {
<         fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);  |	      case Default:
<       } else {						      |	      case Normal:
<         fprintf (stdout, "%da%d\n", o, boInserts + 1);	      |	        if (1 < nInserts) {
<       }							      |	          fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n)
<       for (unsigned l = boInserts; l < n; l += 1) {	      |	        } else {
<         fprintf (stdout, "> %s", lines[1][l].line->c_str ()); |	          fprintf (stdout, "%da%d\n", o, boInserts + 1);
< 							      >	        }
< 							      >	        for (unsigned l = boInserts; l < n; l += 1) {
< 							      >	          fprintf (stdout, "> %s", lines[1][l].line->c_str ()
< 							      >	        }
< 							      >	        break;
< 							      >	      case Unified:
< 							      >	        for (unsigned l = boInserts; l < n; l += 1) {
< 							      >	          fprintf (stdout, "+%s", lines[1][l].line->c_str ())
< 							      >	        }
< 							      >	        break;
<       }								      }
<     }								    }
< 
<     // When we get here, we're dealing with matching lines.	    // When we get here, we're dealing with matching lines.
< 
<     o += 1;						      |	    switch (diffFormat) {
<     n += 1;						      |	    case Default:
<   }							      |	    case Normal:
< }							      |	      break;
< 							      |	    case Unified:
< void pass6r () {					      |	      fprintf (stdout, " %s", lines[0][o].line->c_str ());
< }							      |	      break;
< 							      <
< void pass6s () {					      <
< }							      <
< 							      <
< void pass6u ()						      <
< {							      <
<   if (0 < optVerbose) {					      <
---
>     // are inserts.                                           <
>                                                               <
>     unsigned boInserts;                                       <
>     for (boInserts = n;                                       <
>          n < lines[1].size () && lines[1][n].l == ~0;         <
>          n += 1                                               <
>         )                                                     <
>     {}                                                        <
>                                                               <
>     // We've got deleted line(s) from boDeletes .. o.         <
>     // We've got deleted line(s) from boInserts .. n.         <
>                                                               <
>     unsigned nDeletes = o - boDeletes;                        <
>     unsigned nInserts = n - boInserts;                        <
>                                                               <
>     // We've got...                                                 // We've got...
>                                                               | 
>     if (nDeletes && nInserts) {                                     if (nDeletes && nInserts) {
>                                                               | 
>       // ... deletes and inserts.                                     // ... deletes and inserts.
>                                                               | 
>       if (1 < nDeletes && 1 < nInserts) {                     |       switch (diffFormat) {
>         fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, b |       case Default:
>       } else if (1 < nDeletes) {                              |       case Normal:
>         fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boIn |         if (1 < nDeletes && 1 < nInserts) {
>       } else if (1 < nInserts) {                              |           fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o,
>         fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInser |         } else if (1 < nDeletes) {
>       }                                                       |           fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, bo
>       for (unsigned l = boDeletes; l < o; l += 1) {           |         } else if (1 < nInserts) {
>         fprintf (stdout, "< %s", lines[0][l].line->c_str ()); |           fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boIns
>       }                                                       |         } 
>       fprintf (stderr, "---\n");                              |         for (unsigned l = boDeletes; l < o; l += 1) {
>       for (unsigned l = boInserts; l < n; l += 1) {           |           fprintf (stdout, "< %s", lines[0][l].line->c_str ()
>         fprintf (stdout, "> %s", lines[1][l].line->c_str ()); |         }
>       }                                                       |         fprintf (stderr, "---\n");
>                                                               >         for (unsigned l = boInserts; l < n; l += 1) {
>                                                               >           fprintf (stdout, "> %s", lines[1][l].line->c_str ()
>                                                               >         }
>                                                               >         break;
>                                                               > 
>                                                               >       case Unified:
>                                                               >         for (unsigned l = boDeletes; l < o; l += 1) {
>                                                               >           fprintf (stdout, "-%s", lines[0][l].line->c_str ())
>                                                               >         }
>                                                               >         for (unsigned l = boInserts; l < n; l += 1) {
>                                                               >           fprintf (stdout, "+%s", lines[1][l].line->c_str ())
>                                                               >         }
>                                                               >         break;
>                                                               >       }
>     } else if (nDeletes) {                                          } else if (nDeletes) {
>                                                               | 
>       //  ... just deletes.                                           //  ... just deletes.
>                                                               | 
>       if (1 < nDeletes) {                                     |       switch (diffFormat) {
>         fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);  |       case Default:
>       } else {                                                |       case Normal:
>         fprintf (stdout, "%dd%d\n", boDeletes + 1, n);        |         if (1 < nDeletes) {
>       }                                                       |           fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n)
>       for (unsigned l = boDeletes; l < o; l += 1) {           |         } else {
>         fprintf (stdout, "< %s", lines[0][l].line->c_str ()); |           fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
>       }                                                       |         }
>                                                               >         for (unsigned l = boDeletes; l < o; l += 1) {
>                                                               >           fprintf (stdout, "< %s", lines[0][l].line->c_str ()
>                                                               >         }
>                                                               >         break;
>                                                               >       case Unified:
>                                                               >         for (unsigned l = boDeletes; l < o; l += 1) {
>                                                               >           fprintf (stdout, "-%s", lines[0][l].line->c_str ())
>                                                               >         }
>                                                               >         break;
>                                                               >       }
>     } else if (nInserts) {                                          } else if (nInserts) {
>                                                               | 
>       //  ... just inserts.                                           //  ... just inserts.
>                                                               | 
>       if (1 < nInserts) {                                     |       switch (diffFormat) {
>         fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);  |       case Default:
>       } else {                                                |       case Normal:
>         fprintf (stdout, "%da%d\n", o, boInserts + 1);        |         if (1 < nInserts) {
>       }                                                       |           fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n)
>       for (unsigned l = boInserts; l < n; l += 1) {           |         } else {
>         fprintf (stdout, "> %s", lines[1][l].line->c_str ()); |           fprintf (stdout, "%da%d\n", o, boInserts + 1);
>       }                                                       |         }
>                                                               >         for (unsigned l = boInserts; l < n; l += 1) {
>                                                               >           fprintf (stdout, "> %s", lines[1][l].line->c_str ()
>                                                               >         }
>                                                               >         break;
>                                                               >       case Unified:
>                                                               >         for (unsigned l = boInserts; l < n; l += 1) {
>                                                               >           fprintf (stdout, "+%s", lines[1][l].line->c_str ())
>                                                               >         }
>                                                               >         break;
>                                                               >       }
>                                                               >     }
>                                                               > 
>                                                               >     // When we get here, we're dealing with matching lines.
>                                                               > 
>                                                               >     switch (diffFormat) {
>                                                               >     case Default:
>                                                               >     case Normal:
>                                                               >       break;
>                                                               >     case Unified:
>                                                               >       fprintf (stdout, " %s", lines[0][o].line->c_str ());
>                                                               >       break;
>     }                                                               }
>                                                               <
>     // When we get here, we're dealing with matching lines.   <
>                                                               <
>     o += 1;                                                   <
>     n += 1;                                                   <
>   }                                                           <
> }                                                             <
>                                                               <
> void pass6r () {                                              <
> }                                                             <
>                                                               <
> void pass6s () {                                              <
> }                                                             <
>                                                               <
> void pass6u ()                                                <
> {                                                             <
>   if (0 < optVerbose) {                                       <
970,975c997,1002
<   }							      <
< 							      <
<   nMatchedLines = 0;					      <
< 							      <
<   // Write the header.					      <
< 							      <
---
>   }                                                           <
>                                                               <
>   nMatchedLines = 0;                                          <
>                                                               <
>   // Write the header.                                        <
>                                                               <
979,984c1006,1011
< 							      <
<   // Starting at the top of both files,...		      <
< 							      <
<   unsigned o = 0;					      <
<   unsigned n = 0;					      <
< 							      <
---
>                                                               <
>   // Starting at the top of both files,...                    <
>                                                               <
>   unsigned o = 0;                                             <
>   unsigned n = 0;                                             <
>                                                               <
986c1013
< 							      <
---
>                                                               <
988,996c1015,1023
<     // are deletes.					      <
< 							      <
<     unsigned boDeletes;					      <
<     for (boDeletes = o;					      <
<          o < lines[0].size () && lines[0][o].l == ~0;	      <
<          o += 1						      <
<         )						      <
<     {}							      <
< 							      <
---
>     // are deletes.                                           <
>                                                               <
>     unsigned boDeletes;                                       <
>     for (boDeletes = o;                                       <
>          o < lines[0].size () && lines[0][o].l == ~0;         <
>          o += 1                                               <
>         )                                                     <
>     {}                                                        <
>                                                               <
998,1019c1025,1046
<     // are inserts.					      <
< 							      <
<     unsigned boInserts;					      <
<     for (boInserts = n;					      <
<          n < lines[1].size () && lines[1][n].l == ~0;	      <
<          n += 1						      <
<         )						      <
<     {}							      <
< 							      <
<     // We've got deleted line(s) from boDeletes .. o.	      <
<     // We've got deleted line(s) from boInserts .. n.	      <
< 							      <
<     unsigned nDeletes = o - boDeletes;			      <
<     unsigned nInserts = n - boInserts;			      <
< 							      <
<     // We've got...					      <
< 							      <
<     if (nDeletes && nInserts) {				      <
< 							      <
<       // ... deletes and inserts.			      <
< 							      <
<       for (unsigned l = boDeletes; l < o; l += 1) {	      <
---
>     // are inserts.                                           <
>                                                               <
>     unsigned boInserts;                                       <
>     for (boInserts = n;                                       <
>          n < lines[1].size () && lines[1][n].l == ~0;         <
>          n += 1                                               <
>         )                                                     <
>     {}                                                        <
>                                                               <
>     // We've got deleted line(s) from boDeletes .. o.         <
>     // We've got deleted line(s) from boInserts .. n.         <
>                                                               <
>     unsigned nDeletes = o - boDeletes;                        <
>     unsigned nInserts = n - boInserts;                        <
>                                                               <
>     // We've got...                                           <
>                                                               <
>     if (nDeletes && nInserts) {                               <
>                                                               <
>       // ... deletes and inserts.                             <
>                                                               <
>       for (unsigned l = boDeletes; l < o; l += 1) {           <
1021,1022c1048,1049
<       }							      <
<       for (unsigned l = boInserts; l < n; l += 1) {	      <
---
>       }                                                       <
>       for (unsigned l = boInserts; l < n; l += 1) {           <
1024,1029c1051,1056
<       }							      <
<     } else if (nDeletes) {				      <
< 							      <
<       //  ... just deletes.				      <
< 							      <
<       for (unsigned l = boDeletes; l < o; l += 1) {	      <
---
>       }                                                       <
>     } else if (nDeletes) {                                    <
>                                                               <
>       //  ... just deletes.                                   <
>                                                               <
>       for (unsigned l = boDeletes; l < o; l += 1) {           <
1031,1036c1058,1063
<       }							      <
<     } else if (nInserts) {				      <
< 							      <
<       //  ... just inserts.				      <
< 							      <
<       for (unsigned l = boInserts; l < n; l += 1) {	      <
---
>       }                                                       <
>     } else if (nInserts) {                                    <
>                                                               <
>       //  ... just inserts.                                   <
>                                                               <
>       for (unsigned l = boInserts; l < n; l += 1) {           <
1038,1040c1065,1067
<       }							      <
<     }								    }
< 							      <
---
>       }                                                       <
>     }                                                         <
>                                                               <
1042c1069
< 							      <
---
>                                                               <
1044,1047c1071,1074
<     o += 1;							    o += 1;
<     n += 1;							    n += 1;
<   }								  }
< }								}
---
>     o += 1;                                                         o += 1;
>     n += 1;                                                         n += 1;
>   }                                                               }
> }                                                               }
# ../sdiff -y dif.5.cpp dif.6.cpp >& dif.5.6.diff-y.test
# dif.5.6.diff-y ---------------------------------------------------------------
1,807c1,761
< #include <algorithm>						#include <algorithm>
< using std::find;						using std::find;
< #include <string>						#include <string>
< using std::string;						using std::string;
< #include <list>							#include <list>
< using std::list;						using std::list;
< #include <map>							#include <map>
< using std::map;							using std::map;
< #include <vector>						#include <vector>
< using std::vector;						using std::vector;
< #include <stdio.h>						#include <stdio.h>
< 
< enum DiffFormat {						enum DiffFormat {
<   Default,							  Default,
< 
<   Context,							  Context,
<   EdScript,							  EdScript,
<   IfThenElse,							  IfThenElse,
<   Normal,							  Normal,
<   RCS,								  RCS,
<   SideBySide,							  SideBySide,
<   Unified							  Unified
< };								};
< 
< DiffFormat diffFormat = Context;				DiffFormat diffFormat = Context;
< unsigned optCopyContext = 3;					unsigned optCopyContext = 3;
< 
< int optVerbose = 1;						int optVerbose = 1;
< 
< struct Line : public string {					struct Line : public string {
<   Line (string _text) :						  Line (string _text) :
<     string (_text)						    string (_text)
<   {								  {
<   }								  }
<   ~Line () {							  ~Line () {
<     copies[0].erase (copies[0].begin (), copies[0].end ());	    copies[0].erase (copies[0].begin (), copies[0].end ());
<     copies[1].erase (copies[1].begin (), copies[1].end ());	    copies[1].erase (copies[1].begin (), copies[1].end ());
<   }								  }
<   void Dump (FILE *out) {					  void Dump (FILE *out) {
<     fprintf (out, "{{ ");					    fprintf (out, "{{ ");
<     for (list<unsigned>::iterator i = copies[0].begin (); i !	    for (list<unsigned>::iterator i = copies[0].begin (); i !
<       fprintf (out, "%u ", *i);					      fprintf (out, "%u ", *i);
<     }								    }
<     fprintf (out, "},{ ");					    fprintf (out, "},{ ");
<     for (list<unsigned>::iterator i = copies[1].begin (); i !	    for (list<unsigned>::iterator i = copies[1].begin (); i !
<       fprintf (out, "%u ", *i);					      fprintf (out, "%u ", *i);
<     }								    }
<     fprintf (out, "}}\t%s", c_str ());				    fprintf (out, "}}\t%s", c_str ());
<   }								  }
<   list<unsigned> copies[2];					  list<unsigned> copies[2];
< };								};
< 
< struct LinePtr {						struct LinePtr {
<   LinePtr (Line *_line) :					  LinePtr (Line *_line) :
<     line (_line),						    line (_line),
<     l (~0u)							    l (~0u)
<   {								  {
<   }								  }
<   void Dump (FILE *out) {					  void Dump (FILE *out) {
<     fprintf (out, "[%d] ", l);					    fprintf (out, "[%d] ", l);
<     line->Dump (out);						    line->Dump (out);
<   }								  }
<   Line *line;							  Line *line;
<   unsigned l;							  unsigned l;
< };								};
< 
< typedef map<string, Line *> MapStringToLinePtr;			typedef map<string, Line *> MapStringToLinePtr;
< typedef vector<LinePtr> VectorLinePtr;				typedef vector<LinePtr> VectorLinePtr;
< 
< // Our name.							// Our name.
< 
< char *ARGV0 = "dif3";						char *ARGV0 = "dif3";
< 
< // The 'symbol' (line) table.					// The 'symbol' (line) table.
< 
< MapStringToLinePtr table;					MapStringToLinePtr table;
< 
< // The names of the 2 files to be diff'd.			// The names of the 2 files to be diff'd.
< 
< char const *files[2] = { 0, 0 };				char const *files[2] = { 0, 0 };
< 
< // The lines of the 2 files to be diff'd.			// The lines of the 2 files to be diff'd.
< 
< VectorLinePtr lines[2];						VectorLinePtr lines[2];
< 
< // Miscellaneous metrics.					// Miscellaneous metrics.
< 
< unsigned nTotalMatchedBlocks = 0;				unsigned nTotalMatchedBlocks = 0;
< unsigned nMatchedBlocks = 0;					unsigned nMatchedBlocks = 0;
< unsigned nTotalMatchedLines = 0;				unsigned nTotalMatchedLines = 0;
< unsigned nMatchedLines = 0;					unsigned nMatchedLines = 0;
< 
< void pass1 ();							void pass1 ();
< void pass2 ();							void pass2 ();
< void pass3 ();							void pass3 ();
< void pass4 ();							void pass4 ();
< void pass5 ();							void pass5 ();
< void pass6 ();							void pass6 ();
< 
< int main (int argc, char *argv[])				int main (int argc, char *argv[])
< {								{
<   // Read the old [0] file, and the new [1] file.		  // Read the old [0] file, and the new [1] file.
< 
<   for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {	  for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
<     files[n] = argv[a];						    files[n] = argv[a];
< 
<     if (FILE *f = fopen (files[n], "r")) {			    if (FILE *f = fopen (files[n], "r")) {
<       if (0 < optVerbose) {					      if (0 < optVerbose) {
<         fprintf (stderr, "# Reading %s...", files[n]);		        fprintf (stderr, "# Reading %s...", files[n]);
<       }								      }
< 
<       char buffer[1024];					      char buffer[1024];
<       unsigned nUniq = 0;					      unsigned nUniq = 0;
< 
<       while (fgets (buffer, sizeof (buffer), f)) {		      while (fgets (buffer, sizeof (buffer), f)) {
<         string text (buffer);					        string text (buffer);
< 
<         Line *line = table[text];				        Line *line = table[text];
< 
<         if (!line) {						        if (!line) {
<           table[text] = line = new Line (text);			          table[text] = line = new Line (text);
<           nUniq += 1;						          nUniq += 1;
<         }							        }
<         line->copies[n].push_back (lines[n].size ());		        line->copies[n].push_back (lines[n].size ());
<         lines[n].push_back (line);				        lines[n].push_back (line);
<       }								      }
< 
<       if (0 < optVerbose) {					      if (0 < optVerbose) {
<         fprintf (stderr, " %u lines, %u unique.\n", lines[n].	        fprintf (stderr, " %u lines, %u unique.\n", lines[n].
<       }								      }
<     } else {							    } else {
<       fprintf (stderr, "%s: Unable to open %s!  Exiting....\n	      fprintf (stderr, "%s: Unable to open %s!  Exiting....\n
<       perror (ARGV0);						      perror (ARGV0);
<       exit (1);							      exit (1);
<     }								    }
<   }								  }
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Total unique lines = %d\n", table.siz	    fprintf (stderr, "# Total unique lines = %d\n", table.siz
<   }								  }
< 
<   // map<int, int> counts;					  // map<int, int> counts;
<   // for (MapStringToLinePtr::iterator i = table.begin (); i 	  // for (MapStringToLinePtr::iterator i = table.begin (); i 
<   //   Line *l = i->second;					  //   Line *l = i->second;
<   //   counts[l->counts[0].size () + l->counts[1].size ()] +=	  //   counts[l->counts[0].size () + l->counts[1].size ()] +=
<   // }								  // }
<   // for (map<int, int>::iterator i = counts.begin (); i != c	  // for (map<int, int>::iterator i = counts.begin (); i != c
<   //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s	  //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s
<   // }								  // }
< 
<   pass1 ();							  pass1 ();
<   pass2 ();							  pass2 ();
<   pass3 ();							  pass3 ();
<   pass4 ();							  pass4 ();
<   pass5 ();							  pass5 ();
<   pass6 ();							  pass6 ();
< 
<   return 0;							  return 0;
< }								}
< 
< // Perform pass #1, in which we find all explicit matches amo	// Perform pass #1, in which we find all explicit matches amo
< // unique lines.  For every unique line that appears the same	// unique lines.  For every unique line that appears the same
< // of times in both files, we declare the lines to match.	// of times in both files, we declare the lines to match.
< 
< void pass1 ()							void pass1 ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass 1 (finding matches amongst uniqu	    fprintf (stderr, "# Pass 1 (finding matches amongst uniqu
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   for (MapStringToLinePtr::iterator i = table.begin (); i != 	  for (MapStringToLinePtr::iterator i = table.begin (); i != 
<     Line *l = i->second;					    Line *l = i->second;
< 
<     // If the number of old and new lines match, then we decl	    // If the number of old and new lines match, then we decl
<     // they are (all) the same line.  Note, it isn't possible	    // they are (all) the same line.  Note, it isn't possible
<     // numbers of both files to be 0.				    // numbers of both files to be 0.
< 
<     // (In the original algorithm, we only recognized a match	    // (In the original algorithm, we only recognized a match
<     // if there was exactly 1 copy for each file.)		    // if there was exactly 1 copy for each file.)
< 
<     if (l->copies[0].size () == l->copies[1].size ()) {		    if (l->copies[0].size () == l->copies[1].size ()) {
<       nMatchedLines += 1;					      nMatchedLines += 1;
< 
<       // For each matched line in the new file, mark it with 	      // For each matched line in the new file, mark it with 
<       // corresponding line (number) in the old file.		      // corresponding line (number) in the old file.
< 
<       while (!l->copies[0].empty ()) {				      while (!l->copies[0].empty ()) {
<         unsigned o = l->copies[0].front ();			        unsigned o = l->copies[0].front ();
<         unsigned n = l->copies[1].front ();			        unsigned n = l->copies[1].front ();
< 
<         // Match up the pair.					        // Match up the pair.
< 
<         lines[0][o].l = n;					        lines[0][o].l = n;
<         lines[1][n].l = o;					        lines[1][n].l = o;
< 
<         // Remove the matched line numbers from the lists.	        // Remove the matched line numbers from the lists.
< 
<         l->copies[0].pop_front ();				        l->copies[0].pop_front ();
<         l->copies[1].pop_front ();				        l->copies[1].pop_front ();
<       }								      }
<     }								    }
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, " found %u matched lines (%u total).\n",	    fprintf (stderr, " found %u matched lines (%u total).\n",
< 
<     if (1 < optVerbose) {					    if (1 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< }								}
< 
< // Perform Pass #2, in which we attempt to 'widen' blocks of 	// Perform Pass #2, in which we attempt to 'widen' blocks of 
< // lines, by appending lines which are the same in both files	// lines, by appending lines which are the same in both files
< 
< void pass2 ()							void pass2 ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #2 (spreading matches down)...")	    fprintf (stderr, "# Pass #2 (spreading matches down)...")
<   }								  }
< 
<   nMatchedBlocks = 0;						  nMatchedBlocks = 0;
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Starting at the top of the old file,...			  // Starting at the top of the old file,...
< 
<   for (unsigned o = 0; o < lines[0].size (); o += 1) {		  for (unsigned o = 0; o < lines[0].size (); o += 1) {
< 
<     // ... skip any currently unmatched lines...		    // ... skip any currently unmatched lines...
< 
<     if (lines[0][o].l == ~0) {					    if (lines[0][o].l == ~0) {
<       continue;							      continue;
<     }								    }
< 
<     // ... until we find an [already] matched line.  Then, sk	    // ... until we find an [already] matched line.  Then, sk
<     // the set of 1 or more matched lines, until we reach any	    // the set of 1 or more matched lines, until we reach any
<     // following, still-unmatched line.				    // following, still-unmatched line.
< 
<     unsigned n;							    unsigned n;
<     do {							    do {
<       n = lines[0][o].l + 1;					      n = lines[0][o].l + 1;
<       o += 1;							      o += 1;
<     } while (o < lines[0].size () && lines[0][o].l != ~0);	    } while (o < lines[0].size () && lines[0][o].l != ~0);
< 
<     // Now, o - 1 is the line number of the last matched old 	    // Now, o - 1 is the line number of the last matched old 
<     // n - 1 is the line number of the last matched new line.	    // n - 1 is the line number of the last matched new line.
<     // to add new old and new lines, if they match.		    // to add new old and new lines, if they match.
< 
<     // Finally, attempt to add unmatched lines to the preceed	    // Finally, attempt to add unmatched lines to the preceed
<     // matched set.						    // matched set.
< 
<     for (; o < lines[0].size () && lines[0][o].l == ~0; o += 	    for (; o < lines[0].size () && lines[0][o].l == ~0; o += 
< 
<       // If the [next] pair of old and new lines aren't the s	      // If the [next] pair of old and new lines aren't the s
< 
<       if (lines[0][o].line != lines[1][n].line) {		      if (lines[0][o].line != lines[1][n].line) {
<         break;							        break;
<       }								      }
< 
<       // Match up the pair.					      // Match up the pair.
< 
<       lines[0][o].l = n;					      lines[0][o].l = n;
<       lines[1][n].l = o;					      lines[1][n].l = o;
< 
<       // Remove the matched line numbers form the lists.	      // Remove the matched line numbers form the lists.
< 
<       Line *line = lines[0][o].line;				      Line *line = lines[0][o].line;
<       list<unsigned> &oldCopies = line->copies[0];		      list<unsigned> &oldCopies = line->copies[0];
<       list<unsigned>::iterator oL = find (oldCopies.begin (),	      list<unsigned>::iterator oL = find (oldCopies.begin (),
<       if (oL != oldCopies.end ()) {				      if (oL != oldCopies.end ()) {
<         oldCopies.erase (oL);					        oldCopies.erase (oL);
<       }								      }
<       list<unsigned> &newCopies = line->copies[0];		      list<unsigned> &newCopies = line->copies[0];
<       list<unsigned>::iterator nL = find (newCopies.begin (),	      list<unsigned>::iterator nL = find (newCopies.begin (),
<       if (nL != newCopies.end ()) {				      if (nL != newCopies.end ()) {
<         newCopies.erase (nL);					        newCopies.erase (nL);
<       }								      }
< 
<       nMatchedLines += 1;					      nMatchedLines += 1;
<     }								    }
<     nMatchedBlocks += 1;					    nMatchedBlocks += 1;
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
<   nTotalMatchedBlocks += nMatchedBlocks;			  nTotalMatchedBlocks += nMatchedBlocks;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr,						    fprintf (stderr,
<              " found %u/%u matched lines/blocks (%u/%u totals	             " found %u/%u matched lines/blocks (%u/%u totals
<              nMatchedLines,					             nMatchedLines,
<              nMatchedBlocks,					             nMatchedBlocks,
<              nTotalMatchedLines,				             nTotalMatchedLines,
<              nTotalMatchedBlocks				             nTotalMatchedBlocks
<             );							            );
<     if (1 < optVerbose) {					    if (1 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< }								}
< 
< // Perform Pass #3, in which we attempt to 'widen' blocks of 	// Perform Pass #3, in which we attempt to 'widen' blocks of 
< // lines, by prepending lines which are the same in both file	// lines, by prepending lines which are the same in both file
< 
< void pass3 ()							void pass3 ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #3 (spreading matches up)...");	    fprintf (stderr, "# Pass #3 (spreading matches up)...");
<   }								  }
< 
<   nMatchedBlocks = 0;						  nMatchedBlocks = 0;
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Starting at the bottom of the old file,...			  // Starting at the bottom of the old file,...
< 
<   for (int o = lines[0].size (); 0 <= o; o -= 1) {		  for (int o = lines[0].size (); 0 <= o; o -= 1) {
< 
<     // ... skip any currently unmatched lines...		    // ... skip any currently unmatched lines...
< 
<     if (lines[0][o].l == ~0) {					    if (lines[0][o].l == ~0) {
<       continue;							      continue;
<     }								    }
< 
<     // ... until we find an [already] matched line.  Then, sk	    // ... until we find an [already] matched line.  Then, sk
<     // the set of 1 or more matched lines, until we reach any	    // the set of 1 or more matched lines, until we reach any
<     // following, still-unmatched line.				    // following, still-unmatched line.
< 
<     unsigned n;							    unsigned n;
<     do {							    do {
<       n = lines[0][o].l - 1;					      n = lines[0][o].l - 1;
<       o -= 1;							      o -= 1;
<     } while (0 <= o && lines[0][o].l != ~0);			    } while (0 <= o && lines[0][o].l != ~0);
< 
<     // Now, o + 1 is the line number of the last matched old 	    // Now, o + 1 is the line number of the last matched old 
<     // n + 1 is the line number of the last matched new line.	    // n + 1 is the line number of the last matched new line.
<     // to add new old and new lines, if they match.		    // to add new old and new lines, if they match.
< 
<     // Finally, attempt to add unmatched lines to the preceed	    // Finally, attempt to add unmatched lines to the preceed
<     // matched set.						    // matched set.
< 
<     for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {	    for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
< 
<       // If the [next] pair of old and new lines aren't the s	      // If the [next] pair of old and new lines aren't the s
< 
<       if (lines[0][o].line != lines[1][n].line) {		      if (lines[0][o].line != lines[1][n].line) {
<         break;							        break;
<       }								      }
< 
<       // Match up the pair.					      // Match up the pair.
< 
<       lines[0][o].l = n;					      lines[0][o].l = n;
<       lines[1][n].l = o;					      lines[1][n].l = o;
< 
<       // Remove the matched line numbers form the lists.	      // Remove the matched line numbers form the lists.
< 
<       Line *line = lines[0][o].line;				      Line *line = lines[0][o].line;
<       list<unsigned> &oldCopies = line->copies[0];		      list<unsigned> &oldCopies = line->copies[0];
<       list<unsigned>::iterator oL = find (oldCopies.begin (),	      list<unsigned>::iterator oL = find (oldCopies.begin (),
<       if (oL != oldCopies.end ()) {				      if (oL != oldCopies.end ()) {
<         oldCopies.erase (oL);					        oldCopies.erase (oL);
<       }								      }
<       list<unsigned> &newCopies = line->copies[0];		      list<unsigned> &newCopies = line->copies[0];
<       list<unsigned>::iterator nL = find (newCopies.begin (),	      list<unsigned>::iterator nL = find (newCopies.begin (),
<       if (nL != newCopies.end ()) {				      if (nL != newCopies.end ()) {
<         newCopies.erase (nL);					        newCopies.erase (nL);
<       }								      }
< 
<       nMatchedLines += 1;					      nMatchedLines += 1;
<     }								    }
<     nMatchedBlocks += 1;					    nMatchedBlocks += 1;
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr,						    fprintf (stderr,
<              " found %u/%u matched lines/blocks (%u/%u totals	             " found %u/%u matched lines/blocks (%u/%u totals
<              nMatchedLines,					             nMatchedLines,
<              nMatchedBlocks,					             nMatchedBlocks,
<              nTotalMatchedLines,				             nTotalMatchedLines,
<              nTotalMatchedBlocks				             nTotalMatchedBlocks
<             );							            );
< 
<     if (1 < optVerbose) {					    if (1 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< }								}
< 
< // Perform pass #4, in which we find any remaining matches am	// Perform pass #4, in which we find any remaining matches am
< // unique lines.  For every unique line that has more than 1 	// unique lines.  For every unique line that has more than 1 
< // both files, we declare the copies to match.			// both files, we declare the copies to match.
< 
< void pass4 ()							void pass4 ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass 4 (finding remaining matches amo	    fprintf (stderr, "# Pass 4 (finding remaining matches amo
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   for (MapStringToLinePtr::iterator i = table.begin (); i != 	  for (MapStringToLinePtr::iterator i = table.begin (); i != 
<     Line *l = i->second;					    Line *l = i->second;
< 
<     // If there's more than 1 matching old and new lines, the	    // If there's more than 1 matching old and new lines, the
<     // declare that each pair are (all) the same line.		    // declare that each pair are (all) the same line.
< 
<     // (In the original algorithm, we only recognized a match	    // (In the original algorithm, we only recognized a match
<     // if there was exactly 1 copy for each file.)		    // if there was exactly 1 copy for each file.)
< 
<     while (0 < l->copies[0].size () && 0 < l->copies[1].size 	    while (0 < l->copies[0].size () && 0 < l->copies[1].size 
<       nMatchedLines += 1;					      nMatchedLines += 1;
< 
<       // For each matched line in the new file, mark it with 	      // For each matched line in the new file, mark it with 
<       // corresponding line (number) in the old file.		      // corresponding line (number) in the old file.
< 
<       unsigned o = l->copies[0].front ();			      unsigned o = l->copies[0].front ();
<       unsigned n = l->copies[1].front ();			      unsigned n = l->copies[1].front ();
< 
<       // Match up the pair.					      // Match up the pair.
< 
<       lines[0][o].l = n;					      lines[0][o].l = n;
<       lines[1][n].l = o;					      lines[1][n].l = o;
< 
<       // Remove the matched line numbers from the lists.	      // Remove the matched line numbers from the lists.
< 
<       l->copies[0].pop_front ();				      l->copies[0].pop_front ();
<       l->copies[1].pop_front ();				      l->copies[1].pop_front ();
<     }								    }
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, " found %u matched lines (%u total).\n",	    fprintf (stderr, " found %u matched lines (%u total).\n",
< 
<     if (1 < optVerbose) {					    if (1 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< }								}
< 
< // Perform Pass #5, in which we look for blocks which match, 	// Perform Pass #5, in which we look for blocks which match, 
< // the result of a move (their not in their original position	// the result of a move (their not in their original position
< // these, we'll unmatch the blocks, turning them into a delet	// these, we'll unmatch the blocks, turning them into a delet
< // insert.							// insert.
< 
< void pass5 ()							void pass5 ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #5 (unmatching block moves)...\n	    fprintf (stderr, "# Pass #5 (unmatching block moves)...\n
<   }								  }
< 
<   nMatchedBlocks = 0;						  nMatchedBlocks = 0;
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Starting at the top of both files,...			  // Starting at the top of both files,...
< 
<   unsigned o = 0;						  unsigned o = 0;
<   unsigned n = 0;						  unsigned n = 0;
< 
<   while (o < lines[0].size () || n < lines[1].size ()) {	  while (o < lines[0].size () || n < lines[1].size ()) {
< 
<     // Skip any unmatched lines at this point in the old file	    // Skip any unmatched lines at this point in the old file
<     // are deletes.						    // are deletes.
< 
<     //    Old     New						    //    Old     New
<     //   +---+							    //   +---+
<     // 0 | a |							    // 0 | a |
<     //   +---+   +---+						    //   +---+   +---+
<     //         0 | b |						    //         0 | b |
<     //   +---+   +---+						    //   +---+   +---+
<     // 1 | c | 1 | c |						    // 1 | c | 1 | c |
<     //   +---+   +---+						    //   +---+   +---+
<     //         2 | z |						    //         2 | z |
<     //   +---+   +---+						    //   +---+   +---+
<     // 2 | d | 3 | d |						    // 2 | d | 3 | d |
<     //   +---+   +---+						    //   +---+   +---+
< 
<     while (o < lines[0].size () && lines[0][o].l == ~0) {	    while (o < lines[0].size () && lines[0][o].l == ~0) {
<       o += 1;							      o += 1;
<     }								    }
< 
<     // Skip any unmatched lines at this point in the new file	    // Skip any unmatched lines at this point in the new file
<     // are inserts.						    // are inserts.
< 
<     while (n < lines[1].size () && lines[1][n].l == ~0) {	    while (n < lines[1].size () && lines[1][n].l == ~0) {
<       n += 1;							      n += 1;
<     }								    }
< 
<     // When we get here, we know that we're dealing with matc	    // When we get here, we know that we're dealing with matc
<     // lines (or the end of one or both files).  We're done w	    // lines (or the end of one or both files).  We're done w
<     // pass, if we've reached the end of either file.		    // pass, if we've reached the end of either file.
< 
<     if (lines[0].size () <= o || lines[1].size () <= n) {	    if (lines[0].size () <= o || lines[1].size () <= n) {
<       break;							      break;
<     }								    }
< 
<     // We now know that we've got a pair of matching lines, t	    // We now know that we've got a pair of matching lines, t
<     // of a matching block.  If the new file's line number is	    // of a matching block.  If the new file's line number is
<     // expect, then the matched pair is unmoved, and we can s	    // expect, then the matched pair is unmoved, and we can s
<     // the pair.  (If this is really the start of a block of 	    // the pair.  (If this is really the start of a block of 
<     // 1 lines, we'll handle it one pair at a time.)		    // 1 lines, we'll handle it one pair at a time.)
< 
<     if (lines[0][o].l == n) {					    if (lines[0][o].l == n) {
<       o += 1;							      o += 1;
<       n += 1;							      n += 1;
<       continue;							      continue;
<     }								    }
< 
<     // If, on the other hand, we don't expect this [new] line	    // If, on the other hand, we don't expect this [new] line
<     // then this matching block has been moved.  We need to t	    // then this matching block has been moved.  We need to t
<     // matched pair into an *unmatched* pair, one of deletes,	    // matched pair into an *unmatched* pair, one of deletes,
<     // of inserts.  First, though, we need to know how big th	    // of inserts.  First, though, we need to know how big th
<     // is, and how far it was moved....				    // is, and how far it was moved....
< 
<     // Remember where we were when we started.			    // Remember where we were when we started.
< 
<     unsigned oOld = o;						    unsigned oOld = o;
<     unsigned nOld = n;						    unsigned nOld = n;
< 
<     // Remember where the block came from.			    // Remember where the block came from.
< 
<     unsigned nNew = lines[0][o].l;				    unsigned nNew = lines[0][o].l;
< 
<     // Find the end of this matched pair.			    // Find the end of this matched pair.
< 
<     for (n = nNew; o < lines[0].size () && n < lines[1].size 	    for (n = nNew; o < lines[0].size () && n < lines[1].size 
<       if (lines[0][o].l != n) {					      if (lines[0][o].l != n) {
<         break;							        break;
<       }								      }
<     }								    }
< 
<     // When we get here:					    // When we get here:
<     // * oOld..o is the old file's block,			    // * oOld..o is the old file's block,
<     // * nNew..n is the new file's *moved* block, and		    // * nNew..n is the new file's *moved* block, and
<     // * nOld is where we originally expected the new block f	    // * nOld is where we originally expected the new block f
<  								 
<     // We can now calculate the length of the block...		    // We can now calculate the length of the block...
<     								    
<     unsigned bSize = o - oOld;  // (or n - nNew)		    unsigned bSize = o - oOld;  // (or n - nNew)
< 
<     // ... and we can calculate how far the block moved:	    // ... and we can calculate how far the block moved:
< 
<     unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;	    unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
< 
<     // The larger of the two will become our delete, and the 	    // The larger of the two will become our delete, and the 
<     // will become our insert.					    // will become our insert.
< 
<     //    Old     New						    //    Old     New
<     //   +---+   +---+						    //   +---+   +---+
<     // 0 | a | 0 | b |						    // 0 | a | 0 | b |
<     //   +---+ 1 | b |						    //   +---+ 1 | b |
<     // 1 | b |   +---+						    // 1 | b |   +---+
<     // 2 | b | 2 | a |						    // 2 | b | 2 | a |
<     //   +---+   +---+						    //   +---+   +---+
<     // 3 | c | 3 | c |						    // 3 | c | 3 | c |
<     //   +---+   +---+						    //   +---+   +---+
< 
<     // (1) Delete a@0, insert a@2, or				    // (1) Delete a@0, insert a@2, or
<     // (2) insert bb@0, delete bb@1?				    // (2) insert bb@0, delete bb@1?
< 
<     // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and	    // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and
<     // (of a) is 2-0 or 2, the size of b@0.  We choose to del	    // (of a) is 2-0 or 2, the size of b@0.  We choose to del
<     // and reinsert a@2.					    // and reinsert a@2.
< 
<     // if (bSize <= bMove) {					    // if (bSize <= bMove) {
<       for (unsigned a = oOld; a < o; a += 1) {			      for (unsigned a = oOld; a < o; a += 1) {
<         lines[0][a].l = ~0;					        lines[0][a].l = ~0;
<       }								      }
<       for (unsigned d = nNew; d < n; d += 1) {			      for (unsigned d = nNew; d < n; d += 1) {
<         lines[1][d].l = ~0;					        lines[1][d].l = ~0;
<       }								      }
<     // } else {							    // } else {
<       // for (unsigned a = oOld; a < o; a += 1) {		      // for (unsigned a = oOld; a < o; a += 1) {
<       //   lines[0][a].l = ~0;					      //   lines[0][a].l = ~0;
<       // }							      // }
<       // for (unsigned d = nNew; d < n; d += 1) {		      // for (unsigned d = nNew; d < n; d += 1) {
<       //   lines[1][d].l = ~0;					      //   lines[1][d].l = ~0;
<       // }							      // }
<     // }							    // }
< 
<     // Continue from where we left off.				    // Continue from where we left off.
< 
<     n = nOld;							    n = nOld;
<   }								  }
<   nTotalMatchedLines -= nMatchedLines;				  nTotalMatchedLines -= nMatchedLines;
<   nTotalMatchedBlocks -= nMatchedBlocks;			  nTotalMatchedBlocks -= nMatchedBlocks;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr,						    fprintf (stderr,
<              " found %u/%u matched lines/blocks (%u/%u totals	             " found %u/%u matched lines/blocks (%u/%u totals
<              nMatchedLines,					             nMatchedLines,
<              nMatchedBlocks,					             nMatchedBlocks,
<              nTotalMatchedLines,				             nTotalMatchedLines,
<              nTotalMatchedBlocks				             nTotalMatchedBlocks
<             );							            );
< 
<     if (1 < optVerbose) {					    if (1 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< }								}
< 
< // Perform Pass #6, in which we create the desired output.	// Perform Pass #6, in which we create the desired output.
< 
< void pass6c ();							void pass6c ();
< void pass6e ();							void pass6e ();
< void pass6i ();							void pass6i ();
< void pass6n ();							void pass6n ();
< void pass6r ();							void pass6r ();
< void pass6s ();							void pass6s ();
< void pass6u ();							void pass6u ();
< 
< void pass6 ()							void pass6 ()
< {								{
< 
<   switch (diffFormat) {						  switch (diffFormat) {
<   case Context:							  case Context:
<     pass6c ();							    pass6c ();
<     break;							    break;
< 
<   case EdScript:						  case EdScript:
<     pass6e ();							    pass6e ();
<     break;							    break;
< 
<   case IfThenElse:						  case IfThenElse:
<     pass6i ();							    pass6i ();
<     break;							    break;
< 
<   case Normal:							  case Normal:
<     pass6n ();							    pass6n ();
<     break;							    break;
< 
<   case RCS:							  case RCS:
<     pass6r ();							    pass6r ();
<     break;							    break;
< 
<   case SideBySide:						  case SideBySide:
<     pass6s ();							    pass6s ();
<     break;							    break;
< 
<   case Unified:							  case Unified:
<     pass6u ();							    pass6u ();
<     break;							    break;
< 
<   case Default:							  case Default:
<   default:							  default:
<     pass6c ();							    pass6c ();
<     break;							    break;
<   }								  }
< }								}
< 
< template<typename T> T min (T l, T r) {				template<typename T> T min (T l, T r) {
<   if (l < r) {							  if (l < r) {
<     return l;							    return l;
<   }								  }
<   return r;							  return r;
< }								}
< 
< template<typename T> T max (T l, T r) {				template<typename T> T max (T l, T r) {
<   if (l < r) {							  if (l < r) {
<     return r;							    return r;
<   }								  }
<   return l;							  return l;
< }								}
< 
< void pass6c () {						void pass6c () {
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #6u (walking the differences)...	    fprintf (stderr, "# Pass #6u (walking the differences)...
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Write the header.						  // Write the header.
< 
<   fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:0	  fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:0
<   fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:0	  fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:0
< 
<   // Starting at the top of both files,...			  // Starting at the top of both files,...
< 
<   unsigned o = 0;						  unsigned o = 0;
<   unsigned n = 0;						  unsigned n = 0;
< 
<   while (o < lines[0].size () || n < lines[1].size ()) {	  while (o < lines[0].size () || n < lines[1].size ()) {
< 
<     // Find any unmatched lines at this point in the old file |	    // Find the bounds of the current contextual 'window'.
<     // are deletes.					      <
< 
<     unsigned boDeletes;					      |	    // If we aren't looking at a delete or an insert, we're n
<     for (boDeletes = o;					      |	    // start of a context window.
<          o < lines[0].size () && lines[0][o].l == ~0;	      <
<          o += 1						      <
<         )						      <
<     {}							      <
< 
<     // Find any unmatched lines at this point in the new file |	    if (lines[0][o].l != ~0 && lines[1][n].l != ~0) {
<     // are inserts.					      |	      o += 1;
< 							      >	      n += 1;
< 							      >	      continue;
< 							      >	    }
< 
<     unsigned boInserts;					      |	    // We're looking at at least 1 delete or insert, so a win
<     for (boInserts = n;					      |	    // begins here (or, rather, optCopyContext lines earlier)
<          n < lines[1].size () && lines[1][n].l == ~0;	      |	    
<          n += 1						      |	    int boOldWindow = max (0, int (boDeletes) - int(optCopyCo
<         )						      |	    int eoOldWindow = min (int (lines[0].size ()), int(o) + i
<     {}							      |
< 							      >	    // Look for the end of the window.
< 							      >
< 							      >	    bool widenWindow = false;
< 							      >	    do {
< 							      >
< 							      >	      // Skip over the delete(s) and/or insert(s) defining th
< 							      >	      // context.
< 							      >
< 							      >	      while (o < lines[0].size () && lines[0][o].l == ~0) {
< 							      >	        o += 1;
< 							      >	      }
< 							      >	      while (n < lines[1].size () && lines[1][n].l == ~0) {
< 							      >	        n += 1;
< 							      >	      }
< 							      >
< 							      >	      // ...  This context will end optCopyContext lines past
< 							      >	      // set of deletes or inserts we find.  However, since a
< 							      >	      // window could follow, we look 2 * optCopyContext ahea
< 							      >	      // another delete or insert.
< 							      >
< 							      >	      for (unsigned l = 0; l < (2 * optCopyContext); i += 1) 
< 							      >	        if (o < lines[0].size ()) {
< 							      >	          if (widenWindow |= lines[0][o].l == ~0) {
< 							      >	            break;
< 							      >	          }
< 							      >	          o += 1;
< 							      >	        }
< 							      >	        if (n < lines[1].size ()) {
< 							      >	          if (widenWindow |= lines[1][o].l == ~0) {
< 							      >	            break;
< 							      >	          }
< 							      >	          n += 1;
< 							      >	        }
< 							      >	      }
< 							      >	    } while (widenWindow);
< 
<     // We've got deleted line(s) from boDeletes .. o.	      |	    // We've found the end of the window.
<     // We've got deleted line(s) from boInserts .. n.	      <
< 
<     unsigned nDeletes = o - boDeletes;			      |	    int boNewWindow = max (0, int (boInserts) - int (optCopyC
<     unsigned nInserts = n - boInserts;			      |	    int eoNewWindow = min (int (lines[1].size ()), int(n) + i
< 							      >
< 							      >	    // Now, reset ourselves to the start of the window, and w
< 							      >	    // produce the output.  We'll walk it twice, first for th
< 							      >	    // file part, then for the new file part.
< 							      >
< 							      >	    fprintf (stdout, "***************\n");
< 							      >	    fprintf (stdout, "*** %d,%d ****\n", boOldWindow + 1, eoO
< 
<     // Have we got anything?				      |	    o = boOldWindow;
< 							      >	    n = boNewWindow;
< 
<     if (nDeletes || nInserts) {				      |	    while (o < eoOldWindow && n < eoNewWindow) {
<       int boOldWindow = max (0, int (boDeletes) - int(optCopy |
<       int eoOldWindow = min (int (lines[0].size ()), int(o) + |	      // Find any unmatched lines at this point in the old fi
< 							      |	      // are deletes.
<       int boNewWindow = max (0, int (boInserts) - int (optCop |
<       int eoNewWindow = min (int (lines[1].size ()), int(n) + |	      unsigned boDeletes = o;
< 							      |	      while (o < eoOldWindow && lines[0][o].l == ~0) {
<       fprintf (stdout, "***************\n*** %d,%d ****", boO |	        o += 1;
---
> #include <algorithm>                                            #include <algorithm>
> using std::find;                                                using std::find;
> #include <string>                                               #include <string>
> using std::string;                                              using std::string;
> #include <list>                                                 #include <list>
> using std::list;                                                using std::list;
> #include <map>                                                  #include <map>
> using std::map;                                                 using std::map;
> #include <vector>                                               #include <vector>
> using std::vector;                                              using std::vector;
> #include <stdio.h>                                              #include <stdio.h>
>                                                                 
> enum DiffFormat {                                               enum DiffFormat {
>   Default,                                                        Default,
>                                                                 
>   Context,                                                        Context,
>   EdScript,                                                       EdScript,
>   IfThenElse,                                                     IfThenElse,
>   Normal,                                                         Normal,
>   RCS,                                                            RCS,
>   SideBySide,                                                     SideBySide,
>   Unified                                                         Unified
> };                                                              };
>                                                                 
> DiffFormat diffFormat = Context;                                DiffFormat diffFormat = Context;
> unsigned optCopyContext = 3;                                    unsigned optCopyContext = 3;
>                                                                 
> int optVerbose = 1;                                             int optVerbose = 1;
>                                                                 
> struct Line : public string {                                   struct Line : public string {
>   Line (string _text) :                                           Line (string _text) :
>     string (_text)                                                  string (_text)
>   {                                                               {
>   }                                                               }
>   ~Line () {                                                      ~Line () {
>     copies[0].erase (copies[0].begin (), copies[0].end ());         copies[0].erase (copies[0].begin (), copies[0].end ());
>     copies[1].erase (copies[1].begin (), copies[1].end ());         copies[1].erase (copies[1].begin (), copies[1].end ());
>   }                                                               }
>   void Dump (FILE *out) {                                         void Dump (FILE *out) {
>     fprintf (out, "{{ ");                                           fprintf (out, "{{ ");
>     for (list<unsigned>::iterator i = copies[0].begin (); i !       for (list<unsigned>::iterator i = copies[0].begin (); i !
>       fprintf (out, "%u ", *i);                                       fprintf (out, "%u ", *i);
>     }                                                               }
>     fprintf (out, "},{ ");                                          fprintf (out, "},{ ");
>     for (list<unsigned>::iterator i = copies[1].begin (); i !       for (list<unsigned>::iterator i = copies[1].begin (); i !
>       fprintf (out, "%u ", *i);                                       fprintf (out, "%u ", *i);
>     }                                                               }
>     fprintf (out, "}}\t%s", c_str ());                              fprintf (out, "}}\t%s", c_str ());
>   }                                                               }
>   list<unsigned> copies[2];                                       list<unsigned> copies[2];
> };                                                              };
>                                                                 
> struct LinePtr {                                                struct LinePtr {
>   LinePtr (Line *_line) :                                         LinePtr (Line *_line) :
>     line (_line),                                                   line (_line),
>     l (~0u)                                                         l (~0u)
>   {                                                               {
>   }                                                               }
>   void Dump (FILE *out) {                                         void Dump (FILE *out) {
>     fprintf (out, "[%d] ", l);                                      fprintf (out, "[%d] ", l);
>     line->Dump (out);                                               line->Dump (out);
>   }                                                               }
>   Line *line;                                                     Line *line;
>   unsigned l;                                                     unsigned l;
> };                                                              };
>                                                                 
> typedef map<string, Line *> MapStringToLinePtr;                 typedef map<string, Line *> MapStringToLinePtr;
> typedef vector<LinePtr> VectorLinePtr;                          typedef vector<LinePtr> VectorLinePtr;
>                                                                 
> // Our name.                                                    // Our name.
>                                                                 
> char *ARGV0 = "dif3";                                           char *ARGV0 = "dif3";
>                                                                 
> // The 'symbol' (line) table.                                   // The 'symbol' (line) table.
>                                                                 
> MapStringToLinePtr table;                                       MapStringToLinePtr table;
>                                                                 
> // The names of the 2 files to be diff'd.                       // The names of the 2 files to be diff'd.
>                                                                 
> char const *files[2] = { 0, 0 };                                char const *files[2] = { 0, 0 };
>                                                                 
> // The lines of the 2 files to be diff'd.                       // The lines of the 2 files to be diff'd.
>                                                                 
> VectorLinePtr lines[2];                                         VectorLinePtr lines[2];
>                                                                 
> // Miscellaneous metrics.                                       // Miscellaneous metrics.
>                                                                 
> unsigned nTotalMatchedBlocks = 0;                               unsigned nTotalMatchedBlocks = 0;
> unsigned nMatchedBlocks = 0;                                    unsigned nMatchedBlocks = 0;
> unsigned nTotalMatchedLines = 0;                                unsigned nTotalMatchedLines = 0;
> unsigned nMatchedLines = 0;                                     unsigned nMatchedLines = 0;
>                                                                 
> void pass1 ();                                                  void pass1 ();
> void pass2 ();                                                  void pass2 ();
> void pass3 ();                                                  void pass3 ();
> void pass4 ();                                                  void pass4 ();
> void pass5 ();                                                  void pass5 ();
> void pass6 ();                                                  void pass6 ();
>                                                                 
> int main (int argc, char *argv[])                               int main (int argc, char *argv[])
> {                                                               {
>   // Read the old [0] file, and the new [1] file.                 // Read the old [0] file, and the new [1] file.
>                                                                 
>   for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {     for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
>     files[n] = argv[a];                                             files[n] = argv[a];
>                                                                 
>     if (FILE *f = fopen (files[n], "r")) {                          if (FILE *f = fopen (files[n], "r")) {
>       if (0 < optVerbose) {                                           if (0 < optVerbose) {
>         fprintf (stderr, "# Reading %s...", files[n]);                  fprintf (stderr, "# Reading %s...", files[n]);
>       }                                                               }
>                                                                 
>       char buffer[1024];                                              char buffer[1024];
>       unsigned nUniq = 0;                                             unsigned nUniq = 0;
>                                                                 
>       while (fgets (buffer, sizeof (buffer), f)) {                    while (fgets (buffer, sizeof (buffer), f)) {
>         string text (buffer);                                           string text (buffer);
>                                                                 
>         Line *line = table[text];                                       Line *line = table[text];
>                                                                 
>         if (!line) {                                                    if (!line) {
>           table[text] = line = new Line (text);                           table[text] = line = new Line (text);
>           nUniq += 1;                                                     nUniq += 1;
>         }                                                               }
>         line->copies[n].push_back (lines[n].size ());                   line->copies[n].push_back (lines[n].size ());
>         lines[n].push_back (line);                                      lines[n].push_back (line);
>       }                                                               }
>                                                                 
>       if (0 < optVerbose) {                                           if (0 < optVerbose) {
>         fprintf (stderr, " %u lines, %u unique.\n", lines[n].           fprintf (stderr, " %u lines, %u unique.\n", lines[n].
>       }                                                               }
>     } else {                                                        } else {
>       fprintf (stderr, "%s: Unable to open %s!  Exiting....\n         fprintf (stderr, "%s: Unable to open %s!  Exiting....\n
>       perror (ARGV0);                                                 perror (ARGV0);
>       exit (1);                                                       exit (1);
>     }                                                               }
>   }                                                               }
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Total unique lines = %d\n", table.siz       fprintf (stderr, "# Total unique lines = %d\n", table.siz
>   }                                                               }
>                                                                 
>   // map<int, int> counts;                                        // map<int, int> counts;
>   // for (MapStringToLinePtr::iterator i = table.begin (); i      // for (MapStringToLinePtr::iterator i = table.begin (); i 
>   //   Line *l = i->second;                                       //   Line *l = i->second;
>   //   counts[l->counts[0].size () + l->counts[1].size ()] +=     //   counts[l->counts[0].size () + l->counts[1].size ()] +=
>   // }                                                            // }
>   // for (map<int, int>::iterator i = counts.begin (); i != c     // for (map<int, int>::iterator i = counts.begin (); i != c
>   //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s     //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s
>   // }                                                            // }
>                                                                 
>   pass1 ();                                                       pass1 ();
>   pass2 ();                                                       pass2 ();
>   pass3 ();                                                       pass3 ();
>   pass4 ();                                                       pass4 ();
>   pass5 ();                                                       pass5 ();
>   pass6 ();                                                       pass6 ();
>                                                                 
>   return 0;                                                       return 0;
> }                                                               }
>                                                                 
> // Perform pass #1, in which we find all explicit matches amo   // Perform pass #1, in which we find all explicit matches amo
> // unique lines.  For every unique line that appears the same   // unique lines.  For every unique line that appears the same
> // of times in both files, we declare the lines to match.       // of times in both files, we declare the lines to match.
>                                                                 
> void pass1 ()                                                   void pass1 ()
> {                                                               {
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Pass 1 (finding matches amongst uniqu       fprintf (stderr, "# Pass 1 (finding matches amongst uniqu
>   }                                                               }
>                                                                 
>   nMatchedLines = 0;                                              nMatchedLines = 0;
>                                                                 
>   for (MapStringToLinePtr::iterator i = table.begin (); i !=      for (MapStringToLinePtr::iterator i = table.begin (); i != 
>     Line *l = i->second;                                            Line *l = i->second;
>                                                                 
>     // If the number of old and new lines match, then we decl       // If the number of old and new lines match, then we decl
>     // they are (all) the same line.  Note, it isn't possible       // they are (all) the same line.  Note, it isn't possible
>     // numbers of both files to be 0.                               // numbers of both files to be 0.
>                                                                 
>     // (In the original algorithm, we only recognized a match       // (In the original algorithm, we only recognized a match
>     // if there was exactly 1 copy for each file.)                  // if there was exactly 1 copy for each file.)
>                                                                 
>     if (l->copies[0].size () == l->copies[1].size ()) {             if (l->copies[0].size () == l->copies[1].size ()) {
>       nMatchedLines += 1;                                             nMatchedLines += 1;
>                                                                 
>       // For each matched line in the new file, mark it with          // For each matched line in the new file, mark it with 
>       // corresponding line (number) in the old file.                 // corresponding line (number) in the old file.
>                                                                 
>       while (!l->copies[0].empty ()) {                                while (!l->copies[0].empty ()) {
>         unsigned o = l->copies[0].front ();                             unsigned o = l->copies[0].front ();
>         unsigned n = l->copies[1].front ();                             unsigned n = l->copies[1].front ();
>                                                                 
>         // Match up the pair.                                           // Match up the pair.
>                                                                 
>         lines[0][o].l = n;                                              lines[0][o].l = n;
>         lines[1][n].l = o;                                              lines[1][n].l = o;
>                                                                 
>         // Remove the matched line numbers from the lists.              // Remove the matched line numbers from the lists.
>                                                                 
>         l->copies[0].pop_front ();                                      l->copies[0].pop_front ();
>         l->copies[1].pop_front ();                                      l->copies[1].pop_front ();
>       }                                                               }
>     }                                                               }
>   }                                                               }
>   nTotalMatchedLines += nMatchedLines;                            nTotalMatchedLines += nMatchedLines;
>                                                                 
>   // Let's see the intermediate results.                          // Let's see the intermediate results.
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, " found %u matched lines (%u total).\n",       fprintf (stderr, " found %u matched lines (%u total).\n",
>                                                                 
>     if (1 < optVerbose) {                                           if (1 < optVerbose) {
>       for (int f = 0; f < 2; f += 1) {                                for (int f = 0; f < 2; f += 1) {
>         fprintf (stderr, "# file #%d\n", f + 1);                        fprintf (stderr, "# file #%d\n", f + 1);
>         for (int l = 0; l < lines[f].size (); l += 1) {                 for (int l = 0; l < lines[f].size (); l += 1) {
>           fprintf (stderr, "#   [%d] ", l);                               fprintf (stderr, "#   [%d] ", l);
>           lines[f][l].Dump (stderr);                                      lines[f][l].Dump (stderr);
>         }                                                               }
>       }                                                               }
>     }                                                               }
>   }                                                               }
> }                                                               }
>                                                                 
> // Perform Pass #2, in which we attempt to 'widen' blocks of    // Perform Pass #2, in which we attempt to 'widen' blocks of 
> // lines, by appending lines which are the same in both files   // lines, by appending lines which are the same in both files
>                                                                 
> void pass2 ()                                                   void pass2 ()
> {                                                               {
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Pass #2 (spreading matches down)...")       fprintf (stderr, "# Pass #2 (spreading matches down)...")
>   }                                                               }
>                                                                 
>   nMatchedBlocks = 0;                                             nMatchedBlocks = 0;
>   nMatchedLines = 0;                                              nMatchedLines = 0;
>                                                                 
>   // Starting at the top of the old file,...                      // Starting at the top of the old file,...
>                                                                 
>   for (unsigned o = 0; o < lines[0].size (); o += 1) {            for (unsigned o = 0; o < lines[0].size (); o += 1) {
>                                                                 
>     // ... skip any currently unmatched lines...                    // ... skip any currently unmatched lines...
>                                                                 
>     if (lines[0][o].l == ~0) {                                      if (lines[0][o].l == ~0) {
>       continue;                                                       continue;
>     }                                                               }
>                                                                 
>     // ... until we find an [already] matched line.  Then, sk       // ... until we find an [already] matched line.  Then, sk
>     // the set of 1 or more matched lines, until we reach any       // the set of 1 or more matched lines, until we reach any
>     // following, still-unmatched line.                             // following, still-unmatched line.
>                                                                 
>     unsigned n;                                                     unsigned n;
>     do {                                                            do {
>       n = lines[0][o].l + 1;                                          n = lines[0][o].l + 1;
>       o += 1;                                                         o += 1;
>     } while (o < lines[0].size () && lines[0][o].l != ~0);          } while (o < lines[0].size () && lines[0][o].l != ~0);
>                                                                 
>     // Now, o - 1 is the line number of the last matched old        // Now, o - 1 is the line number of the last matched old 
>     // n - 1 is the line number of the last matched new line.       // n - 1 is the line number of the last matched new line.
>     // to add new old and new lines, if they match.                 // to add new old and new lines, if they match.
>                                                                 
>     // Finally, attempt to add unmatched lines to the preceed       // Finally, attempt to add unmatched lines to the preceed
>     // matched set.                                                 // matched set.
>                                                                 
>     for (; o < lines[0].size () && lines[0][o].l == ~0; o +=        for (; o < lines[0].size () && lines[0][o].l == ~0; o += 
>                                                                 
>       // If the [next] pair of old and new lines aren't the s         // If the [next] pair of old and new lines aren't the s
>                                                                 
>       if (lines[0][o].line != lines[1][n].line) {                     if (lines[0][o].line != lines[1][n].line) {
>         break;                                                          break;
>       }                                                               }
>                                                                 
>       // Match up the pair.                                           // Match up the pair.
>                                                                 
>       lines[0][o].l = n;                                              lines[0][o].l = n;
>       lines[1][n].l = o;                                              lines[1][n].l = o;
>                                                                 
>       // Remove the matched line numbers form the lists.              // Remove the matched line numbers form the lists.
>                                                                 
>       Line *line = lines[0][o].line;                                  Line *line = lines[0][o].line;
>       list<unsigned> &oldCopies = line->copies[0];                    list<unsigned> &oldCopies = line->copies[0];
>       list<unsigned>::iterator oL = find (oldCopies.begin (),         list<unsigned>::iterator oL = find (oldCopies.begin (),
>       if (oL != oldCopies.end ()) {                                   if (oL != oldCopies.end ()) {
>         oldCopies.erase (oL);                                           oldCopies.erase (oL);
>       }                                                               }
>       list<unsigned> &newCopies = line->copies[0];                    list<unsigned> &newCopies = line->copies[0];
>       list<unsigned>::iterator nL = find (newCopies.begin (),         list<unsigned>::iterator nL = find (newCopies.begin (),
>       if (nL != newCopies.end ()) {                                   if (nL != newCopies.end ()) {
>         newCopies.erase (nL);                                           newCopies.erase (nL);
>       }                                                               }
>                                                                 
>       nMatchedLines += 1;                                             nMatchedLines += 1;
>     }                                                               }
>     nMatchedBlocks += 1;                                            nMatchedBlocks += 1;
>   }                                                               }
>   nTotalMatchedLines += nMatchedLines;                            nTotalMatchedLines += nMatchedLines;
>   nTotalMatchedBlocks += nMatchedBlocks;                          nTotalMatchedBlocks += nMatchedBlocks;
>                                                                 
>   // Let's see the intermediate results.                          // Let's see the intermediate results.
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr,                                                fprintf (stderr,
>              " found %u/%u matched lines/blocks (%u/%u totals                " found %u/%u matched lines/blocks (%u/%u totals
>              nMatchedLines,                                                  nMatchedLines,
>              nMatchedBlocks,                                                 nMatchedBlocks,
>              nTotalMatchedLines,                                             nTotalMatchedLines,
>              nTotalMatchedBlocks                                             nTotalMatchedBlocks
>             );                                                              );
>     if (1 < optVerbose) {                                           if (1 < optVerbose) {
>       for (int f = 0; f < 2; f += 1) {                                for (int f = 0; f < 2; f += 1) {
>         fprintf (stderr, "# file #%d\n", f + 1);                        fprintf (stderr, "# file #%d\n", f + 1);
>         for (int l = 0; l < lines[f].size (); l += 1) {                 for (int l = 0; l < lines[f].size (); l += 1) {
>           fprintf (stderr, "#   [%d] ", l);                               fprintf (stderr, "#   [%d] ", l);
>           lines[f][l].Dump (stderr);                                      lines[f][l].Dump (stderr);
>         }                                                               }
>       }                                                               }
>     }                                                               }
>   }                                                               }
> }                                                               }
>                                                                 
> // Perform Pass #3, in which we attempt to 'widen' blocks of    // Perform Pass #3, in which we attempt to 'widen' blocks of 
> // lines, by prepending lines which are the same in both file   // lines, by prepending lines which are the same in both file
>                                                                 
> void pass3 ()                                                   void pass3 ()
> {                                                               {
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Pass #3 (spreading matches up)...");        fprintf (stderr, "# Pass #3 (spreading matches up)...");
>   }                                                               }
>                                                                 
>   nMatchedBlocks = 0;                                             nMatchedBlocks = 0;
>   nMatchedLines = 0;                                              nMatchedLines = 0;
>                                                                 
>   // Starting at the bottom of the old file,...                   // Starting at the bottom of the old file,...
>                                                                 
>   for (int o = lines[0].size (); 0 <= o; o -= 1) {                for (int o = lines[0].size (); 0 <= o; o -= 1) {
>                                                                 
>     // ... skip any currently unmatched lines...                    // ... skip any currently unmatched lines...
>                                                                 
>     if (lines[0][o].l == ~0) {                                      if (lines[0][o].l == ~0) {
>       continue;                                                       continue;
>     }                                                               }
>                                                                 
>     // ... until we find an [already] matched line.  Then, sk       // ... until we find an [already] matched line.  Then, sk
>     // the set of 1 or more matched lines, until we reach any       // the set of 1 or more matched lines, until we reach any
>     // following, still-unmatched line.                             // following, still-unmatched line.
>                                                                 
>     unsigned n;                                                     unsigned n;
>     do {                                                            do {
>       n = lines[0][o].l - 1;                                          n = lines[0][o].l - 1;
>       o -= 1;                                                         o -= 1;
>     } while (0 <= o && lines[0][o].l != ~0);                        } while (0 <= o && lines[0][o].l != ~0);
>                                                                 
>     // Now, o + 1 is the line number of the last matched old        // Now, o + 1 is the line number of the last matched old 
>     // n + 1 is the line number of the last matched new line.       // n + 1 is the line number of the last matched new line.
>     // to add new old and new lines, if they match.                 // to add new old and new lines, if they match.
>                                                                 
>     // Finally, attempt to add unmatched lines to the preceed       // Finally, attempt to add unmatched lines to the preceed
>     // matched set.                                                 // matched set.
>                                                                 
>     for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {         for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
>                                                                 
>       // If the [next] pair of old and new lines aren't the s         // If the [next] pair of old and new lines aren't the s
>                                                                 
>       if (lines[0][o].line != lines[1][n].line) {                     if (lines[0][o].line != lines[1][n].line) {
>         break;                                                          break;
>       }                                                               }
>                                                                 
>       // Match up the pair.                                           // Match up the pair.
>                                                                 
>       lines[0][o].l = n;                                              lines[0][o].l = n;
>       lines[1][n].l = o;                                              lines[1][n].l = o;
>                                                                 
>       // Remove the matched line numbers form the lists.              // Remove the matched line numbers form the lists.
>                                                                 
>       Line *line = lines[0][o].line;                                  Line *line = lines[0][o].line;
>       list<unsigned> &oldCopies = line->copies[0];                    list<unsigned> &oldCopies = line->copies[0];
>       list<unsigned>::iterator oL = find (oldCopies.begin (),         list<unsigned>::iterator oL = find (oldCopies.begin (),
>       if (oL != oldCopies.end ()) {                                   if (oL != oldCopies.end ()) {
>         oldCopies.erase (oL);                                           oldCopies.erase (oL);
>       }                                                               }
>       list<unsigned> &newCopies = line->copies[0];                    list<unsigned> &newCopies = line->copies[0];
>       list<unsigned>::iterator nL = find (newCopies.begin (),         list<unsigned>::iterator nL = find (newCopies.begin (),
>       if (nL != newCopies.end ()) {                                   if (nL != newCopies.end ()) {
>         newCopies.erase (nL);                                           newCopies.erase (nL);
>       }                                                               }
>                                                                 
>       nMatchedLines += 1;                                             nMatchedLines += 1;
>     }                                                               }
>     nMatchedBlocks += 1;                                            nMatchedBlocks += 1;
>   }                                                               }
>   nTotalMatchedLines += nMatchedLines;                            nTotalMatchedLines += nMatchedLines;
>                                                                 
>   // Let's see the intermediate results.                          // Let's see the intermediate results.
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr,                                                fprintf (stderr,
>              " found %u/%u matched lines/blocks (%u/%u totals                " found %u/%u matched lines/blocks (%u/%u totals
>              nMatchedLines,                                                  nMatchedLines,
>              nMatchedBlocks,                                                 nMatchedBlocks,
>              nTotalMatchedLines,                                             nTotalMatchedLines,
>              nTotalMatchedBlocks                                             nTotalMatchedBlocks
>             );                                                              );
>                                                                 
>     if (1 < optVerbose) {                                           if (1 < optVerbose) {
>       for (int f = 0; f < 2; f += 1) {                                for (int f = 0; f < 2; f += 1) {
>         fprintf (stderr, "# file #%d\n", f + 1);                        fprintf (stderr, "# file #%d\n", f + 1);
>         for (int l = 0; l < lines[f].size (); l += 1) {                 for (int l = 0; l < lines[f].size (); l += 1) {
>           fprintf (stderr, "#   [%d] ", l);                               fprintf (stderr, "#   [%d] ", l);
>           lines[f][l].Dump (stderr);                                      lines[f][l].Dump (stderr);
>         }                                                               }
>       }                                                               }
>     }                                                               }
>   }                                                               }
> }                                                               }
>                                                                 
> // Perform pass #4, in which we find any remaining matches am   // Perform pass #4, in which we find any remaining matches am
> // unique lines.  For every unique line that has more than 1    // unique lines.  For every unique line that has more than 1 
> // both files, we declare the copies to match.                  // both files, we declare the copies to match.
>                                                                 
> void pass4 ()                                                   void pass4 ()
> {                                                               {
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Pass 4 (finding remaining matches amo       fprintf (stderr, "# Pass 4 (finding remaining matches amo
>   }                                                               }
>                                                                 
>   nMatchedLines = 0;                                              nMatchedLines = 0;
>                                                                 
>   for (MapStringToLinePtr::iterator i = table.begin (); i !=      for (MapStringToLinePtr::iterator i = table.begin (); i != 
>     Line *l = i->second;                                            Line *l = i->second;
>                                                                 
>     // If there's more than 1 matching old and new lines, the       // If there's more than 1 matching old and new lines, the
>     // declare that each pair are (all) the same line.              // declare that each pair are (all) the same line.
>                                                                 
>     // (In the original algorithm, we only recognized a match       // (In the original algorithm, we only recognized a match
>     // if there was exactly 1 copy for each file.)                  // if there was exactly 1 copy for each file.)
>                                                                 
>     while (0 < l->copies[0].size () && 0 < l->copies[1].size        while (0 < l->copies[0].size () && 0 < l->copies[1].size 
>       nMatchedLines += 1;                                             nMatchedLines += 1;
>                                                                 
>       // For each matched line in the new file, mark it with          // For each matched line in the new file, mark it with 
>       // corresponding line (number) in the old file.                 // corresponding line (number) in the old file.
>                                                                 
>       unsigned o = l->copies[0].front ();                             unsigned o = l->copies[0].front ();
>       unsigned n = l->copies[1].front ();                             unsigned n = l->copies[1].front ();
>                                                                 
>       // Match up the pair.                                           // Match up the pair.
>                                                                 
>       lines[0][o].l = n;                                              lines[0][o].l = n;
>       lines[1][n].l = o;                                              lines[1][n].l = o;
>                                                                 
>       // Remove the matched line numbers from the lists.              // Remove the matched line numbers from the lists.
>                                                                 
>       l->copies[0].pop_front ();                                      l->copies[0].pop_front ();
>       l->copies[1].pop_front ();                                      l->copies[1].pop_front ();
>     }                                                               }
>   }                                                               }
>   nTotalMatchedLines += nMatchedLines;                            nTotalMatchedLines += nMatchedLines;
>                                                                 
>   // Let's see the intermediate results.                          // Let's see the intermediate results.
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, " found %u matched lines (%u total).\n",       fprintf (stderr, " found %u matched lines (%u total).\n",
>                                                                 
>     if (1 < optVerbose) {                                           if (1 < optVerbose) {
>       for (int f = 0; f < 2; f += 1) {                                for (int f = 0; f < 2; f += 1) {
>         fprintf (stderr, "# file #%d\n", f + 1);                        fprintf (stderr, "# file #%d\n", f + 1);
>         for (int l = 0; l < lines[f].size (); l += 1) {                 for (int l = 0; l < lines[f].size (); l += 1) {
>           fprintf (stderr, "#   [%d] ", l);                               fprintf (stderr, "#   [%d] ", l);
>           lines[f][l].Dump (stderr);                                      lines[f][l].Dump (stderr);
>         }                                                               }
>       }                                                               }
>     }                                                               }
>   }                                                               }
> }                                                               }
>                                                                 
> // Perform Pass #5, in which we look for blocks which match,    // Perform Pass #5, in which we look for blocks which match, 
> // the result of a move (their not in their original position   // the result of a move (their not in their original position
> // these, we'll unmatch the blocks, turning them into a delet   // these, we'll unmatch the blocks, turning them into a delet
> // insert.                                                      // insert.
>                                                                 
> void pass5 ()                                                   void pass5 ()
> {                                                               {
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Pass #5 (unmatching block moves)...\n       fprintf (stderr, "# Pass #5 (unmatching block moves)...\n
>   }                                                               }
>                                                                 
>   nMatchedBlocks = 0;                                             nMatchedBlocks = 0;
>   nMatchedLines = 0;                                              nMatchedLines = 0;
>                                                                 
>   // Starting at the top of both files,...                        // Starting at the top of both files,...
>                                                                 
>   unsigned o = 0;                                                 unsigned o = 0;
>   unsigned n = 0;                                                 unsigned n = 0;
>                                                                 
>   while (o < lines[0].size () || n < lines[1].size ()) {          while (o < lines[0].size () || n < lines[1].size ()) {
>                                                                 
>     // Skip any unmatched lines at this point in the old file       // Skip any unmatched lines at this point in the old file
>     // are deletes.                                                 // are deletes.
>                                                                 
>     //    Old     New                                               //    Old     New
>     //   +---+                                                      //   +---+
>     // 0 | a |                                                      // 0 | a |
>     //   +---+   +---+                                              //   +---+   +---+
>     //         0 | b |                                              //         0 | b |
>     //   +---+   +---+                                              //   +---+   +---+
>     // 1 | c | 1 | c |                                              // 1 | c | 1 | c |
>     //   +---+   +---+                                              //   +---+   +---+
>     //         2 | z |                                              //         2 | z |
>     //   +---+   +---+                                              //   +---+   +---+
>     // 2 | d | 3 | d |                                              // 2 | d | 3 | d |
>     //   +---+   +---+                                              //   +---+   +---+
>                                                                 
>     while (o < lines[0].size () && lines[0][o].l == ~0) {           while (o < lines[0].size () && lines[0][o].l == ~0) {
>       o += 1;                                                         o += 1;
>     }                                                               }
>                                                                 
>     // Skip any unmatched lines at this point in the new file       // Skip any unmatched lines at this point in the new file
>     // are inserts.                                                 // are inserts.
>                                                                 
>     while (n < lines[1].size () && lines[1][n].l == ~0) {           while (n < lines[1].size () && lines[1][n].l == ~0) {
>       n += 1;                                                         n += 1;
>     }                                                               }
>                                                                 
>     // When we get here, we know that we're dealing with matc       // When we get here, we know that we're dealing with matc
>     // lines (or the end of one or both files).  We're done w       // lines (or the end of one or both files).  We're done w
>     // pass, if we've reached the end of either file.               // pass, if we've reached the end of either file.
>                                                                 
>     if (lines[0].size () <= o || lines[1].size () <= n) {           if (lines[0].size () <= o || lines[1].size () <= n) {
>       break;                                                          break;
>     }                                                               }
>                                                                 
>     // We now know that we've got a pair of matching lines, t       // We now know that we've got a pair of matching lines, t
>     // of a matching block.  If the new file's line number is       // of a matching block.  If the new file's line number is
>     // expect, then the matched pair is unmoved, and we can s       // expect, then the matched pair is unmoved, and we can s
>     // the pair.  (If this is really the start of a block of        // the pair.  (If this is really the start of a block of 
>     // 1 lines, we'll handle it one pair at a time.)                // 1 lines, we'll handle it one pair at a time.)
>                                                                 
>     if (lines[0][o].l == n) {                                       if (lines[0][o].l == n) {
>       o += 1;                                                         o += 1;
>       n += 1;                                                         n += 1;
>       continue;                                                       continue;
>     }                                                               }
>                                                                 
>     // If, on the other hand, we don't expect this [new] line       // If, on the other hand, we don't expect this [new] line
>     // then this matching block has been moved.  We need to t       // then this matching block has been moved.  We need to t
>     // matched pair into an *unmatched* pair, one of deletes,       // matched pair into an *unmatched* pair, one of deletes,
>     // of inserts.  First, though, we need to know how big th       // of inserts.  First, though, we need to know how big th
>     // is, and how far it was moved....                             // is, and how far it was moved....
>                                                                 
>     // Remember where we were when we started.                      // Remember where we were when we started.
>                                                                 
>     unsigned oOld = o;                                              unsigned oOld = o;
>     unsigned nOld = n;                                              unsigned nOld = n;
>                                                                 
>     // Remember where the block came from.                          // Remember where the block came from.
>                                                                 
>     unsigned nNew = lines[0][o].l;                                  unsigned nNew = lines[0][o].l;
>                                                                 
>     // Find the end of this matched pair.                           // Find the end of this matched pair.
>                                                                 
>     for (n = nNew; o < lines[0].size () && n < lines[1].size        for (n = nNew; o < lines[0].size () && n < lines[1].size 
>       if (lines[0][o].l != n) {                                       if (lines[0][o].l != n) {
>         break;                                                          break;
>       }                                                               }
>     }                                                               }
>                                                                 
>     // When we get here:                                            // When we get here:
>     // * oOld..o is the old file's block,                           // * oOld..o is the old file's block,
>     // * nNew..n is the new file's *moved* block, and               // * nNew..n is the new file's *moved* block, and
>     // * nOld is where we originally expected the new block f       // * nOld is where we originally expected the new block f
>                                                                  
>     // We can now calculate the length of the block...              // We can now calculate the length of the block...
>                                                                     
>     unsigned bSize = o - oOld;  // (or n - nNew)                    unsigned bSize = o - oOld;  // (or n - nNew)
>                                                                 
>     // ... and we can calculate how far the block moved:            // ... and we can calculate how far the block moved:
>                                                                 
>     unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;       unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
>                                                                 
>     // The larger of the two will become our delete, and the        // The larger of the two will become our delete, and the 
>     // will become our insert.                                      // will become our insert.
>                                                                 
>     //    Old     New                                               //    Old     New
>     //   +---+   +---+                                              //   +---+   +---+
>     // 0 | a | 0 | b |                                              // 0 | a | 0 | b |
>     //   +---+ 1 | b |                                              //   +---+ 1 | b |
>     // 1 | b |   +---+                                              // 1 | b |   +---+
>     // 2 | b | 2 | a |                                              // 2 | b | 2 | a |
>     //   +---+   +---+                                              //   +---+   +---+
>     // 3 | c | 3 | c |                                              // 3 | c | 3 | c |
>     //   +---+   +---+                                              //   +---+   +---+
>                                                                 
>     // (1) Delete a@0, insert a@2, or                               // (1) Delete a@0, insert a@2, or
>     // (2) insert bb@0, delete bb@1?                                // (2) insert bb@0, delete bb@1?
>                                                                 
>     // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and       // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and
>     // (of a) is 2-0 or 2, the size of b@0.  We choose to del       // (of a) is 2-0 or 2, the size of b@0.  We choose to del
>     // and reinsert a@2.                                            // and reinsert a@2.
>                                                                 
>     // if (bSize <= bMove) {                                        // if (bSize <= bMove) {
>       for (unsigned a = oOld; a < o; a += 1) {                        for (unsigned a = oOld; a < o; a += 1) {
>         lines[0][a].l = ~0;                                             lines[0][a].l = ~0;
>       }                                                               }
>       for (unsigned d = nNew; d < n; d += 1) {                        for (unsigned d = nNew; d < n; d += 1) {
>         lines[1][d].l = ~0;                                             lines[1][d].l = ~0;
>       }                                                               }
>     // } else {                                                     // } else {
>       // for (unsigned a = oOld; a < o; a += 1) {                     // for (unsigned a = oOld; a < o; a += 1) {
>       //   lines[0][a].l = ~0;                                        //   lines[0][a].l = ~0;
>       // }                                                            // }
>       // for (unsigned d = nNew; d < n; d += 1) {                     // for (unsigned d = nNew; d < n; d += 1) {
>       //   lines[1][d].l = ~0;                                        //   lines[1][d].l = ~0;
>       // }                                                            // }
>     // }                                                            // }
>                                                                 
>     // Continue from where we left off.                             // Continue from where we left off.
>                                                                 
>     n = nOld;                                                       n = nOld;
>   }                                                               }
>   nTotalMatchedLines -= nMatchedLines;                            nTotalMatchedLines -= nMatchedLines;
>   nTotalMatchedBlocks -= nMatchedBlocks;                          nTotalMatchedBlocks -= nMatchedBlocks;
>                                                                 
>   // Let's see the intermediate results.                          // Let's see the intermediate results.
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr,                                                fprintf (stderr,
>              " found %u/%u matched lines/blocks (%u/%u totals                " found %u/%u matched lines/blocks (%u/%u totals
>              nMatchedLines,                                                  nMatchedLines,
>              nMatchedBlocks,                                                 nMatchedBlocks,
>              nTotalMatchedLines,                                             nTotalMatchedLines,
>              nTotalMatchedBlocks                                             nTotalMatchedBlocks
>             );                                                              );
>                                                                 
>     if (1 < optVerbose) {                                           if (1 < optVerbose) {
>       for (int f = 0; f < 2; f += 1) {                                for (int f = 0; f < 2; f += 1) {
>         fprintf (stderr, "# file #%d\n", f + 1);                        fprintf (stderr, "# file #%d\n", f + 1);
>         for (int l = 0; l < lines[f].size (); l += 1) {                 for (int l = 0; l < lines[f].size (); l += 1) {
>           fprintf (stderr, "#   [%d] ", l);                               fprintf (stderr, "#   [%d] ", l);
>           lines[f][l].Dump (stderr);                                      lines[f][l].Dump (stderr);
>         }                                                               }
>       }                                                               }
>     }                                                               }
>   }                                                               }
> }                                                               }
>                                                                 
> // Perform Pass #6, in which we create the desired output.      // Perform Pass #6, in which we create the desired output.
>                                                                 
> void pass6c ();                                                 void pass6c ();
> void pass6e ();                                                 void pass6e ();
> void pass6i ();                                                 void pass6i ();
> void pass6n ();                                                 void pass6n ();
> void pass6r ();                                                 void pass6r ();
> void pass6s ();                                                 void pass6s ();
> void pass6u ();                                                 void pass6u ();
>                                                                 
> void pass6 ()                                                   void pass6 ()
> {                                                               {
>                                                                 
>   switch (diffFormat) {                                           switch (diffFormat) {
>   case Context:                                                   case Context:
>     pass6c ();                                                      pass6c ();
>     break;                                                          break;
>                                                                 
>   case EdScript:                                                  case EdScript:
>     pass6e ();                                                      pass6e ();
>     break;                                                          break;
>                                                                 
>   case IfThenElse:                                                case IfThenElse:
>     pass6i ();                                                      pass6i ();
>     break;                                                          break;
>                                                                 
>   case Normal:                                                    case Normal:
>     pass6n ();                                                      pass6n ();
>     break;                                                          break;
>                                                                 
>   case RCS:                                                       case RCS:
>     pass6r ();                                                      pass6r ();
>     break;                                                          break;
>                                                                 
>   case SideBySide:                                                case SideBySide:
>     pass6s ();                                                      pass6s ();
>     break;                                                          break;
>                                                                 
>   case Unified:                                                   case Unified:
>     pass6u ();                                                      pass6u ();
>     break;                                                          break;
>                                                                 
>   case Default:                                                   case Default:
>   default:                                                        default:
>     pass6c ();                                                      pass6c ();
>     break;                                                          break;
>   }                                                               }
> }                                                               }
>                                                                 
> template<typename T> T min (T l, T r) {                         template<typename T> T min (T l, T r) {
>   if (l < r) {                                                    if (l < r) {
>     return l;                                                       return l;
>   }                                                               }
>   return r;                                                       return r;
> }                                                               }
>                                                                 
> template<typename T> T max (T l, T r) {                         template<typename T> T max (T l, T r) {
>   if (l < r) {                                                    if (l < r) {
>     return r;                                                       return r;
>   }                                                               }
>   return l;                                                       return l;
> }                                                               }
>                                                                 
> void pass6c () {                                                void pass6c () {
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Pass #6u (walking the differences)...       fprintf (stderr, "# Pass #6u (walking the differences)...
>   }                                                               }
>                                                                 
>   nMatchedLines = 0;                                              nMatchedLines = 0;
>                                                                 
>   // Write the header.                                            // Write the header.
>                                                                 
>   fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:0     fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:0
>   fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:0     fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:0
>                                                                 
>   // Starting at the top of both files,...                        // Starting at the top of both files,...
>                                                                 
>   unsigned o = 0;                                                 unsigned o = 0;
>   unsigned n = 0;                                                 unsigned n = 0;
>                                                                 
>   while (o < lines[0].size () || n < lines[1].size ()) {          while (o < lines[0].size () || n < lines[1].size ()) {
>                                                                 
>     // Find any unmatched lines at this point in the old file |     // Find the bounds of the current contextual 'window'.
>     // are deletes.                                           <
>                                                                 
>     unsigned boDeletes;                                       |     // If we aren't looking at a delete or an insert, we're n
>     for (boDeletes = o;                                       |     // start of a context window.
>          o < lines[0].size () && lines[0][o].l == ~0;         <
>          o += 1                                               <
>         )                                                     <
>     {}                                                        <
>                                                                 
>     // Find any unmatched lines at this point in the new file |     if (lines[0][o].l != ~0 && lines[1][n].l != ~0) {
>     // are inserts.                                           |       o += 1;
>                                                               |       n += 1;
>     unsigned boInserts;                                       |       continue;
>     for (boInserts = n;                                       <
>          n < lines[1].size () && lines[1][n].l == ~0;         <
>          n += 1                                               <
>         )                                                     <
>     {}                                                        <
>                                                               <
>     // We've got deleted line(s) from boDeletes .. o.         <
>     // We've got deleted line(s) from boInserts .. n.         <
>                                                               <
>     unsigned nDeletes = o - boDeletes;                        <
>     unsigned nInserts = n - boInserts;                        <
>                                                               <
>     // Have we got anything?                                  <
>                                                               <
>     if (nDeletes || nInserts) {                               <
>       int boOldWindow = max (0, int (boDeletes) - int(optCopy <
>       int eoOldWindow = min (int (lines[0].size ()), int(o) + <
>                                                               <
>       int boNewWindow = max (0, int (boInserts) - int (optCop <
>       int eoNewWindow = min (int (lines[1].size ()), int(n) + <
>                                                               <
>       fprintf (stdout, "***************\n*** %d,%d ****", boO <
810,898c764,810
<       }								      }
< 
< 							      >	      // Find any unmatched lines at this point in the new fi
< 							      >	      // are inserts.
< 							      >
< 							      >	      unsigned boInserts = n;
< 							      >	      while (n < eoNewWindow && lines[1][n].l == ~0) {
< 							      >	        n += 1;
< 							      >	      }
< 							      >
< 							      >	      // We've got deleted line(s) from boDeletes .. o.
< 							      >	      // We've got deleted line(s) from boInserts .. n.
< 							      >
< 							      >	      unsigned nDeletes = o - boDeletes;
< 							      >	      unsigned nInserts = n - boInserts;
< 							      >
<       // We've got...						      // We've got...
< 
<       if (nDeletes && nInserts) {				      if (nDeletes && nInserts) {
< 
<         // ... deletes and inserts.				        // ... deletes and inserts.
< 
<         for (unsigned l = boDeletes; l < o; l += 1) {		        for (unsigned l = boDeletes; l < o; l += 1) {
<           fprintf (stdout, "! %s", lines[0][l].line->c_str ()	          fprintf (stdout, "! %s", lines[0][l].line->c_str ()
<         }							        }
<       } else if (nDeletes) {					      } else if (nDeletes) {
< 
<         //  ... just deletes.					        //  ... just deletes.
< 
<         for (unsigned l = boDeletes; l < o; l += 1) {		        for (unsigned l = boDeletes; l < o; l += 1) {
<           fprintf (stdout, "- %s", lines[0][l].line->c_str ()	          fprintf (stdout, "- %s", lines[0][l].line->c_str ()
<         }							        }
<       }								      }
< 
<       for (unsigned l = o; l < eoOldWindow; l += 1) {	      |	      // When we get here, we're dealing with matching lines.
<         fprintf (stdout, "  %s", lines[0][l].line->c_str ()); |
< 							      >	      fprintf (stdout, "  %s", lines[0][l].line->c_str ());
< 							      >	      o += 1;
< 							      >	      n += 1;
< 							      >	    }
< 							      >
< 							      >	    fprintf (stdout, "--- %d,%d ----\n", boNewWindow + 1, eoN
< 							      >
< 							      >	    o = boOldWindow;
< 							      >	    n = boNewWindow;
< 							      >
< 							      >	    while (o < eoOldWindow && n < eoNewWindow) {
< 							      >
< 							      >	      // Find any unmatched lines at this point in the old fi
< 							      >	      // are deletes.
< 							      >
< 							      >	      unsigned boDeletes = o;
< 							      >	      while (o < eoOldWindow && lines[0][o].l == ~0) {
< 							      >	        o += 1;
<       }								      }
<       fprintf (stdout, "--- %d,%d ----", boNewWindow, eoNewWi |
<       for (unsigned l = boNewWindow; l < boInserts; l += 1) { |	      // Find any unmatched lines at this point in the new fi
<         fprintf (stdout, "  %s", lines[1][l].line->c_str ()); |	      // are inserts.
< 							      >
< 							      >	      unsigned boInserts = n;
< 							      >	      while (n < eoNewWindow && lines[1][n].l == ~0) {
< 							      >	        n += 1;
<       }								      }
< 
< 							      >	      // We've got deleted line(s) from boDeletes .. o.
< 							      >	      // We've got deleted line(s) from boInserts .. n.
< 							      >
< 							      >	      unsigned nDeletes = o - boDeletes;
< 							      >	      unsigned nInserts = n - boInserts;
< 							      >
<       // We've got...						      // We've got...
< 
<       if (nDeletes && nInserts) {				      if (nDeletes && nInserts) {
< 
<         // ... deletes and inserts.				        // ... deletes and inserts.
< 
<         for (unsigned l = boInserts; l < n; l += 1) {		        for (unsigned l = boInserts; l < n; l += 1) {
<           fprintf (stdout, "! %s", lines[1][l].line->c_str ()	          fprintf (stdout, "! %s", lines[1][l].line->c_str ()
<         }							        }
<       } else if (nInserts) {					      } else if (nInserts) {
< 
<         //  ... just inserts.					        //  ... just inserts.
< 
<         for (unsigned l = boInserts; l < n; l += 1) {		        for (unsigned l = boInserts; l < n; l += 1) {
<           fprintf (stdout, "+ %s", lines[1][l].line->c_str ()	          fprintf (stdout, "+ %s", lines[1][l].line->c_str ()
<         }							        }
<       }								      }
< 
<       for (unsigned l = n; l < eoNewWindow; l += 1) {	      |	      // When we get here, we're dealing with matching lines.
---
>       }                                                       <
>                                                               <
>       // We've got...                                         <
>                                                               <
>       if (nDeletes && nInserts) {                             <
>                                                               <
>         // ... deletes and inserts.                           <
>                                                               <
>         for (unsigned l = boDeletes; l < o; l += 1) {         <
>           fprintf (stdout, "! %s", lines[0][l].line->c_str () <
>         }                                                     <
>       } else if (nDeletes) {                                  <
>                                                               <
>         //  ... just deletes.                                 <
>                                                               <
>         for (unsigned l = boDeletes; l < o; l += 1) {         <
>           fprintf (stdout, "- %s", lines[0][l].line->c_str () <
>         }                                                     <
>       }                                                       <
>                                                               <
>       for (unsigned l = o; l < eoOldWindow; l += 1) {         <
>         fprintf (stdout, "  %s", lines[0][l].line->c_str ()); <
>       }                                                       <
>       fprintf (stdout, "--- %d,%d ----", boNewWindow, eoNewWi <
>       for (unsigned l = boNewWindow; l < boInserts; l += 1) { <
>         fprintf (stdout, "  %s", lines[1][l].line->c_str ()); <
>       }                                                       <
>                                                               <
>       // We've got...                                         <
>                                                               <
>       if (nDeletes && nInserts) {                             <
>                                                               <
>         // ... deletes and inserts.                           <
>                                                               <
>         for (unsigned l = boInserts; l < n; l += 1) {         <
>           fprintf (stdout, "! %s", lines[1][l].line->c_str () <
>         }                                                     <
>       } else if (nInserts) {                                  <
>                                                               <
>         //  ... just inserts.                                 <
>                                                               <
>         for (unsigned l = boInserts; l < n; l += 1) {         <
>           fprintf (stdout, "+ %s", lines[1][l].line->c_str () <
>         }                                                     <
>       }                                                       <
>                                                               <
>       for (unsigned l = n; l < eoNewWindow; l += 1) {         <
900,1101c812,1166
<       }							      <
<     }							      <
< 							      <
<     // When we get here, we're dealing with matching lines.   <
< 
<     o += 1;						      |	      fprintf (stdout, "  %s", lines[1][l].line->c_str ());
<     n += 1;						      |	      o += 1;
< 							      >	      n += 1;
< 							      >	    }
<   }								  }
< }								}
< 
< void pass6e () {						void pass6e () {
< }								}
< 
< void pass6i () {						void pass6i () {
< }								}
< 
< void pass6n ()							void pass6n ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #6n (walking the differences)...	    fprintf (stderr, "# Pass #6n (walking the differences)...
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Write the header.  (None for normal.)			  // Write the header.  (None for normal.)
< 
<   // Starting at the top of both files,...			  // Starting at the top of both files,...
< 
<   unsigned o = 0;						  unsigned o = 0;
<   unsigned n = 0;						  unsigned n = 0;
< 
<   while (o < lines[0].size () || n < lines[1].size ()) {	  while (o < lines[0].size () || n < lines[1].size ()) {
< 
<     // Find any unmatched lines at this point in the old file	    // Find any unmatched lines at this point in the old file
<     // are deletes.						    // are deletes.
< 
<     unsigned boDeletes;						    unsigned boDeletes;
<     for (boDeletes = o;						    for (boDeletes = o;
<          o < lines[0].size () && lines[0][o].l == ~0;		         o < lines[0].size () && lines[0][o].l == ~0;
<          o += 1							         o += 1
<         )							        )
<     {}								    {}
< 
<     // Find any unmatched lines at this point in the new file	    // Find any unmatched lines at this point in the new file
<     // are inserts.						    // are inserts.
< 
<     unsigned boInserts;						    unsigned boInserts;
<     for (boInserts = n;						    for (boInserts = n;
<          n < lines[1].size () && lines[1][n].l == ~0;		         n < lines[1].size () && lines[1][n].l == ~0;
<          n += 1							         n += 1
<         )							        )
<     {}								    {}
< 
<     // We've got deleted line(s) from boDeletes .. o.		    // We've got deleted line(s) from boDeletes .. o.
<     // We've got deleted line(s) from boInserts .. n.		    // We've got deleted line(s) from boInserts .. n.
< 
<     unsigned nDeletes = o - boDeletes;				    unsigned nDeletes = o - boDeletes;
<     unsigned nInserts = n - boInserts;				    unsigned nInserts = n - boInserts;
< 
<     // We've got...						    // We've got...
< 
<     if (nDeletes && nInserts) {					    if (nDeletes && nInserts) {
< 
<       // ... deletes and inserts.				      // ... deletes and inserts.
< 
<       if (1 < nDeletes && 1 < nInserts) {			      if (1 < nDeletes && 1 < nInserts) {
<         fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, b	        fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, b
<       } else if (1 < nDeletes) {				      } else if (1 < nDeletes) {
<         fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boIn	        fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boIn
<       } else if (1 < nInserts) {				      } else if (1 < nInserts) {
<         fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInser	        fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInser
<       } 							      } 
<       for (unsigned l = boDeletes; l < o; l += 1) {		      for (unsigned l = boDeletes; l < o; l += 1) {
<         fprintf (stdout, "< %s", lines[0][l].line->c_str ());	        fprintf (stdout, "< %s", lines[0][l].line->c_str ());
<       }								      }
<       fprintf (stderr, "---\n");				      fprintf (stderr, "---\n");
<       for (unsigned l = boInserts; l < n; l += 1) {		      for (unsigned l = boInserts; l < n; l += 1) {
<         fprintf (stdout, "> %s", lines[1][l].line->c_str ());	        fprintf (stdout, "> %s", lines[1][l].line->c_str ());
<       }								      }
<     } else if (nDeletes) {					    } else if (nDeletes) {
< 
<       //  ... just deletes.					      //  ... just deletes.
< 
<       if (1 < nDeletes) {					      if (1 < nDeletes) {
<         fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);	        fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
<       } else {							      } else {
<         fprintf (stdout, "%dd%d\n", boDeletes + 1, n);		        fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
<       }								      }
<       for (unsigned l = boDeletes; l < o; l += 1) {		      for (unsigned l = boDeletes; l < o; l += 1) {
<         fprintf (stdout, "< %s", lines[0][l].line->c_str ());	        fprintf (stdout, "< %s", lines[0][l].line->c_str ());
<       }								      }
<     } else if (nInserts) {					    } else if (nInserts) {
< 
<       //  ... just inserts.					      //  ... just inserts.
< 
<       if (1 < nInserts) {					      if (1 < nInserts) {
<         fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);	        fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
<       } else {							      } else {
<         fprintf (stdout, "%da%d\n", o, boInserts + 1);		        fprintf (stdout, "%da%d\n", o, boInserts + 1);
<       }								      }
<       for (unsigned l = boInserts; l < n; l += 1) {		      for (unsigned l = boInserts; l < n; l += 1) {
<         fprintf (stdout, "> %s", lines[1][l].line->c_str ());	        fprintf (stdout, "> %s", lines[1][l].line->c_str ());
<       }								      }
<     }								    }
< 
<     // When we get here, we're dealing with matching lines.	    // When we get here, we're dealing with matching lines.
< 
<     o += 1;							    o += 1;
<     n += 1;							    n += 1;
<   }								  }
< }								}
< 
< void pass6r () {						void pass6r () {
< }								}
< 
< void pass6s () {						void pass6s () {
< }								}
< 
< void pass6u ()							void pass6u ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #6u (walking the differences)...	    fprintf (stderr, "# Pass #6u (walking the differences)...
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Write the header.						  // Write the header.
< 
<   fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:0	  fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:0
<   fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:0	  fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:0
<   fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), l	  fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), l
< 
<   // Starting at the top of both files,...			  // Starting at the top of both files,...
< 
<   unsigned o = 0;						  unsigned o = 0;
<   unsigned n = 0;						  unsigned n = 0;
< 
<   while (o < lines[0].size () || n < lines[1].size ()) {	  while (o < lines[0].size () || n < lines[1].size ()) {
< 
<     // Find any unmatched lines at this point in the old file	    // Find any unmatched lines at this point in the old file
<     // are deletes.						    // are deletes.
< 
<     unsigned boDeletes;						    unsigned boDeletes;
<     for (boDeletes = o;						    for (boDeletes = o;
<          o < lines[0].size () && lines[0][o].l == ~0;		         o < lines[0].size () && lines[0][o].l == ~0;
<          o += 1							         o += 1
<         )							        )
<     {}								    {}
< 
<     // Find any unmatched lines at this point in the new file	    // Find any unmatched lines at this point in the new file
<     // are inserts.						    // are inserts.
< 
<     unsigned boInserts;						    unsigned boInserts;
<     for (boInserts = n;						    for (boInserts = n;
<          n < lines[1].size () && lines[1][n].l == ~0;		         n < lines[1].size () && lines[1][n].l == ~0;
<          n += 1							         n += 1
<         )							        )
<     {}								    {}
< 
<     // We've got deleted line(s) from boDeletes .. o.		    // We've got deleted line(s) from boDeletes .. o.
<     // We've got deleted line(s) from boInserts .. n.		    // We've got deleted line(s) from boInserts .. n.
< 
<     unsigned nDeletes = o - boDeletes;				    unsigned nDeletes = o - boDeletes;
<     unsigned nInserts = n - boInserts;				    unsigned nInserts = n - boInserts;
< 
<     // We've got...						    // We've got...
< 
<     if (nDeletes && nInserts) {					    if (nDeletes && nInserts) {
< 
<       // ... deletes and inserts.				      // ... deletes and inserts.
< 
<       for (unsigned l = boDeletes; l < o; l += 1) {		      for (unsigned l = boDeletes; l < o; l += 1) {
<         fprintf (stdout, "-%s", lines[0][l].line->c_str ());	        fprintf (stdout, "-%s", lines[0][l].line->c_str ());
<       }								      }
<       for (unsigned l = boInserts; l < n; l += 1) {		      for (unsigned l = boInserts; l < n; l += 1) {
<         fprintf (stdout, "+%s", lines[1][l].line->c_str ());	        fprintf (stdout, "+%s", lines[1][l].line->c_str ());
<       }								      }
<     } else if (nDeletes) {					    } else if (nDeletes) {
< 
<       //  ... just deletes.					      //  ... just deletes.
< 
<       for (unsigned l = boDeletes; l < o; l += 1) {		      for (unsigned l = boDeletes; l < o; l += 1) {
<         fprintf (stdout, "-%s", lines[0][l].line->c_str ());	        fprintf (stdout, "-%s", lines[0][l].line->c_str ());
<       }								      }
<     } else if (nInserts) {					    } else if (nInserts) {
< 
<       //  ... just inserts.					      //  ... just inserts.
< 
<       for (unsigned l = boInserts; l < n; l += 1) {		      for (unsigned l = boInserts; l < n; l += 1) {
<         fprintf (stdout, "+%s", lines[1][l].line->c_str ());	        fprintf (stdout, "+%s", lines[1][l].line->c_str ());
<       }								      }
<     }								    }
< 
<     // When we get here, we're dealing with matching lines.	    // When we get here, we're dealing with matching lines.
< 
<     fprintf (stdout, " %s", lines[0][o].line->c_str ());	    fprintf (stdout, " %s", lines[0][o].line->c_str ());
<     o += 1;							    o += 1;
<     n += 1;							    n += 1;
<   }								  }
< }								}
---
>       }                                                       <
>     }                                                               }
>                                                               > 
>                                                               >     // We're looking at at least 1 delete or insert, so a win
>                                                               >     // begins here (or, rather, optCopyContext lines earlier)
>                                                               >     
>                                                               >     int boOldWindow = max (0, int (boDeletes) - int(optCopyCo
>                                                               >     int eoOldWindow = min (int (lines[0].size ()), int(o) + i
>                                                               > 
>                                                               >     // Look for the end of the window.
>                                                               > 
>                                                               >     bool widenWindow = false;
>                                                               >     do {
>                                                               > 
>                                                               >       // Skip over the delete(s) and/or insert(s) defining th
>                                                               >       // context.
>                                                               > 
>                                                               >       while (o < lines[0].size () && lines[0][o].l == ~0) {
>                                                               >         o += 1;
>                                                               >       }
>                                                               >       while (n < lines[1].size () && lines[1][n].l == ~0) {
>                                                               >         n += 1;
>                                                               >       }
>                                                               > 
>                                                               >       // ...  This context will end optCopyContext lines past
>                                                               >       // set of deletes or inserts we find.  However, since a
>                                                               >       // window could follow, we look 2 * optCopyContext ahea
>                                                               >       // another delete or insert.
>                                                               > 
>                                                               >       for (unsigned l = 0; l < (2 * optCopyContext); i += 1) 
>                                                               >         if (o < lines[0].size ()) {
>                                                               >           if (widenWindow |= lines[0][o].l == ~0) {
>                                                               >             break;
>                                                               >           }
>                                                               >           o += 1;
>                                                               >         }
>                                                               >         if (n < lines[1].size ()) {
>                                                               >           if (widenWindow |= lines[1][o].l == ~0) {
>                                                               >             break;
>                                                               >           }
>                                                               >           n += 1;
>                                                               >         }
>                                                               >       }
>                                                               >     } while (widenWindow);
>                                                                 
>     // When we get here, we're dealing with matching lines.   |     // We've found the end of the window.
>                                                                 
>     o += 1;                                                   |     int boNewWindow = max (0, int (boInserts) - int (optCopyC
>     n += 1;                                                   |     int eoNewWindow = min (int (lines[1].size ()), int(n) + i
>                                                               > 
>                                                               >     // Now, reset ourselves to the start of the window, and w
>                                                               >     // produce the output.  We'll walk it twice, first for th
>                                                               >     // file part, then for the new file part.
>                                                               > 
>                                                               >     fprintf (stdout, "***************\n");
>                                                               >     fprintf (stdout, "*** %d,%d ****\n", boOldWindow + 1, eoO
>                                                               > 
>                                                               >     o = boOldWindow;
>                                                               >     n = boNewWindow;
>                                                               > 
>                                                               >     while (o < eoOldWindow && n < eoNewWindow) {
>                                                               > 
>                                                               >       // Find any unmatched lines at this point in the old fi
>                                                               >       // are deletes.
>                                                               > 
>                                                               >       unsigned boDeletes = o;
>                                                               >       while (o < eoOldWindow && lines[0][o].l == ~0) {
>                                                               >         o += 1;
>                                                               >       }
>                                                               > 
>                                                               >       // Find any unmatched lines at this point in the new fi
>                                                               >       // are inserts.
>                                                               > 
>                                                               >       unsigned boInserts = n;
>                                                               >       while (n < eoNewWindow && lines[1][n].l == ~0) {
>                                                               >         n += 1;
>                                                               >       }
>                                                               > 
>                                                               >       // We've got deleted line(s) from boDeletes .. o.
>                                                               >       // We've got deleted line(s) from boInserts .. n.
>                                                               > 
>                                                               >       unsigned nDeletes = o - boDeletes;
>                                                               >       unsigned nInserts = n - boInserts;
>                                                               > 
>                                                               >       // We've got...
>                                                               > 
>                                                               >       if (nDeletes && nInserts) {
>                                                               > 
>                                                               >         // ... deletes and inserts.
>                                                               > 
>                                                               >         for (unsigned l = boDeletes; l < o; l += 1) {
>                                                               >           fprintf (stdout, "! %s", lines[0][l].line->c_str ()
>                                                               >         }
>                                                               >       } else if (nDeletes) {
>                                                               > 
>                                                               >         //  ... just deletes.
>                                                               > 
>                                                               >         for (unsigned l = boDeletes; l < o; l += 1) {
>                                                               >           fprintf (stdout, "- %s", lines[0][l].line->c_str ()
>                                                               >         }
>                                                               >       }
>                                                               > 
>                                                               >       // When we get here, we're dealing with matching lines.
>                                                               > 
>                                                               >       fprintf (stdout, "  %s", lines[0][l].line->c_str ());
>                                                               >       o += 1;
>                                                               >       n += 1;
>                                                               >     }
>                                                               > 
>                                                               >     fprintf (stdout, "--- %d,%d ----\n", boNewWindow + 1, eoN
>                                                               > 
>                                                               >     o = boOldWindow;
>                                                               >     n = boNewWindow;
>                                                               > 
>                                                               >     while (o < eoOldWindow && n < eoNewWindow) {
>                                                               > 
>                                                               >       // Find any unmatched lines at this point in the old fi
>                                                               >       // are deletes.
>                                                               > 
>                                                               >       unsigned boDeletes = o;
>                                                               >       while (o < eoOldWindow && lines[0][o].l == ~0) {
>                                                               >         o += 1;
>                                                               >       }
>                                                               > 
>                                                               >       // Find any unmatched lines at this point in the new fi
>                                                               >       // are inserts.
>                                                               > 
>                                                               >       unsigned boInserts = n;
>                                                               >       while (n < eoNewWindow && lines[1][n].l == ~0) {
>                                                               >         n += 1;
>                                                               >       }
>                                                               > 
>                                                               >       // We've got deleted line(s) from boDeletes .. o.
>                                                               >       // We've got deleted line(s) from boInserts .. n.
>                                                               > 
>                                                               >       unsigned nDeletes = o - boDeletes;
>                                                               >       unsigned nInserts = n - boInserts;
>                                                               > 
>                                                               >       // We've got...
>                                                               > 
>                                                               >       if (nDeletes && nInserts) {
>                                                               > 
>                                                               >         // ... deletes and inserts.
>                                                               > 
>                                                               >         for (unsigned l = boInserts; l < n; l += 1) {
>                                                               >           fprintf (stdout, "! %s", lines[1][l].line->c_str ()
>                                                               >         }
>                                                               >       } else if (nInserts) {
>                                                               > 
>                                                               >         //  ... just inserts.
>                                                               > 
>                                                               >         for (unsigned l = boInserts; l < n; l += 1) {
>                                                               >           fprintf (stdout, "+ %s", lines[1][l].line->c_str ()
>                                                               >         }
>                                                               >       }
>                                                               > 
>                                                               >       // When we get here, we're dealing with matching lines.
>                                                               > 
>                                                               >       fprintf (stdout, "  %s", lines[1][l].line->c_str ());
>                                                               >       o += 1;
>                                                               >       n += 1;
>                                                               >     }
>   }                                                               }
> }                                                               }
>                                                                 
> void pass6e () {                                                void pass6e () {
> }                                                               }
>                                                                 
> void pass6i () {                                                void pass6i () {
> }                                                               }
>                                                                 
> void pass6n ()                                                  void pass6n ()
> {                                                               {
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Pass #6n (walking the differences)...       fprintf (stderr, "# Pass #6n (walking the differences)...
>   }                                                               }
>                                                                 
>   nMatchedLines = 0;                                              nMatchedLines = 0;
>                                                                 
>   // Write the header.  (None for normal.)                        // Write the header.  (None for normal.)
>                                                                 
>   // Starting at the top of both files,...                        // Starting at the top of both files,...
>                                                                 
>   unsigned o = 0;                                                 unsigned o = 0;
>   unsigned n = 0;                                                 unsigned n = 0;
>                                                                 
>   while (o < lines[0].size () || n < lines[1].size ()) {          while (o < lines[0].size () || n < lines[1].size ()) {
>                                                                 
>     // Find any unmatched lines at this point in the old file       // Find any unmatched lines at this point in the old file
>     // are deletes.                                                 // are deletes.
>                                                                 
>     unsigned boDeletes;                                             unsigned boDeletes;
>     for (boDeletes = o;                                             for (boDeletes = o;
>          o < lines[0].size () && lines[0][o].l == ~0;                    o < lines[0].size () && lines[0][o].l == ~0;
>          o += 1                                                          o += 1
>         )                                                               )
>     {}                                                              {}
>                                                                 
>     // Find any unmatched lines at this point in the new file       // Find any unmatched lines at this point in the new file
>     // are inserts.                                                 // are inserts.
>                                                                 
>     unsigned boInserts;                                             unsigned boInserts;
>     for (boInserts = n;                                             for (boInserts = n;
>          n < lines[1].size () && lines[1][n].l == ~0;                    n < lines[1].size () && lines[1][n].l == ~0;
>          n += 1                                                          n += 1
>         )                                                               )
>     {}                                                              {}
>                                                                 
>     // We've got deleted line(s) from boDeletes .. o.               // We've got deleted line(s) from boDeletes .. o.
>     // We've got deleted line(s) from boInserts .. n.               // We've got deleted line(s) from boInserts .. n.
>                                                                 
>     unsigned nDeletes = o - boDeletes;                              unsigned nDeletes = o - boDeletes;
>     unsigned nInserts = n - boInserts;                              unsigned nInserts = n - boInserts;
>                                                                 
>     // We've got...                                                 // We've got...
>                                                                 
>     if (nDeletes && nInserts) {                                     if (nDeletes && nInserts) {
>                                                                 
>       // ... deletes and inserts.                                     // ... deletes and inserts.
>                                                                 
>       if (1 < nDeletes && 1 < nInserts) {                             if (1 < nDeletes && 1 < nInserts) {
>         fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, b           fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, b
>       } else if (1 < nDeletes) {                                      } else if (1 < nDeletes) {
>         fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boIn           fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boIn
>       } else if (1 < nInserts) {                                      } else if (1 < nInserts) {
>         fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInser           fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInser
>       }                                                               } 
>       for (unsigned l = boDeletes; l < o; l += 1) {                   for (unsigned l = boDeletes; l < o; l += 1) {
>         fprintf (stdout, "< %s", lines[0][l].line->c_str ());           fprintf (stdout, "< %s", lines[0][l].line->c_str ());
>       }                                                               }
>       fprintf (stderr, "---\n");                                      fprintf (stderr, "---\n");
>       for (unsigned l = boInserts; l < n; l += 1) {                   for (unsigned l = boInserts; l < n; l += 1) {
>         fprintf (stdout, "> %s", lines[1][l].line->c_str ());           fprintf (stdout, "> %s", lines[1][l].line->c_str ());
>       }                                                               }
>     } else if (nDeletes) {                                          } else if (nDeletes) {
>                                                                 
>       //  ... just deletes.                                           //  ... just deletes.
>                                                                 
>       if (1 < nDeletes) {                                             if (1 < nDeletes) {
>         fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);            fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
>       } else {                                                        } else {
>         fprintf (stdout, "%dd%d\n", boDeletes + 1, n);                  fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
>       }                                                               }
>       for (unsigned l = boDeletes; l < o; l += 1) {                   for (unsigned l = boDeletes; l < o; l += 1) {
>         fprintf (stdout, "< %s", lines[0][l].line->c_str ());           fprintf (stdout, "< %s", lines[0][l].line->c_str ());
>       }                                                               }
>     } else if (nInserts) {                                          } else if (nInserts) {
>                                                                 
>       //  ... just inserts.                                           //  ... just inserts.
>                                                                 
>       if (1 < nInserts) {                                             if (1 < nInserts) {
>         fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);            fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
>       } else {                                                        } else {
>         fprintf (stdout, "%da%d\n", o, boInserts + 1);                  fprintf (stdout, "%da%d\n", o, boInserts + 1);
>       }                                                               }
>       for (unsigned l = boInserts; l < n; l += 1) {                   for (unsigned l = boInserts; l < n; l += 1) {
>         fprintf (stdout, "> %s", lines[1][l].line->c_str ());           fprintf (stdout, "> %s", lines[1][l].line->c_str ());
>       }                                                               }
>     }                                                               }
>                                                                 
>     // When we get here, we're dealing with matching lines.         // When we get here, we're dealing with matching lines.
>                                                                 
>     o += 1;                                                         o += 1;
>     n += 1;                                                         n += 1;
>   }                                                               }
> }                                                               }
>                                                                 
> void pass6r () {                                                void pass6r () {
> }                                                               }
>                                                                 
> void pass6s () {                                                void pass6s () {
> }                                                               }
>                                                                 
> void pass6u ()                                                  void pass6u ()
> {                                                               {
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Pass #6u (walking the differences)...       fprintf (stderr, "# Pass #6u (walking the differences)...
>   }                                                               }
>                                                                 
>   nMatchedLines = 0;                                              nMatchedLines = 0;
>                                                                 
>   // Write the header.                                            // Write the header.
>                                                                 
>   fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:0     fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:0
>   fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:0     fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:0
>   fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), l     fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), l
>                                                                 
>   // Starting at the top of both files,...                        // Starting at the top of both files,...
>                                                                 
>   unsigned o = 0;                                                 unsigned o = 0;
>   unsigned n = 0;                                                 unsigned n = 0;
>                                                                 
>   while (o < lines[0].size () || n < lines[1].size ()) {          while (o < lines[0].size () || n < lines[1].size ()) {
>                                                                 
>     // Find any unmatched lines at this point in the old file       // Find any unmatched lines at this point in the old file
>     // are deletes.                                                 // are deletes.
>                                                                 
>     unsigned boDeletes;                                             unsigned boDeletes;
>     for (boDeletes = o;                                             for (boDeletes = o;
>          o < lines[0].size () && lines[0][o].l == ~0;                    o < lines[0].size () && lines[0][o].l == ~0;
>          o += 1                                                          o += 1
>         )                                                               )
>     {}                                                              {}
>                                                                 
>     // Find any unmatched lines at this point in the new file       // Find any unmatched lines at this point in the new file
>     // are inserts.                                                 // are inserts.
>                                                                 
>     unsigned boInserts;                                             unsigned boInserts;
>     for (boInserts = n;                                             for (boInserts = n;
>          n < lines[1].size () && lines[1][n].l == ~0;                    n < lines[1].size () && lines[1][n].l == ~0;
>          n += 1                                                          n += 1
>         )                                                               )
>     {}                                                              {}
>                                                                 
>     // We've got deleted line(s) from boDeletes .. o.               // We've got deleted line(s) from boDeletes .. o.
>     // We've got deleted line(s) from boInserts .. n.               // We've got deleted line(s) from boInserts .. n.
>                                                                 
>     unsigned nDeletes = o - boDeletes;                              unsigned nDeletes = o - boDeletes;
>     unsigned nInserts = n - boInserts;                              unsigned nInserts = n - boInserts;
>                                                                 
>     // We've got...                                                 // We've got...
>                                                                 
>     if (nDeletes && nInserts) {                                     if (nDeletes && nInserts) {
>                                                                 
>       // ... deletes and inserts.                                     // ... deletes and inserts.
>                                                                 
>       for (unsigned l = boDeletes; l < o; l += 1) {                   for (unsigned l = boDeletes; l < o; l += 1) {
>         fprintf (stdout, "-%s", lines[0][l].line->c_str ());            fprintf (stdout, "-%s", lines[0][l].line->c_str ());
>       }                                                               }
>       for (unsigned l = boInserts; l < n; l += 1) {                   for (unsigned l = boInserts; l < n; l += 1) {
>         fprintf (stdout, "+%s", lines[1][l].line->c_str ());            fprintf (stdout, "+%s", lines[1][l].line->c_str ());
>       }                                                               }
>     } else if (nDeletes) {                                          } else if (nDeletes) {
>                                                                 
>       //  ... just deletes.                                           //  ... just deletes.
>                                                                 
>       for (unsigned l = boDeletes; l < o; l += 1) {                   for (unsigned l = boDeletes; l < o; l += 1) {
>         fprintf (stdout, "-%s", lines[0][l].line->c_str ());            fprintf (stdout, "-%s", lines[0][l].line->c_str ());
>       }                                                               }
>     } else if (nInserts) {                                          } else if (nInserts) {
>                                                                 
>       //  ... just inserts.                                           //  ... just inserts.
>                                                                 
>       for (unsigned l = boInserts; l < n; l += 1) {                   for (unsigned l = boInserts; l < n; l += 1) {
>         fprintf (stdout, "+%s", lines[1][l].line->c_str ());            fprintf (stdout, "+%s", lines[1][l].line->c_str ());
>       }                                                               }
>     }                                                               }
>                                                                 
>     // When we get here, we're dealing with matching lines.         // When we get here, we're dealing with matching lines.
>                                                                 
>     fprintf (stdout, " %s", lines[0][o].line->c_str ());            fprintf (stdout, " %s", lines[0][o].line->c_str ());
>     o += 1;                                                         o += 1;
>     n += 1;                                                         n += 1;
>   }                                                               }
> }                                                               }
# ../sdiff -y dif.6.cpp dif.5.cpp >& dif.6.5.diff-y.test
# dif.6.5.diff-y ---------------------------------------------------------------
1,753c1,760
< #include <algorithm>						#include <algorithm>
< using std::find;						using std::find;
< #include <string>						#include <string>
< using std::string;						using std::string;
< #include <list>							#include <list>
< using std::list;						using std::list;
< #include <map>							#include <map>
< using std::map;							using std::map;
< #include <vector>						#include <vector>
< using std::vector;						using std::vector;
< #include <stdio.h>						#include <stdio.h>
< 
< enum DiffFormat {						enum DiffFormat {
<   Default,							  Default,
< 
<   Context,							  Context,
<   EdScript,							  EdScript,
<   IfThenElse,							  IfThenElse,
<   Normal,							  Normal,
<   RCS,								  RCS,
<   SideBySide,							  SideBySide,
<   Unified							  Unified
< };								};
< 
< DiffFormat diffFormat = Context;				DiffFormat diffFormat = Context;
< unsigned optCopyContext = 3;					unsigned optCopyContext = 3;
< 
< int optVerbose = 1;						int optVerbose = 1;
< 
< struct Line : public string {					struct Line : public string {
<   Line (string _text) :						  Line (string _text) :
<     string (_text)						    string (_text)
<   {								  {
<   }								  }
<   ~Line () {							  ~Line () {
<     copies[0].erase (copies[0].begin (), copies[0].end ());	    copies[0].erase (copies[0].begin (), copies[0].end ());
<     copies[1].erase (copies[1].begin (), copies[1].end ());	    copies[1].erase (copies[1].begin (), copies[1].end ());
<   }								  }
<   void Dump (FILE *out) {					  void Dump (FILE *out) {
<     fprintf (out, "{{ ");					    fprintf (out, "{{ ");
<     for (list<unsigned>::iterator i = copies[0].begin (); i !	    for (list<unsigned>::iterator i = copies[0].begin (); i !
<       fprintf (out, "%u ", *i);					      fprintf (out, "%u ", *i);
<     }								    }
<     fprintf (out, "},{ ");					    fprintf (out, "},{ ");
<     for (list<unsigned>::iterator i = copies[1].begin (); i !	    for (list<unsigned>::iterator i = copies[1].begin (); i !
<       fprintf (out, "%u ", *i);					      fprintf (out, "%u ", *i);
<     }								    }
<     fprintf (out, "}}\t%s", c_str ());				    fprintf (out, "}}\t%s", c_str ());
<   }								  }
<   list<unsigned> copies[2];					  list<unsigned> copies[2];
< };								};
< 
< struct LinePtr {						struct LinePtr {
<   LinePtr (Line *_line) :					  LinePtr (Line *_line) :
<     line (_line),						    line (_line),
<     l (~0u)							    l (~0u)
<   {								  {
<   }								  }
<   void Dump (FILE *out) {					  void Dump (FILE *out) {
<     fprintf (out, "[%d] ", l);					    fprintf (out, "[%d] ", l);
<     line->Dump (out);						    line->Dump (out);
<   }								  }
<   Line *line;							  Line *line;
<   unsigned l;							  unsigned l;
< };								};
< 
< typedef map<string, Line *> MapStringToLinePtr;			typedef map<string, Line *> MapStringToLinePtr;
< typedef vector<LinePtr> VectorLinePtr;				typedef vector<LinePtr> VectorLinePtr;
< 
< // Our name.							// Our name.
< 
< char *ARGV0 = "dif3";						char *ARGV0 = "dif3";
< 
< // The 'symbol' (line) table.					// The 'symbol' (line) table.
< 
< MapStringToLinePtr table;					MapStringToLinePtr table;
< 
< // The names of the 2 files to be diff'd.			// The names of the 2 files to be diff'd.
< 
< char const *files[2] = { 0, 0 };				char const *files[2] = { 0, 0 };
< 
< // The lines of the 2 files to be diff'd.			// The lines of the 2 files to be diff'd.
< 
< VectorLinePtr lines[2];						VectorLinePtr lines[2];
< 
< // Miscellaneous metrics.					// Miscellaneous metrics.
< 
< unsigned nTotalMatchedBlocks = 0;				unsigned nTotalMatchedBlocks = 0;
< unsigned nMatchedBlocks = 0;					unsigned nMatchedBlocks = 0;
< unsigned nTotalMatchedLines = 0;				unsigned nTotalMatchedLines = 0;
< unsigned nMatchedLines = 0;					unsigned nMatchedLines = 0;
< 
< void pass1 ();							void pass1 ();
< void pass2 ();							void pass2 ();
< void pass3 ();							void pass3 ();
< void pass4 ();							void pass4 ();
< void pass5 ();							void pass5 ();
< void pass6 ();							void pass6 ();
< 
< int main (int argc, char *argv[])				int main (int argc, char *argv[])
< {								{
<   // Read the old [0] file, and the new [1] file.		  // Read the old [0] file, and the new [1] file.
< 
<   for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {	  for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
<     files[n] = argv[a];						    files[n] = argv[a];
< 
<     if (FILE *f = fopen (files[n], "r")) {			    if (FILE *f = fopen (files[n], "r")) {
<       if (0 < optVerbose) {					      if (0 < optVerbose) {
<         fprintf (stderr, "# Reading %s...", files[n]);		        fprintf (stderr, "# Reading %s...", files[n]);
<       }								      }
< 
<       char buffer[1024];					      char buffer[1024];
<       unsigned nUniq = 0;					      unsigned nUniq = 0;
< 
<       while (fgets (buffer, sizeof (buffer), f)) {		      while (fgets (buffer, sizeof (buffer), f)) {
<         string text (buffer);					        string text (buffer);
< 
<         Line *line = table[text];				        Line *line = table[text];
< 
<         if (!line) {						        if (!line) {
<           table[text] = line = new Line (text);			          table[text] = line = new Line (text);
<           nUniq += 1;						          nUniq += 1;
<         }							        }
<         line->copies[n].push_back (lines[n].size ());		        line->copies[n].push_back (lines[n].size ());
<         lines[n].push_back (line);				        lines[n].push_back (line);
<       }								      }
< 
<       if (0 < optVerbose) {					      if (0 < optVerbose) {
<         fprintf (stderr, " %u lines, %u unique.\n", lines[n].	        fprintf (stderr, " %u lines, %u unique.\n", lines[n].
<       }								      }
<     } else {							    } else {
<       fprintf (stderr, "%s: Unable to open %s!  Exiting....\n	      fprintf (stderr, "%s: Unable to open %s!  Exiting....\n
<       perror (ARGV0);						      perror (ARGV0);
<       exit (1);							      exit (1);
<     }								    }
<   }								  }
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Total unique lines = %d\n", table.siz	    fprintf (stderr, "# Total unique lines = %d\n", table.siz
<   }								  }
< 
<   // map<int, int> counts;					  // map<int, int> counts;
<   // for (MapStringToLinePtr::iterator i = table.begin (); i 	  // for (MapStringToLinePtr::iterator i = table.begin (); i 
<   //   Line *l = i->second;					  //   Line *l = i->second;
<   //   counts[l->counts[0].size () + l->counts[1].size ()] +=	  //   counts[l->counts[0].size () + l->counts[1].size ()] +=
<   // }								  // }
<   // for (map<int, int>::iterator i = counts.begin (); i != c	  // for (map<int, int>::iterator i = counts.begin (); i != c
<   //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s	  //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s
<   // }								  // }
< 
<   pass1 ();							  pass1 ();
<   pass2 ();							  pass2 ();
<   pass3 ();							  pass3 ();
<   pass4 ();							  pass4 ();
<   pass5 ();							  pass5 ();
<   pass6 ();							  pass6 ();
< 
<   return 0;							  return 0;
< }								}
< 
< // Perform pass #1, in which we find all explicit matches amo	// Perform pass #1, in which we find all explicit matches amo
< // unique lines.  For every unique line that appears the same	// unique lines.  For every unique line that appears the same
< // of times in both files, we declare the lines to match.	// of times in both files, we declare the lines to match.
< 
< void pass1 ()							void pass1 ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass 1 (finding matches amongst uniqu	    fprintf (stderr, "# Pass 1 (finding matches amongst uniqu
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   for (MapStringToLinePtr::iterator i = table.begin (); i != 	  for (MapStringToLinePtr::iterator i = table.begin (); i != 
<     Line *l = i->second;					    Line *l = i->second;
< 
<     // If the number of old and new lines match, then we decl	    // If the number of old and new lines match, then we decl
<     // they are (all) the same line.  Note, it isn't possible	    // they are (all) the same line.  Note, it isn't possible
<     // numbers of both files to be 0.				    // numbers of both files to be 0.
< 
<     // (In the original algorithm, we only recognized a match	    // (In the original algorithm, we only recognized a match
<     // if there was exactly 1 copy for each file.)		    // if there was exactly 1 copy for each file.)
< 
<     if (l->copies[0].size () == l->copies[1].size ()) {		    if (l->copies[0].size () == l->copies[1].size ()) {
<       nMatchedLines += 1;					      nMatchedLines += 1;
< 
<       // For each matched line in the new file, mark it with 	      // For each matched line in the new file, mark it with 
<       // corresponding line (number) in the old file.		      // corresponding line (number) in the old file.
< 
<       while (!l->copies[0].empty ()) {				      while (!l->copies[0].empty ()) {
<         unsigned o = l->copies[0].front ();			        unsigned o = l->copies[0].front ();
<         unsigned n = l->copies[1].front ();			        unsigned n = l->copies[1].front ();
< 
<         // Match up the pair.					        // Match up the pair.
< 
<         lines[0][o].l = n;					        lines[0][o].l = n;
<         lines[1][n].l = o;					        lines[1][n].l = o;
< 
<         // Remove the matched line numbers from the lists.	        // Remove the matched line numbers from the lists.
< 
<         l->copies[0].pop_front ();				        l->copies[0].pop_front ();
<         l->copies[1].pop_front ();				        l->copies[1].pop_front ();
<       }								      }
<     }								    }
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, " found %u matched lines (%u total).\n",	    fprintf (stderr, " found %u matched lines (%u total).\n",
< 
<     if (1 < optVerbose) {					    if (1 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< }								}
< 
< // Perform Pass #2, in which we attempt to 'widen' blocks of 	// Perform Pass #2, in which we attempt to 'widen' blocks of 
< // lines, by appending lines which are the same in both files	// lines, by appending lines which are the same in both files
< 
< void pass2 ()							void pass2 ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #2 (spreading matches down)...")	    fprintf (stderr, "# Pass #2 (spreading matches down)...")
<   }								  }
< 
<   nMatchedBlocks = 0;						  nMatchedBlocks = 0;
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Starting at the top of the old file,...			  // Starting at the top of the old file,...
< 
<   for (unsigned o = 0; o < lines[0].size (); o += 1) {		  for (unsigned o = 0; o < lines[0].size (); o += 1) {
< 
<     // ... skip any currently unmatched lines...		    // ... skip any currently unmatched lines...
< 
<     if (lines[0][o].l == ~0) {					    if (lines[0][o].l == ~0) {
<       continue;							      continue;
<     }								    }
< 
<     // ... until we find an [already] matched line.  Then, sk	    // ... until we find an [already] matched line.  Then, sk
<     // the set of 1 or more matched lines, until we reach any	    // the set of 1 or more matched lines, until we reach any
<     // following, still-unmatched line.				    // following, still-unmatched line.
< 
<     unsigned n;							    unsigned n;
<     do {							    do {
<       n = lines[0][o].l + 1;					      n = lines[0][o].l + 1;
<       o += 1;							      o += 1;
<     } while (o < lines[0].size () && lines[0][o].l != ~0);	    } while (o < lines[0].size () && lines[0][o].l != ~0);
< 
<     // Now, o - 1 is the line number of the last matched old 	    // Now, o - 1 is the line number of the last matched old 
<     // n - 1 is the line number of the last matched new line.	    // n - 1 is the line number of the last matched new line.
<     // to add new old and new lines, if they match.		    // to add new old and new lines, if they match.
< 
<     // Finally, attempt to add unmatched lines to the preceed	    // Finally, attempt to add unmatched lines to the preceed
<     // matched set.						    // matched set.
< 
<     for (; o < lines[0].size () && lines[0][o].l == ~0; o += 	    for (; o < lines[0].size () && lines[0][o].l == ~0; o += 
< 
<       // If the [next] pair of old and new lines aren't the s	      // If the [next] pair of old and new lines aren't the s
< 
<       if (lines[0][o].line != lines[1][n].line) {		      if (lines[0][o].line != lines[1][n].line) {
<         break;							        break;
<       }								      }
< 
<       // Match up the pair.					      // Match up the pair.
< 
<       lines[0][o].l = n;					      lines[0][o].l = n;
<       lines[1][n].l = o;					      lines[1][n].l = o;
< 
<       // Remove the matched line numbers form the lists.	      // Remove the matched line numbers form the lists.
< 
<       Line *line = lines[0][o].line;				      Line *line = lines[0][o].line;
<       list<unsigned> &oldCopies = line->copies[0];		      list<unsigned> &oldCopies = line->copies[0];
<       list<unsigned>::iterator oL = find (oldCopies.begin (),	      list<unsigned>::iterator oL = find (oldCopies.begin (),
<       if (oL != oldCopies.end ()) {				      if (oL != oldCopies.end ()) {
<         oldCopies.erase (oL);					        oldCopies.erase (oL);
<       }								      }
<       list<unsigned> &newCopies = line->copies[0];		      list<unsigned> &newCopies = line->copies[0];
<       list<unsigned>::iterator nL = find (newCopies.begin (),	      list<unsigned>::iterator nL = find (newCopies.begin (),
<       if (nL != newCopies.end ()) {				      if (nL != newCopies.end ()) {
<         newCopies.erase (nL);					        newCopies.erase (nL);
<       }								      }
< 
<       nMatchedLines += 1;					      nMatchedLines += 1;
<     }								    }
<     nMatchedBlocks += 1;					    nMatchedBlocks += 1;
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
<   nTotalMatchedBlocks += nMatchedBlocks;			  nTotalMatchedBlocks += nMatchedBlocks;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr,						    fprintf (stderr,
<              " found %u/%u matched lines/blocks (%u/%u totals	             " found %u/%u matched lines/blocks (%u/%u totals
<              nMatchedLines,					             nMatchedLines,
<              nMatchedBlocks,					             nMatchedBlocks,
<              nTotalMatchedLines,				             nTotalMatchedLines,
<              nTotalMatchedBlocks				             nTotalMatchedBlocks
<             );							            );
<     if (1 < optVerbose) {					    if (1 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< }								}
< 
< // Perform Pass #3, in which we attempt to 'widen' blocks of 	// Perform Pass #3, in which we attempt to 'widen' blocks of 
< // lines, by prepending lines which are the same in both file	// lines, by prepending lines which are the same in both file
< 
< void pass3 ()							void pass3 ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #3 (spreading matches up)...");	    fprintf (stderr, "# Pass #3 (spreading matches up)...");
<   }								  }
< 
<   nMatchedBlocks = 0;						  nMatchedBlocks = 0;
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Starting at the bottom of the old file,...			  // Starting at the bottom of the old file,...
< 
<   for (int o = lines[0].size (); 0 <= o; o -= 1) {		  for (int o = lines[0].size (); 0 <= o; o -= 1) {
< 
<     // ... skip any currently unmatched lines...		    // ... skip any currently unmatched lines...
< 
<     if (lines[0][o].l == ~0) {					    if (lines[0][o].l == ~0) {
<       continue;							      continue;
<     }								    }
< 
<     // ... until we find an [already] matched line.  Then, sk	    // ... until we find an [already] matched line.  Then, sk
<     // the set of 1 or more matched lines, until we reach any	    // the set of 1 or more matched lines, until we reach any
<     // following, still-unmatched line.				    // following, still-unmatched line.
< 
<     unsigned n;							    unsigned n;
<     do {							    do {
<       n = lines[0][o].l - 1;					      n = lines[0][o].l - 1;
<       o -= 1;							      o -= 1;
<     } while (0 <= o && lines[0][o].l != ~0);			    } while (0 <= o && lines[0][o].l != ~0);
< 
<     // Now, o + 1 is the line number of the last matched old 	    // Now, o + 1 is the line number of the last matched old 
<     // n + 1 is the line number of the last matched new line.	    // n + 1 is the line number of the last matched new line.
<     // to add new old and new lines, if they match.		    // to add new old and new lines, if they match.
< 
<     // Finally, attempt to add unmatched lines to the preceed	    // Finally, attempt to add unmatched lines to the preceed
<     // matched set.						    // matched set.
< 
<     for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {	    for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
< 
<       // If the [next] pair of old and new lines aren't the s	      // If the [next] pair of old and new lines aren't the s
< 
<       if (lines[0][o].line != lines[1][n].line) {		      if (lines[0][o].line != lines[1][n].line) {
<         break;							        break;
<       }								      }
< 
<       // Match up the pair.					      // Match up the pair.
< 
<       lines[0][o].l = n;					      lines[0][o].l = n;
<       lines[1][n].l = o;					      lines[1][n].l = o;
< 
<       // Remove the matched line numbers form the lists.	      // Remove the matched line numbers form the lists.
< 
<       Line *line = lines[0][o].line;				      Line *line = lines[0][o].line;
<       list<unsigned> &oldCopies = line->copies[0];		      list<unsigned> &oldCopies = line->copies[0];
<       list<unsigned>::iterator oL = find (oldCopies.begin (),	      list<unsigned>::iterator oL = find (oldCopies.begin (),
<       if (oL != oldCopies.end ()) {				      if (oL != oldCopies.end ()) {
<         oldCopies.erase (oL);					        oldCopies.erase (oL);
<       }								      }
<       list<unsigned> &newCopies = line->copies[0];		      list<unsigned> &newCopies = line->copies[0];
<       list<unsigned>::iterator nL = find (newCopies.begin (),	      list<unsigned>::iterator nL = find (newCopies.begin (),
<       if (nL != newCopies.end ()) {				      if (nL != newCopies.end ()) {
<         newCopies.erase (nL);					        newCopies.erase (nL);
<       }								      }
< 
<       nMatchedLines += 1;					      nMatchedLines += 1;
<     }								    }
<     nMatchedBlocks += 1;					    nMatchedBlocks += 1;
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr,						    fprintf (stderr,
<              " found %u/%u matched lines/blocks (%u/%u totals	             " found %u/%u matched lines/blocks (%u/%u totals
<              nMatchedLines,					             nMatchedLines,
<              nMatchedBlocks,					             nMatchedBlocks,
<              nTotalMatchedLines,				             nTotalMatchedLines,
<              nTotalMatchedBlocks				             nTotalMatchedBlocks
<             );							            );
< 
<     if (1 < optVerbose) {					    if (1 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< }								}
< 
< // Perform pass #4, in which we find any remaining matches am	// Perform pass #4, in which we find any remaining matches am
< // unique lines.  For every unique line that has more than 1 	// unique lines.  For every unique line that has more than 1 
< // both files, we declare the copies to match.			// both files, we declare the copies to match.
< 
< void pass4 ()							void pass4 ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass 4 (finding remaining matches amo	    fprintf (stderr, "# Pass 4 (finding remaining matches amo
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   for (MapStringToLinePtr::iterator i = table.begin (); i != 	  for (MapStringToLinePtr::iterator i = table.begin (); i != 
<     Line *l = i->second;					    Line *l = i->second;
< 
<     // If there's more than 1 matching old and new lines, the	    // If there's more than 1 matching old and new lines, the
<     // declare that each pair are (all) the same line.		    // declare that each pair are (all) the same line.
< 
<     // (In the original algorithm, we only recognized a match	    // (In the original algorithm, we only recognized a match
<     // if there was exactly 1 copy for each file.)		    // if there was exactly 1 copy for each file.)
< 
<     while (0 < l->copies[0].size () && 0 < l->copies[1].size 	    while (0 < l->copies[0].size () && 0 < l->copies[1].size 
<       nMatchedLines += 1;					      nMatchedLines += 1;
< 
<       // For each matched line in the new file, mark it with 	      // For each matched line in the new file, mark it with 
<       // corresponding line (number) in the old file.		      // corresponding line (number) in the old file.
< 
<       unsigned o = l->copies[0].front ();			      unsigned o = l->copies[0].front ();
<       unsigned n = l->copies[1].front ();			      unsigned n = l->copies[1].front ();
< 
<       // Match up the pair.					      // Match up the pair.
< 
<       lines[0][o].l = n;					      lines[0][o].l = n;
<       lines[1][n].l = o;					      lines[1][n].l = o;
< 
<       // Remove the matched line numbers from the lists.	      // Remove the matched line numbers from the lists.
< 
<       l->copies[0].pop_front ();				      l->copies[0].pop_front ();
<       l->copies[1].pop_front ();				      l->copies[1].pop_front ();
<     }								    }
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, " found %u matched lines (%u total).\n",	    fprintf (stderr, " found %u matched lines (%u total).\n",
< 
<     if (1 < optVerbose) {					    if (1 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< }								}
< 
< // Perform Pass #5, in which we look for blocks which match, 	// Perform Pass #5, in which we look for blocks which match, 
< // the result of a move (their not in their original position	// the result of a move (their not in their original position
< // these, we'll unmatch the blocks, turning them into a delet	// these, we'll unmatch the blocks, turning them into a delet
< // insert.							// insert.
< 
< void pass5 ()							void pass5 ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #5 (unmatching block moves)...\n	    fprintf (stderr, "# Pass #5 (unmatching block moves)...\n
<   }								  }
< 
<   nMatchedBlocks = 0;						  nMatchedBlocks = 0;
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Starting at the top of both files,...			  // Starting at the top of both files,...
< 
<   unsigned o = 0;						  unsigned o = 0;
<   unsigned n = 0;						  unsigned n = 0;
< 
<   while (o < lines[0].size () || n < lines[1].size ()) {	  while (o < lines[0].size () || n < lines[1].size ()) {
< 
<     // Skip any unmatched lines at this point in the old file	    // Skip any unmatched lines at this point in the old file
<     // are deletes.						    // are deletes.
< 
<     //    Old     New						    //    Old     New
<     //   +---+							    //   +---+
<     // 0 | a |							    // 0 | a |
<     //   +---+   +---+						    //   +---+   +---+
<     //         0 | b |						    //         0 | b |
<     //   +---+   +---+						    //   +---+   +---+
<     // 1 | c | 1 | c |						    // 1 | c | 1 | c |
<     //   +---+   +---+						    //   +---+   +---+
<     //         2 | z |						    //         2 | z |
<     //   +---+   +---+						    //   +---+   +---+
<     // 2 | d | 3 | d |						    // 2 | d | 3 | d |
<     //   +---+   +---+						    //   +---+   +---+
< 
<     while (o < lines[0].size () && lines[0][o].l == ~0) {	    while (o < lines[0].size () && lines[0][o].l == ~0) {
<       o += 1;							      o += 1;
<     }								    }
< 
<     // Skip any unmatched lines at this point in the new file	    // Skip any unmatched lines at this point in the new file
<     // are inserts.						    // are inserts.
< 
<     while (n < lines[1].size () && lines[1][n].l == ~0) {	    while (n < lines[1].size () && lines[1][n].l == ~0) {
<       n += 1;							      n += 1;
<     }								    }
< 
<     // When we get here, we know that we're dealing with matc	    // When we get here, we know that we're dealing with matc
<     // lines (or the end of one or both files).  We're done w	    // lines (or the end of one or both files).  We're done w
<     // pass, if we've reached the end of either file.		    // pass, if we've reached the end of either file.
< 
<     if (lines[0].size () <= o || lines[1].size () <= n) {	    if (lines[0].size () <= o || lines[1].size () <= n) {
<       break;							      break;
<     }								    }
< 
<     // We now know that we've got a pair of matching lines, t	    // We now know that we've got a pair of matching lines, t
<     // of a matching block.  If the new file's line number is	    // of a matching block.  If the new file's line number is
<     // expect, then the matched pair is unmoved, and we can s	    // expect, then the matched pair is unmoved, and we can s
<     // the pair.  (If this is really the start of a block of 	    // the pair.  (If this is really the start of a block of 
<     // 1 lines, we'll handle it one pair at a time.)		    // 1 lines, we'll handle it one pair at a time.)
< 
<     if (lines[0][o].l == n) {					    if (lines[0][o].l == n) {
<       o += 1;							      o += 1;
<       n += 1;							      n += 1;
<       continue;							      continue;
<     }								    }
< 
<     // If, on the other hand, we don't expect this [new] line	    // If, on the other hand, we don't expect this [new] line
<     // then this matching block has been moved.  We need to t	    // then this matching block has been moved.  We need to t
<     // matched pair into an *unmatched* pair, one of deletes,	    // matched pair into an *unmatched* pair, one of deletes,
<     // of inserts.  First, though, we need to know how big th	    // of inserts.  First, though, we need to know how big th
<     // is, and how far it was moved....				    // is, and how far it was moved....
< 
<     // Remember where we were when we started.			    // Remember where we were when we started.
< 
<     unsigned oOld = o;						    unsigned oOld = o;
<     unsigned nOld = n;						    unsigned nOld = n;
< 
<     // Remember where the block came from.			    // Remember where the block came from.
< 
<     unsigned nNew = lines[0][o].l;				    unsigned nNew = lines[0][o].l;
< 
<     // Find the end of this matched pair.			    // Find the end of this matched pair.
< 
<     for (n = nNew; o < lines[0].size () && n < lines[1].size 	    for (n = nNew; o < lines[0].size () && n < lines[1].size 
<       if (lines[0][o].l != n) {					      if (lines[0][o].l != n) {
<         break;							        break;
<       }								      }
<     }								    }
< 
<     // When we get here:					    // When we get here:
<     // * oOld..o is the old file's block,			    // * oOld..o is the old file's block,
<     // * nNew..n is the new file's *moved* block, and		    // * nNew..n is the new file's *moved* block, and
<     // * nOld is where we originally expected the new block f	    // * nOld is where we originally expected the new block f
<  								 
<     // We can now calculate the length of the block...		    // We can now calculate the length of the block...
<     								    
<     unsigned bSize = o - oOld;  // (or n - nNew)		    unsigned bSize = o - oOld;  // (or n - nNew)
< 
<     // ... and we can calculate how far the block moved:	    // ... and we can calculate how far the block moved:
< 
<     unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;	    unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
< 
<     // The larger of the two will become our delete, and the 	    // The larger of the two will become our delete, and the 
<     // will become our insert.					    // will become our insert.
< 
<     //    Old     New						    //    Old     New
<     //   +---+   +---+						    //   +---+   +---+
<     // 0 | a | 0 | b |						    // 0 | a | 0 | b |
<     //   +---+ 1 | b |						    //   +---+ 1 | b |
<     // 1 | b |   +---+						    // 1 | b |   +---+
<     // 2 | b | 2 | a |						    // 2 | b | 2 | a |
<     //   +---+   +---+						    //   +---+   +---+
<     // 3 | c | 3 | c |						    // 3 | c | 3 | c |
<     //   +---+   +---+						    //   +---+   +---+
< 
<     // (1) Delete a@0, insert a@2, or				    // (1) Delete a@0, insert a@2, or
<     // (2) insert bb@0, delete bb@1?				    // (2) insert bb@0, delete bb@1?
< 
<     // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and	    // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and
<     // (of a) is 2-0 or 2, the size of b@0.  We choose to del	    // (of a) is 2-0 or 2, the size of b@0.  We choose to del
<     // and reinsert a@2.					    // and reinsert a@2.
< 
<     // if (bSize <= bMove) {					    // if (bSize <= bMove) {
<       for (unsigned a = oOld; a < o; a += 1) {			      for (unsigned a = oOld; a < o; a += 1) {
<         lines[0][a].l = ~0;					        lines[0][a].l = ~0;
<       }								      }
<       for (unsigned d = nNew; d < n; d += 1) {			      for (unsigned d = nNew; d < n; d += 1) {
<         lines[1][d].l = ~0;					        lines[1][d].l = ~0;
<       }								      }
<     // } else {							    // } else {
<       // for (unsigned a = oOld; a < o; a += 1) {		      // for (unsigned a = oOld; a < o; a += 1) {
<       //   lines[0][a].l = ~0;					      //   lines[0][a].l = ~0;
<       // }							      // }
<       // for (unsigned d = nNew; d < n; d += 1) {		      // for (unsigned d = nNew; d < n; d += 1) {
<       //   lines[1][d].l = ~0;					      //   lines[1][d].l = ~0;
<       // }							      // }
<     // }							    // }
< 
<     // Continue from where we left off.				    // Continue from where we left off.
< 
<     n = nOld;							    n = nOld;
<   }								  }
<   nTotalMatchedLines -= nMatchedLines;				  nTotalMatchedLines -= nMatchedLines;
<   nTotalMatchedBlocks -= nMatchedBlocks;			  nTotalMatchedBlocks -= nMatchedBlocks;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr,						    fprintf (stderr,
<              " found %u/%u matched lines/blocks (%u/%u totals	             " found %u/%u matched lines/blocks (%u/%u totals
<              nMatchedLines,					             nMatchedLines,
<              nMatchedBlocks,					             nMatchedBlocks,
<              nTotalMatchedLines,				             nTotalMatchedLines,
<              nTotalMatchedBlocks				             nTotalMatchedBlocks
<             );							            );
< 
<     if (1 < optVerbose) {					    if (1 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< }								}
< 
< // Perform Pass #6, in which we create the desired output.	// Perform Pass #6, in which we create the desired output.
< 
< void pass6c ();							void pass6c ();
< void pass6e ();							void pass6e ();
< void pass6i ();							void pass6i ();
< void pass6n ();							void pass6n ();
< void pass6r ();							void pass6r ();
< void pass6s ();							void pass6s ();
< void pass6u ();							void pass6u ();
< 
< void pass6 ()							void pass6 ()
< {								{
< 
<   switch (diffFormat) {						  switch (diffFormat) {
<   case Context:							  case Context:
<     pass6c ();							    pass6c ();
<     break;							    break;
< 
<   case EdScript:						  case EdScript:
<     pass6e ();							    pass6e ();
<     break;							    break;
< 
<   case IfThenElse:						  case IfThenElse:
<     pass6i ();							    pass6i ();
<     break;							    break;
< 
<   case Normal:							  case Normal:
<     pass6n ();							    pass6n ();
<     break;							    break;
< 
<   case RCS:							  case RCS:
<     pass6r ();							    pass6r ();
<     break;							    break;
< 
<   case SideBySide:						  case SideBySide:
<     pass6s ();							    pass6s ();
<     break;							    break;
< 
<   case Unified:							  case Unified:
<     pass6u ();							    pass6u ();
<     break;							    break;
< 
<   case Default:							  case Default:
<   default:							  default:
<     pass6c ();							    pass6c ();
<     break;							    break;
<   }								  }
< }								}
< 
< template<typename T> T min (T l, T r) {				template<typename T> T min (T l, T r) {
<   if (l < r) {							  if (l < r) {
<     return l;							    return l;
<   }								  }
<   return r;							  return r;
< }								}
< 
< template<typename T> T max (T l, T r) {				template<typename T> T max (T l, T r) {
<   if (l < r) {							  if (l < r) {
<     return r;							    return r;
<   }								  }
<   return l;							  return l;
< }								}
< 
< void pass6c () {						void pass6c () {
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #6u (walking the differences)...	    fprintf (stderr, "# Pass #6u (walking the differences)...
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Write the header.						  // Write the header.
< 
<   fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:0	  fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:0
<   fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:0	  fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:0
< 
<   // Starting at the top of both files,...			  // Starting at the top of both files,...
< 
<   unsigned o = 0;						  unsigned o = 0;
<   unsigned n = 0;						  unsigned n = 0;
< 
<   while (o < lines[0].size () || n < lines[1].size ()) {	  while (o < lines[0].size () || n < lines[1].size ()) {
< 
<     // Find the bounds of the current contextual 'window'.    |	    // Find any unmatched lines at this point in the old file
< 							      |	    // are deletes.
<     // If we aren't looking at a delete or an insert, we're n <
<     // start of a context window.			      <
< 							      <
<     if (lines[0][o].l != ~0 && lines[1][n].l != ~0) {	      <
<       o += 1;						      <
<       n += 1;						      <
<       continue;						      <
<     }							      <
< 							      <
<     // We're looking at at least 1 delete or insert, so a win <
<     // begins here (or, rather, optCopyContext lines earlier) <
<     							      <
<     int boOldWindow = max (0, int (boDeletes) - int(optCopyCo <
<     int eoOldWindow = min (int (lines[0].size ()), int(o) + i <
< 							      <
<     // Look for the end of the window.			      <
< 							      <
<     bool widenWindow = false;				      <
<     do {						      <
< 							      <
<       // Skip over the delete(s) and/or insert(s) defining th <
<       // context.					      <
< 							      <
<       while (o < lines[0].size () && lines[0][o].l == ~0) {   <
<         o += 1;						      <
<       }							      <
---
> #include <algorithm>                                            #include <algorithm>
> using std::find;                                                using std::find;
> #include <string>                                               #include <string>
> using std::string;                                              using std::string;
> #include <list>                                                 #include <list>
> using std::list;                                                using std::list;
> #include <map>                                                  #include <map>
> using std::map;                                                 using std::map;
> #include <vector>                                               #include <vector>
> using std::vector;                                              using std::vector;
> #include <stdio.h>                                              #include <stdio.h>
>                                                                 
> enum DiffFormat {                                               enum DiffFormat {
>   Default,                                                        Default,
>                                                                 
>   Context,                                                        Context,
>   EdScript,                                                       EdScript,
>   IfThenElse,                                                     IfThenElse,
>   Normal,                                                         Normal,
>   RCS,                                                            RCS,
>   SideBySide,                                                     SideBySide,
>   Unified                                                         Unified
> };                                                              };
>                                                                 
> DiffFormat diffFormat = Context;                                DiffFormat diffFormat = Context;
> unsigned optCopyContext = 3;                                    unsigned optCopyContext = 3;
>                                                                 
> int optVerbose = 1;                                             int optVerbose = 1;
>                                                                 
> struct Line : public string {                                   struct Line : public string {
>   Line (string _text) :                                           Line (string _text) :
>     string (_text)                                                  string (_text)
>   {                                                               {
>   }                                                               }
>   ~Line () {                                                      ~Line () {
>     copies[0].erase (copies[0].begin (), copies[0].end ());         copies[0].erase (copies[0].begin (), copies[0].end ());
>     copies[1].erase (copies[1].begin (), copies[1].end ());         copies[1].erase (copies[1].begin (), copies[1].end ());
>   }                                                               }
>   void Dump (FILE *out) {                                         void Dump (FILE *out) {
>     fprintf (out, "{{ ");                                           fprintf (out, "{{ ");
>     for (list<unsigned>::iterator i = copies[0].begin (); i !       for (list<unsigned>::iterator i = copies[0].begin (); i !
>       fprintf (out, "%u ", *i);                                       fprintf (out, "%u ", *i);
>     }                                                               }
>     fprintf (out, "},{ ");                                          fprintf (out, "},{ ");
>     for (list<unsigned>::iterator i = copies[1].begin (); i !       for (list<unsigned>::iterator i = copies[1].begin (); i !
>       fprintf (out, "%u ", *i);                                       fprintf (out, "%u ", *i);
>     }                                                               }
>     fprintf (out, "}}\t%s", c_str ());                              fprintf (out, "}}\t%s", c_str ());
>   }                                                               }
>   list<unsigned> copies[2];                                       list<unsigned> copies[2];
> };                                                              };
>                                                                 
> struct LinePtr {                                                struct LinePtr {
>   LinePtr (Line *_line) :                                         LinePtr (Line *_line) :
>     line (_line),                                                   line (_line),
>     l (~0u)                                                         l (~0u)
>   {                                                               {
>   }                                                               }
>   void Dump (FILE *out) {                                         void Dump (FILE *out) {
>     fprintf (out, "[%d] ", l);                                      fprintf (out, "[%d] ", l);
>     line->Dump (out);                                               line->Dump (out);
>   }                                                               }
>   Line *line;                                                     Line *line;
>   unsigned l;                                                     unsigned l;
> };                                                              };
>                                                                 
> typedef map<string, Line *> MapStringToLinePtr;                 typedef map<string, Line *> MapStringToLinePtr;
> typedef vector<LinePtr> VectorLinePtr;                          typedef vector<LinePtr> VectorLinePtr;
>                                                                 
> // Our name.                                                    // Our name.
>                                                                 
> char *ARGV0 = "dif3";                                           char *ARGV0 = "dif3";
>                                                                 
> // The 'symbol' (line) table.                                   // The 'symbol' (line) table.
>                                                                 
> MapStringToLinePtr table;                                       MapStringToLinePtr table;
>                                                                 
> // The names of the 2 files to be diff'd.                       // The names of the 2 files to be diff'd.
>                                                                 
> char const *files[2] = { 0, 0 };                                char const *files[2] = { 0, 0 };
>                                                                 
> // The lines of the 2 files to be diff'd.                       // The lines of the 2 files to be diff'd.
>                                                                 
> VectorLinePtr lines[2];                                         VectorLinePtr lines[2];
>                                                                 
> // Miscellaneous metrics.                                       // Miscellaneous metrics.
>                                                                 
> unsigned nTotalMatchedBlocks = 0;                               unsigned nTotalMatchedBlocks = 0;
> unsigned nMatchedBlocks = 0;                                    unsigned nMatchedBlocks = 0;
> unsigned nTotalMatchedLines = 0;                                unsigned nTotalMatchedLines = 0;
> unsigned nMatchedLines = 0;                                     unsigned nMatchedLines = 0;
>                                                                 
> void pass1 ();                                                  void pass1 ();
> void pass2 ();                                                  void pass2 ();
> void pass3 ();                                                  void pass3 ();
> void pass4 ();                                                  void pass4 ();
> void pass5 ();                                                  void pass5 ();
> void pass6 ();                                                  void pass6 ();
>                                                                 
> int main (int argc, char *argv[])                               int main (int argc, char *argv[])
> {                                                               {
>   // Read the old [0] file, and the new [1] file.                 // Read the old [0] file, and the new [1] file.
>                                                                 
>   for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {     for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
>     files[n] = argv[a];                                             files[n] = argv[a];
>                                                                 
>     if (FILE *f = fopen (files[n], "r")) {                          if (FILE *f = fopen (files[n], "r")) {
>       if (0 < optVerbose) {                                           if (0 < optVerbose) {
>         fprintf (stderr, "# Reading %s...", files[n]);                  fprintf (stderr, "# Reading %s...", files[n]);
>       }                                                               }
>                                                                 
>       char buffer[1024];                                              char buffer[1024];
>       unsigned nUniq = 0;                                             unsigned nUniq = 0;
>                                                                 
>       while (fgets (buffer, sizeof (buffer), f)) {                    while (fgets (buffer, sizeof (buffer), f)) {
>         string text (buffer);                                           string text (buffer);
>                                                                 
>         Line *line = table[text];                                       Line *line = table[text];
>                                                                 
>         if (!line) {                                                    if (!line) {
>           table[text] = line = new Line (text);                           table[text] = line = new Line (text);
>           nUniq += 1;                                                     nUniq += 1;
>         }                                                               }
>         line->copies[n].push_back (lines[n].size ());                   line->copies[n].push_back (lines[n].size ());
>         lines[n].push_back (line);                                      lines[n].push_back (line);
>       }                                                               }
>                                                                 
>       if (0 < optVerbose) {                                           if (0 < optVerbose) {
>         fprintf (stderr, " %u lines, %u unique.\n", lines[n].           fprintf (stderr, " %u lines, %u unique.\n", lines[n].
>       }                                                               }
>     } else {                                                        } else {
>       fprintf (stderr, "%s: Unable to open %s!  Exiting....\n         fprintf (stderr, "%s: Unable to open %s!  Exiting....\n
>       perror (ARGV0);                                                 perror (ARGV0);
>       exit (1);                                                       exit (1);
>     }                                                               }
>   }                                                               }
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Total unique lines = %d\n", table.siz       fprintf (stderr, "# Total unique lines = %d\n", table.siz
>   }                                                               }
>                                                                 
>   // map<int, int> counts;                                        // map<int, int> counts;
>   // for (MapStringToLinePtr::iterator i = table.begin (); i      // for (MapStringToLinePtr::iterator i = table.begin (); i 
>   //   Line *l = i->second;                                       //   Line *l = i->second;
>   //   counts[l->counts[0].size () + l->counts[1].size ()] +=     //   counts[l->counts[0].size () + l->counts[1].size ()] +=
>   // }                                                            // }
>   // for (map<int, int>::iterator i = counts.begin (); i != c     // for (map<int, int>::iterator i = counts.begin (); i != c
>   //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s     //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s
>   // }                                                            // }
>                                                                 
>   pass1 ();                                                       pass1 ();
>   pass2 ();                                                       pass2 ();
>   pass3 ();                                                       pass3 ();
>   pass4 ();                                                       pass4 ();
>   pass5 ();                                                       pass5 ();
>   pass6 ();                                                       pass6 ();
>                                                                 
>   return 0;                                                       return 0;
> }                                                               }
>                                                                 
> // Perform pass #1, in which we find all explicit matches amo   // Perform pass #1, in which we find all explicit matches amo
> // unique lines.  For every unique line that appears the same   // unique lines.  For every unique line that appears the same
> // of times in both files, we declare the lines to match.       // of times in both files, we declare the lines to match.
>                                                                 
> void pass1 ()                                                   void pass1 ()
> {                                                               {
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Pass 1 (finding matches amongst uniqu       fprintf (stderr, "# Pass 1 (finding matches amongst uniqu
>   }                                                               }
>                                                                 
>   nMatchedLines = 0;                                              nMatchedLines = 0;
>                                                                 
>   for (MapStringToLinePtr::iterator i = table.begin (); i !=      for (MapStringToLinePtr::iterator i = table.begin (); i != 
>     Line *l = i->second;                                            Line *l = i->second;
>                                                                 
>     // If the number of old and new lines match, then we decl       // If the number of old and new lines match, then we decl
>     // they are (all) the same line.  Note, it isn't possible       // they are (all) the same line.  Note, it isn't possible
>     // numbers of both files to be 0.                               // numbers of both files to be 0.
>                                                                 
>     // (In the original algorithm, we only recognized a match       // (In the original algorithm, we only recognized a match
>     // if there was exactly 1 copy for each file.)                  // if there was exactly 1 copy for each file.)
>                                                                 
>     if (l->copies[0].size () == l->copies[1].size ()) {             if (l->copies[0].size () == l->copies[1].size ()) {
>       nMatchedLines += 1;                                             nMatchedLines += 1;
>                                                                 
>       // For each matched line in the new file, mark it with          // For each matched line in the new file, mark it with 
>       // corresponding line (number) in the old file.                 // corresponding line (number) in the old file.
>                                                                 
>       while (!l->copies[0].empty ()) {                                while (!l->copies[0].empty ()) {
>         unsigned o = l->copies[0].front ();                             unsigned o = l->copies[0].front ();
>         unsigned n = l->copies[1].front ();                             unsigned n = l->copies[1].front ();
>                                                                 
>         // Match up the pair.                                           // Match up the pair.
>                                                                 
>         lines[0][o].l = n;                                              lines[0][o].l = n;
>         lines[1][n].l = o;                                              lines[1][n].l = o;
>                                                                 
>         // Remove the matched line numbers from the lists.              // Remove the matched line numbers from the lists.
>                                                                 
>         l->copies[0].pop_front ();                                      l->copies[0].pop_front ();
>         l->copies[1].pop_front ();                                      l->copies[1].pop_front ();
>       }                                                               }
>     }                                                               }
>   }                                                               }
>   nTotalMatchedLines += nMatchedLines;                            nTotalMatchedLines += nMatchedLines;
>                                                                 
>   // Let's see the intermediate results.                          // Let's see the intermediate results.
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, " found %u matched lines (%u total).\n",       fprintf (stderr, " found %u matched lines (%u total).\n",
>                                                                 
>     if (1 < optVerbose) {                                           if (1 < optVerbose) {
>       for (int f = 0; f < 2; f += 1) {                                for (int f = 0; f < 2; f += 1) {
>         fprintf (stderr, "# file #%d\n", f + 1);                        fprintf (stderr, "# file #%d\n", f + 1);
>         for (int l = 0; l < lines[f].size (); l += 1) {                 for (int l = 0; l < lines[f].size (); l += 1) {
>           fprintf (stderr, "#   [%d] ", l);                               fprintf (stderr, "#   [%d] ", l);
>           lines[f][l].Dump (stderr);                                      lines[f][l].Dump (stderr);
>         }                                                               }
>       }                                                               }
>     }                                                               }
>   }                                                               }
> }                                                               }
>                                                                 
> // Perform Pass #2, in which we attempt to 'widen' blocks of    // Perform Pass #2, in which we attempt to 'widen' blocks of 
> // lines, by appending lines which are the same in both files   // lines, by appending lines which are the same in both files
>                                                                 
> void pass2 ()                                                   void pass2 ()
> {                                                               {
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Pass #2 (spreading matches down)...")       fprintf (stderr, "# Pass #2 (spreading matches down)...")
>   }                                                               }
>                                                                 
>   nMatchedBlocks = 0;                                             nMatchedBlocks = 0;
>   nMatchedLines = 0;                                              nMatchedLines = 0;
>                                                                 
>   // Starting at the top of the old file,...                      // Starting at the top of the old file,...
>                                                                 
>   for (unsigned o = 0; o < lines[0].size (); o += 1) {            for (unsigned o = 0; o < lines[0].size (); o += 1) {
>                                                                 
>     // ... skip any currently unmatched lines...                    // ... skip any currently unmatched lines...
>                                                                 
>     if (lines[0][o].l == ~0) {                                      if (lines[0][o].l == ~0) {
>       continue;                                                       continue;
>     }                                                               }
>                                                                 
>     // ... until we find an [already] matched line.  Then, sk       // ... until we find an [already] matched line.  Then, sk
>     // the set of 1 or more matched lines, until we reach any       // the set of 1 or more matched lines, until we reach any
>     // following, still-unmatched line.                             // following, still-unmatched line.
>                                                                 
>     unsigned n;                                                     unsigned n;
>     do {                                                            do {
>       n = lines[0][o].l + 1;                                          n = lines[0][o].l + 1;
>       o += 1;                                                         o += 1;
>     } while (o < lines[0].size () && lines[0][o].l != ~0);          } while (o < lines[0].size () && lines[0][o].l != ~0);
>                                                                 
>     // Now, o - 1 is the line number of the last matched old        // Now, o - 1 is the line number of the last matched old 
>     // n - 1 is the line number of the last matched new line.       // n - 1 is the line number of the last matched new line.
>     // to add new old and new lines, if they match.                 // to add new old and new lines, if they match.
>                                                                 
>     // Finally, attempt to add unmatched lines to the preceed       // Finally, attempt to add unmatched lines to the preceed
>     // matched set.                                                 // matched set.
>                                                                 
>     for (; o < lines[0].size () && lines[0][o].l == ~0; o +=        for (; o < lines[0].size () && lines[0][o].l == ~0; o += 
>                                                                 
>       // If the [next] pair of old and new lines aren't the s         // If the [next] pair of old and new lines aren't the s
>                                                                 
>       if (lines[0][o].line != lines[1][n].line) {                     if (lines[0][o].line != lines[1][n].line) {
>         break;                                                          break;
>       }                                                               }
>                                                                 
>       // Match up the pair.                                           // Match up the pair.
>                                                                 
>       lines[0][o].l = n;                                              lines[0][o].l = n;
>       lines[1][n].l = o;                                              lines[1][n].l = o;
>                                                                 
>       // Remove the matched line numbers form the lists.              // Remove the matched line numbers form the lists.
>                                                                 
>       Line *line = lines[0][o].line;                                  Line *line = lines[0][o].line;
>       list<unsigned> &oldCopies = line->copies[0];                    list<unsigned> &oldCopies = line->copies[0];
>       list<unsigned>::iterator oL = find (oldCopies.begin (),         list<unsigned>::iterator oL = find (oldCopies.begin (),
>       if (oL != oldCopies.end ()) {                                   if (oL != oldCopies.end ()) {
>         oldCopies.erase (oL);                                           oldCopies.erase (oL);
>       }                                                               }
>       list<unsigned> &newCopies = line->copies[0];                    list<unsigned> &newCopies = line->copies[0];
>       list<unsigned>::iterator nL = find (newCopies.begin (),         list<unsigned>::iterator nL = find (newCopies.begin (),
>       if (nL != newCopies.end ()) {                                   if (nL != newCopies.end ()) {
>         newCopies.erase (nL);                                           newCopies.erase (nL);
>       }                                                               }
>                                                                 
>       nMatchedLines += 1;                                             nMatchedLines += 1;
>     }                                                               }
>     nMatchedBlocks += 1;                                            nMatchedBlocks += 1;
>   }                                                               }
>   nTotalMatchedLines += nMatchedLines;                            nTotalMatchedLines += nMatchedLines;
>   nTotalMatchedBlocks += nMatchedBlocks;                          nTotalMatchedBlocks += nMatchedBlocks;
>                                                                 
>   // Let's see the intermediate results.                          // Let's see the intermediate results.
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr,                                                fprintf (stderr,
>              " found %u/%u matched lines/blocks (%u/%u totals                " found %u/%u matched lines/blocks (%u/%u totals
>              nMatchedLines,                                                  nMatchedLines,
>              nMatchedBlocks,                                                 nMatchedBlocks,
>              nTotalMatchedLines,                                             nTotalMatchedLines,
>              nTotalMatchedBlocks                                             nTotalMatchedBlocks
>             );                                                              );
>     if (1 < optVerbose) {                                           if (1 < optVerbose) {
>       for (int f = 0; f < 2; f += 1) {                                for (int f = 0; f < 2; f += 1) {
>         fprintf (stderr, "# file #%d\n", f + 1);                        fprintf (stderr, "# file #%d\n", f + 1);
>         for (int l = 0; l < lines[f].size (); l += 1) {                 for (int l = 0; l < lines[f].size (); l += 1) {
>           fprintf (stderr, "#   [%d] ", l);                               fprintf (stderr, "#   [%d] ", l);
>           lines[f][l].Dump (stderr);                                      lines[f][l].Dump (stderr);
>         }                                                               }
>       }                                                               }
>     }                                                               }
>   }                                                               }
> }                                                               }
>                                                                 
> // Perform Pass #3, in which we attempt to 'widen' blocks of    // Perform Pass #3, in which we attempt to 'widen' blocks of 
> // lines, by prepending lines which are the same in both file   // lines, by prepending lines which are the same in both file
>                                                                 
> void pass3 ()                                                   void pass3 ()
> {                                                               {
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Pass #3 (spreading matches up)...");        fprintf (stderr, "# Pass #3 (spreading matches up)...");
>   }                                                               }
>                                                                 
>   nMatchedBlocks = 0;                                             nMatchedBlocks = 0;
>   nMatchedLines = 0;                                              nMatchedLines = 0;
>                                                                 
>   // Starting at the bottom of the old file,...                   // Starting at the bottom of the old file,...
>                                                                 
>   for (int o = lines[0].size (); 0 <= o; o -= 1) {                for (int o = lines[0].size (); 0 <= o; o -= 1) {
>                                                                 
>     // ... skip any currently unmatched lines...                    // ... skip any currently unmatched lines...
>                                                                 
>     if (lines[0][o].l == ~0) {                                      if (lines[0][o].l == ~0) {
>       continue;                                                       continue;
>     }                                                               }
>                                                                 
>     // ... until we find an [already] matched line.  Then, sk       // ... until we find an [already] matched line.  Then, sk
>     // the set of 1 or more matched lines, until we reach any       // the set of 1 or more matched lines, until we reach any
>     // following, still-unmatched line.                             // following, still-unmatched line.
>                                                                 
>     unsigned n;                                                     unsigned n;
>     do {                                                            do {
>       n = lines[0][o].l - 1;                                          n = lines[0][o].l - 1;
>       o -= 1;                                                         o -= 1;
>     } while (0 <= o && lines[0][o].l != ~0);                        } while (0 <= o && lines[0][o].l != ~0);
>                                                                 
>     // Now, o + 1 is the line number of the last matched old        // Now, o + 1 is the line number of the last matched old 
>     // n + 1 is the line number of the last matched new line.       // n + 1 is the line number of the last matched new line.
>     // to add new old and new lines, if they match.                 // to add new old and new lines, if they match.
>                                                                 
>     // Finally, attempt to add unmatched lines to the preceed       // Finally, attempt to add unmatched lines to the preceed
>     // matched set.                                                 // matched set.
>                                                                 
>     for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {         for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
>                                                                 
>       // If the [next] pair of old and new lines aren't the s         // If the [next] pair of old and new lines aren't the s
>                                                                 
>       if (lines[0][o].line != lines[1][n].line) {                     if (lines[0][o].line != lines[1][n].line) {
>         break;                                                          break;
>       }                                                               }
>                                                                 
>       // Match up the pair.                                           // Match up the pair.
>                                                                 
>       lines[0][o].l = n;                                              lines[0][o].l = n;
>       lines[1][n].l = o;                                              lines[1][n].l = o;
>                                                                 
>       // Remove the matched line numbers form the lists.              // Remove the matched line numbers form the lists.
>                                                                 
>       Line *line = lines[0][o].line;                                  Line *line = lines[0][o].line;
>       list<unsigned> &oldCopies = line->copies[0];                    list<unsigned> &oldCopies = line->copies[0];
>       list<unsigned>::iterator oL = find (oldCopies.begin (),         list<unsigned>::iterator oL = find (oldCopies.begin (),
>       if (oL != oldCopies.end ()) {                                   if (oL != oldCopies.end ()) {
>         oldCopies.erase (oL);                                           oldCopies.erase (oL);
>       }                                                               }
>       list<unsigned> &newCopies = line->copies[0];                    list<unsigned> &newCopies = line->copies[0];
>       list<unsigned>::iterator nL = find (newCopies.begin (),         list<unsigned>::iterator nL = find (newCopies.begin (),
>       if (nL != newCopies.end ()) {                                   if (nL != newCopies.end ()) {
>         newCopies.erase (nL);                                           newCopies.erase (nL);
>       }                                                               }
>                                                                 
>       nMatchedLines += 1;                                             nMatchedLines += 1;
>     }                                                               }
>     nMatchedBlocks += 1;                                            nMatchedBlocks += 1;
>   }                                                               }
>   nTotalMatchedLines += nMatchedLines;                            nTotalMatchedLines += nMatchedLines;
>                                                                 
>   // Let's see the intermediate results.                          // Let's see the intermediate results.
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr,                                                fprintf (stderr,
>              " found %u/%u matched lines/blocks (%u/%u totals                " found %u/%u matched lines/blocks (%u/%u totals
>              nMatchedLines,                                                  nMatchedLines,
>              nMatchedBlocks,                                                 nMatchedBlocks,
>              nTotalMatchedLines,                                             nTotalMatchedLines,
>              nTotalMatchedBlocks                                             nTotalMatchedBlocks
>             );                                                              );
>                                                                 
>     if (1 < optVerbose) {                                           if (1 < optVerbose) {
>       for (int f = 0; f < 2; f += 1) {                                for (int f = 0; f < 2; f += 1) {
>         fprintf (stderr, "# file #%d\n", f + 1);                        fprintf (stderr, "# file #%d\n", f + 1);
>         for (int l = 0; l < lines[f].size (); l += 1) {                 for (int l = 0; l < lines[f].size (); l += 1) {
>           fprintf (stderr, "#   [%d] ", l);                               fprintf (stderr, "#   [%d] ", l);
>           lines[f][l].Dump (stderr);                                      lines[f][l].Dump (stderr);
>         }                                                               }
>       }                                                               }
>     }                                                               }
>   }                                                               }
> }                                                               }
>                                                                 
> // Perform pass #4, in which we find any remaining matches am   // Perform pass #4, in which we find any remaining matches am
> // unique lines.  For every unique line that has more than 1    // unique lines.  For every unique line that has more than 1 
> // both files, we declare the copies to match.                  // both files, we declare the copies to match.
>                                                                 
> void pass4 ()                                                   void pass4 ()
> {                                                               {
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Pass 4 (finding remaining matches amo       fprintf (stderr, "# Pass 4 (finding remaining matches amo
>   }                                                               }
>                                                                 
>   nMatchedLines = 0;                                              nMatchedLines = 0;
>                                                                 
>   for (MapStringToLinePtr::iterator i = table.begin (); i !=      for (MapStringToLinePtr::iterator i = table.begin (); i != 
>     Line *l = i->second;                                            Line *l = i->second;
>                                                                 
>     // If there's more than 1 matching old and new lines, the       // If there's more than 1 matching old and new lines, the
>     // declare that each pair are (all) the same line.              // declare that each pair are (all) the same line.
>                                                                 
>     // (In the original algorithm, we only recognized a match       // (In the original algorithm, we only recognized a match
>     // if there was exactly 1 copy for each file.)                  // if there was exactly 1 copy for each file.)
>                                                                 
>     while (0 < l->copies[0].size () && 0 < l->copies[1].size        while (0 < l->copies[0].size () && 0 < l->copies[1].size 
>       nMatchedLines += 1;                                             nMatchedLines += 1;
>                                                                 
>       // For each matched line in the new file, mark it with          // For each matched line in the new file, mark it with 
>       // corresponding line (number) in the old file.                 // corresponding line (number) in the old file.
>                                                                 
>       unsigned o = l->copies[0].front ();                             unsigned o = l->copies[0].front ();
>       unsigned n = l->copies[1].front ();                             unsigned n = l->copies[1].front ();
>                                                                 
>       // Match up the pair.                                           // Match up the pair.
>                                                                 
>       lines[0][o].l = n;                                              lines[0][o].l = n;
>       lines[1][n].l = o;                                              lines[1][n].l = o;
>                                                                 
>       // Remove the matched line numbers from the lists.              // Remove the matched line numbers from the lists.
>                                                                 
>       l->copies[0].pop_front ();                                      l->copies[0].pop_front ();
>       l->copies[1].pop_front ();                                      l->copies[1].pop_front ();
>     }                                                               }
>   }                                                               }
>   nTotalMatchedLines += nMatchedLines;                            nTotalMatchedLines += nMatchedLines;
>                                                                 
>   // Let's see the intermediate results.                          // Let's see the intermediate results.
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, " found %u matched lines (%u total).\n",       fprintf (stderr, " found %u matched lines (%u total).\n",
>                                                                 
>     if (1 < optVerbose) {                                           if (1 < optVerbose) {
>       for (int f = 0; f < 2; f += 1) {                                for (int f = 0; f < 2; f += 1) {
>         fprintf (stderr, "# file #%d\n", f + 1);                        fprintf (stderr, "# file #%d\n", f + 1);
>         for (int l = 0; l < lines[f].size (); l += 1) {                 for (int l = 0; l < lines[f].size (); l += 1) {
>           fprintf (stderr, "#   [%d] ", l);                               fprintf (stderr, "#   [%d] ", l);
>           lines[f][l].Dump (stderr);                                      lines[f][l].Dump (stderr);
>         }                                                               }
>       }                                                               }
>     }                                                               }
>   }                                                               }
> }                                                               }
>                                                                 
> // Perform Pass #5, in which we look for blocks which match,    // Perform Pass #5, in which we look for blocks which match, 
> // the result of a move (their not in their original position   // the result of a move (their not in their original position
> // these, we'll unmatch the blocks, turning them into a delet   // these, we'll unmatch the blocks, turning them into a delet
> // insert.                                                      // insert.
>                                                                 
> void pass5 ()                                                   void pass5 ()
> {                                                               {
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Pass #5 (unmatching block moves)...\n       fprintf (stderr, "# Pass #5 (unmatching block moves)...\n
>   }                                                               }
>                                                                 
>   nMatchedBlocks = 0;                                             nMatchedBlocks = 0;
>   nMatchedLines = 0;                                              nMatchedLines = 0;
>                                                                 
>   // Starting at the top of both files,...                        // Starting at the top of both files,...
>                                                                 
>   unsigned o = 0;                                                 unsigned o = 0;
>   unsigned n = 0;                                                 unsigned n = 0;
>                                                                 
>   while (o < lines[0].size () || n < lines[1].size ()) {          while (o < lines[0].size () || n < lines[1].size ()) {
>                                                                 
>     // Skip any unmatched lines at this point in the old file       // Skip any unmatched lines at this point in the old file
>     // are deletes.                                                 // are deletes.
>                                                                 
>     //    Old     New                                               //    Old     New
>     //   +---+                                                      //   +---+
>     // 0 | a |                                                      // 0 | a |
>     //   +---+   +---+                                              //   +---+   +---+
>     //         0 | b |                                              //         0 | b |
>     //   +---+   +---+                                              //   +---+   +---+
>     // 1 | c | 1 | c |                                              // 1 | c | 1 | c |
>     //   +---+   +---+                                              //   +---+   +---+
>     //         2 | z |                                              //         2 | z |
>     //   +---+   +---+                                              //   +---+   +---+
>     // 2 | d | 3 | d |                                              // 2 | d | 3 | d |
>     //   +---+   +---+                                              //   +---+   +---+
>                                                                 
>     while (o < lines[0].size () && lines[0][o].l == ~0) {           while (o < lines[0].size () && lines[0][o].l == ~0) {
>       o += 1;                                                         o += 1;
>     }                                                               }
>                                                                 
>     // Skip any unmatched lines at this point in the new file       // Skip any unmatched lines at this point in the new file
>     // are inserts.                                                 // are inserts.
>                                                                 
>     while (n < lines[1].size () && lines[1][n].l == ~0) {           while (n < lines[1].size () && lines[1][n].l == ~0) {
>       n += 1;                                                         n += 1;
>     }                                                               }
>                                                                 
>     // When we get here, we know that we're dealing with matc       // When we get here, we know that we're dealing with matc
>     // lines (or the end of one or both files).  We're done w       // lines (or the end of one or both files).  We're done w
>     // pass, if we've reached the end of either file.               // pass, if we've reached the end of either file.
>                                                                 
>     if (lines[0].size () <= o || lines[1].size () <= n) {           if (lines[0].size () <= o || lines[1].size () <= n) {
>       break;                                                          break;
>     }                                                               }
>                                                                 
>     // We now know that we've got a pair of matching lines, t       // We now know that we've got a pair of matching lines, t
>     // of a matching block.  If the new file's line number is       // of a matching block.  If the new file's line number is
>     // expect, then the matched pair is unmoved, and we can s       // expect, then the matched pair is unmoved, and we can s
>     // the pair.  (If this is really the start of a block of        // the pair.  (If this is really the start of a block of 
>     // 1 lines, we'll handle it one pair at a time.)                // 1 lines, we'll handle it one pair at a time.)
>                                                                 
>     if (lines[0][o].l == n) {                                       if (lines[0][o].l == n) {
>       o += 1;                                                         o += 1;
>       n += 1;                                                         n += 1;
>       continue;                                                       continue;
>     }                                                               }
>                                                                 
>     // If, on the other hand, we don't expect this [new] line       // If, on the other hand, we don't expect this [new] line
>     // then this matching block has been moved.  We need to t       // then this matching block has been moved.  We need to t
>     // matched pair into an *unmatched* pair, one of deletes,       // matched pair into an *unmatched* pair, one of deletes,
>     // of inserts.  First, though, we need to know how big th       // of inserts.  First, though, we need to know how big th
>     // is, and how far it was moved....                             // is, and how far it was moved....
>                                                                 
>     // Remember where we were when we started.                      // Remember where we were when we started.
>                                                                 
>     unsigned oOld = o;                                              unsigned oOld = o;
>     unsigned nOld = n;                                              unsigned nOld = n;
>                                                                 
>     // Remember where the block came from.                          // Remember where the block came from.
>                                                                 
>     unsigned nNew = lines[0][o].l;                                  unsigned nNew = lines[0][o].l;
>                                                                 
>     // Find the end of this matched pair.                           // Find the end of this matched pair.
>                                                                 
>     for (n = nNew; o < lines[0].size () && n < lines[1].size        for (n = nNew; o < lines[0].size () && n < lines[1].size 
>       if (lines[0][o].l != n) {                                       if (lines[0][o].l != n) {
>         break;                                                          break;
>       }                                                               }
>     }                                                               }
>                                                                 
>     // When we get here:                                            // When we get here:
>     // * oOld..o is the old file's block,                           // * oOld..o is the old file's block,
>     // * nNew..n is the new file's *moved* block, and               // * nNew..n is the new file's *moved* block, and
>     // * nOld is where we originally expected the new block f       // * nOld is where we originally expected the new block f
>                                                                  
>     // We can now calculate the length of the block...              // We can now calculate the length of the block...
>                                                                     
>     unsigned bSize = o - oOld;  // (or n - nNew)                    unsigned bSize = o - oOld;  // (or n - nNew)
>                                                                 
>     // ... and we can calculate how far the block moved:            // ... and we can calculate how far the block moved:
>                                                                 
>     unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;       unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
>                                                                 
>     // The larger of the two will become our delete, and the        // The larger of the two will become our delete, and the 
>     // will become our insert.                                      // will become our insert.
>                                                                 
>     //    Old     New                                               //    Old     New
>     //   +---+   +---+                                              //   +---+   +---+
>     // 0 | a | 0 | b |                                              // 0 | a | 0 | b |
>     //   +---+ 1 | b |                                              //   +---+ 1 | b |
>     // 1 | b |   +---+                                              // 1 | b |   +---+
>     // 2 | b | 2 | a |                                              // 2 | b | 2 | a |
>     //   +---+   +---+                                              //   +---+   +---+
>     // 3 | c | 3 | c |                                              // 3 | c | 3 | c |
>     //   +---+   +---+                                              //   +---+   +---+
>                                                                 
>     // (1) Delete a@0, insert a@2, or                               // (1) Delete a@0, insert a@2, or
>     // (2) insert bb@0, delete bb@1?                                // (2) insert bb@0, delete bb@1?
>                                                                 
>     // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and       // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and
>     // (of a) is 2-0 or 2, the size of b@0.  We choose to del       // (of a) is 2-0 or 2, the size of b@0.  We choose to del
>     // and reinsert a@2.                                            // and reinsert a@2.
>                                                                 
>     // if (bSize <= bMove) {                                        // if (bSize <= bMove) {
>       for (unsigned a = oOld; a < o; a += 1) {                        for (unsigned a = oOld; a < o; a += 1) {
>         lines[0][a].l = ~0;                                             lines[0][a].l = ~0;
>       }                                                               }
>       for (unsigned d = nNew; d < n; d += 1) {                        for (unsigned d = nNew; d < n; d += 1) {
>         lines[1][d].l = ~0;                                             lines[1][d].l = ~0;
>       }                                                               }
>     // } else {                                                     // } else {
>       // for (unsigned a = oOld; a < o; a += 1) {                     // for (unsigned a = oOld; a < o; a += 1) {
>       //   lines[0][a].l = ~0;                                        //   lines[0][a].l = ~0;
>       // }                                                            // }
>       // for (unsigned d = nNew; d < n; d += 1) {                     // for (unsigned d = nNew; d < n; d += 1) {
>       //   lines[1][d].l = ~0;                                        //   lines[1][d].l = ~0;
>       // }                                                            // }
>     // }                                                            // }
>                                                                 
>     // Continue from where we left off.                             // Continue from where we left off.
>                                                                 
>     n = nOld;                                                       n = nOld;
>   }                                                               }
>   nTotalMatchedLines -= nMatchedLines;                            nTotalMatchedLines -= nMatchedLines;
>   nTotalMatchedBlocks -= nMatchedBlocks;                          nTotalMatchedBlocks -= nMatchedBlocks;
>                                                                 
>   // Let's see the intermediate results.                          // Let's see the intermediate results.
>                                                                 
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr,                                                fprintf (stderr,
>              " found %u/%u matched lines/blocks (%u/%u totals                " found %u/%u matched lines/blocks (%u/%u totals
>              nMatchedLines,                                                  nMatchedLines,
>              nMatchedBlocks,                                                 nMatchedBlocks,
>              nTotalMatchedLines,                                             nTotalMatchedLines,
>              nTotalMatchedBlocks                                             nTotalMatchedBlocks
>             );                                                              );
>                                                                 
>     if (1 < optVerbose) {                                           if (1 < optVerbose) {
>       for (int f = 0; f < 2; f += 1) {                                for (int f = 0; f < 2; f += 1) {
>         fprintf (stderr, "# file #%d\n", f + 1);                        fprintf (stderr, "# file #%d\n", f + 1);
>         for (int l = 0; l < lines[f].size (); l += 1) {                 for (int l = 0; l < lines[f].size (); l += 1) {
>           fprintf (stderr, "#   [%d] ", l);                               fprintf (stderr, "#   [%d] ", l);
>           lines[f][l].Dump (stderr);                                      lines[f][l].Dump (stderr);
>         }                                                               }
>       }                                                               }
>     }                                                               }
>   }                                                               }
> }                                                               }
>                                                                 
> // Perform Pass #6, in which we create the desired output.      // Perform Pass #6, in which we create the desired output.
>                                                                 
> void pass6c ();                                                 void pass6c ();
> void pass6e ();                                                 void pass6e ();
> void pass6i ();                                                 void pass6i ();
> void pass6n ();                                                 void pass6n ();
> void pass6r ();                                                 void pass6r ();
> void pass6s ();                                                 void pass6s ();
> void pass6u ();                                                 void pass6u ();
>                                                                 
> void pass6 ()                                                   void pass6 ()
> {                                                               {
>                                                                 
>   switch (diffFormat) {                                           switch (diffFormat) {
>   case Context:                                                   case Context:
>     pass6c ();                                                      pass6c ();
>     break;                                                          break;
>                                                                 
>   case EdScript:                                                  case EdScript:
>     pass6e ();                                                      pass6e ();
>     break;                                                          break;
>                                                                 
>   case IfThenElse:                                                case IfThenElse:
>     pass6i ();                                                      pass6i ();
>     break;                                                          break;
>                                                                 
>   case Normal:                                                    case Normal:
>     pass6n ();                                                      pass6n ();
>     break;                                                          break;
>                                                                 
>   case RCS:                                                       case RCS:
>     pass6r ();                                                      pass6r ();
>     break;                                                          break;
>                                                                 
>   case SideBySide:                                                case SideBySide:
>     pass6s ();                                                      pass6s ();
>     break;                                                          break;
>                                                                 
>   case Unified:                                                   case Unified:
>     pass6u ();                                                      pass6u ();
>     break;                                                          break;
>                                                                 
>   case Default:                                                   case Default:
>   default:                                                        default:
>     pass6c ();                                                      pass6c ();
>     break;                                                          break;
>   }                                                               }
> }                                                               }
>                                                                 
> template<typename T> T min (T l, T r) {                         template<typename T> T min (T l, T r) {
>   if (l < r) {                                                    if (l < r) {
>     return l;                                                       return l;
>   }                                                               }
>   return r;                                                       return r;
> }                                                               }
>                                                                 
> template<typename T> T max (T l, T r) {                         template<typename T> T max (T l, T r) {
>   if (l < r) {                                                    if (l < r) {
>     return r;                                                       return r;
>   }                                                               }
>   return l;                                                       return l;
> }                                                               }
>                                                                 
> void pass6c () {                                                void pass6c () {
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Pass #6u (walking the differences)...       fprintf (stderr, "# Pass #6u (walking the differences)...
>   }                                                               }
>                                                                 
>   nMatchedLines = 0;                                              nMatchedLines = 0;
>                                                                 
>   // Write the header.                                            // Write the header.
>                                                                 
>   fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:0     fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:0
>   fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:0     fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:0
>                                                                 
>   // Starting at the top of both files,...                        // Starting at the top of both files,...
>                                                                 
>   unsigned o = 0;                                                 unsigned o = 0;
>   unsigned n = 0;                                                 unsigned n = 0;
>                                                                 
>   while (o < lines[0].size () || n < lines[1].size ()) {          while (o < lines[0].size () || n < lines[1].size ()) {
>                                                                 
>     // Find the bounds of the current contextual 'window'.    |     // Find any unmatched lines at this point in the old file
>                                                               >     // are deletes.
>                                                                 
>     // If we aren't looking at a delete or an insert, we're n |     unsigned boDeletes;
>     // start of a context window.                             |     for (boDeletes = o;
>                                                               >          o < lines[0].size () && lines[0][o].l == ~0;
>                                                               >          o += 1
>                                                               >         )
>                                                               >     {}
>                                                                 
>     if (lines[0][o].l != ~0 && lines[1][n].l != ~0) {         |     // Find any unmatched lines at this point in the new file
>       o += 1;                                                 |     // are inserts.
>       n += 1;                                                 <
>       continue;                                               <
>     }                                                         <
>                                                                 
>     // We're looking at at least 1 delete or insert, so a win |     unsigned boInserts;
>     // begins here (or, rather, optCopyContext lines earlier) |     for (boInserts = n;
>                                                               |          n < lines[1].size () && lines[1][n].l == ~0;
>     int boOldWindow = max (0, int (boDeletes) - int(optCopyCo |          n += 1
>     int eoOldWindow = min (int (lines[0].size ()), int(o) + i |         )
>                                                               >     {}
>                                                                 
>     // Look for the end of the window.                        |     // We've got deleted line(s) from boDeletes .. o.
>                                                               >     // We've got deleted line(s) from boInserts .. n.
>                                                                 
>     bool widenWindow = false;                                 |     unsigned nDeletes = o - boDeletes;
>     do {                                                      |     unsigned nInserts = n - boInserts;
>                                                                 
>       // Skip over the delete(s) and/or insert(s) defining th |     // Have we got anything?
>       // context.                                             <
>                                                                 
>       while (o < lines[0].size () && lines[0][o].l == ~0) {   |     if (nDeletes || nInserts) {
>         o += 1;                                               |       int boOldWindow = max (0, int (boDeletes) - int(optCopy
>       }                                                       |       int eoOldWindow = min (int (lines[0].size ()), int(o) +
755,759c762,766
<         n += 1;						      <
<       }							      <
< 							      <
<       // ...  This context will end optCopyContext lines past <
<       // set of deletes or inserts we find.  However, since a <
---
>         n += 1;                                               <
>       }                                                       <
>                                                                 
>       // ...  This context will end optCopyContext lines past |       int boNewWindow = max (0, int (boInserts) - int (optCop
>       // set of deletes or inserts we find.  However, since a |       int eoNewWindow = min (int (lines[1].size ()), int(n) +
761,780c768,787
<       // another delete or insert.			      <
< 							      <
<       for (unsigned l = 0; l < (2 * optCopyContext); i += 1)  <
<         if (o < lines[0].size ()) {			      <
<           if (widenWindow |= lines[0][o].l == ~0) {	      <
<             break;					      <
<           }						      <
<           o += 1;					      <
<         }						      <
<         if (n < lines[1].size ()) {			      <
<           if (widenWindow |= lines[1][o].l == ~0) {	      <
<             break;					      <
<           }						      <
<           n += 1;					      <
<         }						      <
<       }							      <
<     } while (widenWindow);				      <
< 							      <
<     // We've found the end of the window.		      <
< 							      <
---
>       // another delete or insert.                            <
>                                                                 
>       for (unsigned l = 0; l < (2 * optCopyContext); i += 1)  |       fprintf (stdout, "***************\n*** %d,%d ****", boO
>         if (o < lines[0].size ()) {                           |       for (unsigned l = boOldWindow; l < boDeletes; l += 1) {
>           if (widenWindow |= lines[0][o].l == ~0) {           |         fprintf (stdout, "  %s", lines[0][l].line->c_str ());
>             break;                                            |       }
>           }                                                   <
>           o += 1;                                             <
>         }                                                     <
>         if (n < lines[1].size ()) {                           <
>           if (widenWindow |= lines[1][o].l == ~0) {           <
>             break;                                            <
>           }                                                   <
>           n += 1;                                             <
>         }                                                     <
>       }                                                       <
>     } while (widenWindow);                                    <
>                                                               <
>     // We've found the end of the window.                     <
>                                                               <
783c790
< 							      <
---
>                                                               <
786,858c793,849
<     // file part, then for the new file part.		      <
< 
<     fprintf (stdout, "***************\n");		      |	    unsigned boDeletes;
<     fprintf (stdout, "*** %d,%d ****\n", boOldWindow + 1, eoO |	    for (boDeletes = o;
< 							      >	         o < lines[0].size () && lines[0][o].l == ~0;
< 							      >	         o += 1
< 							      >	        )
< 							      >	    {}
< 
<     o = boOldWindow;					      |	    // Find any unmatched lines at this point in the new file
<     n = boNewWindow;					      |	    // are inserts.
< 
<     while (o < eoOldWindow && n < eoNewWindow) {	      |	    unsigned boInserts;
< 							      >	    for (boInserts = n;
< 							      >	         n < lines[1].size () && lines[1][n].l == ~0;
< 							      >	         n += 1
< 							      >	        )
< 							      >	    {}
< 
<       // Find any unmatched lines at this point in the old fi |	    // We've got deleted line(s) from boDeletes .. o.
<       // are deletes.					      |	    // We've got deleted line(s) from boInserts .. n.
< 
<       unsigned boDeletes = o;				      |	    unsigned nDeletes = o - boDeletes;
<       while (o < eoOldWindow && lines[0][o].l == ~0) {	      |	    unsigned nInserts = n - boInserts;
<         o += 1;						      <
<       }							      <
< 
<       // Find any unmatched lines at this point in the new fi |	    // Have we got anything?
<       // are inserts.					      <
< 
<       unsigned boInserts = n;				      |	    if (nDeletes || nInserts) {
<       while (n < eoNewWindow && lines[1][n].l == ~0) {	      |	      int boOldWindow = max (0, int (boDeletes) - int(optCopy
<         n += 1;						      |	      int eoOldWindow = min (int (lines[0].size ()), int(o) +
< 							      >
< 							      >	      int boNewWindow = max (0, int (boInserts) - int (optCop
< 							      >	      int eoNewWindow = min (int (lines[1].size ()), int(n) +
< 							      >
< 							      >	      fprintf (stdout, "***************\n*** %d,%d ****", boO
< 							      >	      for (unsigned l = boOldWindow; l < boDeletes; l += 1) {
< 							      >	        fprintf (stdout, "  %s", lines[0][l].line->c_str ());
<       }								      }
< 
<       // We've got deleted line(s) from boDeletes .. o.	      <
<       // We've got deleted line(s) from boInserts .. n.	      <
< 							      <
<       unsigned nDeletes = o - boDeletes;		      <
<       unsigned nInserts = n - boInserts;		      <
< 							      <
<       // We've got...						      // We've got...
< 
<       if (nDeletes && nInserts) {				      if (nDeletes && nInserts) {
< 
<         // ... deletes and inserts.				        // ... deletes and inserts.
< 
<         for (unsigned l = boDeletes; l < o; l += 1) {		        for (unsigned l = boDeletes; l < o; l += 1) {
<           fprintf (stdout, "! %s", lines[0][l].line->c_str ()	          fprintf (stdout, "! %s", lines[0][l].line->c_str ()
<         }							        }
<       } else if (nDeletes) {					      } else if (nDeletes) {
< 
<         //  ... just deletes.					        //  ... just deletes.
< 
<         for (unsigned l = boDeletes; l < o; l += 1) {		        for (unsigned l = boDeletes; l < o; l += 1) {
<           fprintf (stdout, "- %s", lines[0][l].line->c_str ()	          fprintf (stdout, "- %s", lines[0][l].line->c_str ()
<         }							        }
<       }								      }
< 
<       // When we get here, we're dealing with matching lines. |	      for (unsigned l = o; l < eoOldWindow; l += 1) {
< 							      |	        fprintf (stdout, "  %s", lines[0][l].line->c_str ());
<       fprintf (stdout, "  %s", lines[0][l].line->c_str ());   <
<       o += 1;						      <
<       n += 1;						      <
<     }							      <
< 							      <
---
>     // file part, then for the new file part.                 <
>                                                               <
>     fprintf (stdout, "***************\n");                    <
>     fprintf (stdout, "*** %d,%d ****\n", boOldWindow + 1, eoO <
>                                                               <
>     o = boOldWindow;                                          <
>     n = boNewWindow;                                          <
>                                                               <
>     while (o < eoOldWindow && n < eoNewWindow) {              <
>                                                               <
>       // Find any unmatched lines at this point in the old fi <
>       // are deletes.                                         <
>                                                               <
>       unsigned boDeletes = o;                                 <
>       while (o < eoOldWindow && lines[0][o].l == ~0) {        <
>         o += 1;                                               <
>       }                                                       <
>                                                               <
>       // Find any unmatched lines at this point in the new fi <
>       // are inserts.                                         <
>                                                               <
>       unsigned boInserts = n;                                 <
>       while (n < eoNewWindow && lines[1][n].l == ~0) {        <
>         n += 1;                                               <
>       }                                                       <
>                                                               <
>       // We've got deleted line(s) from boDeletes .. o.       <
>       // We've got deleted line(s) from boInserts .. n.       <
>                                                               <
>       unsigned nDeletes = o - boDeletes;                      <
>       unsigned nInserts = n - boInserts;                      <
>                                                                 
>       // We've got...                                                 // We've got...
>                                                                 
>       if (nDeletes && nInserts) {                                     if (nDeletes && nInserts) {
>                                                                 
>         // ... deletes and inserts.                                     // ... deletes and inserts.
>                                                                 
>         for (unsigned l = boDeletes; l < o; l += 1) {                   for (unsigned l = boDeletes; l < o; l += 1) {
>           fprintf (stdout, "! %s", lines[0][l].line->c_str ()             fprintf (stdout, "! %s", lines[0][l].line->c_str ()
>         }                                                               }
>       } else if (nDeletes) {                                          } else if (nDeletes) {
>                                                                 
>         //  ... just deletes.                                           //  ... just deletes.
>                                                                 
>         for (unsigned l = boDeletes; l < o; l += 1) {                   for (unsigned l = boDeletes; l < o; l += 1) {
>           fprintf (stdout, "- %s", lines[0][l].line->c_str ()             fprintf (stdout, "- %s", lines[0][l].line->c_str ()
>         }                                                               }
>       }                                                               }
>                                                                 
>       // When we get here, we're dealing with matching lines. |       for (unsigned l = o; l < eoOldWindow; l += 1) {
>                                                               |         fprintf (stdout, "  %s", lines[0][l].line->c_str ());
>       fprintf (stdout, "  %s", lines[0][l].line->c_str ());   |       }
>       o += 1;                                                 |       fprintf (stdout, "--- %d,%d ----", boNewWindow, eoNewWi
>       n += 1;                                                 |       for (unsigned l = boNewWindow; l < boInserts; l += 1) {
>     }                                                         |         fprintf (stdout, "  %s", lines[1][l].line->c_str ());
>                                                               |       }
860,865c851,856
< 							      <
<     o = boOldWindow;					      <
<     n = boNewWindow;					      <
< 							      <
<     while (o < eoOldWindow && n < eoNewWindow) {	      <
< 							      <
---
>                                                               <
>     o = boOldWindow;                                          <
>     n = boNewWindow;                                          <
>                                                               <
>     while (o < eoOldWindow && n < eoNewWindow) {              <
>                                                               <
867,1109c858,1098
<       // are deletes.					      <
< 							      <
<       unsigned boDeletes = o;				      <
<       while (o < eoOldWindow && lines[0][o].l == ~0) {	      <
<         o += 1;						      <
<       }								      }
< 							      |	      fprintf (stdout, "--- %d,%d ----", boNewWindow, eoNewWi
<       // Find any unmatched lines at this point in the new fi |	      for (unsigned l = boNewWindow; l < boInserts; l += 1) {
<       // are inserts.					      |	        fprintf (stdout, "  %s", lines[1][l].line->c_str ());
< 							      <
<       unsigned boInserts = n;				      <
<       while (n < eoNewWindow && lines[1][n].l == ~0) {	      <
<         n += 1;						      <
<       }								      }
< 
<       // We've got deleted line(s) from boDeletes .. o.	      <
<       // We've got deleted line(s) from boInserts .. n.	      <
< 							      <
<       unsigned nDeletes = o - boDeletes;		      <
<       unsigned nInserts = n - boInserts;		      <
< 							      <
<       // We've got...						      // We've got...
< 
<       if (nDeletes && nInserts) {				      if (nDeletes && nInserts) {
< 
<         // ... deletes and inserts.				        // ... deletes and inserts.
< 
<         for (unsigned l = boInserts; l < n; l += 1) {		        for (unsigned l = boInserts; l < n; l += 1) {
<           fprintf (stdout, "! %s", lines[1][l].line->c_str ()	          fprintf (stdout, "! %s", lines[1][l].line->c_str ()
<         }							        }
<       } else if (nInserts) {					      } else if (nInserts) {
< 
<         //  ... just inserts.					        //  ... just inserts.
< 
<         for (unsigned l = boInserts; l < n; l += 1) {		        for (unsigned l = boInserts; l < n; l += 1) {
<           fprintf (stdout, "+ %s", lines[1][l].line->c_str ()	          fprintf (stdout, "+ %s", lines[1][l].line->c_str ()
<         }							        }
<       }								      }
< 
<       // When we get here, we're dealing with matching lines. |	      for (unsigned l = n; l < eoNewWindow; l += 1) {
< 							      |	        fprintf (stdout, "  %s", lines[1][l].line->c_str ());
<       fprintf (stdout, "  %s", lines[1][l].line->c_str ());   |	      }
<       o += 1;						      <
<       n += 1;						      <
<     }								    }
< 							      >
< 							      >	    // When we get here, we're dealing with matching lines.
< 							      >
< 							      >	    o += 1;
< 							      >	    n += 1;
<   }								  }
< }								}
< 
< void pass6e () {						void pass6e () {
< }								}
< 
< void pass6i () {						void pass6i () {
< }								}
< 
< void pass6n ()							void pass6n ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #6n (walking the differences)...	    fprintf (stderr, "# Pass #6n (walking the differences)...
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Write the header.  (None for normal.)			  // Write the header.  (None for normal.)
< 
<   // Starting at the top of both files,...			  // Starting at the top of both files,...
< 
<   unsigned o = 0;						  unsigned o = 0;
<   unsigned n = 0;						  unsigned n = 0;
< 
<   while (o < lines[0].size () || n < lines[1].size ()) {	  while (o < lines[0].size () || n < lines[1].size ()) {
< 
<     // Find any unmatched lines at this point in the old file	    // Find any unmatched lines at this point in the old file
<     // are deletes.						    // are deletes.
< 
<     unsigned boDeletes;						    unsigned boDeletes;
<     for (boDeletes = o;						    for (boDeletes = o;
<          o < lines[0].size () && lines[0][o].l == ~0;		         o < lines[0].size () && lines[0][o].l == ~0;
<          o += 1							         o += 1
<         )							        )
<     {}								    {}
< 
<     // Find any unmatched lines at this point in the new file	    // Find any unmatched lines at this point in the new file
<     // are inserts.						    // are inserts.
< 
<     unsigned boInserts;						    unsigned boInserts;
<     for (boInserts = n;						    for (boInserts = n;
<          n < lines[1].size () && lines[1][n].l == ~0;		         n < lines[1].size () && lines[1][n].l == ~0;
<          n += 1							         n += 1
<         )							        )
<     {}								    {}
< 
<     // We've got deleted line(s) from boDeletes .. o.		    // We've got deleted line(s) from boDeletes .. o.
<     // We've got deleted line(s) from boInserts .. n.		    // We've got deleted line(s) from boInserts .. n.
< 
<     unsigned nDeletes = o - boDeletes;				    unsigned nDeletes = o - boDeletes;
<     unsigned nInserts = n - boInserts;				    unsigned nInserts = n - boInserts;
< 
<     // We've got...						    // We've got...
< 
<     if (nDeletes && nInserts) {					    if (nDeletes && nInserts) {
< 
<       // ... deletes and inserts.				      // ... deletes and inserts.
< 
<       if (1 < nDeletes && 1 < nInserts) {			      if (1 < nDeletes && 1 < nInserts) {
<         fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, b	        fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, b
<       } else if (1 < nDeletes) {				      } else if (1 < nDeletes) {
<         fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boIn	        fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boIn
<       } else if (1 < nInserts) {				      } else if (1 < nInserts) {
<         fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInser	        fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInser
<       } 							      } 
<       for (unsigned l = boDeletes; l < o; l += 1) {		      for (unsigned l = boDeletes; l < o; l += 1) {
<         fprintf (stdout, "< %s", lines[0][l].line->c_str ());	        fprintf (stdout, "< %s", lines[0][l].line->c_str ());
<       }								      }
<       fprintf (stderr, "---\n");				      fprintf (stderr, "---\n");
<       for (unsigned l = boInserts; l < n; l += 1) {		      for (unsigned l = boInserts; l < n; l += 1) {
<         fprintf (stdout, "> %s", lines[1][l].line->c_str ());	        fprintf (stdout, "> %s", lines[1][l].line->c_str ());
<       }								      }
<     } else if (nDeletes) {					    } else if (nDeletes) {
< 
<       //  ... just deletes.					      //  ... just deletes.
< 
<       if (1 < nDeletes) {					      if (1 < nDeletes) {
<         fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);	        fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
<       } else {							      } else {
<         fprintf (stdout, "%dd%d\n", boDeletes + 1, n);		        fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
<       }								      }
<       for (unsigned l = boDeletes; l < o; l += 1) {		      for (unsigned l = boDeletes; l < o; l += 1) {
<         fprintf (stdout, "< %s", lines[0][l].line->c_str ());	        fprintf (stdout, "< %s", lines[0][l].line->c_str ());
<       }								      }
<     } else if (nInserts) {					    } else if (nInserts) {
< 
<       //  ... just inserts.					      //  ... just inserts.
< 
<       if (1 < nInserts) {					      if (1 < nInserts) {
<         fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);	        fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
<       } else {							      } else {
<         fprintf (stdout, "%da%d\n", o, boInserts + 1);		        fprintf (stdout, "%da%d\n", o, boInserts + 1);
<       }								      }
<       for (unsigned l = boInserts; l < n; l += 1) {		      for (unsigned l = boInserts; l < n; l += 1) {
<         fprintf (stdout, "> %s", lines[1][l].line->c_str ());	        fprintf (stdout, "> %s", lines[1][l].line->c_str ());
<       }								      }
<     }								    }
< 
<     // When we get here, we're dealing with matching lines.	    // When we get here, we're dealing with matching lines.
< 
<     o += 1;							    o += 1;
<     n += 1;							    n += 1;
<   }								  }
< }								}
< 
< void pass6r () {						void pass6r () {
< }								}
< 
< void pass6s () {						void pass6s () {
< }								}
< 
< void pass6u ()							void pass6u ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #6u (walking the differences)...	    fprintf (stderr, "# Pass #6u (walking the differences)...
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Write the header.						  // Write the header.
< 
<   fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:0	  fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:0
<   fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:0	  fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:0
<   fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), l	  fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), l
< 
<   // Starting at the top of both files,...			  // Starting at the top of both files,...
< 
<   unsigned o = 0;						  unsigned o = 0;
<   unsigned n = 0;						  unsigned n = 0;
< 
<   while (o < lines[0].size () || n < lines[1].size ()) {	  while (o < lines[0].size () || n < lines[1].size ()) {
< 
<     // Find any unmatched lines at this point in the old file	    // Find any unmatched lines at this point in the old file
<     // are deletes.						    // are deletes.
< 
<     unsigned boDeletes;						    unsigned boDeletes;
<     for (boDeletes = o;						    for (boDeletes = o;
<          o < lines[0].size () && lines[0][o].l == ~0;		         o < lines[0].size () && lines[0][o].l == ~0;
<          o += 1							         o += 1
<         )							        )
<     {}								    {}
< 
<     // Find any unmatched lines at this point in the new file	    // Find any unmatched lines at this point in the new file
<     // are inserts.						    // are inserts.
< 
<     unsigned boInserts;						    unsigned boInserts;
<     for (boInserts = n;						    for (boInserts = n;
<          n < lines[1].size () && lines[1][n].l == ~0;		         n < lines[1].size () && lines[1][n].l == ~0;
<          n += 1							         n += 1
<         )							        )
<     {}								    {}
< 
<     // We've got deleted line(s) from boDeletes .. o.		    // We've got deleted line(s) from boDeletes .. o.
<     // We've got deleted line(s) from boInserts .. n.		    // We've got deleted line(s) from boInserts .. n.
< 
<     unsigned nDeletes = o - boDeletes;				    unsigned nDeletes = o - boDeletes;
<     unsigned nInserts = n - boInserts;				    unsigned nInserts = n - boInserts;
< 
<     // We've got...						    // We've got...
< 
<     if (nDeletes && nInserts) {					    if (nDeletes && nInserts) {
< 
<       // ... deletes and inserts.				      // ... deletes and inserts.
< 
<       for (unsigned l = boDeletes; l < o; l += 1) {		      for (unsigned l = boDeletes; l < o; l += 1) {
<         fprintf (stdout, "-%s", lines[0][l].line->c_str ());	        fprintf (stdout, "-%s", lines[0][l].line->c_str ());
<       }								      }
<       for (unsigned l = boInserts; l < n; l += 1) {		      for (unsigned l = boInserts; l < n; l += 1) {
<         fprintf (stdout, "+%s", lines[1][l].line->c_str ());	        fprintf (stdout, "+%s", lines[1][l].line->c_str ());
<       }								      }
<     } else if (nDeletes) {					    } else if (nDeletes) {
< 
<       //  ... just deletes.					      //  ... just deletes.
< 
<       for (unsigned l = boDeletes; l < o; l += 1) {		      for (unsigned l = boDeletes; l < o; l += 1) {
<         fprintf (stdout, "-%s", lines[0][l].line->c_str ());	        fprintf (stdout, "-%s", lines[0][l].line->c_str ());
<       }								      }
<     } else if (nInserts) {					    } else if (nInserts) {
< 
<       //  ... just inserts.					      //  ... just inserts.
< 
<       for (unsigned l = boInserts; l < n; l += 1) {		      for (unsigned l = boInserts; l < n; l += 1) {
<         fprintf (stdout, "+%s", lines[1][l].line->c_str ());	        fprintf (stdout, "+%s", lines[1][l].line->c_str ());
<       }								      }
<     }								    }
< 
<     // When we get here, we're dealing with matching lines.	    // When we get here, we're dealing with matching lines.
< 
<     fprintf (stdout, " %s", lines[0][o].line->c_str ());	    fprintf (stdout, " %s", lines[0][o].line->c_str ());
<     o += 1;							    o += 1;
<     n += 1;							    n += 1;
<   }								  }
< }								}
---
>       // are deletes.                                         <
>                                                               <
>       unsigned boDeletes = o;                                 <
>       while (o < eoOldWindow && lines[0][o].l == ~0) {        <
>         o += 1;                                               <
>       }                                                       <
>                                                               <
>       // Find any unmatched lines at this point in the new fi <
>       // are inserts.                                         <
>                                                               <
>       unsigned boInserts = n;                                 <
>       while (n < eoNewWindow && lines[1][n].l == ~0) {        <
>         n += 1;                                               <
>       }                                                       <
>                                                               <
>       // We've got deleted line(s) from boDeletes .. o.       <
>       // We've got deleted line(s) from boInserts .. n.       <
>                                                               <
>       unsigned nDeletes = o - boDeletes;                      <
>       unsigned nInserts = n - boInserts;                      <
>                                                                 
>       // We've got...                                                 // We've got...
>                                                                 
>       if (nDeletes && nInserts) {                                     if (nDeletes && nInserts) {
>                                                                 
>         // ... deletes and inserts.                                     // ... deletes and inserts.
>                                                                 
>         for (unsigned l = boInserts; l < n; l += 1) {                   for (unsigned l = boInserts; l < n; l += 1) {
>           fprintf (stdout, "! %s", lines[1][l].line->c_str ()             fprintf (stdout, "! %s", lines[1][l].line->c_str ()
>         }                                                               }
>       } else if (nInserts) {                                          } else if (nInserts) {
>                                                                 
>         //  ... just inserts.                                           //  ... just inserts.
>                                                                 
>         for (unsigned l = boInserts; l < n; l += 1) {                   for (unsigned l = boInserts; l < n; l += 1) {
>           fprintf (stdout, "+ %s", lines[1][l].line->c_str ()             fprintf (stdout, "+ %s", lines[1][l].line->c_str ()
>         }                                                               }
>       }                                                               }
>                                                                 
>       // When we get here, we're dealing with matching lines. |       for (unsigned l = n; l < eoNewWindow; l += 1) {
>                                                               |         fprintf (stdout, "  %s", lines[1][l].line->c_str ());
>       fprintf (stdout, "  %s", lines[1][l].line->c_str ());   |       }
>       o += 1;                                                 |     }
>       n += 1;                                                 | 
>     }                                                         |     // When we get here, we're dealing with matching lines.
>                                                               > 
>                                                               >     o += 1;
>                                                               >     n += 1;
>   }                                                               }
> }                                                               }
>                                                                 
> void pass6e () {                                                void pass6e () {
> }                                                               }
>                                                                 
> void pass6i () {                                                void pass6i () {
> }                                                               }
>                                                                 
> void pass6n ()                                                  void pass6n ()
> {                                                               {
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Pass #6n (walking the differences)...       fprintf (stderr, "# Pass #6n (walking the differences)...
>   }                                                               }
>                                                                 
>   nMatchedLines = 0;                                              nMatchedLines = 0;
>                                                                 
>   // Write the header.  (None for normal.)                        // Write the header.  (None for normal.)
>                                                                 
>   // Starting at the top of both files,...                        // Starting at the top of both files,...
>                                                                 
>   unsigned o = 0;                                                 unsigned o = 0;
>   unsigned n = 0;                                                 unsigned n = 0;
>                                                                 
>   while (o < lines[0].size () || n < lines[1].size ()) {          while (o < lines[0].size () || n < lines[1].size ()) {
>                                                                 
>     // Find any unmatched lines at this point in the old file       // Find any unmatched lines at this point in the old file
>     // are deletes.                                                 // are deletes.
>                                                                 
>     unsigned boDeletes;                                             unsigned boDeletes;
>     for (boDeletes = o;                                             for (boDeletes = o;
>          o < lines[0].size () && lines[0][o].l == ~0;                    o < lines[0].size () && lines[0][o].l == ~0;
>          o += 1                                                          o += 1
>         )                                                               )
>     {}                                                              {}
>                                                                 
>     // Find any unmatched lines at this point in the new file       // Find any unmatched lines at this point in the new file
>     // are inserts.                                                 // are inserts.
>                                                                 
>     unsigned boInserts;                                             unsigned boInserts;
>     for (boInserts = n;                                             for (boInserts = n;
>          n < lines[1].size () && lines[1][n].l == ~0;                    n < lines[1].size () && lines[1][n].l == ~0;
>          n += 1                                                          n += 1
>         )                                                               )
>     {}                                                              {}
>                                                                 
>     // We've got deleted line(s) from boDeletes .. o.               // We've got deleted line(s) from boDeletes .. o.
>     // We've got deleted line(s) from boInserts .. n.               // We've got deleted line(s) from boInserts .. n.
>                                                                 
>     unsigned nDeletes = o - boDeletes;                              unsigned nDeletes = o - boDeletes;
>     unsigned nInserts = n - boInserts;                              unsigned nInserts = n - boInserts;
>                                                                 
>     // We've got...                                                 // We've got...
>                                                                 
>     if (nDeletes && nInserts) {                                     if (nDeletes && nInserts) {
>                                                                 
>       // ... deletes and inserts.                                     // ... deletes and inserts.
>                                                                 
>       if (1 < nDeletes && 1 < nInserts) {                             if (1 < nDeletes && 1 < nInserts) {
>         fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, b           fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, b
>       } else if (1 < nDeletes) {                                      } else if (1 < nDeletes) {
>         fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boIn           fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boIn
>       } else if (1 < nInserts) {                                      } else if (1 < nInserts) {
>         fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInser           fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInser
>       }                                                               } 
>       for (unsigned l = boDeletes; l < o; l += 1) {                   for (unsigned l = boDeletes; l < o; l += 1) {
>         fprintf (stdout, "< %s", lines[0][l].line->c_str ());           fprintf (stdout, "< %s", lines[0][l].line->c_str ());
>       }                                                               }
>       fprintf (stderr, "---\n");                                      fprintf (stderr, "---\n");
>       for (unsigned l = boInserts; l < n; l += 1) {                   for (unsigned l = boInserts; l < n; l += 1) {
>         fprintf (stdout, "> %s", lines[1][l].line->c_str ());           fprintf (stdout, "> %s", lines[1][l].line->c_str ());
>       }                                                               }
>     } else if (nDeletes) {                                          } else if (nDeletes) {
>                                                                 
>       //  ... just deletes.                                           //  ... just deletes.
>                                                                 
>       if (1 < nDeletes) {                                             if (1 < nDeletes) {
>         fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);            fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
>       } else {                                                        } else {
>         fprintf (stdout, "%dd%d\n", boDeletes + 1, n);                  fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
>       }                                                               }
>       for (unsigned l = boDeletes; l < o; l += 1) {                   for (unsigned l = boDeletes; l < o; l += 1) {
>         fprintf (stdout, "< %s", lines[0][l].line->c_str ());           fprintf (stdout, "< %s", lines[0][l].line->c_str ());
>       }                                                               }
>     } else if (nInserts) {                                          } else if (nInserts) {
>                                                                 
>       //  ... just inserts.                                           //  ... just inserts.
>                                                                 
>       if (1 < nInserts) {                                             if (1 < nInserts) {
>         fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);            fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
>       } else {                                                        } else {
>         fprintf (stdout, "%da%d\n", o, boInserts + 1);                  fprintf (stdout, "%da%d\n", o, boInserts + 1);
>       }                                                               }
>       for (unsigned l = boInserts; l < n; l += 1) {                   for (unsigned l = boInserts; l < n; l += 1) {
>         fprintf (stdout, "> %s", lines[1][l].line->c_str ());           fprintf (stdout, "> %s", lines[1][l].line->c_str ());
>       }                                                               }
>     }                                                               }
>                                                                 
>     // When we get here, we're dealing with matching lines.         // When we get here, we're dealing with matching lines.
>                                                                 
>     o += 1;                                                         o += 1;
>     n += 1;                                                         n += 1;
>   }                                                               }
> }                                                               }
>                                                                 
> void pass6r () {                                                void pass6r () {
> }                                                               }
>                                                                 
> void pass6s () {                                                void pass6s () {
> }                                                               }
>                                                                 
> void pass6u ()                                                  void pass6u ()
> {                                                               {
>   if (0 < optVerbose) {                                           if (0 < optVerbose) {
>     fprintf (stderr, "# Pass #6u (walking the differences)...       fprintf (stderr, "# Pass #6u (walking the differences)...
>   }                                                               }
>                                                                 
>   nMatchedLines = 0;                                              nMatchedLines = 0;
>                                                                 
>   // Write the header.                                            // Write the header.
>                                                                 
>   fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:0     fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:0
>   fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:0     fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:0
>   fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), l     fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), l
>                                                                 
>   // Starting at the top of both files,...                        // Starting at the top of both files,...
>                                                                 
>   unsigned o = 0;                                                 unsigned o = 0;
>   unsigned n = 0;                                                 unsigned n = 0;
>                                                                 
>   while (o < lines[0].size () || n < lines[1].size ()) {          while (o < lines[0].size () || n < lines[1].size ()) {
>                                                                 
>     // Find any unmatched lines at this point in the old file       // Find any unmatched lines at this point in the old file
>     // are deletes.                                                 // are deletes.
>                                                                 
>     unsigned boDeletes;                                             unsigned boDeletes;
>     for (boDeletes = o;                                             for (boDeletes = o;
>          o < lines[0].size () && lines[0][o].l == ~0;                    o < lines[0].size () && lines[0][o].l == ~0;
>          o += 1                                                          o += 1
>         )                                                               )
>     {}                                                              {}
>                                                                 
>     // Find any unmatched lines at this point in the new file       // Find any unmatched lines at this point in the new file
>     // are inserts.                                                 // are inserts.
>                                                                 
>     unsigned boInserts;                                             unsigned boInserts;
>     for (boInserts = n;                                             for (boInserts = n;
>          n < lines[1].size () && lines[1][n].l == ~0;                    n < lines[1].size () && lines[1][n].l == ~0;
>          n += 1                                                          n += 1
>         )                                                               )
>     {}                                                              {}
>                                                                 
>     // We've got deleted line(s) from boDeletes .. o.               // We've got deleted line(s) from boDeletes .. o.
>     // We've got deleted line(s) from boInserts .. n.               // We've got deleted line(s) from boInserts .. n.
>                                                                 
>     unsigned nDeletes = o - boDeletes;                              unsigned nDeletes = o - boDeletes;
>     unsigned nInserts = n - boInserts;                              unsigned nInserts = n - boInserts;
>                                                                 
>     // We've got...                                                 // We've got...
>                                                                 
>     if (nDeletes && nInserts) {                                     if (nDeletes && nInserts) {
>                                                                 
>       // ... deletes and inserts.                                     // ... deletes and inserts.
>                                                                 
>       for (unsigned l = boDeletes; l < o; l += 1) {                   for (unsigned l = boDeletes; l < o; l += 1) {
>         fprintf (stdout, "-%s", lines[0][l].line->c_str ());            fprintf (stdout, "-%s", lines[0][l].line->c_str ());
>       }                                                               }
>       for (unsigned l = boInserts; l < n; l += 1) {                   for (unsigned l = boInserts; l < n; l += 1) {
>         fprintf (stdout, "+%s", lines[1][l].line->c_str ());            fprintf (stdout, "+%s", lines[1][l].line->c_str ());
>       }                                                               }
>     } else if (nDeletes) {                                          } else if (nDeletes) {
>                                                                 
>       //  ... just deletes.                                           //  ... just deletes.
>                                                                 
>       for (unsigned l = boDeletes; l < o; l += 1) {                   for (unsigned l = boDeletes; l < o; l += 1) {
>         fprintf (stdout, "-%s", lines[0][l].line->c_str ());            fprintf (stdout, "-%s", lines[0][l].line->c_str ());
>       }                                                               }
>     } else if (nInserts) {                                          } else if (nInserts) {
>                                                                 
>       //  ... just inserts.                                           //  ... just inserts.
>                                                                 
>       for (unsigned l = boInserts; l < n; l += 1) {                   for (unsigned l = boInserts; l < n; l += 1) {
>         fprintf (stdout, "+%s", lines[1][l].line->c_str ());            fprintf (stdout, "+%s", lines[1][l].line->c_str ());
>       }                                                               }
>     }                                                               }
>                                                                 
>     // When we get here, we're dealing with matching lines.         // When we get here, we're dealing with matching lines.
>                                                                 
>     fprintf (stdout, " %s", lines[0][o].line->c_str ());            fprintf (stdout, " %s", lines[0][o].line->c_str ());
>     o += 1;                                                         o += 1;
>     n += 1;                                                         n += 1;
>   }                                                               }
> }                                                               }
# ../sdiff -y dif.6.cpp dif.7.cpp >& dif.6.7.diff-y.test
# dif.6.7.diff-y ---------------------------------------------------------------
1,797c1,1076
< #include <algorithm>						#include <algorithm>
< using std::find;						using std::find;
< #include <string>						#include <string>
< using std::string;						using std::string;
< #include <list>							#include <list>
< using std::list;						using std::list;
< #include <map>							#include <map>
< using std::map;							using std::map;
< #include <vector>						#include <vector>
< using std::vector;						using std::vector;
< #include <stdio.h>						#include <stdio.h>
< 
< enum DiffFormat {						enum DiffFormat {
<   Default,							  Default,
< 
<   Context,							  Context,
<   EdScript,							  EdScript,
<   IfThenElse,							  IfThenElse,
<   Normal,							  Normal,
<   RCS,								  RCS,
<   SideBySide,							  SideBySide,
<   Unified							  Unified
< };								};
< 
< DiffFormat diffFormat = Context;			      |	DiffFormat diffFormat = SideBySide;
< unsigned optCopyContext = 3;				      <
< 
< int optVerbose = 1;					      |	unsigned optCopyContext = 3;
< 							      >	unsigned optPageWidth = 130;
< 							      >	unsigned optVerbose = 2;
< 
< struct Line : public string {					struct Line : public string {
<   Line (string _text) :						  Line (string _text) :
<     string (_text)						    string (_text)
<   {								  {
<   }								  }
<   ~Line () {							  ~Line () {
<     copies[0].erase (copies[0].begin (), copies[0].end ());	    copies[0].erase (copies[0].begin (), copies[0].end ());
<     copies[1].erase (copies[1].begin (), copies[1].end ());	    copies[1].erase (copies[1].begin (), copies[1].end ());
<   }								  }
<   void Dump (FILE *out) {					  void Dump (FILE *out) {
<     fprintf (out, "{{ ");					    fprintf (out, "{{ ");
<     for (list<unsigned>::iterator i = copies[0].begin (); i !	    for (list<unsigned>::iterator i = copies[0].begin (); i !
<       fprintf (out, "%u ", *i);					      fprintf (out, "%u ", *i);
<     }								    }
<     fprintf (out, "},{ ");					    fprintf (out, "},{ ");
<     for (list<unsigned>::iterator i = copies[1].begin (); i !	    for (list<unsigned>::iterator i = copies[1].begin (); i !
<       fprintf (out, "%u ", *i);					      fprintf (out, "%u ", *i);
<     }								    }
<     fprintf (out, "}}\t%s", c_str ());			      |	    fprintf (out, "}}\t%s\n", c_str ());
<   }								  }
<   list<unsigned> copies[2];					  list<unsigned> copies[2];
< };								};
< 
< struct LinePtr {						struct LinePtr {
<   LinePtr (Line *_line) :					  LinePtr (Line *_line) :
<     line (_line),						    line (_line),
<     l (~0u)							    l (~0u)
<   {								  {
<   }								  }
<   void Dump (FILE *out) {					  void Dump (FILE *out) {
<     fprintf (out, "[%d] ", l);					    fprintf (out, "[%d] ", l);
<     line->Dump (out);						    line->Dump (out);
<   }								  }
<   Line *line;							  Line *line;
<   unsigned l;							  unsigned l;
< };								};
< 
< typedef map<string, Line *> MapStringToLinePtr;			typedef map<string, Line *> MapStringToLinePtr;
< typedef vector<LinePtr> VectorLinePtr;				typedef vector<LinePtr> VectorLinePtr;
< 
< // Our name.							// Our name.
< 
< char *ARGV0 = "dif3";						char *ARGV0 = "dif3";
< 
< // The 'symbol' (line) table.					// The 'symbol' (line) table.
< 
< MapStringToLinePtr table;					MapStringToLinePtr table;
< 
< // The names of the 2 files to be diff'd.			// The names of the 2 files to be diff'd.
< 
< char const *files[2] = { 0, 0 };				char const *files[2] = { 0, 0 };
< 
< // The lines of the 2 files to be diff'd.			// The lines of the 2 files to be diff'd.
< 
< VectorLinePtr lines[2];						VectorLinePtr lines[2];
< 
< // Miscellaneous metrics.					// Miscellaneous metrics.
< 
< unsigned nTotalMatchedBlocks = 0;				unsigned nTotalMatchedBlocks = 0;
< unsigned nMatchedBlocks = 0;					unsigned nMatchedBlocks = 0;
< unsigned nTotalMatchedLines = 0;				unsigned nTotalMatchedLines = 0;
< unsigned nMatchedLines = 0;					unsigned nMatchedLines = 0;
< 
< void pass1 ();							void pass1 ();
< void pass2 ();							void pass2 ();
< void pass3 ();							void pass3 ();
< void pass4 ();							void pass4 ();
< void pass5 ();							void pass5 ();
< void pass6 ();							void pass6 ();
< 
< int main (int argc, char *argv[])				int main (int argc, char *argv[])
< {								{
<   // Read the old [0] file, and the new [1] file.		  // Read the old [0] file, and the new [1] file.
< 
<   for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {	  for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
<     files[n] = argv[a];						    files[n] = argv[a];
< 
<     if (FILE *f = fopen (files[n], "r")) {			    if (FILE *f = fopen (files[n], "r")) {
<       if (0 < optVerbose) {					      if (0 < optVerbose) {
<         fprintf (stderr, "# Reading %s...", files[n]);		        fprintf (stderr, "# Reading %s...", files[n]);
< 							      >	        fflush (stderr);
<       }								      }
< 
<       char buffer[1024];					      char buffer[1024];
<       unsigned nUniq = 0;					      unsigned nUniq = 0;
< 
<       while (fgets (buffer, sizeof (buffer), f)) {		      while (fgets (buffer, sizeof (buffer), f)) {
<         string text (buffer);					        string text (buffer);
< 
< 							      >	        text.erase (text.end () - 1);
< 							      >
<         Line *line = table[text];				        Line *line = table[text];
< 
<         if (!line) {						        if (!line) {
<           table[text] = line = new Line (text);			          table[text] = line = new Line (text);
<           nUniq += 1;						          nUniq += 1;
<         }							        }
<         line->copies[n].push_back (lines[n].size ());		        line->copies[n].push_back (lines[n].size ());
<         lines[n].push_back (line);				        lines[n].push_back (line);
<       }								      }
< 
<       if (0 < optVerbose) {					      if (0 < optVerbose) {
<         fprintf (stderr, " %u lines, %u unique.\n", lines[n].	        fprintf (stderr, " %u lines, %u unique.\n", lines[n].
< 							      >	        fflush (stderr);
<       }								      }
<     } else {							    } else {
<       fprintf (stderr, "%s: Unable to open %s!  Exiting....\n	      fprintf (stderr, "%s: Unable to open %s!  Exiting....\n
< 							      >	      fflush (stderr);
<       perror (ARGV0);						      perror (ARGV0);
<       exit (1);							      exit (1);
<     }								    }
<   }								  }
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Total unique lines = %d\n", table.siz	    fprintf (stderr, "# Total unique lines = %d\n", table.siz
< 							      >	    fflush (stderr);
<   }								  }
< 
<   // map<int, int> counts;					  // map<int, int> counts;
<   // for (MapStringToLinePtr::iterator i = table.begin (); i 	  // for (MapStringToLinePtr::iterator i = table.begin (); i 
<   //   Line *l = i->second;					  //   Line *l = i->second;
<   //   counts[l->counts[0].size () + l->counts[1].size ()] +=	  //   counts[l->counts[0].size () + l->counts[1].size ()] +=
<   // }								  // }
<   // for (map<int, int>::iterator i = counts.begin (); i != c	  // for (map<int, int>::iterator i = counts.begin (); i != c
<   //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s	  //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s
<   // }								  // }
< 
<   pass1 ();							  pass1 ();
<   pass2 ();							  pass2 ();
<   pass3 ();							  pass3 ();
<   pass4 ();							  pass4 ();
<   pass5 ();							  pass5 ();
<   pass6 ();							  pass6 ();
< 
<   return 0;							  return 0;
< }								}
< 
< // Perform pass #1, in which we find all explicit matches amo	// Perform pass #1, in which we find all explicit matches amo
< // unique lines.  For every unique line that appears the same	// unique lines.  For every unique line that appears the same
< // of times in both files, we declare the lines to match.	// of times in both files, we declare the lines to match.
< 
< void pass1 ()							void pass1 ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass 1 (finding matches amongst uniqu	    fprintf (stderr, "# Pass 1 (finding matches amongst uniqu
< 							      >	    fflush (stderr);
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   for (MapStringToLinePtr::iterator i = table.begin (); i != 	  for (MapStringToLinePtr::iterator i = table.begin (); i != 
<     Line *l = i->second;					    Line *l = i->second;
< 
<     // If the number of old and new lines match, then we decl	    // If the number of old and new lines match, then we decl
<     // they are (all) the same line.  Note, it isn't possible	    // they are (all) the same line.  Note, it isn't possible
<     // numbers of both files to be 0.				    // numbers of both files to be 0.
< 
<     // (In the original algorithm, we only recognized a match	    // (In the original algorithm, we only recognized a match
<     // if there was exactly 1 copy for each file.)		    // if there was exactly 1 copy for each file.)
< 
<     if (l->copies[0].size () == l->copies[1].size ()) {		    if (l->copies[0].size () == l->copies[1].size ()) {
<       nMatchedLines += 1;					      nMatchedLines += 1;
< 
<       // For each matched line in the new file, mark it with 	      // For each matched line in the new file, mark it with 
<       // corresponding line (number) in the old file.		      // corresponding line (number) in the old file.
< 
<       while (!l->copies[0].empty ()) {				      while (!l->copies[0].empty ()) {
<         unsigned o = l->copies[0].front ();			        unsigned o = l->copies[0].front ();
<         unsigned n = l->copies[1].front ();			        unsigned n = l->copies[1].front ();
< 
<         // Match up the pair.					        // Match up the pair.
< 
<         lines[0][o].l = n;					        lines[0][o].l = n;
<         lines[1][n].l = o;					        lines[1][n].l = o;
< 
<         // Remove the matched line numbers from the lists.	        // Remove the matched line numbers from the lists.
< 
<         l->copies[0].pop_front ();				        l->copies[0].pop_front ();
<         l->copies[1].pop_front ();				        l->copies[1].pop_front ();
<       }								      }
<     }								    }
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, " found %u matched lines (%u total).\n",	    fprintf (stderr, " found %u matched lines (%u total).\n",
< 							      >	    fflush (stderr);
< 
<     if (1 < optVerbose) {				      |	    if (2 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
< 							      >	        fflush (stderr);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
< 							      >	          fflush (stderr);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< }								}
< 
< // Perform Pass #2, in which we attempt to 'widen' blocks of 	// Perform Pass #2, in which we attempt to 'widen' blocks of 
< // lines, by appending lines which are the same in both files	// lines, by appending lines which are the same in both files
< 
< void pass2 ()							void pass2 ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #2 (spreading matches down)...")	    fprintf (stderr, "# Pass #2 (spreading matches down)...")
< 							      >	    fflush (stderr);
<   }								  }
< 
<   nMatchedBlocks = 0;						  nMatchedBlocks = 0;
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Starting at the top of the old file,...			  // Starting at the top of the old file,...
< 
<   for (unsigned o = 0; o < lines[0].size (); o += 1) {		  for (unsigned o = 0; o < lines[0].size (); o += 1) {
< 
<     // ... skip any currently unmatched lines...		    // ... skip any currently unmatched lines...
< 
<     if (lines[0][o].l == ~0) {					    if (lines[0][o].l == ~0) {
<       continue;							      continue;
<     }								    }
< 
<     // ... until we find an [already] matched line.  Then, sk	    // ... until we find an [already] matched line.  Then, sk
<     // the set of 1 or more matched lines, until we reach any	    // the set of 1 or more matched lines, until we reach any
<     // following, still-unmatched line.				    // following, still-unmatched line.
< 
<     unsigned n;							    unsigned n;
<     do {							    do {
<       n = lines[0][o].l + 1;					      n = lines[0][o].l + 1;
<       o += 1;							      o += 1;
<     } while (o < lines[0].size () && lines[0][o].l != ~0);	    } while (o < lines[0].size () && lines[0][o].l != ~0);
< 
<     // Now, o - 1 is the line number of the last matched old 	    // Now, o - 1 is the line number of the last matched old 
<     // n - 1 is the line number of the last matched new line.	    // n - 1 is the line number of the last matched new line.
<     // to add new old and new lines, if they match.		    // to add new old and new lines, if they match.
< 
<     // Finally, attempt to add unmatched lines to the preceed	    // Finally, attempt to add unmatched lines to the preceed
<     // matched set.						    // matched set.
< 
<     for (; o < lines[0].size () && lines[0][o].l == ~0; o += 	    for (; o < lines[0].size () && lines[0][o].l == ~0; o += 
< 
<       // If the [next] pair of old and new lines aren't the s	      // If the [next] pair of old and new lines aren't the s
< 
<       if (lines[0][o].line != lines[1][n].line) {		      if (lines[0][o].line != lines[1][n].line) {
<         break;							        break;
<       }								      }
< 
<       // Match up the pair.					      // Match up the pair.
< 
<       lines[0][o].l = n;					      lines[0][o].l = n;
<       lines[1][n].l = o;					      lines[1][n].l = o;
< 
<       // Remove the matched line numbers form the lists.	      // Remove the matched line numbers form the lists.
< 
<       Line *line = lines[0][o].line;				      Line *line = lines[0][o].line;
<       list<unsigned> &oldCopies = line->copies[0];		      list<unsigned> &oldCopies = line->copies[0];
<       list<unsigned>::iterator oL = find (oldCopies.begin (),	      list<unsigned>::iterator oL = find (oldCopies.begin (),
<       if (oL != oldCopies.end ()) {				      if (oL != oldCopies.end ()) {
<         oldCopies.erase (oL);					        oldCopies.erase (oL);
<       }								      }
<       list<unsigned> &newCopies = line->copies[0];		      list<unsigned> &newCopies = line->copies[0];
<       list<unsigned>::iterator nL = find (newCopies.begin (),	      list<unsigned>::iterator nL = find (newCopies.begin (),
<       if (nL != newCopies.end ()) {				      if (nL != newCopies.end ()) {
<         newCopies.erase (nL);					        newCopies.erase (nL);
<       }								      }
< 
<       nMatchedLines += 1;					      nMatchedLines += 1;
<     }								    }
<     nMatchedBlocks += 1;					    nMatchedBlocks += 1;
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
<   nTotalMatchedBlocks += nMatchedBlocks;			  nTotalMatchedBlocks += nMatchedBlocks;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr,						    fprintf (stderr,
<              " found %u/%u matched lines/blocks (%u/%u totals	             " found %u/%u matched lines/blocks (%u/%u totals
<              nMatchedLines,					             nMatchedLines,
<              nMatchedBlocks,					             nMatchedBlocks,
<              nTotalMatchedLines,				             nTotalMatchedLines,
<              nTotalMatchedBlocks				             nTotalMatchedBlocks
<             );							            );
<     if (1 < optVerbose) {				      |	    fflush (stderr);
< 							      >	    if (2 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
< 							      >	        fflush (stderr);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
< 							      >	          fflush (stderr);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< }								}
< 
< // Perform Pass #3, in which we attempt to 'widen' blocks of 	// Perform Pass #3, in which we attempt to 'widen' blocks of 
< // lines, by prepending lines which are the same in both file	// lines, by prepending lines which are the same in both file
< 
< void pass3 ()							void pass3 ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #3 (spreading matches up)...");	    fprintf (stderr, "# Pass #3 (spreading matches up)...");
< 							      >	    fflush (stderr);
<   }								  }
< 
<   nMatchedBlocks = 0;						  nMatchedBlocks = 0;
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Starting at the bottom of the old file,...			  // Starting at the bottom of the old file,...
< 
<   for (int o = lines[0].size (); 0 <= o; o -= 1) {		  for (int o = lines[0].size (); 0 <= o; o -= 1) {
< 
<     // ... skip any currently unmatched lines...		    // ... skip any currently unmatched lines...
< 
<     if (lines[0][o].l == ~0) {					    if (lines[0][o].l == ~0) {
<       continue;							      continue;
<     }								    }
< 
<     // ... until we find an [already] matched line.  Then, sk	    // ... until we find an [already] matched line.  Then, sk
<     // the set of 1 or more matched lines, until we reach any	    // the set of 1 or more matched lines, until we reach any
<     // following, still-unmatched line.				    // following, still-unmatched line.
< 
<     unsigned n;							    unsigned n;
<     do {							    do {
<       n = lines[0][o].l - 1;					      n = lines[0][o].l - 1;
<       o -= 1;							      o -= 1;
<     } while (0 <= o && lines[0][o].l != ~0);			    } while (0 <= o && lines[0][o].l != ~0);
< 
<     // Now, o + 1 is the line number of the last matched old 	    // Now, o + 1 is the line number of the last matched old 
<     // n + 1 is the line number of the last matched new line.	    // n + 1 is the line number of the last matched new line.
<     // to add new old and new lines, if they match.		    // to add new old and new lines, if they match.
< 
<     // Finally, attempt to add unmatched lines to the preceed	    // Finally, attempt to add unmatched lines to the preceed
<     // matched set.						    // matched set.
< 
<     for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {	    for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
< 
<       // If the [next] pair of old and new lines aren't the s	      // If the [next] pair of old and new lines aren't the s
< 
<       if (lines[0][o].line != lines[1][n].line) {		      if (lines[0][o].line != lines[1][n].line) {
<         break;							        break;
<       }								      }
< 
<       // Match up the pair.					      // Match up the pair.
< 
<       lines[0][o].l = n;					      lines[0][o].l = n;
<       lines[1][n].l = o;					      lines[1][n].l = o;
< 
<       // Remove the matched line numbers form the lists.	      // Remove the matched line numbers form the lists.
< 
<       Line *line = lines[0][o].line;				      Line *line = lines[0][o].line;
<       list<unsigned> &oldCopies = line->copies[0];		      list<unsigned> &oldCopies = line->copies[0];
<       list<unsigned>::iterator oL = find (oldCopies.begin (),	      list<unsigned>::iterator oL = find (oldCopies.begin (),
<       if (oL != oldCopies.end ()) {				      if (oL != oldCopies.end ()) {
<         oldCopies.erase (oL);					        oldCopies.erase (oL);
<       }								      }
<       list<unsigned> &newCopies = line->copies[0];		      list<unsigned> &newCopies = line->copies[0];
<       list<unsigned>::iterator nL = find (newCopies.begin (),	      list<unsigned>::iterator nL = find (newCopies.begin (),
<       if (nL != newCopies.end ()) {				      if (nL != newCopies.end ()) {
<         newCopies.erase (nL);					        newCopies.erase (nL);
<       }								      }
< 
<       nMatchedLines += 1;					      nMatchedLines += 1;
<     }								    }
<     nMatchedBlocks += 1;					    nMatchedBlocks += 1;
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr,						    fprintf (stderr,
<              " found %u/%u matched lines/blocks (%u/%u totals	             " found %u/%u matched lines/blocks (%u/%u totals
<              nMatchedLines,					             nMatchedLines,
<              nMatchedBlocks,					             nMatchedBlocks,
<              nTotalMatchedLines,				             nTotalMatchedLines,
<              nTotalMatchedBlocks				             nTotalMatchedBlocks
<             );							            );
< 							      >	    fflush (stderr);
< 
<     if (1 < optVerbose) {				      |	    if (2 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
< 							      >	        fflush (stderr);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
< 							      >	          fflush (stderr);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< }								}
< 
< // Perform pass #4, in which we find any remaining matches am	// Perform pass #4, in which we find any remaining matches am
< // unique lines.  For every unique line that has more than 1 	// unique lines.  For every unique line that has more than 1 
< // both files, we declare the copies to match.			// both files, we declare the copies to match.
< 
< void pass4 ()							void pass4 ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass 4 (finding remaining matches amo	    fprintf (stderr, "# Pass 4 (finding remaining matches amo
< 							      >	    fflush (stderr);
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   for (MapStringToLinePtr::iterator i = table.begin (); i != 	  for (MapStringToLinePtr::iterator i = table.begin (); i != 
<     Line *l = i->second;					    Line *l = i->second;
< 
<     // If there's more than 1 matching old and new lines, the	    // If there's more than 1 matching old and new lines, the
<     // declare that each pair are (all) the same line.		    // declare that each pair are (all) the same line.
< 
<     // (In the original algorithm, we only recognized a match	    // (In the original algorithm, we only recognized a match
<     // if there was exactly 1 copy for each file.)		    // if there was exactly 1 copy for each file.)
< 
<     while (0 < l->copies[0].size () && 0 < l->copies[1].size 	    while (0 < l->copies[0].size () && 0 < l->copies[1].size 
<       nMatchedLines += 1;					      nMatchedLines += 1;
< 
<       // For each matched line in the new file, mark it with 	      // For each matched line in the new file, mark it with 
<       // corresponding line (number) in the old file.		      // corresponding line (number) in the old file.
< 
<       unsigned o = l->copies[0].front ();			      unsigned o = l->copies[0].front ();
<       unsigned n = l->copies[1].front ();			      unsigned n = l->copies[1].front ();
< 
<       // Match up the pair.					      // Match up the pair.
< 
<       lines[0][o].l = n;					      lines[0][o].l = n;
<       lines[1][n].l = o;					      lines[1][n].l = o;
< 
<       // Remove the matched line numbers from the lists.	      // Remove the matched line numbers from the lists.
< 
<       l->copies[0].pop_front ();				      l->copies[0].pop_front ();
<       l->copies[1].pop_front ();				      l->copies[1].pop_front ();
<     }								    }
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, " found %u matched lines (%u total).\n",	    fprintf (stderr, " found %u matched lines (%u total).\n",
< 							      >	    fflush (stderr);
< 
<     if (1 < optVerbose) {				      |	    if (2 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
< 							      >	        fflush (stderr);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
< 							      >	          fflush (stderr);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< }								}
< 
< // Perform Pass #5, in which we look for blocks which match, 	// Perform Pass #5, in which we look for blocks which match, 
< // the result of a move (their not in their original position	// the result of a move (their not in their original position
< // these, we'll unmatch the blocks, turning them into a delet	// these, we'll unmatch the blocks, turning them into a delet
< // insert.							// insert.
< 
< void pass5 ()							void pass5 ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #5 (unmatching block moves)...\n	    fprintf (stderr, "# Pass #5 (unmatching block moves)...\n
< 							      >	    fflush (stderr);
<   }								  }
< 
<   nMatchedBlocks = 0;						  nMatchedBlocks = 0;
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Starting at the top of both files,...			  // Starting at the top of both files,...
< 
<   unsigned o = 0;						  unsigned o = 0;
<   unsigned n = 0;						  unsigned n = 0;
< 
<   while (o < lines[0].size () || n < lines[1].size ()) {	  while (o < lines[0].size () || n < lines[1].size ()) {
< 
<     // Skip any unmatched lines at this point in the old file	    // Skip any unmatched lines at this point in the old file
<     // are deletes.						    // are deletes.
< 
<     //    Old     New						    //    Old     New
<     //   +---+							    //   +---+
<     // 0 | a |							    // 0 | a |
<     //   +---+   +---+						    //   +---+   +---+
<     //         0 | b |						    //         0 | b |
<     //   +---+   +---+						    //   +---+   +---+
<     // 1 | c | 1 | c |						    // 1 | c | 1 | c |
<     //   +---+   +---+						    //   +---+   +---+
<     //         2 | z |						    //         2 | z |
<     //   +---+   +---+						    //   +---+   +---+
<     // 2 | d | 3 | d |						    // 2 | d | 3 | d |
<     //   +---+   +---+						    //   +---+   +---+
< 
<     while (o < lines[0].size () && lines[0][o].l == ~0) {	    while (o < lines[0].size () && lines[0][o].l == ~0) {
<       o += 1;							      o += 1;
<     }								    }
< 
<     // Skip any unmatched lines at this point in the new file	    // Skip any unmatched lines at this point in the new file
<     // are inserts.						    // are inserts.
< 
<     while (n < lines[1].size () && lines[1][n].l == ~0) {	    while (n < lines[1].size () && lines[1][n].l == ~0) {
<       n += 1;							      n += 1;
<     }								    }
< 
<     // When we get here, we know that we're dealing with matc	    // When we get here, we know that we're dealing with matc
<     // lines (or the end of one or both files).  We're done w	    // lines (or the end of one or both files).  We're done w
<     // pass, if we've reached the end of either file.		    // pass, if we've reached the end of either file.
< 
<     if (lines[0].size () <= o || lines[1].size () <= n) {	    if (lines[0].size () <= o || lines[1].size () <= n) {
<       break;							      break;
<     }								    }
< 
<     // We now know that we've got a pair of matching lines, t	    // We now know that we've got a pair of matching lines, t
<     // of a matching block.  If the new file's line number is	    // of a matching block.  If the new file's line number is
<     // expect, then the matched pair is unmoved, and we can s	    // expect, then the matched pair is unmoved, and we can s
<     // the pair.  (If this is really the start of a block of 	    // the pair.  (If this is really the start of a block of 
<     // 1 lines, we'll handle it one pair at a time.)		    // 1 lines, we'll handle it one pair at a time.)
< 
<     if (lines[0][o].l == n) {					    if (lines[0][o].l == n) {
<       o += 1;							      o += 1;
<       n += 1;							      n += 1;
<       continue;							      continue;
<     }								    }
< 
<     // If, on the other hand, we don't expect this [new] line	    // If, on the other hand, we don't expect this [new] line
<     // then this matching block has been moved.  We need to t	    // then this matching block has been moved.  We need to t
<     // matched pair into an *unmatched* pair, one of deletes,	    // matched pair into an *unmatched* pair, one of deletes,
<     // of inserts.  First, though, we need to know how big th	    // of inserts.  First, though, we need to know how big th
<     // is, and how far it was moved....				    // is, and how far it was moved....
< 
<     // Remember where we were when we started.			    // Remember where we were when we started.
< 
<     unsigned oOld = o;						    unsigned oOld = o;
<     unsigned nOld = n;						    unsigned nOld = n;
< 
<     // Remember where the block came from.			    // Remember where the block came from.
< 
<     unsigned nNew = lines[0][o].l;				    unsigned nNew = lines[0][o].l;
< 
<     // Find the end of this matched pair.			    // Find the end of this matched pair.
< 
<     for (n = nNew; o < lines[0].size () && n < lines[1].size 	    for (n = nNew; o < lines[0].size () && n < lines[1].size 
<       if (lines[0][o].l != n) {					      if (lines[0][o].l != n) {
<         break;							        break;
<       }								      }
<     }								    }
< 
<     // When we get here:					    // When we get here:
<     // * oOld..o is the old file's block,			    // * oOld..o is the old file's block,
<     // * nNew..n is the new file's *moved* block, and		    // * nNew..n is the new file's *moved* block, and
<     // * nOld is where we originally expected the new block f	    // * nOld is where we originally expected the new block f
<  								 
<     // We can now calculate the length of the block...		    // We can now calculate the length of the block...
<     								    
<     unsigned bSize = o - oOld;  // (or n - nNew)		    unsigned bSize = o - oOld;  // (or n - nNew)
< 
<     // ... and we can calculate how far the block moved:	    // ... and we can calculate how far the block moved:
< 
<     unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;	    unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
< 
<     // The larger of the two will become our delete, and the 	    // The larger of the two will become our delete, and the 
<     // will become our insert.					    // will become our insert.
< 
<     //    Old     New						    //    Old     New
<     //   +---+   +---+						    //   +---+   +---+
<     // 0 | a | 0 | b |						    // 0 | a | 0 | b |
<     //   +---+ 1 | b |						    //   +---+ 1 | b |
<     // 1 | b |   +---+						    // 1 | b |   +---+
<     // 2 | b | 2 | a |						    // 2 | b | 2 | a |
<     //   +---+   +---+						    //   +---+   +---+
<     // 3 | c | 3 | c |						    // 3 | c | 3 | c |
<     //   +---+   +---+						    //   +---+   +---+
< 
<     // (1) Delete a@0, insert a@2, or				    // (1) Delete a@0, insert a@2, or
<     // (2) insert bb@0, delete bb@1?				    // (2) insert bb@0, delete bb@1?
< 
<     // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and	    // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and
<     // (of a) is 2-0 or 2, the size of b@0.  We choose to del	    // (of a) is 2-0 or 2, the size of b@0.  We choose to del
<     // and reinsert a@2.					    // and reinsert a@2.
< 
<     // if (bSize <= bMove) {					    // if (bSize <= bMove) {
<       for (unsigned a = oOld; a < o; a += 1) {			      for (unsigned a = oOld; a < o; a += 1) {
<         lines[0][a].l = ~0;					        lines[0][a].l = ~0;
<       }								      }
<       for (unsigned d = nNew; d < n; d += 1) {			      for (unsigned d = nNew; d < n; d += 1) {
<         lines[1][d].l = ~0;					        lines[1][d].l = ~0;
<       }								      }
<     // } else {							    // } else {
<       // for (unsigned a = oOld; a < o; a += 1) {		      // for (unsigned a = oOld; a < o; a += 1) {
<       //   lines[0][a].l = ~0;					      //   lines[0][a].l = ~0;
<       // }							      // }
<       // for (unsigned d = nNew; d < n; d += 1) {		      // for (unsigned d = nNew; d < n; d += 1) {
<       //   lines[1][d].l = ~0;					      //   lines[1][d].l = ~0;
<       // }							      // }
<     // }							    // }
< 
<     // Continue from where we left off.				    // Continue from where we left off.
< 
<     n = nOld;							    n = nOld;
<   }								  }
<   nTotalMatchedLines -= nMatchedLines;				  nTotalMatchedLines -= nMatchedLines;
<   nTotalMatchedBlocks -= nMatchedBlocks;			  nTotalMatchedBlocks -= nMatchedBlocks;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr,						    fprintf (stderr,
<              " found %u/%u matched lines/blocks (%u/%u totals	             " found %u/%u matched lines/blocks (%u/%u totals
<              nMatchedLines,					             nMatchedLines,
<              nMatchedBlocks,					             nMatchedBlocks,
<              nTotalMatchedLines,				             nTotalMatchedLines,
<              nTotalMatchedBlocks				             nTotalMatchedBlocks
<             );							            );
< 							      >	    fflush (stderr);
< 
<     if (1 < optVerbose) {				      |	    if (2 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
< 							      >	        fflush (stderr);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
< 							      >	          fflush (stderr);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< }								}
< 
< // Perform Pass #6, in which we create the desired output.	// Perform Pass #6, in which we create the desired output.
< 
< void pass6c ();							void pass6c ();
< void pass6e ();							void pass6e ();
< void pass6i ();							void pass6i ();
< void pass6n ();							void pass6n ();
< void pass6r ();							void pass6r ();
< void pass6s ();							void pass6s ();
< void pass6u ();							void pass6u ();
< 							      >	void pass6y ();
< 
< void pass6 ()							void pass6 ()
< {								{
< 
<   switch (diffFormat) {						  switch (diffFormat) {
<   case Context:							  case Context:
<     pass6c ();							    pass6c ();
<     break;							    break;
< 
<   case EdScript:						  case EdScript:
<     pass6e ();							    pass6e ();
<     break;							    break;
< 
<   case IfThenElse:						  case IfThenElse:
<     pass6i ();							    pass6i ();
<     break;							    break;
< 
<   case Normal:							  case Normal:
<     pass6n ();							    pass6n ();
<     break;							    break;
< 
<   case RCS:							  case RCS:
<     pass6r ();							    pass6r ();
<     break;							    break;
< 
<   case SideBySide:						  case SideBySide:
<     pass6s ();						      |	    pass6y ();
<     break;							    break;
< 
<   case Unified:							  case Unified:
<     pass6u ();							    pass6u ();
<     break;							    break;
< 
<   case Default:							  case Default:
<   default:							  default:
<     pass6c ();							    pass6c ();
<     break;							    break;
<   }								  }
< }								}
< 
< template<typename T> T min (T l, T r) {				template<typename T> T min (T l, T r) {
<   if (l < r) {							  if (l < r) {
<     return l;							    return l;
<   }								  }
<   return r;							  return r;
< }								}
< 
< template<typename T> T max (T l, T r) {				template<typename T> T max (T l, T r) {
<   if (l < r) {							  if (l < r) {
<     return r;							    return r;
<   }								  }
<   return l;							  return l;
< }								}
< 
< void pass6c () {						void pass6c () {
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #6u (walking the differences)... |	    fprintf (stderr, "# Pass #6c (walking the differences)...
< 							      >	    fflush (stderr);
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Write the header.						  // Write the header.
< 
<   fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:0	  fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:0
<   fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:0	  fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:0
< 
<   // Starting at the top of both files,...			  // Starting at the top of both files,...
< 
<   unsigned o = 0;						  unsigned o = 0;
<   unsigned n = 0;						  unsigned n = 0;
< 
<   while (o < lines[0].size () || n < lines[1].size ()) {	  while (o < lines[0].size () || n < lines[1].size ()) {
< 
<     // Find the bounds of the current contextual 'window'.	    // Find the bounds of the current contextual 'window'.
< 
<     // If we aren't looking at a delete or an insert, we're n	    // If we aren't looking at a delete or an insert, we're n
<     // start of a context window.				    // start of a context window.
< 
<     if (lines[0][o].l != ~0 && lines[1][n].l != ~0) {		    if (lines[0][o].l != ~0 && lines[1][n].l != ~0) {
<       o += 1;							      o += 1;
<       n += 1;							      n += 1;
<       continue;							      continue;
<     }								    }
< 
<     // We're looking at at least 1 delete or insert, so a win |	    // We're now looking at at least 1 delete or insert, so a
<     // begins here (or, rather, optCopyContext lines earlier)	    // begins here (or, rather, optCopyContext lines earlier)
<     								    
<     int boOldWindow = max (0, int (boDeletes) - int(optCopyCo |	    int boOldWindow = max (0, int (o) - int (optCopyContext))
<     int eoOldWindow = min (int (lines[0].size ()), int(o) + i |	    int boNewWindow = max (0, int (n) - int (optCopyContext))
< 
<     // Look for the end of the window.			      |	    if (1 < optVerbose) {
< 							      >	      fprintf (stderr, "boOldWindow = %d, boNewWindow = %d\n"
< 							      >	      fflush (stderr);
< 							      >	    }
< 
<     bool widenWindow = false;				      |	    // Look for the end of the current window.
<     do {						      |
< 							      >	    int eoOldWindow;
< 							      >	    int eoNewWindow;
< 							      >
< 							      >	    bool widenWindow = true;
< 							      >	    while (widenWindow && o < lines[0].size () || n < lines[1
< 
<       // Skip over the delete(s) and/or insert(s) defining th	      // Skip over the delete(s) and/or insert(s) defining th
<       // context.						      // context.
< 
<       while (o < lines[0].size () && lines[0][o].l == ~0) {	      while (o < lines[0].size () && lines[0][o].l == ~0) {
<         o += 1;							        o += 1;
<       }								      }
<       while (n < lines[1].size () && lines[1][n].l == ~0) {	      while (n < lines[1].size () && lines[1][n].l == ~0) {
<         n += 1;							        n += 1;
<       }								      }
< 
<       // ...  This context will end optCopyContext lines past |	      // This context will end optCopyContext matched lines p
<       // set of deletes or inserts we find.  However, since a |	      // last set of deletes or inserts we find.
---
> #include <algorithm>                                            #include <algorithm>
> using std::find;                                                using std::find;
> #include <string>                                               #include <string>
> using std::string;                                              using std::string;
> #include <list>                                                 #include <list>
> using std::list;                                                using std::list;
> #include <map>                                                  #include <map>
> using std::map;                                                 using std::map;
> #include <vector>                                               #include <vector>
> using std::vector;                                              using std::vector;
> #include <stdio.h>                                              #include <stdio.h>
>                                                                 
> enum DiffFormat {                                               enum DiffFormat {
>   Default,                                                        Default,
>                                                                 
>   Context,                                                        Context,
>   EdScript,                                                       EdScript,
>   IfThenElse,                                                     IfThenElse,
>   Normal,                                                         Normal,
>   RCS,                                                            RCS,
>   SideBySide,                                                     SideBySide,
>   Unified                                                         Unified
> };                                                              };
>                                                                 
> DiffFormat diffFormat = Context;                              | DiffFormat diffFormat = SideBySide;
> unsigned optCopyContext = 3;                                  <
>                                                                 
> int optVerbose = 1;                                           | unsigned optCopyContext = 3;
>                                                               > unsigned optPageWidth = 130;
>                                                               > unsigned optVerbose = 2;
>                                                                 
> struct Line : public string {                                   struct Line : public string {
>   Line (string _text) :                                           Line (string _text) :
>     string (_text)                                                  string (_text)
>   {                                                               {
>   }                                                               }
>   ~Line () {                                                      ~Line () {
>     copies[0].erase (copies[0].begin (), copies[0].end ());         copies[0].erase (copies[0].begin (), copies[0].end ());
>     copies[1].erase (copies[1].begin (), copies[1].end ());         copies[1].erase (copies[1].begin (), copies[1].end ());
>   }                                                               }
>   void Dump (FILE *out) {                                         void Dump (FILE *out) {
>     fprintf (out, "{{ ");                                           fprintf (out, "{{ ");
>     for (list<unsigned>::iterator i = copies[0].begin (); i !       for (list<unsigned>::iterator i = copies[0].begin (); i !
>       fprintf (out, "%u ", *i);                                       fprintf (out, "%u ", *i);
>     }                                                               }
>     fprintf (out, "},{ ");                                          fprintf (out, "},{ ");
>     for (list<unsigned>::iterator i = copies[1].begin (); i !       for (list<unsigned>::iterator i = copies[1].begin (); i !
>       fprintf (out, "%u ", *i);                                       fprintf (out, "%u ", *i);
>     }                                                               }
>     fprintf (out, "}}\t%s", c_str ());                        |     fprintf (out, "}}\t%s\n", c_str ());
>   }                                                               }
>   list<unsigned> copies[2];                                       list<unsigned> copies[2];
> };                                                              };
>                                                                 
> struct LinePtr {                                                struct LinePtr {
>   LinePtr (Line *_line) :                                         LinePtr (Line *_line) :
>     line (_line),                                                   line (_line),
>     l (~0u)                                                         l (~0u)
>   {                                                               {
>   }                                                               }
>   void Dump (FILE *out) {                                         void Dump (FILE *out) {
>     fprintf (out, "[%d] ", l);                                      fprintf (out, "[%d] ", l);
>     line->Dump (out);                                               line->Dump (out);
>   }                                                               }
>   Line *line;                                                     Line *line;
>   unsigned l;                                                     unsigned l;
> };                                                              };
>                                                                 
> typedef map<string, Line *> MapStringToLinePtr;                 typedef map<string, Line *> MapStringToLinePtr;
> typedef vector<LinePtr> VectorLinePtr;                          typedef vector<LinePtr> VectorLinePtr;
>                                                                 
> // Our name.                                                    // Our name.
>                                                                 
> char *ARGV0 = "dif3";                                           char *ARGV0 = "dif3";
>                                                                 
> // The 'symbol' (line) table.                                   // The 'symbol' (line) table.
>                                                                 
> MapStringToLinePtr table;                                       MapStringToLinePtr table;
>                                                                 
> // The names of the 2 files to be diff'd.                       // The names of the 2 files to be diff'd.
>                                                                 
> char const *files[2] = { 0, 0 };                                char const *files[2] = { 0, 0 };
>                                                                 
> // The lines of the 2 files to be diff'd.                       // The lines of the 2 files to be diff'd.
>                                                                 
> VectorLinePtr lines[2];                                         VectorLinePtr lines[2];
>                                                                 
> // Miscellaneous metrics.                                       // Miscellaneous metrics.
>                                                                 
> unsigned nTotalMatchedBlocks = 0;                               unsigned nTotalMatchedBlocks = 0;
> unsigned nMatchedBlocks = 0;                                    unsigned nMatchedBlocks = 0;
> unsigned nTotalMatchedLines = 0;                                unsigned nTotalMatchedLines = 0;
> unsigned nMatchedLines = 0;                                     unsigned nMatchedLines = 0;
>                                                                 
> void pass1 ();                                                  void pass1 ();
> void pass2 ();                                                  void pass2 ();
> void pass3 ();                                                  void pass3 ();
> void pass4 ();                                                  void pass4 ();
> void pass5 ();                                                  void pass5 ();
> void pass6 ();                                                  void pass6 ();
>                                                                 
> int main (int argc, char *argv[])                               int main (int argc, char *argv[])
> {                                                               {
>   // Read the old [0] file, and the new [1] file.                 // Read the old [0] file, and the new [1] file.
>                                                                 
>   for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {     for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
>     files[n] = argv[a];                                             files[n] = argv[a];
>                                                                 
>     if (FILE *f = fopen (files[n], "r")) {                          if (FILE *f = fopen (files[n], "r")) {
>       if (0 < optVerbose) {                                           if (0 < optVerbose) {
>         fprintf (stderr, "# Reading %s...", files[n]);                  fprintf (stderr, "# Reading %s...", files[n]);
>                                                               >         fflush (stderr);
>       }                                                               }
>                                                                 
>       char buffer[1024];                                              char buffer[1024];
>       unsigned nUniq = 0;                                             unsigned nUniq = 0;
>                                                                 
>       while (fgets (buffer, sizeof (buffer), f)) {                    while (fgets (buffer, sizeof (buffer), f)) {
>         string text (buffer);                                           string text (buffer);
>                                                                 
>         Line *line = table[text];                             |         text.erase (text.end () - 1);
>                                                               <
>         if (!line) {                                          <
>           table[text] = line = new Line (text);               <
>           nUniq += 1;                                         <
>         }                                                     <
>         line->copies[n].push_back (lines[n].size ());         <
>         lines[n].push_back (line);                            <
>       }                                                       <
>                                                               <
>       if (0 < optVerbose) {                                   <
>         fprintf (stderr, " %u lines, %u unique.\n", lines[n]. <
>       }                                                       <
>     } else {                                                  <
>       fprintf (stderr, "%s: Unable to open %s!  Exiting....\n <
>       perror (ARGV0);                                         <
>       exit (1);                                               <
>     }                                                         <
>   }                                                           <
>                                                               <
>   if (0 < optVerbose) {                                       <
>     fprintf (stderr, "# Total unique lines = %d\n", table.siz <
>   }                                                           <
>                                                               <
>   // map<int, int> counts;                                    <
>   // for (MapStringToLinePtr::iterator i = table.begin (); i  <
>   //   Line *l = i->second;                                   <
>   //   counts[l->counts[0].size () + l->counts[1].size ()] += <
>   // }                                                        <
>   // for (map<int, int>::iterator i = counts.begin (); i != c <
>   //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s <
>   // }                                                        <
>                                                               <
>   pass1 ();                                                   <
>   pass2 ();                                                   <
>   pass3 ();                                                   <
>   pass4 ();                                                   <
>   pass5 ();                                                   <
>   pass6 ();                                                   <
>                                                               <
>   return 0;                                                   <
> }                                                             <
>                                                               <
> // Perform pass #1, in which we find all explicit matches amo <
> // unique lines.  For every unique line that appears the same <
> // of times in both files, we declare the lines to match.     <
>                                                               <
> void pass1 ()                                                 <
> {                                                             <
>   if (0 < optVerbose) {                                       <
>     fprintf (stderr, "# Pass 1 (finding matches amongst uniqu <
>   }                                                           <
>                                                               <
>   nMatchedLines = 0;                                          <
>                                                               <
>   for (MapStringToLinePtr::iterator i = table.begin (); i !=  <
>     Line *l = i->second;                                      <
>                                                               <
>     // If the number of old and new lines match, then we decl <
>     // they are (all) the same line.  Note, it isn't possible <
>     // numbers of both files to be 0.                         <
>                                                               <
>     // (In the original algorithm, we only recognized a match <
>     // if there was exactly 1 copy for each file.)            <
>                                                               <
>     if (l->copies[0].size () == l->copies[1].size ()) {       <
>       nMatchedLines += 1;                                     <
>                                                               <
>       // For each matched line in the new file, mark it with  <
>       // corresponding line (number) in the old file.         <
>                                                               <
>       while (!l->copies[0].empty ()) {                        <
>         unsigned o = l->copies[0].front ();                   <
>         unsigned n = l->copies[1].front ();                   <
>                                                               <
>         // Match up the pair.                                 <
>                                                               <
>         lines[0][o].l = n;                                    <
>         lines[1][n].l = o;                                    <
>                                                               <
>         // Remove the matched line numbers from the lists.    <
>                                                               <
>         l->copies[0].pop_front ();                            <
>         l->copies[1].pop_front ();                            <
>       }                                                       <
>     }                                                         <
>   }                                                           <
>   nTotalMatchedLines += nMatchedLines;                        <
>                                                               <
>   // Let's see the intermediate results.                      <
>                                                               <
>   if (0 < optVerbose) {                                       <
>     fprintf (stderr, " found %u matched lines (%u total).\n", <
>                                                                 
>     if (1 < optVerbose) {                                     |         Line *line = table[text];
>       for (int f = 0; f < 2; f += 1) {                        | 
>         fprintf (stderr, "# file #%d\n", f + 1);              |         if (!line) {
>         for (int l = 0; l < lines[f].size (); l += 1) {       |           table[text] = line = new Line (text);
>           fprintf (stderr, "#   [%d] ", l);                   |           nUniq += 1;
>           lines[f][l].Dump (stderr);                          |         }
>         }                                                     |         line->copies[n].push_back (lines[n].size ());
>       }                                                       |         lines[n].push_back (line);
>     }                                                         |       }
>   }                                                           | 
> }                                                             |       if (0 < optVerbose) {
>                                                               |         fprintf (stderr, " %u lines, %u unique.\n", lines[n].
> // Perform Pass #2, in which we attempt to 'widen' blocks of  |         fflush (stderr);
> // lines, by appending lines which are the same in both files |       }
>                                                               |     } else {
> void pass2 ()                                                 |       fprintf (stderr, "%s: Unable to open %s!  Exiting....\n
> {                                                             |       fflush (stderr);
>   if (0 < optVerbose) {                                       |       perror (ARGV0);
>     fprintf (stderr, "# Pass #2 (spreading matches down)...") |       exit (1);
>   }                                                           |     }
>                                                               |   }
>   nMatchedBlocks = 0;                                         | 
>   nMatchedLines = 0;                                          |   if (0 < optVerbose) {
>                                                               |     fprintf (stderr, "# Total unique lines = %d\n", table.siz
>   // Starting at the top of the old file,...                  |     fflush (stderr);
>                                                               |   }
>   for (unsigned o = 0; o < lines[0].size (); o += 1) {        | 
>                                                               |   // map<int, int> counts;
>     // ... skip any currently unmatched lines...              |   // for (MapStringToLinePtr::iterator i = table.begin (); i 
>                                                               |   //   Line *l = i->second;
>     if (lines[0][o].l == ~0) {                                |   //   counts[l->counts[0].size () + l->counts[1].size ()] +=
>       continue;                                               |   // }
>     }                                                         |   // for (map<int, int>::iterator i = counts.begin (); i != c
>                                                               |   //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s
>     // ... until we find an [already] matched line.  Then, sk |   // }
>     // the set of 1 or more matched lines, until we reach any | 
>     // following, still-unmatched line.                       |   pass1 ();
>                                                               |   pass2 ();
>     unsigned n;                                               |   pass3 ();
>     do {                                                      |   pass4 ();
>       n = lines[0][o].l + 1;                                  |   pass5 ();
>       o += 1;                                                 |   pass6 ();
>     } while (o < lines[0].size () && lines[0][o].l != ~0);    | 
>                                                               |   return 0;
>     // Now, o - 1 is the line number of the last matched old  | }
>     // n - 1 is the line number of the last matched new line. | 
>     // to add new old and new lines, if they match.           | // Perform pass #1, in which we find all explicit matches amo
>                                                               | // unique lines.  For every unique line that appears the same
>     // Finally, attempt to add unmatched lines to the preceed | // of times in both files, we declare the lines to match.
>     // matched set.                                           | 
>                                                               | void pass1 ()
>     for (; o < lines[0].size () && lines[0][o].l == ~0; o +=  | {
>                                                               |   if (0 < optVerbose) {
>       // If the [next] pair of old and new lines aren't the s |     fprintf (stderr, "# Pass 1 (finding matches amongst uniqu
>                                                               |     fflush (stderr);
>       if (lines[0][o].line != lines[1][n].line) {             |   }
>         break;                                                | 
>       }                                                       |   nMatchedLines = 0;
>                                                               | 
>       // Match up the pair.                                   |   for (MapStringToLinePtr::iterator i = table.begin (); i != 
>                                                               |     Line *l = i->second;
>       lines[0][o].l = n;                                      | 
>       lines[1][n].l = o;                                      |     // If the number of old and new lines match, then we decl
>                                                               |     // they are (all) the same line.  Note, it isn't possible
>       // Remove the matched line numbers form the lists.      |     // numbers of both files to be 0.
>                                                               | 
>       Line *line = lines[0][o].line;                          |     // (In the original algorithm, we only recognized a match
>       list<unsigned> &oldCopies = line->copies[0];            |     // if there was exactly 1 copy for each file.)
>       list<unsigned>::iterator oL = find (oldCopies.begin (), | 
>       if (oL != oldCopies.end ()) {                           |     if (l->copies[0].size () == l->copies[1].size ()) {
>         oldCopies.erase (oL);                                 |       nMatchedLines += 1;
>       }                                                       | 
>       list<unsigned> &newCopies = line->copies[0];            |       // For each matched line in the new file, mark it with 
>       list<unsigned>::iterator nL = find (newCopies.begin (), |       // corresponding line (number) in the old file.
>       if (nL != newCopies.end ()) {                           | 
>         newCopies.erase (nL);                                 |       while (!l->copies[0].empty ()) {
>       }                                                       |         unsigned o = l->copies[0].front ();
>                                                               |         unsigned n = l->copies[1].front ();
>       nMatchedLines += 1;                                     | 
>     }                                                         |         // Match up the pair.
>     nMatchedBlocks += 1;                                      | 
>   }                                                           |         lines[0][o].l = n;
>   nTotalMatchedLines += nMatchedLines;                        |         lines[1][n].l = o;
>   nTotalMatchedBlocks += nMatchedBlocks;                      | 
>                                                               |         // Remove the matched line numbers from the lists.
>   // Let's see the intermediate results.                      | 
>                                                               |         l->copies[0].pop_front ();
>   if (0 < optVerbose) {                                       |         l->copies[1].pop_front ();
>     fprintf (stderr,                                          |       }
>              " found %u/%u matched lines/blocks (%u/%u totals |     }
>              nMatchedLines,                                   |   }
>              nMatchedBlocks,                                  |   nTotalMatchedLines += nMatchedLines;
>              nTotalMatchedLines,                              | 
>              nTotalMatchedBlocks                              |   // Let's see the intermediate results.
>             );                                                | 
>     if (1 < optVerbose) {                                     |   if (0 < optVerbose) {
>       for (int f = 0; f < 2; f += 1) {                        |     fprintf (stderr, " found %u matched lines (%u total).\n",
>         fprintf (stderr, "# file #%d\n", f + 1);              |     fflush (stderr);
>         for (int l = 0; l < lines[f].size (); l += 1) {       <
>           fprintf (stderr, "#   [%d] ", l);                   <
>           lines[f][l].Dump (stderr);                          <
>         }                                                     <
>       }                                                       <
>     }                                                         <
>   }                                                           <
> }                                                             <
>                                                               <
> // Perform Pass #3, in which we attempt to 'widen' blocks of  <
> // lines, by prepending lines which are the same in both file <
>                                                               <
> void pass3 ()                                                 <
> {                                                             <
>   if (0 < optVerbose) {                                       <
>     fprintf (stderr, "# Pass #3 (spreading matches up)...");  <
>   }                                                           <
>                                                               <
>   nMatchedBlocks = 0;                                         <
>   nMatchedLines = 0;                                          <
>                                                               <
>   // Starting at the bottom of the old file,...               <
>                                                               <
>   for (int o = lines[0].size (); 0 <= o; o -= 1) {            <
>                                                               <
>     // ... skip any currently unmatched lines...              <
>                                                               <
>     if (lines[0][o].l == ~0) {                                <
>       continue;                                               <
>     }                                                         <
>                                                               <
>     // ... until we find an [already] matched line.  Then, sk <
>     // the set of 1 or more matched lines, until we reach any <
>     // following, still-unmatched line.                       <
>                                                               <
>     unsigned n;                                               <
>     do {                                                      <
>       n = lines[0][o].l - 1;                                  <
>       o -= 1;                                                 <
>     } while (0 <= o && lines[0][o].l != ~0);                  <
>                                                               <
>     // Now, o + 1 is the line number of the last matched old  <
>     // n + 1 is the line number of the last matched new line. <
>     // to add new old and new lines, if they match.           <
>                                                               <
>     // Finally, attempt to add unmatched lines to the preceed <
>     // matched set.                                           <
>                                                               <
>     for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {   <
>                                                               <
>       // If the [next] pair of old and new lines aren't the s <
>                                                               <
>       if (lines[0][o].line != lines[1][n].line) {             <
>         break;                                                <
>       }                                                       <
>                                                               <
>       // Match up the pair.                                   <
>                                                               <
>       lines[0][o].l = n;                                      <
>       lines[1][n].l = o;                                      <
>                                                               <
>       // Remove the matched line numbers form the lists.      <
>                                                               <
>       Line *line = lines[0][o].line;                          <
>       list<unsigned> &oldCopies = line->copies[0];            <
>       list<unsigned>::iterator oL = find (oldCopies.begin (), <
>       if (oL != oldCopies.end ()) {                           <
>         oldCopies.erase (oL);                                 <
>       }                                                       <
>       list<unsigned> &newCopies = line->copies[0];            <
>       list<unsigned>::iterator nL = find (newCopies.begin (), <
>       if (nL != newCopies.end ()) {                           <
>         newCopies.erase (nL);                                 <
>       }                                                       <
>                                                               <
>       nMatchedLines += 1;                                     <
>     }                                                         <
>     nMatchedBlocks += 1;                                      <
>   }                                                           <
>   nTotalMatchedLines += nMatchedLines;                        <
>                                                               <
>   // Let's see the intermediate results.                      <
>                                                               <
>   if (0 < optVerbose) {                                       <
>     fprintf (stderr,                                          <
>              " found %u/%u matched lines/blocks (%u/%u totals <
>              nMatchedLines,                                   <
>              nMatchedBlocks,                                  <
>              nTotalMatchedLines,                              <
>              nTotalMatchedBlocks                              <
>             );                                                <
>                                                                 
>     if (1 < optVerbose) {                                     |     if (2 < optVerbose) {
>       for (int f = 0; f < 2; f += 1) {                        |       for (int f = 0; f < 2; f += 1) {
>         fprintf (stderr, "# file #%d\n", f + 1);              |         fprintf (stderr, "# file #%d\n", f + 1);
>         for (int l = 0; l < lines[f].size (); l += 1) {       |         fflush (stderr);
>           fprintf (stderr, "#   [%d] ", l);                   |         for (int l = 0; l < lines[f].size (); l += 1) {
>           lines[f][l].Dump (stderr);                          |           fprintf (stderr, "#   [%d] ", l);
>         }                                                     |           fflush (stderr);
>       }                                                       |           lines[f][l].Dump (stderr);
>     }                                                         |         }
>   }                                                           |       }
> }                                                             |     }
>                                                               |   }
> // Perform pass #4, in which we find any remaining matches am | }
> // unique lines.  For every unique line that has more than 1  | 
> // both files, we declare the copies to match.                | // Perform Pass #2, in which we attempt to 'widen' blocks of 
>                                                               | // lines, by appending lines which are the same in both files
> void pass4 ()                                                 | 
> {                                                             | void pass2 ()
>   if (0 < optVerbose) {                                       | {
>     fprintf (stderr, "# Pass 4 (finding remaining matches amo |   if (0 < optVerbose) {
>   }                                                           |     fprintf (stderr, "# Pass #2 (spreading matches down)...")
>                                                               |     fflush (stderr);
>   nMatchedLines = 0;                                          |   }
>                                                               | 
>   for (MapStringToLinePtr::iterator i = table.begin (); i !=  |   nMatchedBlocks = 0;
>     Line *l = i->second;                                      |   nMatchedLines = 0;
>                                                               | 
>     // If there's more than 1 matching old and new lines, the |   // Starting at the top of the old file,...
>     // declare that each pair are (all) the same line.        | 
>                                                               |   for (unsigned o = 0; o < lines[0].size (); o += 1) {
>     // (In the original algorithm, we only recognized a match | 
>     // if there was exactly 1 copy for each file.)            |     // ... skip any currently unmatched lines...
>                                                               | 
>     while (0 < l->copies[0].size () && 0 < l->copies[1].size  |     if (lines[0][o].l == ~0) {
>       nMatchedLines += 1;                                     |       continue;
>                                                               |     }
>       // For each matched line in the new file, mark it with  | 
>       // corresponding line (number) in the old file.         |     // ... until we find an [already] matched line.  Then, sk
>                                                               |     // the set of 1 or more matched lines, until we reach any
>       unsigned o = l->copies[0].front ();                     |     // following, still-unmatched line.
>       unsigned n = l->copies[1].front ();                     | 
>                                                               |     unsigned n;
>       // Match up the pair.                                   |     do {
>                                                               |       n = lines[0][o].l + 1;
>       lines[0][o].l = n;                                      |       o += 1;
>       lines[1][n].l = o;                                      |     } while (o < lines[0].size () && lines[0][o].l != ~0);
>                                                               | 
>       // Remove the matched line numbers from the lists.      |     // Now, o - 1 is the line number of the last matched old 
>                                                               |     // n - 1 is the line number of the last matched new line.
>       l->copies[0].pop_front ();                              |     // to add new old and new lines, if they match.
>       l->copies[1].pop_front ();                              | 
>     }                                                         |     // Finally, attempt to add unmatched lines to the preceed
>   }                                                           |     // matched set.
>   nTotalMatchedLines += nMatchedLines;                        | 
>                                                               |     for (; o < lines[0].size () && lines[0][o].l == ~0; o += 
>   // Let's see the intermediate results.                      | 
>                                                               |       // If the [next] pair of old and new lines aren't the s
>   if (0 < optVerbose) {                                       | 
>     fprintf (stderr, " found %u matched lines (%u total).\n", |       if (lines[0][o].line != lines[1][n].line) {
>                                                               >         break;
>                                                               >       }
>                                                               > 
>                                                               >       // Match up the pair.
>                                                               > 
>                                                               >       lines[0][o].l = n;
>                                                               >       lines[1][n].l = o;
>                                                               > 
>                                                               >       // Remove the matched line numbers form the lists.
>                                                               > 
>                                                               >       Line *line = lines[0][o].line;
>                                                               >       list<unsigned> &oldCopies = line->copies[0];
>                                                               >       list<unsigned>::iterator oL = find (oldCopies.begin (),
>                                                               >       if (oL != oldCopies.end ()) {
>                                                               >         oldCopies.erase (oL);
>                                                               >       }
>                                                               >       list<unsigned> &newCopies = line->copies[0];
>                                                               >       list<unsigned>::iterator nL = find (newCopies.begin (),
>                                                               >       if (nL != newCopies.end ()) {
>                                                               >         newCopies.erase (nL);
>                                                               >       }
>                                                               > 
>                                                               >       nMatchedLines += 1;
>                                                               >     }
>                                                               >     nMatchedBlocks += 1;
>                                                               >   }
>                                                               >   nTotalMatchedLines += nMatchedLines;
>                                                               >   nTotalMatchedBlocks += nMatchedBlocks;
>                                                               > 
>                                                               >   // Let's see the intermediate results.
>                                                               > 
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr,
>                                                               >              " found %u/%u matched lines/blocks (%u/%u totals
>                                                               >              nMatchedLines,
>                                                               >              nMatchedBlocks,
>                                                               >              nTotalMatchedLines,
>                                                               >              nTotalMatchedBlocks
>                                                               >             );
>                                                               >     fflush (stderr);
>                                                               >     if (2 < optVerbose) {
>                                                               >       for (int f = 0; f < 2; f += 1) {
>                                                               >         fprintf (stderr, "# file #%d\n", f + 1);
>                                                               >         fflush (stderr);
>                                                               >         for (int l = 0; l < lines[f].size (); l += 1) {
>                                                               >           fprintf (stderr, "#   [%d] ", l);
>                                                               >           fflush (stderr);
>                                                               >           lines[f][l].Dump (stderr);
>                                                               >         }
>                                                               >       }
>                                                               >     }
>                                                               >   }
>                                                               > }
>                                                               > 
>                                                               > // Perform Pass #3, in which we attempt to 'widen' blocks of 
>                                                               > // lines, by prepending lines which are the same in both file
>                                                               > 
>                                                               > void pass3 ()
>                                                               > {
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr, "# Pass #3 (spreading matches up)...");
>                                                               >     fflush (stderr);
>                                                               >   }
>                                                               > 
>                                                               >   nMatchedBlocks = 0;
>                                                               >   nMatchedLines = 0;
>                                                               > 
>                                                               >   // Starting at the bottom of the old file,...
>                                                               > 
>                                                               >   for (int o = lines[0].size (); 0 <= o; o -= 1) {
>                                                               > 
>                                                               >     // ... skip any currently unmatched lines...
>                                                               > 
>                                                               >     if (lines[0][o].l == ~0) {
>                                                               >       continue;
>                                                               >     }
>                                                               > 
>                                                               >     // ... until we find an [already] matched line.  Then, sk
>                                                               >     // the set of 1 or more matched lines, until we reach any
>                                                               >     // following, still-unmatched line.
>                                                               > 
>                                                               >     unsigned n;
>                                                               >     do {
>                                                               >       n = lines[0][o].l - 1;
>                                                               >       o -= 1;
>                                                               >     } while (0 <= o && lines[0][o].l != ~0);
>                                                               > 
>                                                               >     // Now, o + 1 is the line number of the last matched old 
>                                                               >     // n + 1 is the line number of the last matched new line.
>                                                               >     // to add new old and new lines, if they match.
>                                                               > 
>                                                               >     // Finally, attempt to add unmatched lines to the preceed
>                                                               >     // matched set.
>                                                               > 
>                                                               >     for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
>                                                               > 
>                                                               >       // If the [next] pair of old and new lines aren't the s
>                                                               > 
>                                                               >       if (lines[0][o].line != lines[1][n].line) {
>                                                               >         break;
>                                                               >       }
>                                                               > 
>                                                               >       // Match up the pair.
>                                                               > 
>                                                               >       lines[0][o].l = n;
>                                                               >       lines[1][n].l = o;
>                                                               > 
>                                                               >       // Remove the matched line numbers form the lists.
>                                                               > 
>                                                               >       Line *line = lines[0][o].line;
>                                                               >       list<unsigned> &oldCopies = line->copies[0];
>                                                               >       list<unsigned>::iterator oL = find (oldCopies.begin (),
>                                                               >       if (oL != oldCopies.end ()) {
>                                                               >         oldCopies.erase (oL);
>                                                               >       }
>                                                               >       list<unsigned> &newCopies = line->copies[0];
>                                                               >       list<unsigned>::iterator nL = find (newCopies.begin (),
>                                                               >       if (nL != newCopies.end ()) {
>                                                               >         newCopies.erase (nL);
>                                                               >       }
>                                                               > 
>                                                               >       nMatchedLines += 1;
>                                                               >     }
>                                                               >     nMatchedBlocks += 1;
>                                                               >   }
>                                                               >   nTotalMatchedLines += nMatchedLines;
>                                                               > 
>                                                               >   // Let's see the intermediate results.
>                                                               > 
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr,
>                                                               >              " found %u/%u matched lines/blocks (%u/%u totals
>                                                               >              nMatchedLines,
>                                                               >              nMatchedBlocks,
>                                                               >              nTotalMatchedLines,
>                                                               >              nTotalMatchedBlocks
>                                                               >             );
>                                                               >     fflush (stderr);
>                                                                 
>     if (1 < optVerbose) {                                     |     if (2 < optVerbose) {
>       for (int f = 0; f < 2; f += 1) {                        |       for (int f = 0; f < 2; f += 1) {
>         fprintf (stderr, "# file #%d\n", f + 1);              |         fprintf (stderr, "# file #%d\n", f + 1);
>         for (int l = 0; l < lines[f].size (); l += 1) {       |         fflush (stderr);
>           fprintf (stderr, "#   [%d] ", l);                   |         for (int l = 0; l < lines[f].size (); l += 1) {
>           lines[f][l].Dump (stderr);                          |           fprintf (stderr, "#   [%d] ", l);
>         }                                                     |           fflush (stderr);
>       }                                                       |           lines[f][l].Dump (stderr);
>     }                                                         |         }
>   }                                                           |       }
> }                                                             |     }
>                                                               |   }
> // Perform Pass #5, in which we look for blocks which match,  | }
> // the result of a move (their not in their original position | 
> // these, we'll unmatch the blocks, turning them into a delet | // Perform pass #4, in which we find any remaining matches am
> // insert.                                                    | // unique lines.  For every unique line that has more than 1 
>                                                               | // both files, we declare the copies to match.
> void pass5 ()                                                 | 
> {                                                             | void pass4 ()
>   if (0 < optVerbose) {                                       | {
>     fprintf (stderr, "# Pass #5 (unmatching block moves)...\n |   if (0 < optVerbose) {
>   }                                                           |     fprintf (stderr, "# Pass 4 (finding remaining matches amo
>                                                               |     fflush (stderr);
>   nMatchedBlocks = 0;                                         |   }
>   nMatchedLines = 0;                                          | 
>                                                               |   nMatchedLines = 0;
>   // Starting at the top of both files,...                    | 
>                                                               |   for (MapStringToLinePtr::iterator i = table.begin (); i != 
>   unsigned o = 0;                                             |     Line *l = i->second;
>   unsigned n = 0;                                             | 
>                                                               |     // If there's more than 1 matching old and new lines, the
>   while (o < lines[0].size () || n < lines[1].size ()) {      |     // declare that each pair are (all) the same line.
>                                                               | 
>     // Skip any unmatched lines at this point in the old file |     // (In the original algorithm, we only recognized a match
>     // are deletes.                                           |     // if there was exactly 1 copy for each file.)
>                                                               | 
>     //    Old     New                                         |     while (0 < l->copies[0].size () && 0 < l->copies[1].size 
>     //   +---+                                                |       nMatchedLines += 1;
>     // 0 | a |                                                | 
>     //   +---+   +---+                                        |       // For each matched line in the new file, mark it with 
>     //         0 | b |                                        |       // corresponding line (number) in the old file.
>     //   +---+   +---+                                        | 
>     // 1 | c | 1 | c |                                        |       unsigned o = l->copies[0].front ();
>     //   +---+   +---+                                        |       unsigned n = l->copies[1].front ();
>     //         2 | z |                                        | 
>     //   +---+   +---+                                        |       // Match up the pair.
>     // 2 | d | 3 | d |                                        | 
>     //   +---+   +---+                                        |       lines[0][o].l = n;
>                                                               |       lines[1][n].l = o;
>     while (o < lines[0].size () && lines[0][o].l == ~0) {     | 
>       o += 1;                                                 |       // Remove the matched line numbers from the lists.
>     }                                                         | 
>                                                               |       l->copies[0].pop_front ();
>     // Skip any unmatched lines at this point in the new file |       l->copies[1].pop_front ();
>     // are inserts.                                           |     }
>                                                               |   }
>     while (n < lines[1].size () && lines[1][n].l == ~0) {     |   nTotalMatchedLines += nMatchedLines;
>       n += 1;                                                 | 
>     }                                                         |   // Let's see the intermediate results.
>                                                               | 
>     // When we get here, we know that we're dealing with matc |   if (0 < optVerbose) {
>     // lines (or the end of one or both files).  We're done w |     fprintf (stderr, " found %u matched lines (%u total).\n",
>     // pass, if we've reached the end of either file.         |     fflush (stderr);
>                                                               <
>     if (lines[0].size () <= o || lines[1].size () <= n) {     <
>       break;                                                  <
>     }                                                         <
>                                                               <
>     // We now know that we've got a pair of matching lines, t <
>     // of a matching block.  If the new file's line number is <
>     // expect, then the matched pair is unmoved, and we can s <
>     // the pair.  (If this is really the start of a block of  <
>     // 1 lines, we'll handle it one pair at a time.)          <
>                                                               <
>     if (lines[0][o].l == n) {                                 <
>       o += 1;                                                 <
>       n += 1;                                                 <
>       continue;                                               <
>     }                                                         <
>                                                               <
>     // If, on the other hand, we don't expect this [new] line <
>     // then this matching block has been moved.  We need to t <
>     // matched pair into an *unmatched* pair, one of deletes, <
>     // of inserts.  First, though, we need to know how big th <
>     // is, and how far it was moved....                       <
>                                                               <
>     // Remember where we were when we started.                <
>                                                               <
>     unsigned oOld = o;                                        <
>     unsigned nOld = n;                                        <
>                                                               <
>     // Remember where the block came from.                    <
>                                                               <
>     unsigned nNew = lines[0][o].l;                            <
>                                                               <
>     // Find the end of this matched pair.                     <
>                                                               <
>     for (n = nNew; o < lines[0].size () && n < lines[1].size  <
>       if (lines[0][o].l != n) {                               <
>         break;                                                <
>       }                                                       <
>     }                                                         <
>                                                               <
>     // When we get here:                                      <
>     // * oOld..o is the old file's block,                     <
>     // * nNew..n is the new file's *moved* block, and         <
>     // * nOld is where we originally expected the new block f <
>                                                               <
>     // We can now calculate the length of the block...        <
>                                                               <
>     unsigned bSize = o - oOld;  // (or n - nNew)              <
>                                                               <
>     // ... and we can calculate how far the block moved:      <
>                                                               <
>     unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew; <
>                                                               <
>     // The larger of the two will become our delete, and the  <
>     // will become our insert.                                <
>                                                               <
>     //    Old     New                                         <
>     //   +---+   +---+                                        <
>     // 0 | a | 0 | b |                                        <
>     //   +---+ 1 | b |                                        <
>     // 1 | b |   +---+                                        <
>     // 2 | b | 2 | a |                                        <
>     //   +---+   +---+                                        <
>     // 3 | c | 3 | c |                                        <
>     //   +---+   +---+                                        <
>                                                               <
>     // (1) Delete a@0, insert a@2, or                         <
>     // (2) insert bb@0, delete bb@1?                          <
>                                                               <
>     // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and <
>     // (of a) is 2-0 or 2, the size of b@0.  We choose to del <
>     // and reinsert a@2.                                      <
>                                                               <
>     // if (bSize <= bMove) {                                  <
>       for (unsigned a = oOld; a < o; a += 1) {                <
>         lines[0][a].l = ~0;                                   <
>       }                                                       <
>       for (unsigned d = nNew; d < n; d += 1) {                <
>         lines[1][d].l = ~0;                                   <
>       }                                                       <
>     // } else {                                               <
>       // for (unsigned a = oOld; a < o; a += 1) {             <
>       //   lines[0][a].l = ~0;                                <
>       // }                                                    <
>       // for (unsigned d = nNew; d < n; d += 1) {             <
>       //   lines[1][d].l = ~0;                                <
>       // }                                                    <
>     // }                                                      <
>                                                               <
>     // Continue from where we left off.                       <
>                                                               <
>     n = nOld;                                                 <
>   }                                                           <
>   nTotalMatchedLines -= nMatchedLines;                        <
>   nTotalMatchedBlocks -= nMatchedBlocks;                      <
>                                                               <
>   // Let's see the intermediate results.                      <
>                                                               <
>   if (0 < optVerbose) {                                       <
>     fprintf (stderr,                                          <
>              " found %u/%u matched lines/blocks (%u/%u totals <
>              nMatchedLines,                                   <
>              nMatchedBlocks,                                  <
>              nTotalMatchedLines,                              <
>              nTotalMatchedBlocks                              <
>             );                                                <
>                                                                 
>     if (1 < optVerbose) {                                     |     if (2 < optVerbose) {
>       for (int f = 0; f < 2; f += 1) {                        |       for (int f = 0; f < 2; f += 1) {
>         fprintf (stderr, "# file #%d\n", f + 1);              |         fprintf (stderr, "# file #%d\n", f + 1);
>         for (int l = 0; l < lines[f].size (); l += 1) {       |         fflush (stderr);
>           fprintf (stderr, "#   [%d] ", l);                   |         for (int l = 0; l < lines[f].size (); l += 1) {
>           lines[f][l].Dump (stderr);                          |           fprintf (stderr, "#   [%d] ", l);
>         }                                                     |           fflush (stderr);
>       }                                                       |           lines[f][l].Dump (stderr);
>     }                                                         |         }
>   }                                                           |       }
> }                                                             |     }
>                                                               |   }
> // Perform Pass #6, in which we create the desired output.    | }
>                                                               | 
> void pass6c ();                                               | // Perform Pass #5, in which we look for blocks which match, 
> void pass6e ();                                               | // the result of a move (their not in their original position
> void pass6i ();                                               | // these, we'll unmatch the blocks, turning them into a delet
> void pass6n ();                                               | // insert.
> void pass6r ();                                               | 
> void pass6s ();                                               | void pass5 ()
> void pass6u ();                                               | {
>                                                               |   if (0 < optVerbose) {
> void pass6 ()                                                 |     fprintf (stderr, "# Pass #5 (unmatching block moves)...\n
> {                                                             |     fflush (stderr);
>                                                               |   }
>   switch (diffFormat) {                                       | 
>   case Context:                                               |   nMatchedBlocks = 0;
>     pass6c ();                                                |   nMatchedLines = 0;
>     break;                                                    | 
>                                                               |   // Starting at the top of both files,...
>   case EdScript:                                              | 
>     pass6e ();                                                |   unsigned o = 0;
>     break;                                                    |   unsigned n = 0;
>                                                               | 
>   case IfThenElse:                                            |   while (o < lines[0].size () || n < lines[1].size ()) {
>     pass6i ();                                                | 
>     break;                                                    |     // Skip any unmatched lines at this point in the old file
>                                                               |     // are deletes.
>   case Normal:                                                | 
>     pass6n ();                                                |     //    Old     New
>     break;                                                    |     //   +---+
>                                                               |     // 0 | a |
>   case RCS:                                                   |     //   +---+   +---+
>     pass6r ();                                                |     //         0 | b |
>     break;                                                    |     //   +---+   +---+
>                                                               |     // 1 | c | 1 | c |
>   case SideBySide:                                            |     //   +---+   +---+
>     pass6s ();                                                |     //         2 | z |
>     break;                                                    |     //   +---+   +---+
>                                                               |     // 2 | d | 3 | d |
>   case Unified:                                               |     //   +---+   +---+
>     pass6u ();                                                | 
>     break;                                                    |     while (o < lines[0].size () && lines[0][o].l == ~0) {
>                                                               |       o += 1;
>   case Default:                                               |     }
>   default:                                                    | 
>     pass6c ();                                                |     // Skip any unmatched lines at this point in the new file
>     break;                                                    |     // are inserts.
>   }                                                           | 
> }                                                             |     while (n < lines[1].size () && lines[1][n].l == ~0) {
>                                                               |       n += 1;
> template<typename T> T min (T l, T r) {                       |     }
>   if (l < r) {                                                | 
>     return l;                                                 |     // When we get here, we know that we're dealing with matc
>   }                                                           |     // lines (or the end of one or both files).  We're done w
>   return r;                                                   |     // pass, if we've reached the end of either file.
> }                                                             | 
>                                                               |     if (lines[0].size () <= o || lines[1].size () <= n) {
> template<typename T> T max (T l, T r) {                       |       break;
>   if (l < r) {                                                |     }
>     return r;                                                 | 
>   }                                                           |     // We now know that we've got a pair of matching lines, t
>   return l;                                                   |     // of a matching block.  If the new file's line number is
> }                                                             |     // expect, then the matched pair is unmoved, and we can s
>                                                               |     // the pair.  (If this is really the start of a block of 
> void pass6c () {                                              |     // 1 lines, we'll handle it one pair at a time.)
>   if (0 < optVerbose) {                                       | 
>     fprintf (stderr, "# Pass #6u (walking the differences)... |     if (lines[0][o].l == n) {
>   }                                                           |       o += 1;
>                                                               |       n += 1;
>   nMatchedLines = 0;                                          |       continue;
>                                                               |     }
>   // Write the header.                                        | 
>                                                               |     // If, on the other hand, we don't expect this [new] line
>   fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:0 |     // then this matching block has been moved.  We need to t
>   fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:0 |     // matched pair into an *unmatched* pair, one of deletes,
>                                                               |     // of inserts.  First, though, we need to know how big th
>   // Starting at the top of both files,...                    |     // is, and how far it was moved....
>                                                               | 
>   unsigned o = 0;                                             |     // Remember where we were when we started.
>   unsigned n = 0;                                             | 
>                                                               |     unsigned oOld = o;
>   while (o < lines[0].size () || n < lines[1].size ()) {      |     unsigned nOld = n;
>                                                               | 
>     // Find the bounds of the current contextual 'window'.    |     // Remember where the block came from.
>                                                               | 
>     // If we aren't looking at a delete or an insert, we're n |     unsigned nNew = lines[0][o].l;
>     // start of a context window.                             | 
>                                                               |     // Find the end of this matched pair.
>     if (lines[0][o].l != ~0 && lines[1][n].l != ~0) {         | 
>       o += 1;                                                 |     for (n = nNew; o < lines[0].size () && n < lines[1].size 
>       n += 1;                                                 |       if (lines[0][o].l != n) {
>       continue;                                               |         break;
>     }                                                         |       }
>                                                               |     }
>     // We're looking at at least 1 delete or insert, so a win | 
>     // begins here (or, rather, optCopyContext lines earlier) |     // When we get here:
>                                                               |     // * oOld..o is the old file's block,
>     int boOldWindow = max (0, int (boDeletes) - int(optCopyCo |     // * nNew..n is the new file's *moved* block, and
>     int eoOldWindow = min (int (lines[0].size ()), int(o) + i |     // * nOld is where we originally expected the new block f
>                                                               >  
>                                                               >     // We can now calculate the length of the block...
>                                                               >     
>                                                               >     unsigned bSize = o - oOld;  // (or n - nNew)
>                                                               > 
>                                                               >     // ... and we can calculate how far the block moved:
>                                                               > 
>                                                               >     unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
>                                                               > 
>                                                               >     // The larger of the two will become our delete, and the 
>                                                               >     // will become our insert.
>                                                               > 
>                                                               >     //    Old     New
>                                                               >     //   +---+   +---+
>                                                               >     // 0 | a | 0 | b |
>                                                               >     //   +---+ 1 | b |
>                                                               >     // 1 | b |   +---+
>                                                               >     // 2 | b | 2 | a |
>                                                               >     //   +---+   +---+
>                                                               >     // 3 | c | 3 | c |
>                                                               >     //   +---+   +---+
>                                                               > 
>                                                               >     // (1) Delete a@0, insert a@2, or
>                                                               >     // (2) insert bb@0, delete bb@1?
>                                                               > 
>                                                               >     // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and
>                                                               >     // (of a) is 2-0 or 2, the size of b@0.  We choose to del
>                                                               >     // and reinsert a@2.
>                                                               > 
>                                                               >     // if (bSize <= bMove) {
>                                                               >       for (unsigned a = oOld; a < o; a += 1) {
>                                                               >         lines[0][a].l = ~0;
>                                                               >       }
>                                                               >       for (unsigned d = nNew; d < n; d += 1) {
>                                                               >         lines[1][d].l = ~0;
>                                                               >       }
>                                                               >     // } else {
>                                                               >       // for (unsigned a = oOld; a < o; a += 1) {
>                                                               >       //   lines[0][a].l = ~0;
>                                                               >       // }
>                                                               >       // for (unsigned d = nNew; d < n; d += 1) {
>                                                               >       //   lines[1][d].l = ~0;
>                                                               >       // }
>                                                               >     // }
>                                                               > 
>                                                               >     // Continue from where we left off.
>                                                               > 
>                                                               >     n = nOld;
>                                                               >   }
>                                                               >   nTotalMatchedLines -= nMatchedLines;
>                                                               >   nTotalMatchedBlocks -= nMatchedBlocks;
>                                                               > 
>                                                               >   // Let's see the intermediate results.
>                                                               > 
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr,
>                                                               >              " found %u/%u matched lines/blocks (%u/%u totals
>                                                               >              nMatchedLines,
>                                                               >              nMatchedBlocks,
>                                                               >              nTotalMatchedLines,
>                                                               >              nTotalMatchedBlocks
>                                                               >             );
>                                                               >     fflush (stderr);
>                                                                 
>     // Look for the end of the window.                        |     if (2 < optVerbose) {
>                                                               >       for (int f = 0; f < 2; f += 1) {
>                                                               >         fprintf (stderr, "# file #%d\n", f + 1);
>                                                               >         fflush (stderr);
>                                                               >         for (int l = 0; l < lines[f].size (); l += 1) {
>                                                               >           fprintf (stderr, "#   [%d] ", l);
>                                                               >           fflush (stderr);
>                                                               >           lines[f][l].Dump (stderr);
>                                                               >         }
>                                                               >       }
>                                                               >     }
>                                                               >   }
>                                                               > }
>                                                               > 
>                                                               > // Perform Pass #6, in which we create the desired output.
>                                                               > 
>                                                               > void pass6c ();
>                                                               > void pass6e ();
>                                                               > void pass6i ();
>                                                               > void pass6n ();
>                                                               > void pass6r ();
>                                                               > void pass6s ();
>                                                               > void pass6u ();
>                                                               > void pass6y ();
>                                                               > 
>                                                               > void pass6 ()
>                                                               > {
>                                                               > 
>                                                               >   switch (diffFormat) {
>                                                               >   case Context:
>                                                               >     pass6c ();
>                                                               >     break;
>                                                               > 
>                                                               >   case EdScript:
>                                                               >     pass6e ();
>                                                               >     break;
>                                                               > 
>                                                               >   case IfThenElse:
>                                                               >     pass6i ();
>                                                               >     break;
>                                                               > 
>                                                               >   case Normal:
>                                                               >     pass6n ();
>                                                               >     break;
>                                                               > 
>                                                               >   case RCS:
>                                                               >     pass6r ();
>                                                               >     break;
>                                                               > 
>                                                               >   case SideBySide:
>                                                               >     pass6y ();
>                                                               >     break;
>                                                               > 
>                                                               >   case Unified:
>                                                               >     pass6u ();
>                                                               >     break;
>                                                               > 
>                                                               >   case Default:
>                                                               >   default:
>                                                               >     pass6c ();
>                                                               >     break;
>                                                               >   }
>                                                               > }
>                                                               > 
>                                                               > template<typename T> T min (T l, T r) {
>                                                               >   if (l < r) {
>                                                               >     return l;
>                                                               >   }
>                                                               >   return r;
>                                                               > }
>                                                               > 
>                                                               > template<typename T> T max (T l, T r) {
>                                                               >   if (l < r) {
>                                                               >     return r;
>                                                               >   }
>                                                               >   return l;
>                                                               > }
>                                                               > 
>                                                               > void pass6c () {
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr, "# Pass #6c (walking the differences)...
>                                                               >     fflush (stderr);
>                                                               >   }
>                                                               > 
>                                                               >   nMatchedLines = 0;
>                                                               > 
>                                                               >   // Write the header.
>                                                               > 
>                                                               >   fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:0
>                                                               >   fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:0
>                                                               > 
>                                                               >   // Starting at the top of both files,...
>                                                               > 
>                                                               >   unsigned o = 0;
>                                                               >   unsigned n = 0;
>                                                               > 
>                                                               >   while (o < lines[0].size () || n < lines[1].size ()) {
>                                                               > 
>                                                               >     // Find the bounds of the current contextual 'window'.
>                                                               > 
>                                                               >     // If we aren't looking at a delete or an insert, we're n
>                                                               >     // start of a context window.
>                                                               > 
>                                                               >     if (lines[0][o].l != ~0 && lines[1][n].l != ~0) {
>                                                               >       o += 1;
>                                                               >       n += 1;
>                                                               >       continue;
>                                                               >     }
>                                                               > 
>                                                               >     // We're now looking at at least 1 delete or insert, so a
>                                                               >     // begins here (or, rather, optCopyContext lines earlier)
>                                                               >     
>                                                               >     int boOldWindow = max (0, int (o) - int (optCopyContext))
>                                                               >     int boNewWindow = max (0, int (n) - int (optCopyContext))
>                                                                 
>     bool widenWindow = false;                                 |     if (1 < optVerbose) {
>     do {                                                      |       fprintf (stderr, "boOldWindow = %d, boNewWindow = %d\n"
>                                                               |       fflush (stderr);
>       // Skip over the delete(s) and/or insert(s) defining th <
>       // context.                                             <
>                                                               <
>       while (o < lines[0].size () && lines[0][o].l == ~0) {   <
>         o += 1;                                               <
>       }                                                       <
>       while (n < lines[1].size () && lines[1][n].l == ~0) {   <
>         n += 1;                                               <
>       }                                                       <
>                                                               <
>       // ...  This context will end optCopyContext lines past <
>       // set of deletes or inserts we find.  However, since a <
799,1259c1078,1843
<       // another delete or insert.			      <
< 
<       for (unsigned l = 0; l < (2 * optCopyContext); i += 1)  |	      widenWindow = false;
< 							      >	      for (unsigned l = 0; !widenWindow && l < optCopyContext
<         if (o < lines[0].size ()) {				        if (o < lines[0].size ()) {
<           if (widenWindow |= lines[0][o].l == ~0) {	      |	          widenWindow |= lines[0][o].l == ~0;
<             break;					      <
<           }						      <
<           o += 1;						          o += 1;
<         }							        }
<         if (n < lines[1].size ()) {				        if (n < lines[1].size ()) {
<           if (widenWindow |= lines[1][o].l == ~0) {	      |	          widenWindow |= lines[1][n].l == ~0;
<             break;					      <
<           }						      <
<           n += 1;						          n += 1;
<         }							        }
<       }								      }
<     } while (widenWindow);				      |
< 							      >	      eoOldWindow = o;
< 							      >	      eoNewWindow = n;
< 							      >
< 							      >	      // However, since another window could follow, we look
< 							      >	      // optCopyContext ahead for another delete or insert.
< 							      >
< 							      >	      if (!widenWindow) {
< 							      >	        for (unsigned l = 0; l < (2 * optCopyContext + 1); l 
< 							      >	          if (o < lines[0].size ()) {
< 							      >	            widenWindow |= lines[0][o].l == ~0;
< 							      >	            o += 1;
< 							      >	          }
< 							      >	          if (n < lines[1].size ()) {
< 							      >	            widenWindow |= lines[1][n].l == ~0;
< 							      >	            n += 1;
< 							      >	          }
< 							      >	        }
< 							      >	      }
< 							      >	    }
< 
<     // We've found the end of the window.			    // We've found the end of the window.
< 
<     int boNewWindow = max (0, int (boInserts) - int (optCopyC |	    if (1 < optVerbose) {
<     int eoNewWindow = min (int (lines[1].size ()), int(n) + i |	      fprintf (stderr, "eoOldWindow = %d, eoNewWindow = %d\n"
< 							      >	      fflush (stderr);
< 							      >	    }
< 
<     // Now, reset ourselves to the start of the window, and w	    // Now, reset ourselves to the start of the window, and w
<     // produce the output.  We'll walk it twice, first for th	    // produce the output.  We'll walk it twice, first for th
<     // file part, then for the new file part.			    // file part, then for the new file part.
< 
<     fprintf (stdout, "***************\n");			    fprintf (stdout, "***************\n");
<     fprintf (stdout, "*** %d,%d ****\n", boOldWindow + 1, eoO |	    fprintf (stdout, "*** %d,%d ****\n", boOldWindow + 1, eoO
< 
<     o = boOldWindow;						    o = boOldWindow;
<     n = boNewWindow;						    n = boNewWindow;
< 
<     while (o < eoOldWindow && n < eoNewWindow) {	      |	    while (o < eoOldWindow || n < eoNewWindow) {
< 
<       // Find any unmatched lines at this point in the old fi	      // Find any unmatched lines at this point in the old fi
<       // are deletes.						      // are deletes.
< 
<       unsigned boDeletes = o;					      unsigned boDeletes = o;
<       while (o < eoOldWindow && lines[0][o].l == ~0) {		      while (o < eoOldWindow && lines[0][o].l == ~0) {
<         o += 1;							        o += 1;
<       }								      }
< 
<       // Find any unmatched lines at this point in the new fi	      // Find any unmatched lines at this point in the new fi
<       // are inserts.						      // are inserts.
< 
<       unsigned boInserts = n;					      unsigned boInserts = n;
<       while (n < eoNewWindow && lines[1][n].l == ~0) {		      while (n < eoNewWindow && lines[1][n].l == ~0) {
<         n += 1;							        n += 1;
<       }								      }
< 
<       // We've got deleted line(s) from boDeletes .. o.		      // We've got deleted line(s) from boDeletes .. o.
<       // We've got deleted line(s) from boInserts .. n.		      // We've got deleted line(s) from boInserts .. n.
< 
<       unsigned nDeletes = o - boDeletes;			      unsigned nDeletes = o - boDeletes;
<       unsigned nInserts = n - boInserts;			      unsigned nInserts = n - boInserts;
< 
<       // We've got...						      // We've got...
< 
<       if (nDeletes && nInserts) {				      if (nDeletes && nInserts) {
< 
<         // ... deletes and inserts.				        // ... deletes and inserts.
< 
<         for (unsigned l = boDeletes; l < o; l += 1) {		        for (unsigned l = boDeletes; l < o; l += 1) {
<           fprintf (stdout, "! %s", lines[0][l].line->c_str () |	          fprintf (stdout, "! %s\n", lines[0][l].line->c_str 
<         }							        }
<       } else if (nDeletes) {					      } else if (nDeletes) {
< 
<         //  ... just deletes.					        //  ... just deletes.
< 
<         for (unsigned l = boDeletes; l < o; l += 1) {		        for (unsigned l = boDeletes; l < o; l += 1) {
<           fprintf (stdout, "- %s", lines[0][l].line->c_str () |	          fprintf (stdout, "- %s\n", lines[0][l].line->c_str 
<         }							        }
<       }								      }
< 
<       // When we get here, we're dealing with matching lines.	      // When we get here, we're dealing with matching lines.
< 
<       fprintf (stdout, "  %s", lines[0][l].line->c_str ());   |	      fprintf (stdout, "  %s\n", lines[0][o].line->c_str ());
<       o += 1;							      o += 1;
<       n += 1;							      n += 1;
<     }								    }
< 
<     fprintf (stdout, "--- %d,%d ----\n", boNewWindow + 1, eoN |	    fprintf (stdout, "--- %d,%d ----\n", boNewWindow + 1, eoN
< 
<     o = boOldWindow;						    o = boOldWindow;
<     n = boNewWindow;						    n = boNewWindow;
< 
<     while (o < eoOldWindow && n < eoNewWindow) {		    while (o < eoOldWindow && n < eoNewWindow) {
< 
<       // Find any unmatched lines at this point in the old fi	      // Find any unmatched lines at this point in the old fi
<       // are deletes.						      // are deletes.
< 
<       unsigned boDeletes = o;					      unsigned boDeletes = o;
<       while (o < eoOldWindow && lines[0][o].l == ~0) {		      while (o < eoOldWindow && lines[0][o].l == ~0) {
<         o += 1;							        o += 1;
<       }								      }
< 
<       // Find any unmatched lines at this point in the new fi	      // Find any unmatched lines at this point in the new fi
<       // are inserts.						      // are inserts.
< 
<       unsigned boInserts = n;					      unsigned boInserts = n;
<       while (n < eoNewWindow && lines[1][n].l == ~0) {		      while (n < eoNewWindow && lines[1][n].l == ~0) {
<         n += 1;							        n += 1;
<       }								      }
< 
<       // We've got deleted line(s) from boDeletes .. o.		      // We've got deleted line(s) from boDeletes .. o.
<       // We've got deleted line(s) from boInserts .. n.		      // We've got deleted line(s) from boInserts .. n.
< 
<       unsigned nDeletes = o - boDeletes;			      unsigned nDeletes = o - boDeletes;
<       unsigned nInserts = n - boInserts;			      unsigned nInserts = n - boInserts;
< 
<       // We've got...						      // We've got...
< 
<       if (nDeletes && nInserts) {				      if (nDeletes && nInserts) {
< 
<         // ... deletes and inserts.				        // ... deletes and inserts.
< 
<         for (unsigned l = boInserts; l < n; l += 1) {		        for (unsigned l = boInserts; l < n; l += 1) {
<           fprintf (stdout, "! %s", lines[1][l].line->c_str () |	          fprintf (stdout, "! %s\n", lines[1][l].line->c_str 
<         }							        }
<       } else if (nInserts) {					      } else if (nInserts) {
< 
<         //  ... just inserts.					        //  ... just inserts.
< 
<         for (unsigned l = boInserts; l < n; l += 1) {		        for (unsigned l = boInserts; l < n; l += 1) {
<           fprintf (stdout, "+ %s", lines[1][l].line->c_str () |	          fprintf (stdout, "+ %s\n", lines[1][l].line->c_str 
<         }							        }
<       }								      }
< 
<       // When we get here, we're dealing with matching lines.	      // When we get here, we're dealing with matching lines.
< 
<       fprintf (stdout, "  %s", lines[1][l].line->c_str ());   |	      fprintf (stdout, "  %s\n", lines[1][n].line->c_str ());
<       o += 1;							      o += 1;
<       n += 1;							      n += 1;
<     }								    }
< 							      >
< 							      >	    // Reset to the end of the current window.
< 							      >
< 							      >	    o = eoOldWindow;
< 							      >	    n = eoNewWindow;
<   }								  }
< }								}
< 
< void pass6e () {						void pass6e () {
< 							      >	  fprintf (stderr, "pass6e() is unimplemented!\n");
< 							      >	  fflush (stderr);
< }								}
< 
< void pass6i () {						void pass6i () {
< 							      >	  fprintf (stderr, "pass6i() is unimplemented!\n");
< 							      >	  fflush (stderr);
< }								}
< 
< void pass6n ()							void pass6n ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #6n (walking the differences)...	    fprintf (stderr, "# Pass #6n (walking the differences)...
< 							      >	    fflush (stderr);
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Write the header.  (None for normal.)			  // Write the header.  (None for normal.)
< 
<   // Starting at the top of both files,...			  // Starting at the top of both files,...
< 
<   unsigned o = 0;						  unsigned o = 0;
<   unsigned n = 0;						  unsigned n = 0;
< 
<   while (o < lines[0].size () || n < lines[1].size ()) {	  while (o < lines[0].size () || n < lines[1].size ()) {
< 
<     // Find any unmatched lines at this point in the old file	    // Find any unmatched lines at this point in the old file
<     // are deletes.						    // are deletes.
< 
<     unsigned boDeletes;						    unsigned boDeletes;
<     for (boDeletes = o;						    for (boDeletes = o;
<          o < lines[0].size () && lines[0][o].l == ~0;		         o < lines[0].size () && lines[0][o].l == ~0;
<          o += 1							         o += 1
<         )							        )
<     {}								    {}
< 
<     // Find any unmatched lines at this point in the new file	    // Find any unmatched lines at this point in the new file
<     // are inserts.						    // are inserts.
< 
<     unsigned boInserts;						    unsigned boInserts;
<     for (boInserts = n;						    for (boInserts = n;
<          n < lines[1].size () && lines[1][n].l == ~0;		         n < lines[1].size () && lines[1][n].l == ~0;
<          n += 1							         n += 1
<         )							        )
<     {}								    {}
< 
<     // We've got deleted line(s) from boDeletes .. o.		    // We've got deleted line(s) from boDeletes .. o.
<     // We've got deleted line(s) from boInserts .. n.		    // We've got deleted line(s) from boInserts .. n.
< 
<     unsigned nDeletes = o - boDeletes;				    unsigned nDeletes = o - boDeletes;
<     unsigned nInserts = n - boInserts;				    unsigned nInserts = n - boInserts;
< 
<     // We've got...						    // We've got...
< 
<     if (nDeletes && nInserts) {					    if (nDeletes && nInserts) {
< 
<       // ... deletes and inserts.				      // ... deletes and inserts.
< 
<       if (1 < nDeletes && 1 < nInserts) {			      if (1 < nDeletes && 1 < nInserts) {
<         fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, b	        fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, b
<       } else if (1 < nDeletes) {				      } else if (1 < nDeletes) {
<         fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boIn	        fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boIn
<       } else if (1 < nInserts) {				      } else if (1 < nInserts) {
<         fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInser	        fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInser
<       } 							      } 
<       for (unsigned l = boDeletes; l < o; l += 1) {		      for (unsigned l = boDeletes; l < o; l += 1) {
<         fprintf (stdout, "< %s", lines[0][l].line->c_str ()); |	        fprintf (stdout, "< %s\n", lines[0][l].line->c_str ()
<       }								      }
<       fprintf (stderr, "---\n");			      |	      fprintf (stdout, "---\n");
<       for (unsigned l = boInserts; l < n; l += 1) {		      for (unsigned l = boInserts; l < n; l += 1) {
<         fprintf (stdout, "> %s", lines[1][l].line->c_str ()); |	        fprintf (stdout, "> %s\n", lines[1][l].line->c_str ()
<       }								      }
<     } else if (nDeletes) {					    } else if (nDeletes) {
< 
<       //  ... just deletes.					      //  ... just deletes.
< 
<       if (1 < nDeletes) {					      if (1 < nDeletes) {
<         fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);	        fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
<       } else {							      } else {
<         fprintf (stdout, "%dd%d\n", boDeletes + 1, n);		        fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
<       }								      }
<       for (unsigned l = boDeletes; l < o; l += 1) {		      for (unsigned l = boDeletes; l < o; l += 1) {
<         fprintf (stdout, "< %s", lines[0][l].line->c_str ()); |	        fprintf (stdout, "< %s\n", lines[0][l].line->c_str ()
<       }								      }
<     } else if (nInserts) {					    } else if (nInserts) {
< 
<       //  ... just inserts.					      //  ... just inserts.
< 
<       if (1 < nInserts) {					      if (1 < nInserts) {
<         fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);	        fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
<       } else {							      } else {
<         fprintf (stdout, "%da%d\n", o, boInserts + 1);		        fprintf (stdout, "%da%d\n", o, boInserts + 1);
<       }								      }
<       for (unsigned l = boInserts; l < n; l += 1) {		      for (unsigned l = boInserts; l < n; l += 1) {
<         fprintf (stdout, "> %s", lines[1][l].line->c_str ()); |	        fprintf (stdout, "> %s\n", lines[1][l].line->c_str ()
<       }								      }
<     }								    }
< 
<     // When we get here, we're dealing with matching lines.	    // When we get here, we're dealing with matching lines.
< 
<     o += 1;							    o += 1;
<     n += 1;							    n += 1;
<   }								  }
< }								}
< 
< void pass6r () {						void pass6r () {
< 							      >	  fprintf (stderr, "pass6r() is unimplemented!\n");
< 							      >	  fflush (stderr);
< }								}
< 
< void pass6s () {						void pass6s () {
< 							      >	  fprintf (stderr, "pass6s() is unimplemented!\n");
< 							      >	  fflush (stderr);
< }								}
< 
< void pass6u ()							void pass6u ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #6u (walking the differences)...	    fprintf (stderr, "# Pass #6u (walking the differences)...
< 							      >	    fflush (stderr);
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Write the header.						  // Write the header.
< 
<   fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:0	  fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:0
<   fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:0	  fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:0
<   fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), l	  fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), l
< 
<   // Starting at the top of both files,...			  // Starting at the top of both files,...
< 
<   unsigned o = 0;						  unsigned o = 0;
<   unsigned n = 0;						  unsigned n = 0;
< 
<   while (o < lines[0].size () || n < lines[1].size ()) {	  while (o < lines[0].size () || n < lines[1].size ()) {
< 
<     // Find any unmatched lines at this point in the old file	    // Find any unmatched lines at this point in the old file
<     // are deletes.						    // are deletes.
< 
<     unsigned boDeletes;						    unsigned boDeletes;
<     for (boDeletes = o;						    for (boDeletes = o;
<          o < lines[0].size () && lines[0][o].l == ~0;		         o < lines[0].size () && lines[0][o].l == ~0;
<          o += 1							         o += 1
<         )							        )
<     {}								    {}
< 
<     // Find any unmatched lines at this point in the new file	    // Find any unmatched lines at this point in the new file
<     // are inserts.						    // are inserts.
< 
<     unsigned boInserts;						    unsigned boInserts;
<     for (boInserts = n;						    for (boInserts = n;
<          n < lines[1].size () && lines[1][n].l == ~0;		         n < lines[1].size () && lines[1][n].l == ~0;
<          n += 1							         n += 1
<         )							        )
<     {}								    {}
< 
<     // We've got deleted line(s) from boDeletes .. o.		    // We've got deleted line(s) from boDeletes .. o.
<     // We've got deleted line(s) from boInserts .. n.		    // We've got deleted line(s) from boInserts .. n.
< 
<     unsigned nDeletes = o - boDeletes;				    unsigned nDeletes = o - boDeletes;
<     unsigned nInserts = n - boInserts;				    unsigned nInserts = n - boInserts;
< 
<     // We've got...						    // We've got...
< 
<     if (nDeletes && nInserts) {					    if (nDeletes && nInserts) {
< 
<       // ... deletes and inserts.				      // ... deletes and inserts.
< 
<       for (unsigned l = boDeletes; l < o; l += 1) {		      for (unsigned l = boDeletes; l < o; l += 1) {
<         fprintf (stdout, "-%s", lines[0][l].line->c_str ());  |	        fprintf (stdout, "-%s\n", lines[0][l].line->c_str ())
<       }								      }
<       for (unsigned l = boInserts; l < n; l += 1) {		      for (unsigned l = boInserts; l < n; l += 1) {
<         fprintf (stdout, "+%s", lines[1][l].line->c_str ());  |	        fprintf (stdout, "+%s\n", lines[1][l].line->c_str ())
<       }								      }
<     } else if (nDeletes) {					    } else if (nDeletes) {
< 
<       //  ... just deletes.					      //  ... just deletes.
< 
<       for (unsigned l = boDeletes; l < o; l += 1) {		      for (unsigned l = boDeletes; l < o; l += 1) {
<         fprintf (stdout, "-%s", lines[0][l].line->c_str ());  |	        fprintf (stdout, "-%s\n", lines[0][l].line->c_str ())
<       }								      }
<     } else if (nInserts) {					    } else if (nInserts) {
< 
<       //  ... just inserts.					      //  ... just inserts.
< 
<       for (unsigned l = boInserts; l < n; l += 1) {		      for (unsigned l = boInserts; l < n; l += 1) {
<         fprintf (stdout, "+%s", lines[1][l].line->c_str ());  |	        fprintf (stdout, "+%s\n", lines[1][l].line->c_str ())
<       }								      }
<     }								    }
< 
<     // When we get here, we're dealing with matching lines.	    // When we get here, we're dealing with matching lines.
< 
<     fprintf (stdout, " %s", lines[0][o].line->c_str ());      |	    fprintf (stdout, " %s\n", lines[0][o].line->c_str ());
< 							      >	    o += 1;
< 							      >	    n += 1;
< 							      >	  }
< 							      >	}
< 							      >
< 							      >	void pass6y ()
< 							      >	{
< 							      >	  if (0 < optVerbose) {
< 							      >	    fprintf (stderr, "# Pass #6y (walking the differences)...
< 							      >	    fflush (stderr);
< 							      >	  }
< 							      >
< 							      >	  // Write the header.
< 							      >
< 							      >	  // None for side-by-side.
< 							      >
< 							      >	  // Starting at the top of both files,...
< 							      >
< 							      >	  int columnWidth = (optPageWidth - 7) / 2;
< 							      >
< 							      >	  unsigned o = 0;
< 							      >	  unsigned n = 0;
< 							      >
< 							      >	  while (o < lines[0].size () || n < lines[1].size ()) {
< 							      >
< 							      >	    // Find any unmatched lines at this point in the old file
< 							      >	    // are deletes.
< 							      >
< 							      >	    unsigned boDeletes = o;
< 							      >	    while (o < lines[0].size () && lines[0][o].l == ~0) {
< 							      >	      o += 1;
< 							      >	    }
< 							      >
< 							      >	    // Find any unmatched lines at this point in the new file
< 							      >	    // are inserts.
< 							      >
< 							      >	    unsigned boInserts = n;
< 							      >	    while (n < lines[1].size () && lines[1][n].l == ~0) {
< 							      >	      n += 1;
< 							      >	    }
< 							      >
< 							      >	    // We've got deleted line(s) from boDeletes .. o.
< 							      >	    // We've got deleted line(s) from boInserts .. n.
< 							      >
< 							      >	    unsigned nDeletes = o - boDeletes;
< 							      >	    unsigned nInserts = n - boInserts;
< 							      >
< 							      >	    // We've got...
< 							      >
< 							      >	    while (boDeletes < o && boInserts < n) {
< 							      >
< 							      >	      // ... deletes and inserts.
< 							      >
< 							      >	      fprintf (stdout,
< 							      >	               "%-*s | %s\n",
< 							      >	               columnWidth,
< 							      >	               lines[0][boDeletes].line->substr (0, columnWid
< 							      >	               lines[1][boInserts].line->substr (0, columnWid
< 							      >	              );
< 							      >	      boDeletes += 1;
< 							      >	      boInserts += 1;
< 							      >	    }
< 							      >
< 							      >	    while (boDeletes < o) {
< 							      >
< 							      >	      //  ... just deletes.
< 							      >
< 							      >	      fprintf (stdout,
< 							      >	               "%-*s <\n",
< 							      >	               columnWidth,
< 							      >	               lines[0][boDeletes].line->substr (0, columnWid
< 							      >	              );
< 							      >	      boDeletes += 1;
< 							      >	    }
< 							      >
< 							      >	    while (boInserts < n) {
< 							      >
< 							      >	      //  ... just inserts.
< 							      >
< 							      >	      fprintf (stdout,
< 							      >	               "%-*s > %s\n",
< 							      >	               columnWidth,
< 							      >	               "",
< 							      >	               lines[1][boInserts].line->substr (0, columnWid
< 							      >	              );
< 							      >	      boInserts += 1;
< 							      >	    }
< 							      >
< 							      >	    // When we get here, we're dealing with matching lines.
< 							      >
< 							      >	    fprintf (stdout,
< 							      >	             "%-*s   %s\n",
< 							      >	             columnWidth,
< 							      >	             lines[0][o].line->substr (0, columnWidth).c_str 
< 							      >	             lines[1][n].line->substr (0, columnWidth).c_str 
< 							      >	            );
<     o += 1;							    o += 1;
<     n += 1;							    n += 1;
<   }								  }
< }								}
---
>       // another delete or insert.                            <
>                                                               <
>       for (unsigned l = 0; l < (2 * optCopyContext); i += 1)  <
>         if (o < lines[0].size ()) {                           <
>           if (widenWindow |= lines[0][o].l == ~0) {           <
>             break;                                            <
>           }                                                   <
>           o += 1;                                             <
>         }                                                     <
>         if (n < lines[1].size ()) {                           <
>           if (widenWindow |= lines[1][o].l == ~0) {           <
>             break;                                            <
>           }                                                   <
>           n += 1;                                             <
>         }                                                     <
>       }                                                       <
>     } while (widenWindow);                                    <
>                                                               <
>     // We've found the end of the window.                     <
>                                                               <
>     int boNewWindow = max (0, int (boInserts) - int (optCopyC <
>     int eoNewWindow = min (int (lines[1].size ()), int(n) + i <
>                                                               <
>     // Now, reset ourselves to the start of the window, and w <
>     // produce the output.  We'll walk it twice, first for th <
>     // file part, then for the new file part.                 <
>                                                               <
>     fprintf (stdout, "***************\n");                    <
>     fprintf (stdout, "*** %d,%d ****\n", boOldWindow + 1, eoO <
>                                                               <
>     o = boOldWindow;                                          <
>     n = boNewWindow;                                          <
>                                                               <
>     while (o < eoOldWindow && n < eoNewWindow) {              <
>                                                               <
>       // Find any unmatched lines at this point in the old fi <
>       // are deletes.                                         <
>                                                               <
>       unsigned boDeletes = o;                                 <
>       while (o < eoOldWindow && lines[0][o].l == ~0) {        <
>         o += 1;                                               <
>       }                                                       <
>                                                               <
>       // Find any unmatched lines at this point in the new fi <
>       // are inserts.                                         <
>                                                               <
>       unsigned boInserts = n;                                 <
>       while (n < eoNewWindow && lines[1][n].l == ~0) {        <
>         n += 1;                                               <
>       }                                                       <
>                                                               <
>       // We've got deleted line(s) from boDeletes .. o.       <
>       // We've got deleted line(s) from boInserts .. n.       <
>                                                               <
>       unsigned nDeletes = o - boDeletes;                      <
>       unsigned nInserts = n - boInserts;                      <
>                                                               <
>       // We've got...                                         <
>                                                               <
>       if (nDeletes && nInserts) {                             <
>                                                               <
>         // ... deletes and inserts.                           <
>                                                               <
>         for (unsigned l = boDeletes; l < o; l += 1) {         <
>           fprintf (stdout, "! %s", lines[0][l].line->c_str () <
>         }                                                     <
>       } else if (nDeletes) {                                  <
>                                                               <
>         //  ... just deletes.                                 <
>                                                               <
>         for (unsigned l = boDeletes; l < o; l += 1) {         <
>           fprintf (stdout, "- %s", lines[0][l].line->c_str () <
>         }                                                     <
>       }                                                       <
>                                                               <
>       // When we get here, we're dealing with matching lines. <
>                                                               <
>       fprintf (stdout, "  %s", lines[0][l].line->c_str ());   <
>       o += 1;                                                 <
>       n += 1;                                                 <
>     }                                                               }
>                                                               > 
>                                                               >     // Look for the end of the current window.
>                                                                 
>     fprintf (stdout, "--- %d,%d ----\n", boNewWindow + 1, eoN |     int eoOldWindow;
>                                                               |     int eoNewWindow;
>     o = boOldWindow;                                          <
>     n = boNewWindow;                                          <
>                                                               <
>     while (o < eoOldWindow && n < eoNewWindow) {              <
>                                                               <
>       // Find any unmatched lines at this point in the old fi <
>       // are deletes.                                         <
>                                                               <
>       unsigned boDeletes = o;                                 <
>       while (o < eoOldWindow && lines[0][o].l == ~0) {        <
>         o += 1;                                               <
>       }                                                       <
>                                                               <
>       // Find any unmatched lines at this point in the new fi <
>       // are inserts.                                         <
>                                                               <
>       unsigned boInserts = n;                                 <
>       while (n < eoNewWindow && lines[1][n].l == ~0) {        <
>         n += 1;                                               <
>       }                                                       <
>                                                               <
>       // We've got deleted line(s) from boDeletes .. o.       <
>       // We've got deleted line(s) from boInserts .. n.       <
>                                                               <
>       unsigned nDeletes = o - boDeletes;                      <
>       unsigned nInserts = n - boInserts;                      <
>                                                               <
>       // We've got...                                         <
>                                                               <
>       if (nDeletes && nInserts) {                             <
>                                                               <
>         // ... deletes and inserts.                           <
>                                                               <
>         for (unsigned l = boInserts; l < n; l += 1) {         <
>           fprintf (stdout, "! %s", lines[1][l].line->c_str () <
>         }                                                     <
>       } else if (nInserts) {                                  <
>                                                               <
>         //  ... just inserts.                                 <
>                                                               <
>         for (unsigned l = boInserts; l < n; l += 1) {         <
>           fprintf (stdout, "+ %s", lines[1][l].line->c_str () <
>         }                                                     <
>       }                                                       <
>                                                               <
>       // When we get here, we're dealing with matching lines. <
>                                                               <
>       fprintf (stdout, "  %s", lines[1][l].line->c_str ());   <
>       o += 1;                                                 <
>       n += 1;                                                 <
>     }                                                         <
>   }                                                           <
> }                                                             <
>                                                               <
> void pass6e () {                                              <
> }                                                             <
>                                                                 
> void pass6i () {                                              |     bool widenWindow = true;
> }                                                             |     while (widenWindow && o < lines[0].size () || n < lines[1
>                                                               | 
> void pass6n ()                                                |       // Skip over the delete(s) and/or insert(s) defining th
> {                                                             |       // context.
>   if (0 < optVerbose) {                                       | 
>     fprintf (stderr, "# Pass #6n (walking the differences)... |       while (o < lines[0].size () && lines[0][o].l == ~0) {
>   }                                                           |         o += 1;
>                                                               |       }
>   nMatchedLines = 0;                                          |       while (n < lines[1].size () && lines[1][n].l == ~0) {
>                                                               |         n += 1;
>   // Write the header.  (None for normal.)                    |       }
>                                                               | 
>   // Starting at the top of both files,...                    |       // This context will end optCopyContext matched lines p
>                                                               |       // last set of deletes or inserts we find.
>   unsigned o = 0;                                             <
>   unsigned n = 0;                                             <
>                                                               <
>   while (o < lines[0].size () || n < lines[1].size ()) {      <
>                                                               <
>     // Find any unmatched lines at this point in the old file <
>     // are deletes.                                           <
>                                                               <
>     unsigned boDeletes;                                       <
>     for (boDeletes = o;                                       <
>          o < lines[0].size () && lines[0][o].l == ~0;         <
>          o += 1                                               <
>         )                                                     <
>     {}                                                        <
>                                                               <
>     // Find any unmatched lines at this point in the new file <
>     // are inserts.                                           <
>                                                               <
>     unsigned boInserts;                                       <
>     for (boInserts = n;                                       <
>          n < lines[1].size () && lines[1][n].l == ~0;         <
>          n += 1                                               <
>         )                                                     <
>     {}                                                        <
>                                                               <
>     // We've got deleted line(s) from boDeletes .. o.         <
>     // We've got deleted line(s) from boInserts .. n.         <
>                                                               <
>     unsigned nDeletes = o - boDeletes;                        <
>     unsigned nInserts = n - boInserts;                        <
>                                                               <
>     // We've got...                                           <
>                                                               <
>     if (nDeletes && nInserts) {                               <
>                                                               <
>       // ... deletes and inserts.                             <
>                                                               <
>       if (1 < nDeletes && 1 < nInserts) {                     <
>         fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, b <
>       } else if (1 < nDeletes) {                              <
>         fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boIn <
>       } else if (1 < nInserts) {                              <
>         fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInser <
>       }                                                       <
>       for (unsigned l = boDeletes; l < o; l += 1) {           <
>         fprintf (stdout, "< %s", lines[0][l].line->c_str ()); <
>       }                                                       <
>       fprintf (stderr, "---\n");                              <
>       for (unsigned l = boInserts; l < n; l += 1) {           <
>         fprintf (stdout, "> %s", lines[1][l].line->c_str ()); <
>       }                                                       <
>     } else if (nDeletes) {                                    <
>                                                               <
>       //  ... just deletes.                                   <
>                                                               <
>       if (1 < nDeletes) {                                     <
>         fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);  <
>       } else {                                                <
>         fprintf (stdout, "%dd%d\n", boDeletes + 1, n);        <
>       }                                                       <
>       for (unsigned l = boDeletes; l < o; l += 1) {           <
>         fprintf (stdout, "< %s", lines[0][l].line->c_str ()); <
>       }                                                       <
>     } else if (nInserts) {                                    <
>                                                               <
>       //  ... just inserts.                                   <
>                                                               <
>       if (1 < nInserts) {                                     <
>         fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);  <
>       } else {                                                <
>         fprintf (stdout, "%da%d\n", o, boInserts + 1);        <
>       }                                                       <
>       for (unsigned l = boInserts; l < n; l += 1) {           <
>         fprintf (stdout, "> %s", lines[1][l].line->c_str ()); <
>       }                                                       <
>     }                                                         <
>                                                               <
>     // When we get here, we're dealing with matching lines.   <
>                                                               <
>     o += 1;                                                   <
>     n += 1;                                                   <
>   }                                                           <
> }                                                             <
>                                                               <
> void pass6r () {                                              <
> }                                                             <
>                                                                 
> void pass6s () {                                              |       widenWindow = false;
> }                                                             |       for (unsigned l = 0; !widenWindow && l < optCopyContext
>                                                               |         if (o < lines[0].size ()) {
> void pass6u ()                                                |           widenWindow |= lines[0][o].l == ~0;
> {                                                             |           o += 1;
>   if (0 < optVerbose) {                                       |         }
>     fprintf (stderr, "# Pass #6u (walking the differences)... |         if (n < lines[1].size ()) {
>   }                                                           |           widenWindow |= lines[1][n].l == ~0;
>                                                               |           n += 1;
>   nMatchedLines = 0;                                          |         }
>                                                               |       }
>   // Write the header.                                        <
>                                                               <
>   fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:0 <
>   fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:0 <
>   fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), l <
>                                                               <
>   // Starting at the top of both files,...                    <
>                                                               <
>   unsigned o = 0;                                             <
>   unsigned n = 0;                                             <
>                                                               <
>   while (o < lines[0].size () || n < lines[1].size ()) {      <
>                                                               <
>     // Find any unmatched lines at this point in the old file <
>     // are deletes.                                           <
>                                                               <
>     unsigned boDeletes;                                       <
>     for (boDeletes = o;                                       <
>          o < lines[0].size () && lines[0][o].l == ~0;         <
>          o += 1                                               <
>         )                                                     <
>     {}                                                        <
>                                                               <
>     // Find any unmatched lines at this point in the new file <
>     // are inserts.                                           <
>                                                               <
>     unsigned boInserts;                                       <
>     for (boInserts = n;                                       <
>          n < lines[1].size () && lines[1][n].l == ~0;         <
>          n += 1                                               <
>         )                                                     <
>     {}                                                        <
>                                                               <
>     // We've got deleted line(s) from boDeletes .. o.         <
>     // We've got deleted line(s) from boInserts .. n.         <
>                                                               <
>     unsigned nDeletes = o - boDeletes;                        <
>     unsigned nInserts = n - boInserts;                        <
>                                                               <
>     // We've got...                                           <
>                                                               <
>     if (nDeletes && nInserts) {                               <
>                                                               <
>       // ... deletes and inserts.                             <
>                                                               <
>       for (unsigned l = boDeletes; l < o; l += 1) {           <
>         fprintf (stdout, "-%s", lines[0][l].line->c_str ());  <
>       }                                                       <
>       for (unsigned l = boInserts; l < n; l += 1) {           <
>         fprintf (stdout, "+%s", lines[1][l].line->c_str ());  <
>       }                                                       <
>     } else if (nDeletes) {                                    <
>                                                               <
>       //  ... just deletes.                                   <
>                                                               <
>       for (unsigned l = boDeletes; l < o; l += 1) {           <
>         fprintf (stdout, "-%s", lines[0][l].line->c_str ());  <
>       }                                                       <
>     } else if (nInserts) {                                    <
>                                                               <
>       //  ... just inserts.                                   <
>                                                               <
>       for (unsigned l = boInserts; l < n; l += 1) {           <
>         fprintf (stdout, "+%s", lines[1][l].line->c_str ());  <
>       }                                                       <
>     }                                                         <
>                                                                 
>     // When we get here, we're dealing with matching lines.   |       eoOldWindow = o;
>                                                               >       eoNewWindow = n;
>                                                                 
>     fprintf (stdout, " %s", lines[0][o].line->c_str ());      |       // However, since another window could follow, we look
>                                                               >       // optCopyContext ahead for another delete or insert.
>                                                               > 
>                                                               >       if (!widenWindow) {
>                                                               >         for (unsigned l = 0; l < (2 * optCopyContext + 1); l 
>                                                               >           if (o < lines[0].size ()) {
>                                                               >             widenWindow |= lines[0][o].l == ~0;
>                                                               >             o += 1;
>                                                               >           }
>                                                               >           if (n < lines[1].size ()) {
>                                                               >             widenWindow |= lines[1][n].l == ~0;
>                                                               >             n += 1;
>                                                               >           }
>                                                               >         }
>                                                               >       }
>                                                               >     }
>                                                               > 
>                                                               >     // We've found the end of the window.
>                                                               > 
>                                                               >     if (1 < optVerbose) {
>                                                               >       fprintf (stderr, "eoOldWindow = %d, eoNewWindow = %d\n"
>                                                               >       fflush (stderr);
>                                                               >     }
>                                                               > 
>                                                               >     // Now, reset ourselves to the start of the window, and w
>                                                               >     // produce the output.  We'll walk it twice, first for th
>                                                               >     // file part, then for the new file part.
>                                                               > 
>                                                               >     fprintf (stdout, "***************\n");
>                                                               >     fprintf (stdout, "*** %d,%d ****\n", boOldWindow + 1, eoO
>                                                               > 
>                                                               >     o = boOldWindow;
>                                                               >     n = boNewWindow;
>                                                               > 
>                                                               >     while (o < eoOldWindow || n < eoNewWindow) {
>                                                               > 
>                                                               >       // Find any unmatched lines at this point in the old fi
>                                                               >       // are deletes.
>                                                               > 
>                                                               >       unsigned boDeletes = o;
>                                                               >       while (o < eoOldWindow && lines[0][o].l == ~0) {
>                                                               >         o += 1;
>                                                               >       }
>                                                               > 
>                                                               >       // Find any unmatched lines at this point in the new fi
>                                                               >       // are inserts.
>                                                               > 
>                                                               >       unsigned boInserts = n;
>                                                               >       while (n < eoNewWindow && lines[1][n].l == ~0) {
>                                                               >         n += 1;
>                                                               >       }
>                                                               > 
>                                                               >       // We've got deleted line(s) from boDeletes .. o.
>                                                               >       // We've got deleted line(s) from boInserts .. n.
>                                                               > 
>                                                               >       unsigned nDeletes = o - boDeletes;
>                                                               >       unsigned nInserts = n - boInserts;
>                                                               > 
>                                                               >       // We've got...
>                                                               > 
>                                                               >       if (nDeletes && nInserts) {
>                                                               > 
>                                                               >         // ... deletes and inserts.
>                                                               > 
>                                                               >         for (unsigned l = boDeletes; l < o; l += 1) {
>                                                               >           fprintf (stdout, "! %s\n", lines[0][l].line->c_str 
>                                                               >         }
>                                                               >       } else if (nDeletes) {
>                                                               > 
>                                                               >         //  ... just deletes.
>                                                               > 
>                                                               >         for (unsigned l = boDeletes; l < o; l += 1) {
>                                                               >           fprintf (stdout, "- %s\n", lines[0][l].line->c_str 
>                                                               >         }
>                                                               >       }
>                                                               > 
>                                                               >       // When we get here, we're dealing with matching lines.
>                                                               > 
>                                                               >       fprintf (stdout, "  %s\n", lines[0][o].line->c_str ());
>                                                               >       o += 1;
>                                                               >       n += 1;
>                                                               >     }
>                                                               > 
>                                                               >     fprintf (stdout, "--- %d,%d ----\n", boNewWindow + 1, eoN
>                                                               > 
>                                                               >     o = boOldWindow;
>                                                               >     n = boNewWindow;
>                                                               > 
>                                                               >     while (o < eoOldWindow && n < eoNewWindow) {
>                                                               > 
>                                                               >       // Find any unmatched lines at this point in the old fi
>                                                               >       // are deletes.
>                                                               > 
>                                                               >       unsigned boDeletes = o;
>                                                               >       while (o < eoOldWindow && lines[0][o].l == ~0) {
>                                                               >         o += 1;
>                                                               >       }
>                                                               > 
>                                                               >       // Find any unmatched lines at this point in the new fi
>                                                               >       // are inserts.
>                                                               > 
>                                                               >       unsigned boInserts = n;
>                                                               >       while (n < eoNewWindow && lines[1][n].l == ~0) {
>                                                               >         n += 1;
>                                                               >       }
>                                                               > 
>                                                               >       // We've got deleted line(s) from boDeletes .. o.
>                                                               >       // We've got deleted line(s) from boInserts .. n.
>                                                               > 
>                                                               >       unsigned nDeletes = o - boDeletes;
>                                                               >       unsigned nInserts = n - boInserts;
>                                                               > 
>                                                               >       // We've got...
>                                                               > 
>                                                               >       if (nDeletes && nInserts) {
>                                                               > 
>                                                               >         // ... deletes and inserts.
>                                                               > 
>                                                               >         for (unsigned l = boInserts; l < n; l += 1) {
>                                                               >           fprintf (stdout, "! %s\n", lines[1][l].line->c_str 
>                                                               >         }
>                                                               >       } else if (nInserts) {
>                                                               > 
>                                                               >         //  ... just inserts.
>                                                               > 
>                                                               >         for (unsigned l = boInserts; l < n; l += 1) {
>                                                               >           fprintf (stdout, "+ %s\n", lines[1][l].line->c_str 
>                                                               >         }
>                                                               >       }
>                                                               > 
>                                                               >       // When we get here, we're dealing with matching lines.
>                                                               > 
>                                                               >       fprintf (stdout, "  %s\n", lines[1][n].line->c_str ());
>                                                               >       o += 1;
>                                                               >       n += 1;
>                                                               >     }
>                                                               > 
>                                                               >     // Reset to the end of the current window.
>                                                               > 
>                                                               >     o = eoOldWindow;
>                                                               >     n = eoNewWindow;
>                                                               >   }
>                                                               > }
>                                                               > 
>                                                               > void pass6e () {
>                                                               >   fprintf (stderr, "pass6e() is unimplemented!\n");
>                                                               >   fflush (stderr);
>                                                               > }
>                                                               > 
>                                                               > void pass6i () {
>                                                               >   fprintf (stderr, "pass6i() is unimplemented!\n");
>                                                               >   fflush (stderr);
>                                                               > }
>                                                               > 
>                                                               > void pass6n ()
>                                                               > {
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr, "# Pass #6n (walking the differences)...
>                                                               >     fflush (stderr);
>                                                               >   }
>                                                               > 
>                                                               >   nMatchedLines = 0;
>                                                               > 
>                                                               >   // Write the header.  (None for normal.)
>                                                               > 
>                                                               >   // Starting at the top of both files,...
>                                                               > 
>                                                               >   unsigned o = 0;
>                                                               >   unsigned n = 0;
>                                                               > 
>                                                               >   while (o < lines[0].size () || n < lines[1].size ()) {
>                                                               > 
>                                                               >     // Find any unmatched lines at this point in the old file
>                                                               >     // are deletes.
>                                                               > 
>                                                               >     unsigned boDeletes;
>                                                               >     for (boDeletes = o;
>                                                               >          o < lines[0].size () && lines[0][o].l == ~0;
>                                                               >          o += 1
>                                                               >         )
>                                                               >     {}
>                                                               > 
>                                                               >     // Find any unmatched lines at this point in the new file
>                                                               >     // are inserts.
>                                                               > 
>                                                               >     unsigned boInserts;
>                                                               >     for (boInserts = n;
>                                                               >          n < lines[1].size () && lines[1][n].l == ~0;
>                                                               >          n += 1
>                                                               >         )
>                                                               >     {}
>                                                               > 
>                                                               >     // We've got deleted line(s) from boDeletes .. o.
>                                                               >     // We've got deleted line(s) from boInserts .. n.
>                                                               > 
>                                                               >     unsigned nDeletes = o - boDeletes;
>                                                               >     unsigned nInserts = n - boInserts;
>                                                               > 
>                                                               >     // We've got...
>                                                               > 
>                                                               >     if (nDeletes && nInserts) {
>                                                               > 
>                                                               >       // ... deletes and inserts.
>                                                               > 
>                                                               >       if (1 < nDeletes && 1 < nInserts) {
>                                                               >         fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, b
>                                                               >       } else if (1 < nDeletes) {
>                                                               >         fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boIn
>                                                               >       } else if (1 < nInserts) {
>                                                               >         fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInser
>                                                               >       } 
>                                                               >       for (unsigned l = boDeletes; l < o; l += 1) {
>                                                               >         fprintf (stdout, "< %s\n", lines[0][l].line->c_str ()
>                                                               >       }
>                                                               >       fprintf (stdout, "---\n");
>                                                               >       for (unsigned l = boInserts; l < n; l += 1) {
>                                                               >         fprintf (stdout, "> %s\n", lines[1][l].line->c_str ()
>                                                               >       }
>                                                               >     } else if (nDeletes) {
>                                                               > 
>                                                               >       //  ... just deletes.
>                                                               > 
>                                                               >       if (1 < nDeletes) {
>                                                               >         fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
>                                                               >       } else {
>                                                               >         fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
>                                                               >       }
>                                                               >       for (unsigned l = boDeletes; l < o; l += 1) {
>                                                               >         fprintf (stdout, "< %s\n", lines[0][l].line->c_str ()
>                                                               >       }
>                                                               >     } else if (nInserts) {
>                                                               > 
>                                                               >       //  ... just inserts.
>                                                               > 
>                                                               >       if (1 < nInserts) {
>                                                               >         fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
>                                                               >       } else {
>                                                               >         fprintf (stdout, "%da%d\n", o, boInserts + 1);
>                                                               >       }
>                                                               >       for (unsigned l = boInserts; l < n; l += 1) {
>                                                               >         fprintf (stdout, "> %s\n", lines[1][l].line->c_str ()
>                                                               >       }
>                                                               >     }
>                                                               > 
>                                                               >     // When we get here, we're dealing with matching lines.
>                                                               > 
>                                                               >     o += 1;
>                                                               >     n += 1;
>                                                               >   }
>                                                               > }
>                                                               > 
>                                                               > void pass6r () {
>                                                               >   fprintf (stderr, "pass6r() is unimplemented!\n");
>                                                               >   fflush (stderr);
>                                                               > }
>                                                               > 
>                                                               > void pass6s () {
>                                                               >   fprintf (stderr, "pass6s() is unimplemented!\n");
>                                                               >   fflush (stderr);
>                                                               > }
>                                                               > 
>                                                               > void pass6u ()
>                                                               > {
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr, "# Pass #6u (walking the differences)...
>                                                               >     fflush (stderr);
>                                                               >   }
>                                                               > 
>                                                               >   nMatchedLines = 0;
>                                                               > 
>                                                               >   // Write the header.
>                                                               > 
>                                                               >   fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:0
>                                                               >   fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:0
>                                                               >   fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), l
>                                                               > 
>                                                               >   // Starting at the top of both files,...
>                                                               > 
>                                                               >   unsigned o = 0;
>                                                               >   unsigned n = 0;
>                                                               > 
>                                                               >   while (o < lines[0].size () || n < lines[1].size ()) {
>                                                               > 
>                                                               >     // Find any unmatched lines at this point in the old file
>                                                               >     // are deletes.
>                                                               > 
>                                                               >     unsigned boDeletes;
>                                                               >     for (boDeletes = o;
>                                                               >          o < lines[0].size () && lines[0][o].l == ~0;
>                                                               >          o += 1
>                                                               >         )
>                                                               >     {}
>                                                               > 
>                                                               >     // Find any unmatched lines at this point in the new file
>                                                               >     // are inserts.
>                                                               > 
>                                                               >     unsigned boInserts;
>                                                               >     for (boInserts = n;
>                                                               >          n < lines[1].size () && lines[1][n].l == ~0;
>                                                               >          n += 1
>                                                               >         )
>                                                               >     {}
>                                                               > 
>                                                               >     // We've got deleted line(s) from boDeletes .. o.
>                                                               >     // We've got deleted line(s) from boInserts .. n.
>                                                               > 
>                                                               >     unsigned nDeletes = o - boDeletes;
>                                                               >     unsigned nInserts = n - boInserts;
>                                                               > 
>                                                               >     // We've got...
>                                                               > 
>                                                               >     if (nDeletes && nInserts) {
>                                                               > 
>                                                               >       // ... deletes and inserts.
>                                                               > 
>                                                               >       for (unsigned l = boDeletes; l < o; l += 1) {
>                                                               >         fprintf (stdout, "-%s\n", lines[0][l].line->c_str ())
>                                                               >       }
>                                                               >       for (unsigned l = boInserts; l < n; l += 1) {
>                                                               >         fprintf (stdout, "+%s\n", lines[1][l].line->c_str ())
>                                                               >       }
>                                                               >     } else if (nDeletes) {
>                                                               > 
>                                                               >       //  ... just deletes.
>                                                               > 
>                                                               >       for (unsigned l = boDeletes; l < o; l += 1) {
>                                                               >         fprintf (stdout, "-%s\n", lines[0][l].line->c_str ())
>                                                               >       }
>                                                               >     } else if (nInserts) {
>                                                               > 
>                                                               >       //  ... just inserts.
>                                                               > 
>                                                               >       for (unsigned l = boInserts; l < n; l += 1) {
>                                                               >         fprintf (stdout, "+%s\n", lines[1][l].line->c_str ())
>                                                               >       }
>                                                               >     }
>                                                               > 
>                                                               >     // When we get here, we're dealing with matching lines.
>                                                               > 
>                                                               >     fprintf (stdout, " %s\n", lines[0][o].line->c_str ());
>                                                               >     o += 1;
>                                                               >     n += 1;
>                                                               >   }
>                                                               > }
>                                                               > 
>                                                               > void pass6y ()
>                                                               > {
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr, "# Pass #6y (walking the differences)...
>                                                               >     fflush (stderr);
>                                                               >   }
>                                                               > 
>                                                               >   // Write the header.
>                                                               > 
>                                                               >   // None for side-by-side.
>                                                               > 
>                                                               >   // Starting at the top of both files,...
>                                                               > 
>                                                               >   int columnWidth = (optPageWidth - 7) / 2;
>                                                               > 
>                                                               >   unsigned o = 0;
>                                                               >   unsigned n = 0;
>                                                               > 
>                                                               >   while (o < lines[0].size () || n < lines[1].size ()) {
>                                                               > 
>                                                               >     // Find any unmatched lines at this point in the old file
>                                                               >     // are deletes.
>                                                               > 
>                                                               >     unsigned boDeletes = o;
>                                                               >     while (o < lines[0].size () && lines[0][o].l == ~0) {
>                                                               >       o += 1;
>                                                               >     }
>                                                               > 
>                                                               >     // Find any unmatched lines at this point in the new file
>                                                               >     // are inserts.
>                                                               > 
>                                                               >     unsigned boInserts = n;
>                                                               >     while (n < lines[1].size () && lines[1][n].l == ~0) {
>                                                               >       n += 1;
>                                                               >     }
>                                                               > 
>                                                               >     // We've got deleted line(s) from boDeletes .. o.
>                                                               >     // We've got deleted line(s) from boInserts .. n.
>                                                               > 
>                                                               >     unsigned nDeletes = o - boDeletes;
>                                                               >     unsigned nInserts = n - boInserts;
>                                                               > 
>                                                               >     // We've got...
>                                                               > 
>                                                               >     while (boDeletes < o && boInserts < n) {
>                                                               > 
>                                                               >       // ... deletes and inserts.
>                                                               > 
>                                                               >       fprintf (stdout,
>                                                               >                "%-*s | %s\n",
>                                                               >                columnWidth,
>                                                               >                lines[0][boDeletes].line->substr (0, columnWid
>                                                               >                lines[1][boInserts].line->substr (0, columnWid
>                                                               >               );
>                                                               >       boDeletes += 1;
>                                                               >       boInserts += 1;
>                                                               >     }
>                                                               > 
>                                                               >     while (boDeletes < o) {
>                                                               > 
>                                                               >       //  ... just deletes.
>                                                               > 
>                                                               >       fprintf (stdout,
>                                                               >                "%-*s <\n",
>                                                               >                columnWidth,
>                                                               >                lines[0][boDeletes].line->substr (0, columnWid
>                                                               >               );
>                                                               >       boDeletes += 1;
>                                                               >     }
>                                                               > 
>                                                               >     while (boInserts < n) {
>                                                               > 
>                                                               >       //  ... just inserts.
>                                                               > 
>                                                               >       fprintf (stdout,
>                                                               >                "%-*s > %s\n",
>                                                               >                columnWidth,
>                                                               >                "",
>                                                               >                lines[1][boInserts].line->substr (0, columnWid
>                                                               >               );
>                                                               >       boInserts += 1;
>                                                               >     }
>                                                               > 
>                                                               >     // When we get here, we're dealing with matching lines.
>                                                               > 
>                                                               >     fprintf (stdout,
>                                                               >              "%-*s   %s\n",
>                                                               >              columnWidth,
>                                                               >              lines[0][o].line->substr (0, columnWidth).c_str 
>                                                               >              lines[1][n].line->substr (0, columnWidth).c_str 
>                                                               >             );
>     o += 1;                                                         o += 1;
>     n += 1;                                                         n += 1;
>   }                                                               }
> }                                                               }
# ../sdiff -y dif.7.cpp dif.6.cpp >& dif.7.6.diff-y.test
./test: line 46: 23587 Aborted                 (core dumped) ${DIFF} "${option}" "${oSrc}" "${nSrc}" 1>&"${dst}.test"
# dif.7.6.diff-y ---------------------------------------------------------------
1,1258c1,132
< #include <algorithm>						#include <algorithm>
< using std::find;						using std::find;
< #include <string>						#include <string>
< using std::string;						using std::string;
< #include <list>							#include <list>
< using std::list;						using std::list;
< #include <map>							#include <map>
< using std::map;							using std::map;
< #include <vector>						#include <vector>
< using std::vector;						using std::vector;
< #include <stdio.h>						#include <stdio.h>
< 
< enum DiffFormat {						enum DiffFormat {
<   Default,							  Default,
< 
<   Context,							  Context,
<   EdScript,							  EdScript,
<   IfThenElse,							  IfThenElse,
<   Normal,							  Normal,
<   RCS,								  RCS,
<   SideBySide,							  SideBySide,
<   Unified							  Unified
< };								};
< 
< DiffFormat diffFormat = SideBySide;			      |	DiffFormat diffFormat = Context;
< 							      <
< unsigned optCopyContext = 3;					unsigned optCopyContext = 3;
< unsigned optPageWidth = 130;				      |
< unsigned optVerbose = 2;				      |	int optVerbose = 1;
< 
< struct Line : public string {					struct Line : public string {
<   Line (string _text) :						  Line (string _text) :
<     string (_text)						    string (_text)
<   {								  {
<   }								  }
<   ~Line () {							  ~Line () {
<     copies[0].erase (copies[0].begin (), copies[0].end ());	    copies[0].erase (copies[0].begin (), copies[0].end ());
<     copies[1].erase (copies[1].begin (), copies[1].end ());	    copies[1].erase (copies[1].begin (), copies[1].end ());
<   }								  }
<   void Dump (FILE *out) {					  void Dump (FILE *out) {
<     fprintf (out, "{{ ");					    fprintf (out, "{{ ");
<     for (list<unsigned>::iterator i = copies[0].begin (); i !	    for (list<unsigned>::iterator i = copies[0].begin (); i !
<       fprintf (out, "%u ", *i);					      fprintf (out, "%u ", *i);
<     }								    }
<     fprintf (out, "},{ ");					    fprintf (out, "},{ ");
<     for (list<unsigned>::iterator i = copies[1].begin (); i !	    for (list<unsigned>::iterator i = copies[1].begin (); i !
<       fprintf (out, "%u ", *i);					      fprintf (out, "%u ", *i);
<     }								    }
<     fprintf (out, "}}\t%s\n", c_str ());		      |	    fprintf (out, "}}\t%s", c_str ());
<   }								  }
<   list<unsigned> copies[2];					  list<unsigned> copies[2];
< };								};
< 
< struct LinePtr {						struct LinePtr {
<   LinePtr (Line *_line) :					  LinePtr (Line *_line) :
<     line (_line),						    line (_line),
<     l (~0u)							    l (~0u)
<   {								  {
<   }								  }
<   void Dump (FILE *out) {					  void Dump (FILE *out) {
<     fprintf (out, "[%d] ", l);					    fprintf (out, "[%d] ", l);
<     line->Dump (out);						    line->Dump (out);
<   }								  }
<   Line *line;							  Line *line;
<   unsigned l;							  unsigned l;
< };								};
< 
< typedef map<string, Line *> MapStringToLinePtr;			typedef map<string, Line *> MapStringToLinePtr;
< typedef vector<LinePtr> VectorLinePtr;				typedef vector<LinePtr> VectorLinePtr;
< 
< // Our name.							// Our name.
< 
< char *ARGV0 = "dif3";						char *ARGV0 = "dif3";
< 
< // The 'symbol' (line) table.					// The 'symbol' (line) table.
< 
< MapStringToLinePtr table;					MapStringToLinePtr table;
< 
< // The names of the 2 files to be diff'd.			// The names of the 2 files to be diff'd.
< 
< char const *files[2] = { 0, 0 };				char const *files[2] = { 0, 0 };
< 
< // The lines of the 2 files to be diff'd.			// The lines of the 2 files to be diff'd.
< 
< VectorLinePtr lines[2];						VectorLinePtr lines[2];
< 
< // Miscellaneous metrics.					// Miscellaneous metrics.
< 
< unsigned nTotalMatchedBlocks = 0;				unsigned nTotalMatchedBlocks = 0;
< unsigned nMatchedBlocks = 0;					unsigned nMatchedBlocks = 0;
< unsigned nTotalMatchedLines = 0;				unsigned nTotalMatchedLines = 0;
< unsigned nMatchedLines = 0;					unsigned nMatchedLines = 0;
< 
< void pass1 ();							void pass1 ();
< void pass2 ();							void pass2 ();
< void pass3 ();							void pass3 ();
< void pass4 ();							void pass4 ();
< void pass5 ();							void pass5 ();
< void pass6 ();							void pass6 ();
< 
< int main (int argc, char *argv[])				int main (int argc, char *argv[])
< {								{
<   // Read the old [0] file, and the new [1] file.		  // Read the old [0] file, and the new [1] file.
< 
<   for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {	  for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
<     files[n] = argv[a];						    files[n] = argv[a];
< 
<     if (FILE *f = fopen (files[n], "r")) {			    if (FILE *f = fopen (files[n], "r")) {
<       if (0 < optVerbose) {					      if (0 < optVerbose) {
<         fprintf (stderr, "# Reading %s...", files[n]);		        fprintf (stderr, "# Reading %s...", files[n]);
<         fflush (stderr);				      <
<       }								      }
< 
<       char buffer[1024];					      char buffer[1024];
<       unsigned nUniq = 0;					      unsigned nUniq = 0;
< 
<       while (fgets (buffer, sizeof (buffer), f)) {		      while (fgets (buffer, sizeof (buffer), f)) {
<         string text (buffer);					        string text (buffer);
< 
<         text.erase (text.end () - 1);			      <
< 							      <
<         Line *line = table[text];				        Line *line = table[text];
< 
<         if (!line) {						        if (!line) {
<           table[text] = line = new Line (text);			          table[text] = line = new Line (text);
<           nUniq += 1;						          nUniq += 1;
<         }							        }
<         line->copies[n].push_back (lines[n].size ());		        line->copies[n].push_back (lines[n].size ());
<         lines[n].push_back (line);				        lines[n].push_back (line);
<       }								      }
< 
<       if (0 < optVerbose) {					      if (0 < optVerbose) {
<         fprintf (stderr, " %u lines, %u unique.\n", lines[n].	        fprintf (stderr, " %u lines, %u unique.\n", lines[n].
<         fflush (stderr);				      <
<       }								      }
<     } else {							    } else {
<       fprintf (stderr, "%s: Unable to open %s!  Exiting....\n	      fprintf (stderr, "%s: Unable to open %s!  Exiting....\n
<       fflush (stderr);					      <
<       perror (ARGV0);						      perror (ARGV0);
<       exit (1);							      exit (1);
<     }								    }
<   }								  }
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Total unique lines = %d\n", table.siz	    fprintf (stderr, "# Total unique lines = %d\n", table.siz
<     fflush (stderr);					      <
<   }								  }
< 
<   // map<int, int> counts;					  // map<int, int> counts;
<   // for (MapStringToLinePtr::iterator i = table.begin (); i 	  // for (MapStringToLinePtr::iterator i = table.begin (); i 
<   //   Line *l = i->second;					  //   Line *l = i->second;
<   //   counts[l->counts[0].size () + l->counts[1].size ()] +=	  //   counts[l->counts[0].size () + l->counts[1].size ()] +=
<   // }								  // }
<   // for (map<int, int>::iterator i = counts.begin (); i != c	  // for (map<int, int>::iterator i = counts.begin (); i != c
<   //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s	  //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s
<   // }								  // }
< 
<   pass1 ();							  pass1 ();
<   pass2 ();							  pass2 ();
<   pass3 ();							  pass3 ();
<   pass4 ();							  pass4 ();
<   pass5 ();							  pass5 ();
<   pass6 ();							  pass6 ();
< 
<   return 0;							  return 0;
< }								}
< 
< // Perform pass #1, in which we find all explicit matches amo	// Perform pass #1, in which we find all explicit matches amo
< // unique lines.  For every unique line that appears the same	// unique lines.  For every unique line that appears the same
< // of times in both files, we declare the lines to match.	// of times in both files, we declare the lines to match.
< 
< void pass1 ()							void pass1 ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass 1 (finding matches amongst uniqu	    fprintf (stderr, "# Pass 1 (finding matches amongst uniqu
<     fflush (stderr);					      <
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   for (MapStringToLinePtr::iterator i = table.begin (); i != 	  for (MapStringToLinePtr::iterator i = table.begin (); i != 
<     Line *l = i->second;					    Line *l = i->second;
< 
<     // If the number of old and new lines match, then we decl	    // If the number of old and new lines match, then we decl
<     // they are (all) the same line.  Note, it isn't possible	    // they are (all) the same line.  Note, it isn't possible
<     // numbers of both files to be 0.				    // numbers of both files to be 0.
< 
<     // (In the original algorithm, we only recognized a match	    // (In the original algorithm, we only recognized a match
<     // if there was exactly 1 copy for each file.)		    // if there was exactly 1 copy for each file.)
< 
<     if (l->copies[0].size () == l->copies[1].size ()) {		    if (l->copies[0].size () == l->copies[1].size ()) {
<       nMatchedLines += 1;					      nMatchedLines += 1;
< 
<       // For each matched line in the new file, mark it with 	      // For each matched line in the new file, mark it with 
<       // corresponding line (number) in the old file.		      // corresponding line (number) in the old file.
< 
<       while (!l->copies[0].empty ()) {				      while (!l->copies[0].empty ()) {
<         unsigned o = l->copies[0].front ();			        unsigned o = l->copies[0].front ();
<         unsigned n = l->copies[1].front ();			        unsigned n = l->copies[1].front ();
< 
<         // Match up the pair.					        // Match up the pair.
< 
<         lines[0][o].l = n;					        lines[0][o].l = n;
<         lines[1][n].l = o;					        lines[1][n].l = o;
< 
<         // Remove the matched line numbers from the lists.	        // Remove the matched line numbers from the lists.
< 
<         l->copies[0].pop_front ();				        l->copies[0].pop_front ();
<         l->copies[1].pop_front ();				        l->copies[1].pop_front ();
<       }								      }
<     }								    }
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, " found %u matched lines (%u total).\n",	    fprintf (stderr, " found %u matched lines (%u total).\n",
<     fflush (stderr);					      <
< 
<     if (2 < optVerbose) {				      |	    if (1 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         fflush (stderr);				      <
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           fflush (stderr);				      <
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< }								}
< 
< // Perform Pass #2, in which we attempt to 'widen' blocks of 	// Perform Pass #2, in which we attempt to 'widen' blocks of 
< // lines, by appending lines which are the same in both files	// lines, by appending lines which are the same in both files
< 
< void pass2 ()							void pass2 ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #2 (spreading matches down)...")	    fprintf (stderr, "# Pass #2 (spreading matches down)...")
<     fflush (stderr);					      <
<   }								  }
< 
<   nMatchedBlocks = 0;						  nMatchedBlocks = 0;
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Starting at the top of the old file,...			  // Starting at the top of the old file,...
< 
<   for (unsigned o = 0; o < lines[0].size (); o += 1) {		  for (unsigned o = 0; o < lines[0].size (); o += 1) {
< 
<     // ... skip any currently unmatched lines...		    // ... skip any currently unmatched lines...
< 
<     if (lines[0][o].l == ~0) {					    if (lines[0][o].l == ~0) {
<       continue;							      continue;
<     }								    }
< 
<     // ... until we find an [already] matched line.  Then, sk	    // ... until we find an [already] matched line.  Then, sk
<     // the set of 1 or more matched lines, until we reach any	    // the set of 1 or more matched lines, until we reach any
<     // following, still-unmatched line.				    // following, still-unmatched line.
< 
<     unsigned n;							    unsigned n;
<     do {							    do {
<       n = lines[0][o].l + 1;					      n = lines[0][o].l + 1;
<       o += 1;							      o += 1;
<     } while (o < lines[0].size () && lines[0][o].l != ~0);	    } while (o < lines[0].size () && lines[0][o].l != ~0);
< 
<     // Now, o - 1 is the line number of the last matched old 	    // Now, o - 1 is the line number of the last matched old 
<     // n - 1 is the line number of the last matched new line.	    // n - 1 is the line number of the last matched new line.
<     // to add new old and new lines, if they match.		    // to add new old and new lines, if they match.
< 
<     // Finally, attempt to add unmatched lines to the preceed	    // Finally, attempt to add unmatched lines to the preceed
<     // matched set.						    // matched set.
< 
<     for (; o < lines[0].size () && lines[0][o].l == ~0; o += 	    for (; o < lines[0].size () && lines[0][o].l == ~0; o += 
< 
<       // If the [next] pair of old and new lines aren't the s	      // If the [next] pair of old and new lines aren't the s
< 
<       if (lines[0][o].line != lines[1][n].line) {		      if (lines[0][o].line != lines[1][n].line) {
<         break;							        break;
<       }								      }
< 
<       // Match up the pair.					      // Match up the pair.
< 
<       lines[0][o].l = n;					      lines[0][o].l = n;
<       lines[1][n].l = o;					      lines[1][n].l = o;
< 
<       // Remove the matched line numbers form the lists.	      // Remove the matched line numbers form the lists.
< 
<       Line *line = lines[0][o].line;				      Line *line = lines[0][o].line;
<       list<unsigned> &oldCopies = line->copies[0];		      list<unsigned> &oldCopies = line->copies[0];
<       list<unsigned>::iterator oL = find (oldCopies.begin (),	      list<unsigned>::iterator oL = find (oldCopies.begin (),
<       if (oL != oldCopies.end ()) {				      if (oL != oldCopies.end ()) {
<         oldCopies.erase (oL);					        oldCopies.erase (oL);
<       }								      }
<       list<unsigned> &newCopies = line->copies[0];		      list<unsigned> &newCopies = line->copies[0];
<       list<unsigned>::iterator nL = find (newCopies.begin (),	      list<unsigned>::iterator nL = find (newCopies.begin (),
<       if (nL != newCopies.end ()) {				      if (nL != newCopies.end ()) {
<         newCopies.erase (nL);					        newCopies.erase (nL);
<       }								      }
< 
<       nMatchedLines += 1;					      nMatchedLines += 1;
<     }								    }
<     nMatchedBlocks += 1;					    nMatchedBlocks += 1;
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
<   nTotalMatchedBlocks += nMatchedBlocks;			  nTotalMatchedBlocks += nMatchedBlocks;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr,						    fprintf (stderr,
<              " found %u/%u matched lines/blocks (%u/%u totals	             " found %u/%u matched lines/blocks (%u/%u totals
<              nMatchedLines,					             nMatchedLines,
<              nMatchedBlocks,					             nMatchedBlocks,
<              nTotalMatchedLines,				             nTotalMatchedLines,
<              nTotalMatchedBlocks				             nTotalMatchedBlocks
<             );							            );
<     fflush (stderr);					      |	    if (1 < optVerbose) {
<     if (2 < optVerbose) {				      <
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         fflush (stderr);				      <
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           fflush (stderr);				      <
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< }								}
< 
< // Perform Pass #3, in which we attempt to 'widen' blocks of 	// Perform Pass #3, in which we attempt to 'widen' blocks of 
< // lines, by prepending lines which are the same in both file	// lines, by prepending lines which are the same in both file
< 
< void pass3 ()							void pass3 ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #3 (spreading matches up)...");	    fprintf (stderr, "# Pass #3 (spreading matches up)...");
<     fflush (stderr);					      <
<   }								  }
< 
<   nMatchedBlocks = 0;						  nMatchedBlocks = 0;
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Starting at the bottom of the old file,...			  // Starting at the bottom of the old file,...
< 
<   for (int o = lines[0].size (); 0 <= o; o -= 1) {		  for (int o = lines[0].size (); 0 <= o; o -= 1) {
< 
<     // ... skip any currently unmatched lines...		    // ... skip any currently unmatched lines...
< 
<     if (lines[0][o].l == ~0) {					    if (lines[0][o].l == ~0) {
<       continue;							      continue;
<     }								    }
< 
<     // ... until we find an [already] matched line.  Then, sk	    // ... until we find an [already] matched line.  Then, sk
<     // the set of 1 or more matched lines, until we reach any	    // the set of 1 or more matched lines, until we reach any
<     // following, still-unmatched line.				    // following, still-unmatched line.
< 
<     unsigned n;							    unsigned n;
<     do {							    do {
<       n = lines[0][o].l - 1;					      n = lines[0][o].l - 1;
<       o -= 1;							      o -= 1;
<     } while (0 <= o && lines[0][o].l != ~0);			    } while (0 <= o && lines[0][o].l != ~0);
< 
<     // Now, o + 1 is the line number of the last matched old 	    // Now, o + 1 is the line number of the last matched old 
<     // n + 1 is the line number of the last matched new line.	    // n + 1 is the line number of the last matched new line.
<     // to add new old and new lines, if they match.		    // to add new old and new lines, if they match.
< 
<     // Finally, attempt to add unmatched lines to the preceed	    // Finally, attempt to add unmatched lines to the preceed
<     // matched set.						    // matched set.
< 
<     for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {	    for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
< 
<       // If the [next] pair of old and new lines aren't the s	      // If the [next] pair of old and new lines aren't the s
< 
<       if (lines[0][o].line != lines[1][n].line) {		      if (lines[0][o].line != lines[1][n].line) {
<         break;							        break;
<       }								      }
< 
<       // Match up the pair.					      // Match up the pair.
< 
<       lines[0][o].l = n;					      lines[0][o].l = n;
<       lines[1][n].l = o;					      lines[1][n].l = o;
< 
<       // Remove the matched line numbers form the lists.	      // Remove the matched line numbers form the lists.
< 
<       Line *line = lines[0][o].line;				      Line *line = lines[0][o].line;
<       list<unsigned> &oldCopies = line->copies[0];		      list<unsigned> &oldCopies = line->copies[0];
<       list<unsigned>::iterator oL = find (oldCopies.begin (),	      list<unsigned>::iterator oL = find (oldCopies.begin (),
<       if (oL != oldCopies.end ()) {				      if (oL != oldCopies.end ()) {
<         oldCopies.erase (oL);					        oldCopies.erase (oL);
<       }								      }
<       list<unsigned> &newCopies = line->copies[0];		      list<unsigned> &newCopies = line->copies[0];
<       list<unsigned>::iterator nL = find (newCopies.begin (),	      list<unsigned>::iterator nL = find (newCopies.begin (),
<       if (nL != newCopies.end ()) {				      if (nL != newCopies.end ()) {
<         newCopies.erase (nL);					        newCopies.erase (nL);
<       }								      }
< 
<       nMatchedLines += 1;					      nMatchedLines += 1;
<     }								    }
<     nMatchedBlocks += 1;					    nMatchedBlocks += 1;
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr,						    fprintf (stderr,
<              " found %u/%u matched lines/blocks (%u/%u totals	             " found %u/%u matched lines/blocks (%u/%u totals
<              nMatchedLines,					             nMatchedLines,
<              nMatchedBlocks,					             nMatchedBlocks,
<              nTotalMatchedLines,				             nTotalMatchedLines,
<              nTotalMatchedBlocks				             nTotalMatchedBlocks
<             );							            );
<     fflush (stderr);					      <
< 
<     if (2 < optVerbose) {				      |	    if (1 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         fflush (stderr);				      <
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           fflush (stderr);				      <
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< }								}
< 
< // Perform pass #4, in which we find any remaining matches am	// Perform pass #4, in which we find any remaining matches am
< // unique lines.  For every unique line that has more than 1 	// unique lines.  For every unique line that has more than 1 
< // both files, we declare the copies to match.			// both files, we declare the copies to match.
< 
< void pass4 ()							void pass4 ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass 4 (finding remaining matches amo	    fprintf (stderr, "# Pass 4 (finding remaining matches amo
<     fflush (stderr);					      <
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   for (MapStringToLinePtr::iterator i = table.begin (); i != 	  for (MapStringToLinePtr::iterator i = table.begin (); i != 
<     Line *l = i->second;					    Line *l = i->second;
< 
<     // If there's more than 1 matching old and new lines, the	    // If there's more than 1 matching old and new lines, the
<     // declare that each pair are (all) the same line.		    // declare that each pair are (all) the same line.
< 
<     // (In the original algorithm, we only recognized a match	    // (In the original algorithm, we only recognized a match
<     // if there was exactly 1 copy for each file.)		    // if there was exactly 1 copy for each file.)
< 
<     while (0 < l->copies[0].size () && 0 < l->copies[1].size 	    while (0 < l->copies[0].size () && 0 < l->copies[1].size 
<       nMatchedLines += 1;					      nMatchedLines += 1;
< 
<       // For each matched line in the new file, mark it with 	      // For each matched line in the new file, mark it with 
<       // corresponding line (number) in the old file.		      // corresponding line (number) in the old file.
< 
<       unsigned o = l->copies[0].front ();			      unsigned o = l->copies[0].front ();
<       unsigned n = l->copies[1].front ();			      unsigned n = l->copies[1].front ();
< 
<       // Match up the pair.					      // Match up the pair.
< 
<       lines[0][o].l = n;					      lines[0][o].l = n;
<       lines[1][n].l = o;					      lines[1][n].l = o;
< 
<       // Remove the matched line numbers from the lists.	      // Remove the matched line numbers from the lists.
< 
<       l->copies[0].pop_front ();				      l->copies[0].pop_front ();
<       l->copies[1].pop_front ();				      l->copies[1].pop_front ();
<     }								    }
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, " found %u matched lines (%u total).\n",	    fprintf (stderr, " found %u matched lines (%u total).\n",
<     fflush (stderr);					      <
< 
<     if (2 < optVerbose) {				      |	    if (1 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         fflush (stderr);				      <
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           fflush (stderr);				      <
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< }								}
< 
< // Perform Pass #5, in which we look for blocks which match, 	// Perform Pass #5, in which we look for blocks which match, 
< // the result of a move (their not in their original position	// the result of a move (their not in their original position
< // these, we'll unmatch the blocks, turning them into a delet	// these, we'll unmatch the blocks, turning them into a delet
< // insert.							// insert.
< 
< void pass5 ()							void pass5 ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #5 (unmatching block moves)...\n	    fprintf (stderr, "# Pass #5 (unmatching block moves)...\n
<     fflush (stderr);					      <
<   }								  }
< 
<   nMatchedBlocks = 0;						  nMatchedBlocks = 0;
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Starting at the top of both files,...			  // Starting at the top of both files,...
< 
<   unsigned o = 0;						  unsigned o = 0;
<   unsigned n = 0;						  unsigned n = 0;
< 
<   while (o < lines[0].size () || n < lines[1].size ()) {	  while (o < lines[0].size () || n < lines[1].size ()) {
< 
<     // Skip any unmatched lines at this point in the old file	    // Skip any unmatched lines at this point in the old file
<     // are deletes.						    // are deletes.
< 
<     //    Old     New						    //    Old     New
<     //   +---+							    //   +---+
<     // 0 | a |							    // 0 | a |
<     //   +---+   +---+						    //   +---+   +---+
<     //         0 | b |						    //         0 | b |
<     //   +---+   +---+						    //   +---+   +---+
<     // 1 | c | 1 | c |						    // 1 | c | 1 | c |
<     //   +---+   +---+						    //   +---+   +---+
<     //         2 | z |						    //         2 | z |
<     //   +---+   +---+						    //   +---+   +---+
<     // 2 | d | 3 | d |						    // 2 | d | 3 | d |
<     //   +---+   +---+						    //   +---+   +---+
< 
<     while (o < lines[0].size () && lines[0][o].l == ~0) {	    while (o < lines[0].size () && lines[0][o].l == ~0) {
<       o += 1;							      o += 1;
<     }								    }
< 
<     // Skip any unmatched lines at this point in the new file	    // Skip any unmatched lines at this point in the new file
<     // are inserts.						    // are inserts.
< 
<     while (n < lines[1].size () && lines[1][n].l == ~0) {	    while (n < lines[1].size () && lines[1][n].l == ~0) {
<       n += 1;							      n += 1;
<     }								    }
< 
<     // When we get here, we know that we're dealing with matc	    // When we get here, we know that we're dealing with matc
<     // lines (or the end of one or both files).  We're done w	    // lines (or the end of one or both files).  We're done w
<     // pass, if we've reached the end of either file.		    // pass, if we've reached the end of either file.
< 
<     if (lines[0].size () <= o || lines[1].size () <= n) {	    if (lines[0].size () <= o || lines[1].size () <= n) {
<       break;							      break;
<     }								    }
< 
<     // We now know that we've got a pair of matching lines, t	    // We now know that we've got a pair of matching lines, t
<     // of a matching block.  If the new file's line number is	    // of a matching block.  If the new file's line number is
<     // expect, then the matched pair is unmoved, and we can s	    // expect, then the matched pair is unmoved, and we can s
<     // the pair.  (If this is really the start of a block of 	    // the pair.  (If this is really the start of a block of 
<     // 1 lines, we'll handle it one pair at a time.)		    // 1 lines, we'll handle it one pair at a time.)
< 
<     if (lines[0][o].l == n) {					    if (lines[0][o].l == n) {
<       o += 1;							      o += 1;
<       n += 1;							      n += 1;
<       continue;							      continue;
<     }								    }
< 
<     // If, on the other hand, we don't expect this [new] line	    // If, on the other hand, we don't expect this [new] line
<     // then this matching block has been moved.  We need to t	    // then this matching block has been moved.  We need to t
<     // matched pair into an *unmatched* pair, one of deletes,	    // matched pair into an *unmatched* pair, one of deletes,
<     // of inserts.  First, though, we need to know how big th	    // of inserts.  First, though, we need to know how big th
<     // is, and how far it was moved....				    // is, and how far it was moved....
< 
<     // Remember where we were when we started.			    // Remember where we were when we started.
< 
<     unsigned oOld = o;						    unsigned oOld = o;
<     unsigned nOld = n;						    unsigned nOld = n;
< 
<     // Remember where the block came from.			    // Remember where the block came from.
< 
<     unsigned nNew = lines[0][o].l;				    unsigned nNew = lines[0][o].l;
< 
<     // Find the end of this matched pair.			    // Find the end of this matched pair.
< 
<     for (n = nNew; o < lines[0].size () && n < lines[1].size 	    for (n = nNew; o < lines[0].size () && n < lines[1].size 
<       if (lines[0][o].l != n) {					      if (lines[0][o].l != n) {
<         break;							        break;
<       }								      }
<     }								    }
< 
<     // When we get here:					    // When we get here:
<     // * oOld..o is the old file's block,			    // * oOld..o is the old file's block,
<     // * nNew..n is the new file's *moved* block, and		    // * nNew..n is the new file's *moved* block, and
<     // * nOld is where we originally expected the new block f	    // * nOld is where we originally expected the new block f
<  								 
<     // We can now calculate the length of the block...		    // We can now calculate the length of the block...
<     								    
<     unsigned bSize = o - oOld;  // (or n - nNew)		    unsigned bSize = o - oOld;  // (or n - nNew)
< 
<     // ... and we can calculate how far the block moved:	    // ... and we can calculate how far the block moved:
< 
<     unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;	    unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
< 
<     // The larger of the two will become our delete, and the 	    // The larger of the two will become our delete, and the 
<     // will become our insert.					    // will become our insert.
< 
<     //    Old     New						    //    Old     New
<     //   +---+   +---+						    //   +---+   +---+
<     // 0 | a | 0 | b |						    // 0 | a | 0 | b |
<     //   +---+ 1 | b |						    //   +---+ 1 | b |
<     // 1 | b |   +---+						    // 1 | b |   +---+
<     // 2 | b | 2 | a |						    // 2 | b | 2 | a |
<     //   +---+   +---+						    //   +---+   +---+
<     // 3 | c | 3 | c |						    // 3 | c | 3 | c |
<     //   +---+   +---+						    //   +---+   +---+
< 
<     // (1) Delete a@0, insert a@2, or				    // (1) Delete a@0, insert a@2, or
<     // (2) insert bb@0, delete bb@1?				    // (2) insert bb@0, delete bb@1?
< 
<     // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and	    // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and
<     // (of a) is 2-0 or 2, the size of b@0.  We choose to del	    // (of a) is 2-0 or 2, the size of b@0.  We choose to del
<     // and reinsert a@2.					    // and reinsert a@2.
< 
<     // if (bSize <= bMove) {					    // if (bSize <= bMove) {
<       for (unsigned a = oOld; a < o; a += 1) {			      for (unsigned a = oOld; a < o; a += 1) {
<         lines[0][a].l = ~0;					        lines[0][a].l = ~0;
<       }								      }
<       for (unsigned d = nNew; d < n; d += 1) {			      for (unsigned d = nNew; d < n; d += 1) {
<         lines[1][d].l = ~0;					        lines[1][d].l = ~0;
<       }								      }
<     // } else {							    // } else {
<       // for (unsigned a = oOld; a < o; a += 1) {		      // for (unsigned a = oOld; a < o; a += 1) {
<       //   lines[0][a].l = ~0;					      //   lines[0][a].l = ~0;
<       // }							      // }
<       // for (unsigned d = nNew; d < n; d += 1) {		      // for (unsigned d = nNew; d < n; d += 1) {
<       //   lines[1][d].l = ~0;					      //   lines[1][d].l = ~0;
<       // }							      // }
<     // }							    // }
< 
<     // Continue from where we left off.				    // Continue from where we left off.
< 
<     n = nOld;							    n = nOld;
<   }								  }
<   nTotalMatchedLines -= nMatchedLines;				  nTotalMatchedLines -= nMatchedLines;
<   nTotalMatchedBlocks -= nMatchedBlocks;			  nTotalMatchedBlocks -= nMatchedBlocks;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr,						    fprintf (stderr,
<              " found %u/%u matched lines/blocks (%u/%u totals	             " found %u/%u matched lines/blocks (%u/%u totals
<              nMatchedLines,					             nMatchedLines,
<              nMatchedBlocks,					             nMatchedBlocks,
<              nTotalMatchedLines,				             nTotalMatchedLines,
<              nTotalMatchedBlocks				             nTotalMatchedBlocks
<             );							            );
<     fflush (stderr);					      <
< 
<     if (2 < optVerbose) {				      |	    if (1 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         fflush (stderr);				      <
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           fflush (stderr);				      <
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< }								}
< 
< // Perform Pass #6, in which we create the desired output.	// Perform Pass #6, in which we create the desired output.
< 
< void pass6c ();							void pass6c ();
< void pass6e ();							void pass6e ();
< void pass6i ();							void pass6i ();
< void pass6n ();							void pass6n ();
< void pass6r ();							void pass6r ();
< void pass6s ();							void pass6s ();
< void pass6u ();							void pass6u ();
< void pass6y ();						      <
< 
< void pass6 ()							void pass6 ()
< {								{
< 
<   switch (diffFormat) {						  switch (diffFormat) {
<   case Context:							  case Context:
<     pass6c ();							    pass6c ();
<     break;							    break;
< 
<   case EdScript:						  case EdScript:
<     pass6e ();							    pass6e ();
<     break;							    break;
< 
<   case IfThenElse:						  case IfThenElse:
<     pass6i ();							    pass6i ();
<     break;							    break;
< 
<   case Normal:							  case Normal:
<     pass6n ();							    pass6n ();
<     break;							    break;
< 
<   case RCS:							  case RCS:
<     pass6r ();							    pass6r ();
<     break;							    break;
< 
<   case SideBySide:						  case SideBySide:
<     pass6y ();						      |	    pass6s ();
<     break;							    break;
< 
<   case Unified:							  case Unified:
<     pass6u ();							    pass6u ();
<     break;							    break;
< 
<   case Default:							  case Default:
<   default:							  default:
<     pass6c ();							    pass6c ();
<     break;							    break;
<   }								  }
< }								}
< 
< template<typename T> T min (T l, T r) {				template<typename T> T min (T l, T r) {
<   if (l < r) {							  if (l < r) {
<     return l;							    return l;
<   }								  }
<   return r;							  return r;
< }								}
< 
< template<typename T> T max (T l, T r) {				template<typename T> T max (T l, T r) {
<   if (l < r) {							  if (l < r) {
<     return r;							    return r;
<   }								  }
<   return l;							  return l;
< }								}
< 
< void pass6c () {						void pass6c () {
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #6c (walking the differences)... |	    fprintf (stderr, "# Pass #6u (walking the differences)...
<     fflush (stderr);					      <
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Write the header.						  // Write the header.
< 
<   fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:0	  fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:0
<   fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:0	  fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:0
< 
<   // Starting at the top of both files,...			  // Starting at the top of both files,...
< 
<   unsigned o = 0;						  unsigned o = 0;
<   unsigned n = 0;						  unsigned n = 0;
< 
<   while (o < lines[0].size () || n < lines[1].size ()) {	  while (o < lines[0].size () || n < lines[1].size ()) {
< 
<     // Find the bounds of the current contextual 'window'.	    // Find the bounds of the current contextual 'window'.
< 
<     // If we aren't looking at a delete or an insert, we're n	    // If we aren't looking at a delete or an insert, we're n
<     // start of a context window.				    // start of a context window.
< 
<     if (lines[0][o].l != ~0 && lines[1][n].l != ~0) {		    if (lines[0][o].l != ~0 && lines[1][n].l != ~0) {
<       o += 1;							      o += 1;
<       n += 1;							      n += 1;
<       continue;							      continue;
<     }								    }
< 
<     // We're now looking at at least 1 delete or insert, so a |	    // We're looking at at least 1 delete or insert, so a win
<     // begins here (or, rather, optCopyContext lines earlier)	    // begins here (or, rather, optCopyContext lines earlier)
<     								    
<     int boOldWindow = max (0, int (o) - int (optCopyContext)) |	    int boOldWindow = max (0, int (boDeletes) - int(optCopyCo
<     int boNewWindow = max (0, int (n) - int (optCopyContext)) |	    int eoOldWindow = min (int (lines[0].size ()), int(o) + i
< 							      <
<     if (1 < optVerbose) {				      <
<       fprintf (stderr, "boOldWindow = %d, boNewWindow = %d\n" <
<       fflush (stderr);					      <
<     }							      <
< 
<     // Look for the end of the current window.		      |	    // Look for the end of the window.
< 
<     int eoOldWindow;					      |	    bool widenWindow = false;
<     int eoNewWindow;					      |	    do {
< 							      <
<     bool widenWindow = true;				      <
<     while (widenWindow && o < lines[0].size () || n < lines[1 <
< 
<       // Skip over the delete(s) and/or insert(s) defining th	      // Skip over the delete(s) and/or insert(s) defining th
<       // context.						      // context.
< 
<       while (o < lines[0].size () && lines[0][o].l == ~0) {	      while (o < lines[0].size () && lines[0][o].l == ~0) {
<         o += 1;							        o += 1;
<       }								      }
<       while (n < lines[1].size () && lines[1][n].l == ~0) {	      while (n < lines[1].size () && lines[1][n].l == ~0) {
<         n += 1;							        n += 1;
<       }								      }
< 
<       // This context will end optCopyContext matched lines p |	      // ...  This context will end optCopyContext lines past
<       // last set of deletes or inserts we find.	      |	      // set of deletes or inserts we find.  However, since a
< 							      >	      // window could follow, we look 2 * optCopyContext ahea
< 							      >	      // another delete or insert.
< 
<       widenWindow = false;				      |	      for (unsigned l = 0; l < (2 * optCopyContext); i += 1) 
<       for (unsigned l = 0; !widenWindow && l < optCopyContext <
<         if (o < lines[0].size ()) {				        if (o < lines[0].size ()) {
<           widenWindow |= lines[0][o].l == ~0;		      |	          if (widenWindow |= lines[0][o].l == ~0) {
< 							      >	            break;
< 							      >	          }
<           o += 1;						          o += 1;
<         }							        }
<         if (n < lines[1].size ()) {				        if (n < lines[1].size ()) {
<           widenWindow |= lines[1][n].l == ~0;		      |	          if (widenWindow |= lines[1][o].l == ~0) {
< 							      >	            break;
< 							      >	          }
<           n += 1;						          n += 1;
<         }							        }
<       }								      }
< 							      |	    } while (widenWindow);
<       eoOldWindow = o;					      <
<       eoNewWindow = n;					      <
< 							      <
<       // However, since another window could follow, we look  <
<       // optCopyContext ahead for another delete or insert.   <
< 							      <
<       if (!widenWindow) {				      <
<         for (unsigned l = 0; l < (2 * optCopyContext + 1); l  <
<           if (o < lines[0].size ()) {			      <
<             widenWindow |= lines[0][o].l == ~0;		      <
<             o += 1;					      <
<           }						      <
<           if (n < lines[1].size ()) {			      <
<             widenWindow |= lines[1][n].l == ~0;		      <
<             n += 1;					      <
<           }						      <
<         }						      <
<       }							      <
<     }							      <
< 
<     // We've found the end of the window.			    // We've found the end of the window.
< 
<     if (1 < optVerbose) {				      |	    int boNewWindow = max (0, int (boInserts) - int (optCopyC
<       fprintf (stderr, "eoOldWindow = %d, eoNewWindow = %d\n" |	    int eoNewWindow = min (int (lines[1].size ()), int(n) + i
<       fflush (stderr);					      <
<     }							      <
< 
<     // Now, reset ourselves to the start of the window, and w	    // Now, reset ourselves to the start of the window, and w
<     // produce the output.  We'll walk it twice, first for th	    // produce the output.  We'll walk it twice, first for th
<     // file part, then for the new file part.			    // file part, then for the new file part.
< 
<     fprintf (stdout, "***************\n");			    fprintf (stdout, "***************\n");
<     fprintf (stdout, "*** %d,%d ****\n", boOldWindow + 1, eoO |	    fprintf (stdout, "*** %d,%d ****\n", boOldWindow + 1, eoO
< 
<     o = boOldWindow;						    o = boOldWindow;
<     n = boNewWindow;						    n = boNewWindow;
< 
<     while (o < eoOldWindow || n < eoNewWindow) {	      |	    while (o < eoOldWindow && n < eoNewWindow) {
< 
<       // Find any unmatched lines at this point in the old fi	      // Find any unmatched lines at this point in the old fi
<       // are deletes.						      // are deletes.
< 
<       unsigned boDeletes = o;					      unsigned boDeletes = o;
<       while (o < eoOldWindow && lines[0][o].l == ~0) {		      while (o < eoOldWindow && lines[0][o].l == ~0) {
<         o += 1;							        o += 1;
<       }								      }
< 
<       // Find any unmatched lines at this point in the new fi	      // Find any unmatched lines at this point in the new fi
<       // are inserts.						      // are inserts.
< 
<       unsigned boInserts = n;					      unsigned boInserts = n;
<       while (n < eoNewWindow && lines[1][n].l == ~0) {		      while (n < eoNewWindow && lines[1][n].l == ~0) {
<         n += 1;							        n += 1;
<       }								      }
< 
<       // We've got deleted line(s) from boDeletes .. o.		      // We've got deleted line(s) from boDeletes .. o.
<       // We've got deleted line(s) from boInserts .. n.		      // We've got deleted line(s) from boInserts .. n.
< 
<       unsigned nDeletes = o - boDeletes;			      unsigned nDeletes = o - boDeletes;
<       unsigned nInserts = n - boInserts;			      unsigned nInserts = n - boInserts;
< 
<       // We've got...						      // We've got...
< 
<       if (nDeletes && nInserts) {				      if (nDeletes && nInserts) {
< 
<         // ... deletes and inserts.				        // ... deletes and inserts.
< 
<         for (unsigned l = boDeletes; l < o; l += 1) {		        for (unsigned l = boDeletes; l < o; l += 1) {
<           fprintf (stdout, "! %s\n", lines[0][l].line->c_str  |	          fprintf (stdout, "! %s", lines[0][l].line->c_str ()
<         }							        }
<       } else if (nDeletes) {					      } else if (nDeletes) {
< 
<         //  ... just deletes.					        //  ... just deletes.
< 
<         for (unsigned l = boDeletes; l < o; l += 1) {		        for (unsigned l = boDeletes; l < o; l += 1) {
<           fprintf (stdout, "- %s\n", lines[0][l].line->c_str  |	          fprintf (stdout, "- %s", lines[0][l].line->c_str ()
<         }							        }
<       }								      }
< 
<       // When we get here, we're dealing with matching lines.	      // When we get here, we're dealing with matching lines.
< 
<       fprintf (stdout, "  %s\n", lines[0][o].line->c_str ()); |	      fprintf (stdout, "  %s", lines[0][l].line->c_str ());
<       o += 1;							      o += 1;
<       n += 1;							      n += 1;
<     }								    }
< 
<     fprintf (stdout, "--- %d,%d ----\n", boNewWindow + 1, eoN |	    fprintf (stdout, "--- %d,%d ----\n", boNewWindow + 1, eoN
< 
<     o = boOldWindow;						    o = boOldWindow;
<     n = boNewWindow;						    n = boNewWindow;
< 
<     while (o < eoOldWindow && n < eoNewWindow) {		    while (o < eoOldWindow && n < eoNewWindow) {
< 
<       // Find any unmatched lines at this point in the old fi	      // Find any unmatched lines at this point in the old fi
<       // are deletes.						      // are deletes.
< 
<       unsigned boDeletes = o;					      unsigned boDeletes = o;
<       while (o < eoOldWindow && lines[0][o].l == ~0) {		      while (o < eoOldWindow && lines[0][o].l == ~0) {
<         o += 1;							        o += 1;
<       }								      }
< 
<       // Find any unmatched lines at this point in the new fi	      // Find any unmatched lines at this point in the new fi
<       // are inserts.						      // are inserts.
< 
<       unsigned boInserts = n;					      unsigned boInserts = n;
<       while (n < eoNewWindow && lines[1][n].l == ~0) {		      while (n < eoNewWindow && lines[1][n].l == ~0) {
<         n += 1;							        n += 1;
<       }								      }
< 
<       // We've got deleted line(s) from boDeletes .. o.		      // We've got deleted line(s) from boDeletes .. o.
<       // We've got deleted line(s) from boInserts .. n.		      // We've got deleted line(s) from boInserts .. n.
< 
<       unsigned nDeletes = o - boDeletes;			      unsigned nDeletes = o - boDeletes;
<       unsigned nInserts = n - boInserts;			      unsigned nInserts = n - boInserts;
< 
<       // We've got...						      // We've got...
< 
<       if (nDeletes && nInserts) {				      if (nDeletes && nInserts) {
< 
<         // ... deletes and inserts.				        // ... deletes and inserts.
< 
<         for (unsigned l = boInserts; l < n; l += 1) {		        for (unsigned l = boInserts; l < n; l += 1) {
<           fprintf (stdout, "! %s\n", lines[1][l].line->c_str  |	          fprintf (stdout, "! %s", lines[1][l].line->c_str ()
<         }							        }
<       } else if (nInserts) {					      } else if (nInserts) {
< 
<         //  ... just inserts.					        //  ... just inserts.
< 
<         for (unsigned l = boInserts; l < n; l += 1) {		        for (unsigned l = boInserts; l < n; l += 1) {
<           fprintf (stdout, "+ %s\n", lines[1][l].line->c_str  |	          fprintf (stdout, "+ %s", lines[1][l].line->c_str ()
<         }							        }
<       }								      }
< 
<       // When we get here, we're dealing with matching lines.	      // When we get here, we're dealing with matching lines.
< 
<       fprintf (stdout, "  %s\n", lines[1][n].line->c_str ()); |	      fprintf (stdout, "  %s", lines[1][l].line->c_str ());
<       o += 1;							      o += 1;
<       n += 1;							      n += 1;
<     }								    }
< 							      <
<     // Reset to the end of the current window.		      <
< 							      <
<     o = eoOldWindow;					      <
<     n = eoNewWindow;					      <
<   }								  }
< }								}
< 
< void pass6e () {						void pass6e () {
<   fprintf (stderr, "pass6e() is unimplemented!\n");	      <
<   fflush (stderr);					      <
< }								}
< 
< void pass6i () {						void pass6i () {
<   fprintf (stderr, "pass6i() is unimplemented!\n");	      <
<   fflush (stderr);					      <
< }								}
< 
< void pass6n ()							void pass6n ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #6n (walking the differences)...	    fprintf (stderr, "# Pass #6n (walking the differences)...
<     fflush (stderr);					      <
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Write the header.  (None for normal.)			  // Write the header.  (None for normal.)
< 
<   // Starting at the top of both files,...			  // Starting at the top of both files,...
< 
<   unsigned o = 0;						  unsigned o = 0;
<   unsigned n = 0;						  unsigned n = 0;
< 
<   while (o < lines[0].size () || n < lines[1].size ()) {	  while (o < lines[0].size () || n < lines[1].size ()) {
< 
<     // Find any unmatched lines at this point in the old file	    // Find any unmatched lines at this point in the old file
<     // are deletes.						    // are deletes.
< 
<     unsigned boDeletes;						    unsigned boDeletes;
<     for (boDeletes = o;						    for (boDeletes = o;
<          o < lines[0].size () && lines[0][o].l == ~0;		         o < lines[0].size () && lines[0][o].l == ~0;
<          o += 1							         o += 1
<         )							        )
<     {}								    {}
< 
<     // Find any unmatched lines at this point in the new file	    // Find any unmatched lines at this point in the new file
<     // are inserts.						    // are inserts.
< 
<     unsigned boInserts;						    unsigned boInserts;
<     for (boInserts = n;						    for (boInserts = n;
<          n < lines[1].size () && lines[1][n].l == ~0;		         n < lines[1].size () && lines[1][n].l == ~0;
<          n += 1							         n += 1
<         )							        )
<     {}								    {}
< 
<     // We've got deleted line(s) from boDeletes .. o.		    // We've got deleted line(s) from boDeletes .. o.
<     // We've got deleted line(s) from boInserts .. n.		    // We've got deleted line(s) from boInserts .. n.
< 
<     unsigned nDeletes = o - boDeletes;				    unsigned nDeletes = o - boDeletes;
<     unsigned nInserts = n - boInserts;				    unsigned nInserts = n - boInserts;
< 
<     // We've got...						    // We've got...
< 
<     if (nDeletes && nInserts) {					    if (nDeletes && nInserts) {
< 
<       // ... deletes and inserts.				      // ... deletes and inserts.
< 
<       if (1 < nDeletes && 1 < nInserts) {			      if (1 < nDeletes && 1 < nInserts) {
<         fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, b	        fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, b
<       } else if (1 < nDeletes) {				      } else if (1 < nDeletes) {
<         fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boIn	        fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boIn
<       } else if (1 < nInserts) {				      } else if (1 < nInserts) {
<         fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInser	        fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInser
<       } 							      } 
<       for (unsigned l = boDeletes; l < o; l += 1) {		      for (unsigned l = boDeletes; l < o; l += 1) {
<         fprintf (stdout, "< %s\n", lines[0][l].line->c_str () |	        fprintf (stdout, "< %s", lines[0][l].line->c_str ());
<       }								      }
<       fprintf (stdout, "---\n");			      |	      fprintf (stderr, "---\n");
<       for (unsigned l = boInserts; l < n; l += 1) {		      for (unsigned l = boInserts; l < n; l += 1) {
<         fprintf (stdout, "> %s\n", lines[1][l].line->c_str () |	        fprintf (stdout, "> %s", lines[1][l].line->c_str ());
<       }								      }
<     } else if (nDeletes) {					    } else if (nDeletes) {
< 
<       //  ... just deletes.					      //  ... just deletes.
< 
<       if (1 < nDeletes) {					      if (1 < nDeletes) {
<         fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);	        fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
<       } else {							      } else {
<         fprintf (stdout, "%dd%d\n", boDeletes + 1, n);		        fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
<       }								      }
<       for (unsigned l = boDeletes; l < o; l += 1) {		      for (unsigned l = boDeletes; l < o; l += 1) {
<         fprintf (stdout, "< %s\n", lines[0][l].line->c_str () |	        fprintf (stdout, "< %s", lines[0][l].line->c_str ());
<       }								      }
<     } else if (nInserts) {					    } else if (nInserts) {
< 
<       //  ... just inserts.					      //  ... just inserts.
< 
<       if (1 < nInserts) {					      if (1 < nInserts) {
<         fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);	        fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
<       } else {							      } else {
<         fprintf (stdout, "%da%d\n", o, boInserts + 1);		        fprintf (stdout, "%da%d\n", o, boInserts + 1);
<       }								      }
<       for (unsigned l = boInserts; l < n; l += 1) {		      for (unsigned l = boInserts; l < n; l += 1) {
<         fprintf (stdout, "> %s\n", lines[1][l].line->c_str () |	        fprintf (stdout, "> %s", lines[1][l].line->c_str ());
<       }								      }
<     }								    }
< 
<     // When we get here, we're dealing with matching lines.	    // When we get here, we're dealing with matching lines.
< 
<     o += 1;							    o += 1;
<     n += 1;							    n += 1;
<   }								  }
< }								}
< 
< void pass6r () {						void pass6r () {
<   fprintf (stderr, "pass6r() is unimplemented!\n");	      <
<   fflush (stderr);					      <
< }								}
< 
< void pass6s () {						void pass6s () {
<   fprintf (stderr, "pass6s() is unimplemented!\n");	      <
<   fflush (stderr);					      <
< }								}
< 
< void pass6u ()							void pass6u ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #6u (walking the differences)...	    fprintf (stderr, "# Pass #6u (walking the differences)...
<     fflush (stderr);					      <
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Write the header.						  // Write the header.
< 
<   fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:0	  fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:0
<   fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:0	  fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:0
<   fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), l	  fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), l
< 
<   // Starting at the top of both files,...			  // Starting at the top of both files,...
< 
<   unsigned o = 0;						  unsigned o = 0;
<   unsigned n = 0;						  unsigned n = 0;
< 
<   while (o < lines[0].size () || n < lines[1].size ()) {	  while (o < lines[0].size () || n < lines[1].size ()) {
< 
<     // Find any unmatched lines at this point in the old file	    // Find any unmatched lines at this point in the old file
<     // are deletes.						    // are deletes.
< 
<     unsigned boDeletes;						    unsigned boDeletes;
<     for (boDeletes = o;						    for (boDeletes = o;
<          o < lines[0].size () && lines[0][o].l == ~0;		         o < lines[0].size () && lines[0][o].l == ~0;
<          o += 1							         o += 1
<         )							        )
<     {}								    {}
< 
<     // Find any unmatched lines at this point in the new file	    // Find any unmatched lines at this point in the new file
<     // are inserts.						    // are inserts.
< 
<     unsigned boInserts;						    unsigned boInserts;
<     for (boInserts = n;						    for (boInserts = n;
<          n < lines[1].size () && lines[1][n].l == ~0;		         n < lines[1].size () && lines[1][n].l == ~0;
<          n += 1							         n += 1
<         )							        )
<     {}								    {}
< 
<     // We've got deleted line(s) from boDeletes .. o.		    // We've got deleted line(s) from boDeletes .. o.
<     // We've got deleted line(s) from boInserts .. n.		    // We've got deleted line(s) from boInserts .. n.
< 
<     unsigned nDeletes = o - boDeletes;				    unsigned nDeletes = o - boDeletes;
<     unsigned nInserts = n - boInserts;				    unsigned nInserts = n - boInserts;
< 
<     // We've got...						    // We've got...
< 
<     if (nDeletes && nInserts) {					    if (nDeletes && nInserts) {
< 
<       // ... deletes and inserts.				      // ... deletes and inserts.
< 
<       for (unsigned l = boDeletes; l < o; l += 1) {		      for (unsigned l = boDeletes; l < o; l += 1) {
<         fprintf (stdout, "-%s\n", lines[0][l].line->c_str ()) |	        fprintf (stdout, "-%s", lines[0][l].line->c_str ());
<       }								      }
<       for (unsigned l = boInserts; l < n; l += 1) {		      for (unsigned l = boInserts; l < n; l += 1) {
<         fprintf (stdout, "+%s\n", lines[1][l].line->c_str ()) |	        fprintf (stdout, "+%s", lines[1][l].line->c_str ());
<       }								      }
<     } else if (nDeletes) {					    } else if (nDeletes) {
< 
<       //  ... just deletes.					      //  ... just deletes.
< 
<       for (unsigned l = boDeletes; l < o; l += 1) {		      for (unsigned l = boDeletes; l < o; l += 1) {
<         fprintf (stdout, "-%s\n", lines[0][l].line->c_str ()) |	        fprintf (stdout, "-%s", lines[0][l].line->c_str ());
<       }								      }
<     } else if (nInserts) {					    } else if (nInserts) {
< 
<       //  ... just inserts.					      //  ... just inserts.
< 
<       for (unsigned l = boInserts; l < n; l += 1) {		      for (unsigned l = boInserts; l < n; l += 1) {
<         fprintf (stdout, "+%s\n", lines[1][l].line->c_str ()) |	        fprintf (stdout, "+%s", lines[1][l].line->c_str ());
<       }								      }
<     }								    }
< 
<     // When we get here, we're dealing with matching lines.	    // When we get here, we're dealing with matching lines.
< 
<     fprintf (stdout, " %s\n", lines[0][o].line->c_str ());    |	    fprintf (stdout, " %s", lines[0][o].line->c_str ());
<     o += 1;						      <
<     n += 1;						      <
<   }							      <
< }							      <
< 							      <
< void pass6y ()						      <
< {							      <
<   if (0 < optVerbose) {					      <
<     fprintf (stderr, "# Pass #6y (walking the differences)... <
<     fflush (stderr);					      <
<   }							      <
< 							      <
<   // Write the header.					      <
< 							      <
<   // None for side-by-side.				      <
< 							      <
<   // Starting at the top of both files,...		      <
< 							      <
<   int columnWidth = (optPageWidth - 7) / 2;		      <
< 							      <
<   unsigned o = 0;					      <
<   unsigned n = 0;					      <
< 							      <
<   while (o < lines[0].size () || n < lines[1].size ()) {      <
< 							      <
<     // Find any unmatched lines at this point in the old file <
<     // are deletes.					      <
< 							      <
<     unsigned boDeletes = o;				      <
<     while (o < lines[0].size () && lines[0][o].l == ~0) {     <
<       o += 1;						      <
<     }							      <
< 							      <
<     // Find any unmatched lines at this point in the new file <
<     // are inserts.					      <
< 							      <
<     unsigned boInserts = n;				      <
<     while (n < lines[1].size () && lines[1][n].l == ~0) {     <
<       n += 1;						      <
<     }							      <
< 							      <
<     // We've got deleted line(s) from boDeletes .. o.	      <
<     // We've got deleted line(s) from boInserts .. n.	      <
< 							      <
<     unsigned nDeletes = o - boDeletes;			      <
<     unsigned nInserts = n - boInserts;			      <
< 							      <
<     // We've got...					      <
< 							      <
<     while (boDeletes < o && boInserts < n) {		      <
< 							      <
<       // ... deletes and inserts.			      <
< 							      <
<       fprintf (stdout,					      <
<                "%-*s | %s\n",				      <
<                columnWidth,				      <
<                lines[0][boDeletes].line->substr (0, columnWid <
<                lines[1][boInserts].line->substr (0, columnWid <
<               );					      <
<       boDeletes += 1;					      <
<       boInserts += 1;					      <
<     }							      <
< 							      <
<     while (boDeletes < o) {				      <
< 							      <
<       //  ... just deletes.				      <
< 							      <
<       fprintf (stdout,					      <
<                "%-*s <\n",				      <
<                columnWidth,				      <
<                lines[0][boDeletes].line->substr (0, columnWid <
<               );					      <
<       boDeletes += 1;					      <
<     }							      <
< 							      <
<     while (boInserts < n) {				      <
< 							      <
<       //  ... just inserts.				      <
< 							      <
<       fprintf (stdout,					      <
<                "%-*s > %s\n",				      <
<                columnWidth,				      <
<                "",					      <
<                lines[1][boInserts].line->substr (0, columnWid <
<               );					      <
<       boInserts += 1;					      <
<     }							      <
< 							      <
<     // When we get here, we're dealing with matching lines.   <
< 							      <
<     fprintf (stdout,					      <
<              "%-*s   %s\n",				      <
<              columnWidth,				      <
<              lines[0][o].line->substr (0, columnWidth).c_str  <
<              lines[1][n].line->substr (0, columnWidth).c_str  <
<             );						      <
<     o += 1;							    o += 1;
<     n += 1;							    n += 1;
<   }								  }
< }								}
---
> #include <algorithm>                                            #include <algorithm>
> using std::find;                                                using std::find;
> #include <string>                                               #include <string>
> using std::string;                                              using std::string;
> #include <list>                                                 #include <list>
> using std::list;                                                using std::list;
> #include <map>                                                  #include <map>
> using std::map;                                                 using std::map;
> #include <vector>                                               #include <vector>
> using std::vector;                                              using std::vector;
> #include <stdio.h>                                              #include <stdio.h>
>                                                                 
> enum DiffFormat {                                               enum DiffFormat {
>   Default,                                                        Default,
>                                                                 
>   Context,                                                        Context,
>   EdScript,                                                       EdScript,
>   IfThenElse,                                                     IfThenElse,
>   Normal,                                                         Normal,
>   RCS,                                                            RCS,
>   SideBySide,                                                     SideBySide,
>   Unified                                                         Unified
> };                                                              };
>                                                                 
> DiffFormat diffFormat = SideBySide;                           | DiffFormat diffFormat = Context;
>                                                               <
> unsigned optCopyContext = 3;                                    unsigned optCopyContext = 3;
> unsigned optPageWidth = 130;                                  | 
> unsigned optVerbose = 2;                                      | int optVerbose = 1;
>                                                                 
> struct Line : public string {                                   struct Line : public string {
>   Line (string _text) :                                           Line (string _text) :
>     string (_text)                                                  string (_text)
>   {                                                               {
>   }                                                               }
>   ~Line () {                                                      ~Line () {
>     copies[0].erase (copies[0].begin (), copies[0].end ());         copies[0].erase (copies[0].begin (), copies[0].end ());
>     copies[1].erase (copies[1].begin (), copies[1].end ());         copies[1].erase (copies[1].begin (), copies[1].end ());
>   }                                                               }
>   void Dump (FILE *out) {                                         void Dump (FILE *out) {
>     fprintf (out, "{{ ");                                           fprintf (out, "{{ ");
>     for (list<unsigned>::iterator i = copies[0].begin (); i !       for (list<unsigned>::iterator i = copies[0].begin (); i !
>       fprintf (out, "%u ", *i);                                       fprintf (out, "%u ", *i);
>     }                                                               }
>     fprintf (out, "},{ ");                                          fprintf (out, "},{ ");
>     for (list<unsigned>::iterator i = copies[1].begin (); i !       for (list<unsigned>::iterator i = copies[1].begin (); i !
>       fprintf (out, "%u ", *i);                                       fprintf (out, "%u ", *i);
>     }                                                               }
>     fprintf (out, "}}\t%s\n", c_str ());                      |     fprintf (out, "}}\t%s", c_str ());
>   }                                                               }
>   list<unsigned> copies[2];                                       list<unsigned> copies[2];
> };                                                              };
>                                                                 
> struct LinePtr {                                                struct LinePtr {
>   LinePtr (Line *_line) :                                         LinePtr (Line *_line) :
>     line (_line),                                                   line (_line),
>     l (~0u)                                                         l (~0u)
>   {                                                               {
>   }                                                               }
>   void Dump (FILE *out) {                                         void Dump (FILE *out) {
>     fprintf (out, "[%d] ", l);                                      fprintf (out, "[%d] ", l);
>     line->Dump (out);                                               line->Dump (out);
>   }                                                               }
>   Line *line;                                                     Line *line;
>   unsigned l;                                                     unsigned l;
> };                                                              };
>                                                                 
> typedef map<string, Line *> MapStringToLinePtr;                 typedef map<string, Line *> MapStringToLinePtr;
> typedef vector<LinePtr> VectorLinePtr;                          typedef vector<LinePtr> VectorLinePtr;
>                                                                 
> // Our name.                                                    // Our name.
>                                                                 
> char *ARGV0 = "dif3";                                           char *ARGV0 = "dif3";
>                                                                 
> // The 'symbol' (line) table.                                   // The 'symbol' (line) table.
>                                                                 
> MapStringToLinePtr table;                                       MapStringToLinePtr table;
>                                                                 
> // The names of the 2 files to be diff'd.                       // The names of the 2 files to be diff'd.
>                                                                 
> char const *files[2] = { 0, 0 };                                char const *files[2] = { 0, 0 };
>                                                                 
> // The lines of the 2 files to be diff'd.                       // The lines of the 2 files to be diff'd.
>                                                                 
> VectorLinePtr lines[2];                                         VectorLinePtr lines[2];
>                                                                 
> // Miscellaneous metrics.                                       // Miscellaneous metrics.
>                                                                 
> unsigned nTotalMatchedBlocks = 0;                               unsigned nTotalMatchedBlocks = 0;
> unsigned nMatchedBlocks = 0;                                    unsigned nMatchedBlocks = 0;
> unsigned nTotalMatchedLines = 0;                                unsigned nTotalMatchedLines = 0;
> unsigned nMatchedLines = 0;                                     unsigned nMatchedLines = 0;
>                                                                 
> void pass1 ();                                                  void pass1 ();
> void pass2 ();                                                  void pass2 ();
> void pass3 ();                                                  void pass3 ();
> void pass4 ();                                                  void pass4 ();
> void pass5 ();                                                  void pass5 ();
> void pass6 ();                                                  void pass6 ();
>                                                                 
> int main (int argc, char *argv[])                            sdiff: sdiff.cpp:1858: void pass6y(): Assertion `lines[0][o].line == lines[1][n].line' failed.
>    int main (int argc, char *argv[])
> {                                                               {
>   // Read the old [0] file, and the new [1] file.                 // Read the old [0] file, and the new [1] file.
>                                                                 
>   for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {     for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
>     files[n] = argv[a];                                             files[n] = argv[a];
>                                                                 
>     if (FILE *f = fopen (files[n], "r")) {                          if (FILE *f = fopen (files[n], "r")) {
>       if (0 < optVerbose) {                                           if (0 < optVerbose) {
>         fprintf (stderr, "# Reading %s...", files[n]);                  fprintf (stderr, "# Reading %s...", files[n]);
>         fflush (stderr);                                      <
>       }                                                               }
>                                                                 
>       char buffer[1024];                                              char buffer[1024];
>       unsigned nUniq = 0;                                             unsigned nUniq = 0;
>                                                                 
>       while (fgets (buffer, sizeof (buffer), f)) {                    while (fgets (buffer, sizeof (buffer), f)) {
>         string text (buffer);                                           string text (buffer);
>                                                               > 
>                                                               >         Line *line = table[text];
>                                                               > 
>                                                               >         if (!line) {
>                                                               >           table[text] = line = new Line (text);
>                                                               >           nUniq += 1;
>                                                               >         }
>                                                               >         line->copies[n].push_back (lines[n].size ());
>                                                               >         lines[n].push_back (line);
>                                                               >       }
>                                                               > 
>                                                               >       if (0 < optVerbose) {
>                                                               >         fprintf (stderr, " %u lines, %u unique.\n", lines[n].
# ../sdiff -y dif.7.cpp dif.8.cpp >& dif.7.8.diff-y.test
# dif.7.8.diff-y ---------------------------------------------------------------
1,1680c1,2742
< #include <algorithm>						#include <algorithm>
< using std::find;						using std::find;
< #include <string>						#include <string>
< using std::string;						using std::string;
< #include <list>							#include <list>
< using std::list;						using std::list;
< #include <map>							#include <map>
< using std::map;							using std::map;
< #include <vector>						#include <vector>
< using std::vector;						using std::vector;
< #include <stdio.h>						#include <stdio.h>
< 							      >	#include <getopt.h>
< 
< enum DiffFormat {						enum DiffFormat {
<   Default,						      |	  opt_D_IfThenElse,
< 							      |	  opt___Normal,
<   Context,						      |	  opt_c_Context,
<   EdScript,						      |	  opt_e_EdScript,
<   IfThenElse,						      |	  opt_n_RCS,
<   Normal,						      |	  opt_u_Unified,
<   RCS,							      |	  opt_y_SideBySide
<   SideBySide,						      <
<   Unified						      <
< };								};
< 
< DiffFormat diffFormat = SideBySide;			      |	DiffFormat opt___OutputFormat = opt___Normal;
< 							      >
< 							      >	bool       opt_B_IgnoreBlankLines = false;
< 							      >	unsigned   opt_C_LinesOfCopyContext = 3;
< 							      >	string     opt_D_IfdefName;
< 							      >	bool       opt_E_IgnoreTabExpansionChanges = false;
< 							      >	string     opt_F_ShowMostRecentLineMatching;
< 							      >	string     opt_I_IgnoreLinesMatching;
< 							      >	bool       opt_N_TreatAbsentFilesAsEmpty = false;
< 							      >	string     opt_S_StartWithFileMatching;
< 							      >	bool       opt_T_PrependATab = false;
< 							      >	unsigned   opt_U_LinesOfUnifiedContext = 3;
< 							      >	unsigned   opt_W_MaxPrintColumns = 130;
< 							      >	string     opt_X_ExcludeFilesMatching;
< 							      >	bool       opt_a_TreatAllFilesAsText = false;
< 							      >	bool       opt_b_IgnoreWhitespaceChanges = false;
< 							      >	bool       opt_d_TryToFindMinimalChanges = false;
< 							      >	bool       opt_i_IgnoreCaseDifferences = false;
< 							      >	bool       opt_l_PaginateWithPr = false;
< 							      >	bool       opt_p_ShowChangedCFunction = false;
< 							      >	bool       opt_q_OutputOnlyIfFilesDiffer = false;
< 							      >	bool       opt_r_RecursivelyCompareSubdirectories = false;
< 							      >	bool       opt_s_ReportWhenFilesAreSame = false;
< 							      >	bool       opt_t_ExpandTabs = false;
< 							      >	bool       opt_v_ShowVersionInfo = false;
< 							      >	bool       opt_w_IgnoreAllWhitespace = false;
< 							      >	string     opt_x_IgnoreFilesMatching;
< 
< unsigned optCopyContext = 3;				      <
< unsigned optPageWidth = 130;				      <
< unsigned optVerbose = 2;					unsigned optVerbose = 2;
< 
< struct Line : public string {					struct Line : public string {
<   Line (string _text) :						  Line (string _text) :
<     string (_text)						    string (_text)
<   {								  {
<   }								  }
<   ~Line () {							  ~Line () {
<     copies[0].erase (copies[0].begin (), copies[0].end ());	    copies[0].erase (copies[0].begin (), copies[0].end ());
<     copies[1].erase (copies[1].begin (), copies[1].end ());	    copies[1].erase (copies[1].begin (), copies[1].end ());
<   }								  }
<   void Dump (FILE *out) {					  void Dump (FILE *out) {
<     fprintf (out, "{{ ");					    fprintf (out, "{{ ");
<     for (list<unsigned>::iterator i = copies[0].begin (); i !	    for (list<unsigned>::iterator i = copies[0].begin (); i !
<       fprintf (out, "%u ", *i);					      fprintf (out, "%u ", *i);
<     }								    }
<     fprintf (out, "},{ ");					    fprintf (out, "},{ ");
<     for (list<unsigned>::iterator i = copies[1].begin (); i !	    for (list<unsigned>::iterator i = copies[1].begin (); i !
<       fprintf (out, "%u ", *i);					      fprintf (out, "%u ", *i);
<     }								    }
<     fprintf (out, "}}\t%s\n", c_str ());			    fprintf (out, "}}\t%s\n", c_str ());
<   }								  }
<   list<unsigned> copies[2];					  list<unsigned> copies[2];
< };								};
< 
< struct LinePtr {						struct LinePtr {
<   LinePtr (Line *_line) :					  LinePtr (Line *_line) :
<     line (_line),						    line (_line),
<     l (~0u)							    l (~0u)
<   {								  {
<   }								  }
<   void Dump (FILE *out) {					  void Dump (FILE *out) {
<     fprintf (out, "[%d] ", l);					    fprintf (out, "[%d] ", l);
<     line->Dump (out);						    line->Dump (out);
<   }								  }
<   Line *line;							  Line *line;
<   unsigned l;							  unsigned l;
< };								};
< 
< typedef map<string, Line *> MapStringToLinePtr;			typedef map<string, Line *> MapStringToLinePtr;
< typedef vector<LinePtr> VectorLinePtr;				typedef vector<LinePtr> VectorLinePtr;
< 
< // Our name.							// Our name.
< 
< char *ARGV0 = "dif3";						char *ARGV0 = "dif3";
< 
< // The 'symbol' (line) table.					// The 'symbol' (line) table.
< 
< MapStringToLinePtr table;					MapStringToLinePtr table;
< 
< // The names of the 2 files to be diff'd.			// The names of the 2 files to be diff'd.
< 
< char const *files[2] = { 0, 0 };				char const *files[2] = { 0, 0 };
< 
< // The lines of the 2 files to be diff'd.			// The lines of the 2 files to be diff'd.
< 
< VectorLinePtr lines[2];						VectorLinePtr lines[2];
< 
< // Miscellaneous metrics.					// Miscellaneous metrics.
< 
< unsigned nTotalMatchedBlocks = 0;				unsigned nTotalMatchedBlocks = 0;
< unsigned nMatchedBlocks = 0;					unsigned nMatchedBlocks = 0;
< unsigned nTotalMatchedLines = 0;				unsigned nTotalMatchedLines = 0;
< unsigned nMatchedLines = 0;					unsigned nMatchedLines = 0;
< 
< 							      >	void getopts (int argc, char const *const argv[]);
< 							      >
< void pass1 ();							void pass1 ();
< void pass2 ();							void pass2 ();
< void pass3 ();							void pass3 ();
< void pass4 ();							void pass4 ();
< void pass5 ();							void pass5 ();
< void pass6 ();							void pass6 ();
< 
< int main (int argc, char *argv[])			      |	int main (int argc, char const *const argv[])
< {								{
< 							      >	  getopts (argc, argv);
< 							      >
< 							      >	  if (opt_v_ShowVersionInfo) {
< 							      >	    fprintf
< 							      >	      (stderr,
< 							      >	       "diff () 0.0.1"
< 							      >	       "Copyright (C) 2008 Sidney R Maxwell III"
< 							      >	       ""
< 							      >	       "This program comes with NO WARRANTY, to the extent pe
< 							      >	       "You may redistribute copies of this program"
< 							      >	       "under the terms of the GNU General Public License."
< 							      >	       "For more information about these matters, see the fil
< 							      >	       ""
< 							      >	       "Written by Sid Maxwell."
< 							      >	      );
< 							      >	    exit (0);
< 							      >	  }
< 							      >
<   // Read the old [0] file, and the new [1] file.		  // Read the old [0] file, and the new [1] file.
< 
<   for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) { |	  for (int a = optind, n = 0; a < argc && n < 2; a += 1, n +=
<     files[n] = argv[a];						    files[n] = argv[a];
< 
<     if (FILE *f = fopen (files[n], "r")) {			    if (FILE *f = fopen (files[n], "r")) {
<       if (0 < optVerbose) {					      if (0 < optVerbose) {
<         fprintf (stderr, "# Reading %s...", files[n]);		        fprintf (stderr, "# Reading %s...", files[n]);
<         fflush (stderr);					        fflush (stderr);
<       }								      }
< 
<       char buffer[1024];					      char buffer[1024];
<       unsigned nUniq = 0;					      unsigned nUniq = 0;
< 
<       while (fgets (buffer, sizeof (buffer), f)) {		      while (fgets (buffer, sizeof (buffer), f)) {
<         string text (buffer);					        string text (buffer);
< 
<         text.erase (text.end () - 1);				        text.erase (text.end () - 1);
< 
<         Line *line = table[text];				        Line *line = table[text];
< 
<         if (!line) {						        if (!line) {
<           table[text] = line = new Line (text);			          table[text] = line = new Line (text);
<           nUniq += 1;						          nUniq += 1;
<         }							        }
<         line->copies[n].push_back (lines[n].size ());		        line->copies[n].push_back (lines[n].size ());
<         lines[n].push_back (line);				        lines[n].push_back (line);
<       }								      }
< 
<       if (0 < optVerbose) {					      if (0 < optVerbose) {
<         fprintf (stderr, " %u lines, %u unique.\n", lines[n].	        fprintf (stderr, " %u lines, %u unique.\n", lines[n].
<         fflush (stderr);					        fflush (stderr);
<       }								      }
<     } else {							    } else {
<       fprintf (stderr, "%s: Unable to open %s!  Exiting....\n	      fprintf (stderr, "%s: Unable to open %s!  Exiting....\n
<       fflush (stderr);						      fflush (stderr);
<       perror (ARGV0);						      perror (ARGV0);
<       exit (1);							      exit (1);
<     }								    }
<   }								  }
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Total unique lines = %d\n", table.siz	    fprintf (stderr, "# Total unique lines = %d\n", table.siz
<     fflush (stderr);						    fflush (stderr);
<   }								  }
< 
<   // map<int, int> counts;					  // map<int, int> counts;
<   // for (MapStringToLinePtr::iterator i = table.begin (); i 	  // for (MapStringToLinePtr::iterator i = table.begin (); i 
<   //   Line *l = i->second;					  //   Line *l = i->second;
<   //   counts[l->counts[0].size () + l->counts[1].size ()] +=	  //   counts[l->counts[0].size () + l->counts[1].size ()] +=
<   // }								  // }
<   // for (map<int, int>::iterator i = counts.begin (); i != c	  // for (map<int, int>::iterator i = counts.begin (); i != c
<   //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s	  //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s
<   // }								  // }
< 
<   pass1 ();							  pass1 ();
<   pass2 ();							  pass2 ();
<   pass3 ();							  pass3 ();
<   pass4 ();							  pass4 ();
<   pass5 ();							  pass5 ();
<   pass6 ();							  pass6 ();
< 
<   return 0;							  return 0;
< }								}
< 
< 							      >	// Usage: diff [OPTION]... FILES
< 							      >	// Compare files line by line.
< 							      >	// 
< 							      >	//   --GTYPE-group-format=GFMT  Similar, but format GTYPE inp
< 							      >	//   --LTYPE-line-format=LFMT  Similar, but format LTYPE inpu
< 							      >	//     LTYPE is `old', `new', or `unchanged'.  GTYPE is LTYPE
< 							      >	//     GFMT may contain:
< 							      >	//       %<  lines from FILE1
< 							      >	//       %>  lines from FILE2
< 							      >	//       %=  lines common to FILE1 and FILE2
< 							      >	//       %[-][WIDTH][.[PREC]]{doxX}LETTER  printf-style spec 
< 							      >	//         LETTERs are as follows for new group, lower case f
< 							      >	//           F  first line number
< 							      >	//           L  last line number
< 							      >	//           N  number of lines = L-F+1
< 							      >	//           E  F-1
< 							      >	//           M  L+1
< 							      >	//     LFMT may contain:
< 							      >	//       %L  contents of line
< 							      >	//       %l  contents of line, excluding any trailing newline
< 							      >	//       %[-][WIDTH][.[PREC]]{doxX}n  printf-style spec for i
< 							      >	//     Either GFMT or LFMT may contain:
< 							      >	//       %%  %
< 							      >	//       %c'C'  the single character C
< 							      >	//       %c'\OOO'  the character with octal code OOO
< 							      >	//
< 							      >	//   --brief  -q  Output only whether files differ.
< 							      >	//   --context[=NUM]  -c  -C NUM  Output NUM (default 3) line
< 							      >	//   --ed  -e  Output an ed script.
< 							      >	//   --exclude-from=FILE  -X FILE  Exclude files that match a
< 							      >	//   --exclude=PAT  -x PAT  Exclude files that match PAT.
< 							      >	//   --expand-tabs  -t  Expand tabs to spaces in output.
< 							      >	//   --from-file=FILE1  Compare FILE1 to all operands.  FILE1
< 							      >	//   --help  Output this help.
< 							      >	//   --horizon-lines=NUM  Keep NUM lines of the common prefix
< 							      >	//   --ifdef=NAME  -D NAME  Output merged file to show `#ifde
< 							      >	//   --ignore-all-space  -w  Ignore all white space.
< 							      >	//   --ignore-blank-lines  -B  Ignore changes whose lines are
< 							      >	//   --ignore-case  -i  Ignore case differences in file conte
< 							      >	//   --ignore-file-name-case  Ignore case when comparing file
< 							      >	//   --ignore-matching-lines=RE  -I RE  Ignore changes whose 
< 							      >	//   --ignore-space-change  -b  Ignore changes in the amount 
< 							      >	//   --ignore-tab-expansion  -E  Ignore changes due to tab ex
< 							      >	//   --initial-tab  -T  Make tabs line up by prepending a tab
< 							      >	//   --label LABEL  Use LABEL instead of file name.
< 							      >	//   --left-column  Output only the left column of common lin
< 							      >	//   --line-format=LFMT  Similar, but format all input lines 
< 							      >	//   --minimal  -d  Try hard to find a smaller set of changes
< 							      >	//   --new-file  -N  Treat absent files as empty.
< 							      >	//   --no-ignore-file-name-case  Consider case when comparing
< 							      >	//   --normal  Output a normal diff.
< 							      >	//   --paginate  -l  Pass the output through `pr' to paginate
< 							      >	//   --rcs  -n  Output an RCS format diff.
< 							      >	//   --recursive  -r  Recursively compare any subdirectories 
< 							      >	//   --report-identical-files  -s  Report when two files are 
< 							      >	//   --show-c-function  -p  Show which C function each change
< 							      >	//   --show-function-line=RE  -F RE  Show the most recent lin
< 							      >	//   --side-by-side  -y  Output in two columns.
< 							      >	//   --speed-large-files  Assume large files and many scatter
< 							      >	//   --starting-file=FILE  -S FILE  Start with FILE when comp
< 							      >	//   --strip-trailing-cr  Strip trailing carriage return on i
< 							      >	//   --suppress-common-lines  Do not output common lines.
< 							      >	//   --text  -a  Treat all files as text.
< 							      >	//   --to-file=FILE2  Compare all operands to FILE2.  FILE2 c
< 							      >	//   --unidirectional-new-file  Treat absent first files as e
< 							      >	//   --unified[=NUM]  -u  -U NUM  Output NUM (default 3) line
< 							      >	//   --version  -v  Output version info.
< 							      >	//   --width=NUM  -W NUM  Output at most NUM (default 130) pr
< 							      >	// 
< 							      >	// FILES are `FILE1 FILE2' or `DIR1 DIR2' or `DIR FILE...' or
< 							      >	// If --from-file or --to-file is given, there are no restric
< 							      >	// If a FILE is `-', read standard input.
< 							      >	// 
< 							      >	// Report bugs to <bug-gnu-utils@gnu.org>.
< 							      >
< 							      >	void getopts (int argc, char const *const argv[])
< 							      >	{
< 							      >	  while (1) {
< 							      >	    int option_index = 0;
< 							      >	    static option long_options[] = {
< 							      >	      { "brief",                        0, 0, 'q' }, // Outpu
< 							      >	      { "context",                      2, 0, 'c' }, // Outpu
< 							      >	      { "ed",                           0, 0, 'e' }, // Outpu
< 							      >	      { "exclude-from",                 1, 0, ' ' }, // Exclu
< 							      >	      { "exclude",                      1, 0, 'x' }, // Exclu
< 							      >	      { "expand-tabs",                  0, 0, 't' }, // Expan
< 							      >	      { "from-file",                    1, 0, ' ' }, // Compa
< 							      >	      { "help",                         0, 0, 'h' }, // Outpu
< 							      >	      { "horizon-lines",                1, 0, ' ' }, // Keep 
< 							      >	      { "ifdef",                        1, 0, 'D' }, // Outpu
< 							      >	      { "ignore-all-space",             0, 0, 'w' }, // Ignor
< 							      >	      { "ignore-blank-lines",           0, 0, 'B' }, // Ignor
< 							      >	      { "ignore-case",                  0, 0, 'i' }, // Ignor
< 							      >	      { "ignore-file-name-case",        0, 0, ' ' }, // Ignor
< 							      >	      { "ignore-matching-lines",        1, 0, 'I' }, // Ignor
< 							      >	      { "ignore-space-change",          0, 0, 'b' }, // Ignor
< 							      >	      { "ignore-tab-expansion",         0, 0, 'E' }, // Ignor
< 							      >	      { "initial-tab",                  0, 0, 'T' }, // Make 
< 							      >	      { "label",                        1, 0, ' ' }, // Use L
< 							      >	      { "left-column",                  0, 0, ' ' }, // Outpu
< 							      >	      { "line-format",                  1, 0, ' ' }, // Simil
< 							      >	      { "minimal",                      0, 0, 'd' }, // Try h
< 							      >	      { "new-file",                     0, 0, 'N' }, // Treat
< 							      >	      { "no-ignore-file-name-case",     0, 0, ' ' }, // Consi
< 							      >	      { "normal",                       0, 0, ' ' }, // Outpu
< 							      >	      { "paginate",                     0, 0, 'l' }, // Pass 
< 							      >	      { "rcs",                          0, 0, 'n' }, // Outpu
< 							      >	      { "recursive",                    0, 0, 'r' }, // Recur
< 							      >	      { "report-identical-files",       0, 0, 's' }, // Repor
< 							      >	      { "show-c-function",              0, 0, 'p' }, // Show 
< 							      >	      { "show-function-line",           1, 0, 'F' }, // Show 
< 							      >	      { "side-by-side",                 0, 0, 'y' }, // Outpu
< 							      >	      { "speed-large-files",            0, 0, ' ' }, // Assum
< 							      >	      { "starting-file",                1, 0, 'S' }, // Start
< 							      >	      { "strip-trailing-cr",            0, 0, ' ' }, // Strip
< 							      >	      { "suppress-common-lines",        0, 0, ' ' }, // Do no
< 							      >	      { "text",                         0, 0, 'a' }, // Treat
< 							      >	      { "to-file",                      0, 0, ' ' }, // Compa
< 							      >	      { "unidirectional-new-file",      0, 0, ' ' }, // Treat
< 							      >	      { "unified",                      2, 0, 'u' }, // Outpu
< 							      >	      { "version",                      0, 0, 'v' }, // Outpu
< 							      >	      { "width",                        1, 0, 'W' }, // Outpu
< 							      >	      { 0,				0, 0,   0 }
< 							      >	    };
< 							      >
< 							      >	    char const *short_options =
< 							      >	      "B"                       // Ignore changes whose lines
< 							      >	      "C:"                      // Output NUM (default 3) lin
< 							      >	      "D:"                      // Output merged file to show
< 							      >	      "E"                       // Ignore changes due to tab 
< 							      >	      "F:"                      // Show the most recent line 
< 							      >	      "I:"                      // Ignore changes whose lines
< 							      >	      "N"                       // Treat absent files as empt
< 							      >	      "S:"                      // Start with FILE when compa
< 							      >	      "T"                       // Make tabs line up by prepe
< 							      >	      "U:"                      // Output NUM (default 3) lin
< 							      >	      "W:"                      // Output at most NUM (defaul
< 							      >	      "X:"                      // Exclude files that match a
< 							      >	      "a"                       // Treat all files as text.
< 							      >	      "b"                       // Ignore changes in the amou
< 							      >	      "c"                       // Output NUM (default 3) lin
< 							      >	      "d"                       // Try hard to find a smaller
< 							      >	      "e"                       // Output an ed script.
< 							      >	      "i"                       // Ignore case differences in
< 							      >	      "l"                       // Pass the output through `p
< 							      >	      "n"                       // Output an RCS format diff.
< 							      >	      "p"                       // Show which C function each
< 							      >	      "q"                       // Output only whether files 
< 							      >	      "r"                       // Recursively compare any su
< 							      >	      "s"                       // Report when two files are 
< 							      >	      "t"                       // Expand tabs to spaces in o
< 							      >	      "u"                       // Output NUM (default 3) lin
< 							      >	      "v"                       // Output version info.
< 							      >	      "w"                       // Ignore all white space.
< 							      >	      "x:"                      // Exclude files that match P
< 							      >	      "y"                       // Output in two columns.
< 							      >	      ;
< 							      >
< 							      >	    int c =
< 							      >	      getopt_long
< 							      >	        (argc,
< 							      >	         const_cast<char *const *> (argv),
< 							      >	         short_options,
< 							      >	         long_options,
< 							      >	         &option_index
< 							      >	        );
< 							      >
< 							      >	    switch (c) {
< 							      >	    case -1:
< 							      >	      return;
< 							      >
< 							      >	    case 0:
< 							      >	      printf ("option %s", long_options[option_index].name);
< 							      >	      if (optarg)
< 							      >	        printf (" with arg %s", optarg);
< 							      >	      printf ("\n");
< 							      >	      break;
< 							      >	    case 'B':
< 							      >	      opt_B_IgnoreBlankLines = true;
< 							      >	      break;
< 							      >	    case 'C':
< 							      >	      {
< 							      >	        unsigned linesOfContext = 3;
< 							      >	        if (optarg) {
< 							      >	          if (sscanf (optarg, "%u", &linesOfContext) != 1) {
< 							      >	            fprintf (stderr, "-C <NUM> or --context[=<NUM>] (
< 							      >	            exit (1);
< 							      >	          }
< 							      >	        }
< 							      >	        opt_C_LinesOfCopyContext = linesOfContext;
< 							      >	      }
< 							      >	      break;
< 							      >	    case 'D':
< 							      >	      opt_D_IfdefName = optarg;
< 							      >	      break;
< 							      >	    case 'E':
< 							      >	      opt_E_IgnoreTabExpansionChanges = true;
< 							      >	      break;
< 							      >	    case 'F':
< 							      >	      opt_F_ShowMostRecentLineMatching = optarg;
< 							      >	      break;
< 							      >	    case 'I':
< 							      >	      opt_I_IgnoreLinesMatching = optarg;
< 							      >	      break;
< 							      >	    case 'N':
< 							      >	      opt_N_TreatAbsentFilesAsEmpty = true;
< 							      >	      break;
< 							      >	    case 'S':
< 							      >	      opt_S_StartWithFileMatching = optarg;
< 							      >	      break;
< 							      >	    case 'T':
< 							      >	      opt_T_PrependATab = true;
< 							      >	      break;
< 							      >	    case 'U':
< 							      >	      {
< 							      >	        unsigned linesOfContext = 3;
< 							      >	        if (optarg) {
< 							      >	          if (sscanf (optarg, "%u", &linesOfContext) != 1) {
< 							      >	            fprintf (stderr, "-U <NUM> or --unified[=<NUM>] (
< 							      >	            exit (1);
< 							      >	          }
< 							      >	        }
< 							      >	        opt_U_LinesOfUnifiedContext = linesOfContext;
< 							      >	      }
< 							      >	      break;
< 							      >	    case 'W':
< 							      >	      {
< 							      >	        unsigned maxPrintColumns = 130;
< 							      >	        if (optarg) {
< 							      >	          if (sscanf (optarg, "%u", &maxPrintColumns) != 1) {
< 							      >	            fprintf (stderr, "-W <NUM> or --width[=<NUM>] (%d
< 							      >	            exit (1);
< 							      >	          }
< 							      >	        }
< 							      >	        opt_W_MaxPrintColumns = maxPrintColumns;
< 							      >	      }
< 							      >	      break;
< 							      >	    case 'X':
< 							      >	      opt_X_ExcludeFilesMatching = optarg;
< 							      >	      break;
< 							      >	    case 'a':
< 							      >	      opt_a_TreatAllFilesAsText = true;
< 							      >	      break;
< 							      >	    case 'b':
< 							      >	      opt_b_IgnoreWhitespaceChanges = true;
< 							      >	      break;
< 							      >	    case 'c':
< 							      >	      opt___OutputFormat = opt_c_Context;
< 							      >	      break;
< 							      >	    case 'd':
< 							      >	      opt_d_TryToFindMinimalChanges = true;
< 							      >	      break;
< 							      >	    case 'e':
< 							      >	      opt___OutputFormat = opt_e_EdScript;
< 							      >	      break;
< 							      >	    case 'i':
< 							      >	      opt_i_IgnoreCaseDifferences = true;
< 							      >	      break;
< 							      >	    case 'l':
< 							      >	      opt_l_PaginateWithPr = true;
< 							      >	      break;
< 							      >	    case 'n':
< 							      >	      opt___OutputFormat = opt_n_RCS;
< 							      >	      break;
< 							      >	    case 'p':
< 							      >	      opt_p_ShowChangedCFunction = true;
< 							      >	      break;
< 							      >	    case 'q':
< 							      >	      opt_q_OutputOnlyIfFilesDiffer = true;
< 							      >	      break;
< 							      >	    case 'r':
< 							      >	      opt_r_RecursivelyCompareSubdirectories = true;
< 							      >	      break;
< 							      >	    case 's':
< 							      >	      opt_s_ReportWhenFilesAreSame = true;
< 							      >	      break;
< 							      >	    case 't':
< 							      >	      opt_t_ExpandTabs = true;
< 							      >	      break;
< 							      >	    case 'u':
< 							      >	      opt___OutputFormat = opt_u_Unified;
< 							      >	      break;
< 							      >	    case 'v':
< 							      >	      opt_v_ShowVersionInfo = true;
< 							      >	      break;
< 							      >	    case 'w':
< 							      >	      opt_w_IgnoreAllWhitespace = true;
< 							      >	      break;
< 							      >	    case 'x':
< 							      >	      opt_x_IgnoreFilesMatching = optarg;
< 							      >	      break;
< 							      >	    case 'y':
< 							      >	      opt___OutputFormat = opt_y_SideBySide;
< 							      >	      break;
< 							      >	    case 'h':
< 							      >	    case '?':
< 							      >	      fprintf
< 							      >	        (stderr,
< 							      >	         "Usage: diff [OPTION]... FILES\n"
< 							      >	         "Compare files line by line.\n"
< 							      >	         "\n"
< 							      >	         "  --GTYPE-group-format=GFMT  Similar, but format GT
< 							      >	         "  --LTYPE-line-format=LFMT  Similar, but format LTY
< 							      >	         "    LTYPE is `old', `new', or `unchanged'.  GTYPE i
< 							      >	         "    GFMT may contain:\n"
< 							      >	         "      %<  lines from FILE1\n"
< 							      >	         "      %>  lines from FILE2\n"
< 							      >	         "      %=  lines common to FILE1 and FILE2\n"
< 							      >	         "      %[-][WIDTH][.[PREC]]{doxX}LETTER  printf-styl
< 							      >	         "        LETTERs are as follows for new group, lower
< 							      >	         "          F  first line number\n"
< 							      >	         "          L  last line number\n"
< 							      >	         "          N  number of lines = L-F+1\n"
< 							      >	         "          E  F-1\n"
< 							      >	         "          M  L+1\n"
< 							      >	         "    LFMT may contain:\n"
< 							      >	         "      %L  contents of line\n"
< 							      >	         "      %l  contents of line, excluding any trailing 
< 							      >	         "      %[-][WIDTH][.[PREC]]{doxX}n  printf-style spe
< 							      >	         "    Either GFMT or LFMT may contain:\n"
< 							      >	         "      %%  %\n"
< 							      >	         "      %c'C'  the single character C\n"
< 							      >	         "      %c'\\OOO'  the character with octal code OOO\
< 							      >	         "\n"
< 							      >	         "  --brief  -q  Output only whether files differ.\n"
< 							      >	         "  --context[=NUM]  -c  -C NUM  Output NUM (default 
< 							      >	         "  --ed  -e  Output an ed script.\n"
< 							      >	         "  --exclude-from=FILE  -X FILE  Exclude files that 
< 							      >	         "  --exclude=PAT  -x PAT  Exclude files that match P
< 							      >	         "  --expand-tabs  -t  Expand tabs to spaces in outpu
< 							      >	         "  --from-file=FILE1  Compare FILE1 to all operands.
< 							      >	         "  --help  Output this help.\n"
< 							      >	         "  --horizon-lines=NUM  Keep NUM lines of the common
< 							      >	         "  --ifdef=NAME  -D NAME  Output merged file to show
< 							      >	         "  --ignore-all-space  -w  Ignore all white space.\n
< 							      >	         "  --ignore-blank-lines  -B  Ignore changes whose li
< 							      >	         "  --ignore-case  -i  Ignore case differences in fil
< 							      >	         "  --ignore-file-name-case  Ignore case when compari
< 							      >	         "  --ignore-matching-lines=RE  -I RE  Ignore changes
< 							      >	         "  --ignore-space-change  -b  Ignore changes in the 
< 							      >	         "  --ignore-tab-expansion  -E  Ignore changes due to
< 							      >	         "  --initial-tab  -T  Make tabs line up by prependin
< 							      >	         "  --label LABEL  Use LABEL instead of file name.\n"
< 							      >	         "  --left-column  Output only the left column of com
< 							      >	         "  --line-format=LFMT  Similar, but format all input
< 							      >	         "  --minimal  -d  Try hard to find a smaller set of 
< 							      >	         "  --new-file  -N  Treat absent files as empty.\n"
< 							      >	         "  --no-ignore-file-name-case  Consider case when co
< 							      >	         "  --normal  Output a normal diff.\n"
< 							      >	         "  --paginate  -l  Pass the output through `pr' to p
< 							      >	         "  --rcs  -n  Output an RCS format diff.\n"
< 							      >	         "  --recursive  -r  Recursively compare any subdirec
< 							      >	         "  --report-identical-files  -s  Report when two fil
< 							      >	         "  --show-c-function  -p  Show which C function each
< 							      >	         "  --show-function-line=RE  -F RE  Show the most rec
< 							      >	         "  --side-by-side  -y  Output in two columns.\n"
< 							      >	         "  --speed-large-files  Assume large files and many 
< 							      >	         "  --starting-file=FILE  -S FILE  Start with FILE wh
< 							      >	         "  --strip-trailing-cr  Strip trailing carriage retu
< 							      >	         "  --suppress-common-lines  Do not output common lin
< 							      >	         "  --text  -a  Treat all files as text.\n"
< 							      >	         "  --to-file=FILE2  Compare all operands to FILE2.  
< 							      >	         "  --unidirectional-new-file  Treat absent first fil
< 							      >	         "  --unified[=NUM]  -u  -U NUM  Output NUM (default 
< 							      >	         "  --version  -v  Output version info.\n"
< 							      >	         "  --width=NUM  -W NUM  Output at most NUM (default 
< 							      >	         "\n"
< 							      >	         "FILES are `FILE1 FILE2' or `DIR1 DIR2' or `DIR FILE
< 							      >	         "If --from-file or --to-file is given, there are no 
< 							      >	         "If a FILE is `-', read standard input.\n"
< 							      >	         "\n"
< 							      >	         "Report bugs to <bug-gnu-utils@gnu.org>.\n"
< 							      >	        );
< 							      >	      exit (1);
< 							      >	    default:
< 							      >	      fprintf (stderr, "Unhandled option (%c%s)!\n", c, optar
< 							      >	      exit (1);
< 							      >	    }
< 							      >	  }
< 							      >	}
< 							      >
< // Perform pass #1, in which we find all explicit matches amo	// Perform pass #1, in which we find all explicit matches amo
< // unique lines.  For every unique line that appears the same	// unique lines.  For every unique line that appears the same
< // of times in both files, we declare the lines to match.	// of times in both files, we declare the lines to match.
< 
< void pass1 ()							void pass1 ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass 1 (finding matches amongst uniqu	    fprintf (stderr, "# Pass 1 (finding matches amongst uniqu
<     fflush (stderr);						    fflush (stderr);
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   for (MapStringToLinePtr::iterator i = table.begin (); i != 	  for (MapStringToLinePtr::iterator i = table.begin (); i != 
<     Line *l = i->second;					    Line *l = i->second;
< 
<     // If the number of old and new lines match, then we decl	    // If the number of old and new lines match, then we decl
<     // they are (all) the same line.  Note, it isn't possible	    // they are (all) the same line.  Note, it isn't possible
<     // numbers of both files to be 0.				    // numbers of both files to be 0.
< 
<     // (In the original algorithm, we only recognized a match	    // (In the original algorithm, we only recognized a match
<     // if there was exactly 1 copy for each file.)		    // if there was exactly 1 copy for each file.)
< 
<     if (l->copies[0].size () == l->copies[1].size ()) {		    if (l->copies[0].size () == l->copies[1].size ()) {
<       nMatchedLines += 1;					      nMatchedLines += 1;
< 
<       // For each matched line in the new file, mark it with 	      // For each matched line in the new file, mark it with 
<       // corresponding line (number) in the old file.		      // corresponding line (number) in the old file.
< 
<       while (!l->copies[0].empty ()) {				      while (!l->copies[0].empty ()) {
<         unsigned o = l->copies[0].front ();			        unsigned o = l->copies[0].front ();
<         unsigned n = l->copies[1].front ();			        unsigned n = l->copies[1].front ();
< 
<         // Match up the pair.					        // Match up the pair.
< 
<         lines[0][o].l = n;					        lines[0][o].l = n;
<         lines[1][n].l = o;					        lines[1][n].l = o;
< 
<         // Remove the matched line numbers from the lists.	        // Remove the matched line numbers from the lists.
< 
<         l->copies[0].pop_front ();				        l->copies[0].pop_front ();
<         l->copies[1].pop_front ();				        l->copies[1].pop_front ();
<       }								      }
<     }								    }
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, " found %u matched lines (%u total).\n",	    fprintf (stderr, " found %u matched lines (%u total).\n",
<     fflush (stderr);						    fflush (stderr);
< 
<     if (2 < optVerbose) {					    if (2 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         fflush (stderr);					        fflush (stderr);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           fflush (stderr);					          fflush (stderr);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< }								}
< 
< // Perform Pass #2, in which we attempt to 'widen' blocks of 	// Perform Pass #2, in which we attempt to 'widen' blocks of 
< // lines, by appending lines which are the same in both files	// lines, by appending lines which are the same in both files
< 
< void pass2 ()							void pass2 ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #2 (spreading matches down)...")	    fprintf (stderr, "# Pass #2 (spreading matches down)...")
<     fflush (stderr);						    fflush (stderr);
<   }								  }
< 
<   nMatchedBlocks = 0;						  nMatchedBlocks = 0;
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Starting at the top of the old file,...			  // Starting at the top of the old file,...
< 
<   for (unsigned o = 0; o < lines[0].size (); o += 1) {		  for (unsigned o = 0; o < lines[0].size (); o += 1) {
< 
<     // ... skip any currently unmatched lines...		    // ... skip any currently unmatched lines...
< 
<     if (lines[0][o].l == ~0) {					    if (lines[0][o].l == ~0) {
<       continue;							      continue;
<     }								    }
< 
<     // ... until we find an [already] matched line.  Then, sk	    // ... until we find an [already] matched line.  Then, sk
<     // the set of 1 or more matched lines, until we reach any	    // the set of 1 or more matched lines, until we reach any
<     // following, still-unmatched line.				    // following, still-unmatched line.
< 
<     unsigned n;							    unsigned n;
<     do {							    do {
<       n = lines[0][o].l + 1;					      n = lines[0][o].l + 1;
<       o += 1;							      o += 1;
<     } while (o < lines[0].size () && lines[0][o].l != ~0);	    } while (o < lines[0].size () && lines[0][o].l != ~0);
< 
<     // Now, o - 1 is the line number of the last matched old 	    // Now, o - 1 is the line number of the last matched old 
<     // n - 1 is the line number of the last matched new line.	    // n - 1 is the line number of the last matched new line.
<     // to add new old and new lines, if they match.		    // to add new old and new lines, if they match.
< 
<     // Finally, attempt to add unmatched lines to the preceed	    // Finally, attempt to add unmatched lines to the preceed
<     // matched set.						    // matched set.
< 
<     for (; o < lines[0].size () && lines[0][o].l == ~0; o += 	    for (; o < lines[0].size () && lines[0][o].l == ~0; o += 
< 
<       // If the [next] pair of old and new lines aren't the s	      // If the [next] pair of old and new lines aren't the s
< 
<       if (lines[0][o].line != lines[1][n].line) {		      if (lines[0][o].line != lines[1][n].line) {
<         break;							        break;
<       }								      }
< 
<       // Match up the pair.					      // Match up the pair.
< 
<       lines[0][o].l = n;					      lines[0][o].l = n;
<       lines[1][n].l = o;					      lines[1][n].l = o;
< 
<       // Remove the matched line numbers form the lists.	      // Remove the matched line numbers form the lists.
< 
<       Line *line = lines[0][o].line;				      Line *line = lines[0][o].line;
<       list<unsigned> &oldCopies = line->copies[0];		      list<unsigned> &oldCopies = line->copies[0];
<       list<unsigned>::iterator oL = find (oldCopies.begin (),	      list<unsigned>::iterator oL = find (oldCopies.begin (),
<       if (oL != oldCopies.end ()) {				      if (oL != oldCopies.end ()) {
<         oldCopies.erase (oL);					        oldCopies.erase (oL);
<       }								      }
<       list<unsigned> &newCopies = line->copies[0];		      list<unsigned> &newCopies = line->copies[0];
<       list<unsigned>::iterator nL = find (newCopies.begin (),	      list<unsigned>::iterator nL = find (newCopies.begin (),
<       if (nL != newCopies.end ()) {				      if (nL != newCopies.end ()) {
<         newCopies.erase (nL);					        newCopies.erase (nL);
<       }								      }
< 
<       nMatchedLines += 1;					      nMatchedLines += 1;
<     }								    }
<     nMatchedBlocks += 1;					    nMatchedBlocks += 1;
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
<   nTotalMatchedBlocks += nMatchedBlocks;			  nTotalMatchedBlocks += nMatchedBlocks;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr,						    fprintf (stderr,
<              " found %u/%u matched lines/blocks (%u/%u totals	             " found %u/%u matched lines/blocks (%u/%u totals
<              nMatchedLines,					             nMatchedLines,
<              nMatchedBlocks,					             nMatchedBlocks,
<              nTotalMatchedLines,				             nTotalMatchedLines,
<              nTotalMatchedBlocks				             nTotalMatchedBlocks
<             );							            );
<     fflush (stderr);						    fflush (stderr);
<     if (2 < optVerbose) {					    if (2 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         fflush (stderr);					        fflush (stderr);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           fflush (stderr);					          fflush (stderr);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< }								}
< 
< // Perform Pass #3, in which we attempt to 'widen' blocks of 	// Perform Pass #3, in which we attempt to 'widen' blocks of 
< // lines, by prepending lines which are the same in both file	// lines, by prepending lines which are the same in both file
< 
< void pass3 ()							void pass3 ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #3 (spreading matches up)...");	    fprintf (stderr, "# Pass #3 (spreading matches up)...");
<     fflush (stderr);						    fflush (stderr);
<   }								  }
< 
<   nMatchedBlocks = 0;						  nMatchedBlocks = 0;
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Starting at the bottom of the old file,...			  // Starting at the bottom of the old file,...
< 
<   for (int o = lines[0].size (); 0 <= o; o -= 1) {		  for (int o = lines[0].size (); 0 <= o; o -= 1) {
< 
<     // ... skip any currently unmatched lines...		    // ... skip any currently unmatched lines...
< 
<     if (lines[0][o].l == ~0) {					    if (lines[0][o].l == ~0) {
<       continue;							      continue;
<     }								    }
< 
<     // ... until we find an [already] matched line.  Then, sk	    // ... until we find an [already] matched line.  Then, sk
<     // the set of 1 or more matched lines, until we reach any	    // the set of 1 or more matched lines, until we reach any
<     // following, still-unmatched line.				    // following, still-unmatched line.
< 
<     unsigned n;							    unsigned n;
<     do {							    do {
<       n = lines[0][o].l - 1;					      n = lines[0][o].l - 1;
<       o -= 1;							      o -= 1;
<     } while (0 <= o && lines[0][o].l != ~0);			    } while (0 <= o && lines[0][o].l != ~0);
< 
<     // Now, o + 1 is the line number of the last matched old 	    // Now, o + 1 is the line number of the last matched old 
<     // n + 1 is the line number of the last matched new line.	    // n + 1 is the line number of the last matched new line.
<     // to add new old and new lines, if they match.		    // to add new old and new lines, if they match.
< 
<     // Finally, attempt to add unmatched lines to the preceed	    // Finally, attempt to add unmatched lines to the preceed
<     // matched set.						    // matched set.
< 
<     for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {	    for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
< 
<       // If the [next] pair of old and new lines aren't the s	      // If the [next] pair of old and new lines aren't the s
< 
<       if (lines[0][o].line != lines[1][n].line) {		      if (lines[0][o].line != lines[1][n].line) {
<         break;							        break;
<       }								      }
< 
<       // Match up the pair.					      // Match up the pair.
< 
<       lines[0][o].l = n;					      lines[0][o].l = n;
<       lines[1][n].l = o;					      lines[1][n].l = o;
< 
<       // Remove the matched line numbers form the lists.	      // Remove the matched line numbers form the lists.
< 
<       Line *line = lines[0][o].line;				      Line *line = lines[0][o].line;
<       list<unsigned> &oldCopies = line->copies[0];		      list<unsigned> &oldCopies = line->copies[0];
<       list<unsigned>::iterator oL = find (oldCopies.begin (),	      list<unsigned>::iterator oL = find (oldCopies.begin (),
<       if (oL != oldCopies.end ()) {				      if (oL != oldCopies.end ()) {
<         oldCopies.erase (oL);					        oldCopies.erase (oL);
<       }								      }
<       list<unsigned> &newCopies = line->copies[0];		      list<unsigned> &newCopies = line->copies[0];
<       list<unsigned>::iterator nL = find (newCopies.begin (),	      list<unsigned>::iterator nL = find (newCopies.begin (),
<       if (nL != newCopies.end ()) {				      if (nL != newCopies.end ()) {
<         newCopies.erase (nL);					        newCopies.erase (nL);
<       }								      }
< 
<       nMatchedLines += 1;					      nMatchedLines += 1;
<     }								    }
<     nMatchedBlocks += 1;					    nMatchedBlocks += 1;
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr,						    fprintf (stderr,
<              " found %u/%u matched lines/blocks (%u/%u totals	             " found %u/%u matched lines/blocks (%u/%u totals
<              nMatchedLines,					             nMatchedLines,
<              nMatchedBlocks,					             nMatchedBlocks,
<              nTotalMatchedLines,				             nTotalMatchedLines,
<              nTotalMatchedBlocks				             nTotalMatchedBlocks
<             );							            );
<     fflush (stderr);						    fflush (stderr);
< 
<     if (2 < optVerbose) {					    if (2 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         fflush (stderr);					        fflush (stderr);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           fflush (stderr);					          fflush (stderr);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< }								}
< 
< // Perform pass #4, in which we find any remaining matches am	// Perform pass #4, in which we find any remaining matches am
< // unique lines.  For every unique line that has more than 1 	// unique lines.  For every unique line that has more than 1 
< // both files, we declare the copies to match.			// both files, we declare the copies to match.
< 
< void pass4 ()							void pass4 ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass 4 (finding remaining matches amo	    fprintf (stderr, "# Pass 4 (finding remaining matches amo
<     fflush (stderr);						    fflush (stderr);
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   for (MapStringToLinePtr::iterator i = table.begin (); i != 	  for (MapStringToLinePtr::iterator i = table.begin (); i != 
<     Line *l = i->second;					    Line *l = i->second;
< 
<     // If there's more than 1 matching old and new lines, the	    // If there's more than 1 matching old and new lines, the
<     // declare that each pair are (all) the same line.		    // declare that each pair are (all) the same line.
< 
<     // (In the original algorithm, we only recognized a match	    // (In the original algorithm, we only recognized a match
<     // if there was exactly 1 copy for each file.)		    // if there was exactly 1 copy for each file.)
< 
<     while (0 < l->copies[0].size () && 0 < l->copies[1].size 	    while (0 < l->copies[0].size () && 0 < l->copies[1].size 
<       nMatchedLines += 1;					      nMatchedLines += 1;
< 
<       // For each matched line in the new file, mark it with 	      // For each matched line in the new file, mark it with 
<       // corresponding line (number) in the old file.		      // corresponding line (number) in the old file.
< 
<       unsigned o = l->copies[0].front ();			      unsigned o = l->copies[0].front ();
<       unsigned n = l->copies[1].front ();			      unsigned n = l->copies[1].front ();
< 
<       // Match up the pair.					      // Match up the pair.
< 
<       lines[0][o].l = n;					      lines[0][o].l = n;
<       lines[1][n].l = o;					      lines[1][n].l = o;
< 
<       // Remove the matched line numbers from the lists.	      // Remove the matched line numbers from the lists.
< 
<       l->copies[0].pop_front ();				      l->copies[0].pop_front ();
<       l->copies[1].pop_front ();				      l->copies[1].pop_front ();
<     }								    }
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, " found %u matched lines (%u total).\n",	    fprintf (stderr, " found %u matched lines (%u total).\n",
<     fflush (stderr);						    fflush (stderr);
< 
<     if (2 < optVerbose) {					    if (2 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         fflush (stderr);					        fflush (stderr);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           fflush (stderr);					          fflush (stderr);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< }								}
< 
< // Perform Pass #5, in which we look for blocks which match, 	// Perform Pass #5, in which we look for blocks which match, 
< // the result of a move (their not in their original position	// the result of a move (their not in their original position
< // these, we'll unmatch the blocks, turning them into a delet	// these, we'll unmatch the blocks, turning them into a delet
< // insert.							// insert.
< 
< void pass5 ()							void pass5 ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #5 (unmatching block moves)...\n	    fprintf (stderr, "# Pass #5 (unmatching block moves)...\n
<     fflush (stderr);						    fflush (stderr);
<   }								  }
< 
<   nMatchedBlocks = 0;						  nMatchedBlocks = 0;
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Starting at the top of both files,...			  // Starting at the top of both files,...
< 
<   unsigned o = 0;						  unsigned o = 0;
<   unsigned n = 0;						  unsigned n = 0;
< 
<   while (o < lines[0].size () || n < lines[1].size ()) {	  while (o < lines[0].size () || n < lines[1].size ()) {
< 
<     // Skip any unmatched lines at this point in the old file	    // Skip any unmatched lines at this point in the old file
<     // are deletes.						    // are deletes.
< 
<     //    Old     New						    //    Old     New
<     //   +---+							    //   +---+
<     // 0 | a |							    // 0 | a |
<     //   +---+   +---+						    //   +---+   +---+
<     //         0 | b |						    //         0 | b |
<     //   +---+   +---+						    //   +---+   +---+
<     // 1 | c | 1 | c |						    // 1 | c | 1 | c |
<     //   +---+   +---+						    //   +---+   +---+
<     //         2 | z |						    //         2 | z |
<     //   +---+   +---+						    //   +---+   +---+
<     // 2 | d | 3 | d |						    // 2 | d | 3 | d |
<     //   +---+   +---+						    //   +---+   +---+
< 
<     while (o < lines[0].size () && lines[0][o].l == ~0) {	    while (o < lines[0].size () && lines[0][o].l == ~0) {
<       o += 1;							      o += 1;
<     }								    }
< 
<     // Skip any unmatched lines at this point in the new file	    // Skip any unmatched lines at this point in the new file
<     // are inserts.						    // are inserts.
< 
<     while (n < lines[1].size () && lines[1][n].l == ~0) {	    while (n < lines[1].size () && lines[1][n].l == ~0) {
<       n += 1;							      n += 1;
<     }								    }
< 
<     // When we get here, we know that we're dealing with matc	    // When we get here, we know that we're dealing with matc
<     // lines (or the end of one or both files).  We're done w	    // lines (or the end of one or both files).  We're done w
<     // pass, if we've reached the end of either file.		    // pass, if we've reached the end of either file.
< 
<     if (lines[0].size () <= o || lines[1].size () <= n) {	    if (lines[0].size () <= o || lines[1].size () <= n) {
<       break;							      break;
<     }								    }
< 
<     // We now know that we've got a pair of matching lines, t	    // We now know that we've got a pair of matching lines, t
<     // of a matching block.  If the new file's line number is	    // of a matching block.  If the new file's line number is
<     // expect, then the matched pair is unmoved, and we can s	    // expect, then the matched pair is unmoved, and we can s
<     // the pair.  (If this is really the start of a block of 	    // the pair.  (If this is really the start of a block of 
<     // 1 lines, we'll handle it one pair at a time.)		    // 1 lines, we'll handle it one pair at a time.)
< 
<     if (lines[0][o].l == n) {					    if (lines[0][o].l == n) {
<       o += 1;							      o += 1;
<       n += 1;							      n += 1;
<       continue;							      continue;
<     }								    }
< 
<     // If, on the other hand, we don't expect this [new] line	    // If, on the other hand, we don't expect this [new] line
<     // then this matching block has been moved.  We need to t	    // then this matching block has been moved.  We need to t
<     // matched pair into an *unmatched* pair, one of deletes,	    // matched pair into an *unmatched* pair, one of deletes,
<     // of inserts.  First, though, we need to know how big th	    // of inserts.  First, though, we need to know how big th
<     // is, and how far it was moved....				    // is, and how far it was moved....
< 
<     // Remember where we were when we started.			    // Remember where we were when we started.
< 
<     unsigned oOld = o;						    unsigned oOld = o;
<     unsigned nOld = n;						    unsigned nOld = n;
< 
<     // Remember where the block came from.			    // Remember where the block came from.
< 
<     unsigned nNew = lines[0][o].l;				    unsigned nNew = lines[0][o].l;
< 
<     // Find the end of this matched pair.			    // Find the end of this matched pair.
< 
<     for (n = nNew; o < lines[0].size () && n < lines[1].size 	    for (n = nNew; o < lines[0].size () && n < lines[1].size 
<       if (lines[0][o].l != n) {					      if (lines[0][o].l != n) {
<         break;							        break;
<       }								      }
<     }								    }
< 
<     // When we get here:					    // When we get here:
<     // * oOld..o is the old file's block,			    // * oOld..o is the old file's block,
<     // * nNew..n is the new file's *moved* block, and		    // * nNew..n is the new file's *moved* block, and
<     // * nOld is where we originally expected the new block f	    // * nOld is where we originally expected the new block f
<  								 
<     // We can now calculate the length of the block...		    // We can now calculate the length of the block...
<     								    
<     unsigned bSize = o - oOld;  // (or n - nNew)		    unsigned bSize = o - oOld;  // (or n - nNew)
< 
<     // ... and we can calculate how far the block moved:	    // ... and we can calculate how far the block moved:
< 
<     unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;	    unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
< 
<     // The larger of the two will become our delete, and the 	    // The larger of the two will become our delete, and the 
<     // will become our insert.					    // will become our insert.
< 
<     //    Old     New						    //    Old     New
<     //   +---+   +---+						    //   +---+   +---+
<     // 0 | a | 0 | b |						    // 0 | a | 0 | b |
<     //   +---+ 1 | b |						    //   +---+ 1 | b |
<     // 1 | b |   +---+						    // 1 | b |   +---+
<     // 2 | b | 2 | a |						    // 2 | b | 2 | a |
<     //   +---+   +---+						    //   +---+   +---+
<     // 3 | c | 3 | c |						    // 3 | c | 3 | c |
<     //   +---+   +---+						    //   +---+   +---+
< 
<     // (1) Delete a@0, insert a@2, or				    // (1) Delete a@0, insert a@2, or
<     // (2) insert bb@0, delete bb@1?				    // (2) insert bb@0, delete bb@1?
< 
<     // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and	    // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and
<     // (of a) is 2-0 or 2, the size of b@0.  We choose to del	    // (of a) is 2-0 or 2, the size of b@0.  We choose to del
<     // and reinsert a@2.					    // and reinsert a@2.
< 
<     // if (bSize <= bMove) {					    // if (bSize <= bMove) {
<       for (unsigned a = oOld; a < o; a += 1) {			      for (unsigned a = oOld; a < o; a += 1) {
<         lines[0][a].l = ~0;					        lines[0][a].l = ~0;
<       }								      }
<       for (unsigned d = nNew; d < n; d += 1) {			      for (unsigned d = nNew; d < n; d += 1) {
<         lines[1][d].l = ~0;					        lines[1][d].l = ~0;
<       }								      }
<     // } else {							    // } else {
<       // for (unsigned a = oOld; a < o; a += 1) {		      // for (unsigned a = oOld; a < o; a += 1) {
<       //   lines[0][a].l = ~0;					      //   lines[0][a].l = ~0;
<       // }							      // }
<       // for (unsigned d = nNew; d < n; d += 1) {		      // for (unsigned d = nNew; d < n; d += 1) {
<       //   lines[1][d].l = ~0;					      //   lines[1][d].l = ~0;
<       // }							      // }
<     // }							    // }
< 
<     // Continue from where we left off.				    // Continue from where we left off.
< 
<     n = nOld;							    n = nOld;
<   }								  }
<   nTotalMatchedLines -= nMatchedLines;				  nTotalMatchedLines -= nMatchedLines;
<   nTotalMatchedBlocks -= nMatchedBlocks;			  nTotalMatchedBlocks -= nMatchedBlocks;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr,						    fprintf (stderr,
<              " found %u/%u matched lines/blocks (%u/%u totals	             " found %u/%u matched lines/blocks (%u/%u totals
<              nMatchedLines,					             nMatchedLines,
<              nMatchedBlocks,					             nMatchedBlocks,
<              nTotalMatchedLines,				             nTotalMatchedLines,
<              nTotalMatchedBlocks				             nTotalMatchedBlocks
<             );							            );
<     fflush (stderr);						    fflush (stderr);
< 
<     if (2 < optVerbose) {					    if (2 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         fflush (stderr);					        fflush (stderr);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           fflush (stderr);					          fflush (stderr);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< }								}
< 
< // Perform Pass #6, in which we create the desired output.	// Perform Pass #6, in which we create the desired output.
< 
< void pass6c ();							void pass6c ();
< void pass6e ();							void pass6e ();
< void pass6i ();							void pass6i ();
< void pass6n ();							void pass6n ();
< void pass6r ();							void pass6r ();
< void pass6s ();							void pass6s ();
< void pass6u ();							void pass6u ();
< void pass6y ();							void pass6y ();
< 
< void pass6 ()							void pass6 ()
< {								{
< 							      |	  switch (opt___OutputFormat) {
<   switch (diffFormat) {					      |	  case opt_c_Context:
<   case Context:						      <
<     pass6c ();							    pass6c ();
<     break;							    break;
< 
<   case EdScript:					      |	  case opt_e_EdScript:
<     pass6e ();							    pass6e ();
<     break;							    break;
< 
<   case IfThenElse:					      |	  case opt_D_IfThenElse:
<     pass6i ();							    pass6i ();
<     break;							    break;
< 
<   case Normal:						      |	  case opt___Normal:
<     pass6n ();							    pass6n ();
<     break;							    break;
< 
<   case RCS:						      |	  case opt_n_RCS:
<     pass6r ();							    pass6r ();
<     break;							    break;
< 
<   case SideBySide:					      |	  case opt_y_SideBySide:
<     pass6y ();							    pass6y ();
<     break;							    break;
< 
<   case Unified:						      |	  case opt_u_Unified:
<     pass6u ();							    pass6u ();
<     break;							    break;
< 
<   case Default:						      <
<   default:							  default:
<     pass6c ();						      |	    pass6n ();
<     break;							    break;
<   }								  }
< }								}
< 
< template<typename T> T min (T l, T r) {				template<typename T> T min (T l, T r) {
<   if (l < r) {							  if (l < r) {
<     return l;							    return l;
<   }								  }
<   return r;							  return r;
< }								}
< 
< template<typename T> T max (T l, T r) {				template<typename T> T max (T l, T r) {
<   if (l < r) {							  if (l < r) {
<     return r;							    return r;
<   }								  }
<   return l;							  return l;
< }								}
< 
< void pass6c () {						void pass6c () {
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #6c (walking the differences)...	    fprintf (stderr, "# Pass #6c (walking the differences)...
<     fflush (stderr);						    fflush (stderr);
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Write the header.						  // Write the header.
< 
<   fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:0	  fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:0
<   fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:0	  fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:0
< 
<   // Starting at the top of both files,...			  // Starting at the top of both files,...
< 
<   unsigned o = 0;						  unsigned o = 0;
<   unsigned n = 0;						  unsigned n = 0;
< 
<   while (o < lines[0].size () || n < lines[1].size ()) {	  while (o < lines[0].size () || n < lines[1].size ()) {
< 
<     // Find the bounds of the current contextual 'window'.	    // Find the bounds of the current contextual 'window'.
< 
<     // If we aren't looking at a delete or an insert, we're n	    // If we aren't looking at a delete or an insert, we're n
<     // start of a context window.				    // start of a context window.
< 
<     if (lines[0][o].l != ~0 && lines[1][n].l != ~0) {		    if (lines[0][o].l != ~0 && lines[1][n].l != ~0) {
<       o += 1;							      o += 1;
<       n += 1;							      n += 1;
<       continue;							      continue;
<     }								    }
< 
<     // We're now looking at at least 1 delete or insert, so a	    // We're now looking at at least 1 delete or insert, so a
<     // begins here (or, rather, optCopyContext lines earlier) |	    // begins here (or, rather, opt_C_LinesOfCopyContext line
<     								    
<     int boOldWindow = max (0, int (o) - int (optCopyContext)) |	    int boOldWindow = max (0, int (o) - int (opt_C_LinesOfCop
<     int boNewWindow = max (0, int (n) - int (optCopyContext)) |	    int boNewWindow = max (0, int (n) - int (opt_C_LinesOfCop
< 
<     if (1 < optVerbose) {					    if (1 < optVerbose) {
<       fprintf (stderr, "boOldWindow = %d, boNewWindow = %d\n"	      fprintf (stderr, "boOldWindow = %d, boNewWindow = %d\n"
<       fflush (stderr);						      fflush (stderr);
<     }								    }
< 
<     // Look for the end of the current window.			    // Look for the end of the current window.
< 
<     int eoOldWindow;						    int eoOldWindow;
<     int eoNewWindow;						    int eoNewWindow;
< 
<     bool widenWindow = true;					    bool widenWindow = true;
<     while (widenWindow && o < lines[0].size () || n < lines[1	    while (widenWindow && o < lines[0].size () || n < lines[1
< 
<       // Skip over the delete(s) and/or insert(s) defining th	      // Skip over the delete(s) and/or insert(s) defining th
<       // context.						      // context.
< 
<       while (o < lines[0].size () && lines[0][o].l == ~0) {	      while (o < lines[0].size () && lines[0][o].l == ~0) {
<         o += 1;							        o += 1;
<       }								      }
<       while (n < lines[1].size () && lines[1][n].l == ~0) {	      while (n < lines[1].size () && lines[1][n].l == ~0) {
<         n += 1;							        n += 1;
<       }								      }
< 
<       // This context will end optCopyContext matched lines p |	      // This context will end opt_C_LinesOfCopyContext match
<       // last set of deletes or inserts we find.		      // last set of deletes or inserts we find.
< 
<       widenWindow = false;					      widenWindow = false;
<       for (unsigned l = 0; !widenWindow && l < optCopyContext |	      for (unsigned l = 0; !widenWindow && l < opt_C_LinesOfC
<         if (o < lines[0].size ()) {				        if (o < lines[0].size ()) {
<           widenWindow |= lines[0][o].l == ~0;			          widenWindow |= lines[0][o].l == ~0;
<           o += 1;						          o += 1;
<         }							        }
<         if (n < lines[1].size ()) {				        if (n < lines[1].size ()) {
<           widenWindow |= lines[1][n].l == ~0;			          widenWindow |= lines[1][n].l == ~0;
<           n += 1;						          n += 1;
<         }							        }
<       }								      }
< 
<       eoOldWindow = o;						      eoOldWindow = o;
<       eoNewWindow = n;						      eoNewWindow = n;
< 
<       // However, since another window could follow, we look	      // However, since another window could follow, we look
<       // optCopyContext ahead for another delete or insert.   |	      // opt_C_LinesOfCopyContext ahead for another delete or
< 
<       if (!widenWindow) {					      if (!widenWindow) {
<         for (unsigned l = 0; l < (2 * optCopyContext + 1); l  |	        for (unsigned l = 0; l < (2 * opt_C_LinesOfCopyContex
<           if (o < lines[0].size ()) {				          if (o < lines[0].size ()) {
<             widenWindow |= lines[0][o].l == ~0;			            widenWindow |= lines[0][o].l == ~0;
<             o += 1;						            o += 1;
<           }							          }
<           if (n < lines[1].size ()) {				          if (n < lines[1].size ()) {
<             widenWindow |= lines[1][n].l == ~0;			            widenWindow |= lines[1][n].l == ~0;
<             n += 1;						            n += 1;
<           }							          }
<         }							        }
<       }								      }
<     }								    }
< 
<     // We've found the end of the window.			    // We've found the end of the window.
< 
<     if (1 < optVerbose) {					    if (1 < optVerbose) {
<       fprintf (stderr, "eoOldWindow = %d, eoNewWindow = %d\n"	      fprintf (stderr, "eoOldWindow = %d, eoNewWindow = %d\n"
<       fflush (stderr);						      fflush (stderr);
<     }								    }
< 
<     // Now, reset ourselves to the start of the window, and w	    // Now, reset ourselves to the start of the window, and w
<     // produce the output.  We'll walk it twice, first for th	    // produce the output.  We'll walk it twice, first for th
<     // file part, then for the new file part.			    // file part, then for the new file part.
< 
<     fprintf (stdout, "***************\n");			    fprintf (stdout, "***************\n");
<     fprintf (stdout, "*** %d,%d ****\n", boOldWindow + 1, eoO	    fprintf (stdout, "*** %d,%d ****\n", boOldWindow + 1, eoO
< 
<     o = boOldWindow;						    o = boOldWindow;
<     n = boNewWindow;						    n = boNewWindow;
< 
<     while (o < eoOldWindow || n < eoNewWindow) {		    while (o < eoOldWindow || n < eoNewWindow) {
< 
<       // Find any unmatched lines at this point in the old fi	      // Find any unmatched lines at this point in the old fi
<       // are deletes.						      // are deletes.
< 
<       unsigned boDeletes = o;					      unsigned boDeletes = o;
<       while (o < eoOldWindow && lines[0][o].l == ~0) {		      while (o < eoOldWindow && lines[0][o].l == ~0) {
<         o += 1;							        o += 1;
<       }								      }
< 
<       // Find any unmatched lines at this point in the new fi	      // Find any unmatched lines at this point in the new fi
<       // are inserts.						      // are inserts.
< 
<       unsigned boInserts = n;					      unsigned boInserts = n;
<       while (n < eoNewWindow && lines[1][n].l == ~0) {		      while (n < eoNewWindow && lines[1][n].l == ~0) {
<         n += 1;							        n += 1;
<       }								      }
< 
<       // We've got deleted line(s) from boDeletes .. o.		      // We've got deleted line(s) from boDeletes .. o.
<       // We've got deleted line(s) from boInserts .. n.		      // We've got deleted line(s) from boInserts .. n.
< 
<       unsigned nDeletes = o - boDeletes;			      unsigned nDeletes = o - boDeletes;
<       unsigned nInserts = n - boInserts;			      unsigned nInserts = n - boInserts;
< 
<       // We've got...						      // We've got...
< 
<       if (nDeletes && nInserts) {				      if (nDeletes && nInserts) {
< 
<         // ... deletes and inserts.				        // ... deletes and inserts.
< 
<         for (unsigned l = boDeletes; l < o; l += 1) {		        for (unsigned l = boDeletes; l < o; l += 1) {
<           fprintf (stdout, "! %s\n", lines[0][l].line->c_str 	          fprintf (stdout, "! %s\n", lines[0][l].line->c_str 
<         }							        }
<       } else if (nDeletes) {					      } else if (nDeletes) {
< 
<         //  ... just deletes.					        //  ... just deletes.
< 
<         for (unsigned l = boDeletes; l < o; l += 1) {		        for (unsigned l = boDeletes; l < o; l += 1) {
<           fprintf (stdout, "- %s\n", lines[0][l].line->c_str 	          fprintf (stdout, "- %s\n", lines[0][l].line->c_str 
<         }							        }
<       }								      }
< 
<       // When we get here, we're dealing with matching lines.	      // When we get here, we're dealing with matching lines.
< 
<       fprintf (stdout, "  %s\n", lines[0][o].line->c_str ());	      fprintf (stdout, "  %s\n", lines[0][o].line->c_str ());
<       o += 1;							      o += 1;
<       n += 1;							      n += 1;
<     }								    }
< 
<     fprintf (stdout, "--- %d,%d ----\n", boNewWindow + 1, eoN	    fprintf (stdout, "--- %d,%d ----\n", boNewWindow + 1, eoN
< 
<     o = boOldWindow;						    o = boOldWindow;
<     n = boNewWindow;						    n = boNewWindow;
< 
<     while (o < eoOldWindow && n < eoNewWindow) {		    while (o < eoOldWindow && n < eoNewWindow) {
< 
<       // Find any unmatched lines at this point in the old fi	      // Find any unmatched lines at this point in the old fi
<       // are deletes.						      // are deletes.
< 
<       unsigned boDeletes = o;					      unsigned boDeletes = o;
<       while (o < eoOldWindow && lines[0][o].l == ~0) {		      while (o < eoOldWindow && lines[0][o].l == ~0) {
<         o += 1;							        o += 1;
<       }								      }
< 
<       // Find any unmatched lines at this point in the new fi	      // Find any unmatched lines at this point in the new fi
<       // are inserts.						      // are inserts.
< 
<       unsigned boInserts = n;					      unsigned boInserts = n;
<       while (n < eoNewWindow && lines[1][n].l == ~0) {		      while (n < eoNewWindow && lines[1][n].l == ~0) {
<         n += 1;							        n += 1;
<       }								      }
< 
<       // We've got deleted line(s) from boDeletes .. o.		      // We've got deleted line(s) from boDeletes .. o.
<       // We've got deleted line(s) from boInserts .. n.		      // We've got deleted line(s) from boInserts .. n.
< 
<       unsigned nDeletes = o - boDeletes;			      unsigned nDeletes = o - boDeletes;
<       unsigned nInserts = n - boInserts;			      unsigned nInserts = n - boInserts;
< 
<       // We've got...						      // We've got...
< 
<       if (nDeletes && nInserts) {				      if (nDeletes && nInserts) {
< 
<         // ... deletes and inserts.				        // ... deletes and inserts.
< 
<         for (unsigned l = boInserts; l < n; l += 1) {		        for (unsigned l = boInserts; l < n; l += 1) {
<           fprintf (stdout, "! %s\n", lines[1][l].line->c_str 	          fprintf (stdout, "! %s\n", lines[1][l].line->c_str 
<         }							        }
<       } else if (nInserts) {					      } else if (nInserts) {
< 
<         //  ... just inserts.					        //  ... just inserts.
< 
<         for (unsigned l = boInserts; l < n; l += 1) {		        for (unsigned l = boInserts; l < n; l += 1) {
<           fprintf (stdout, "+ %s\n", lines[1][l].line->c_str 	          fprintf (stdout, "+ %s\n", lines[1][l].line->c_str 
<         }							        }
<       }								      }
< 
<       // When we get here, we're dealing with matching lines.	      // When we get here, we're dealing with matching lines.
< 
<       fprintf (stdout, "  %s\n", lines[1][n].line->c_str ());	      fprintf (stdout, "  %s\n", lines[1][n].line->c_str ());
<       o += 1;							      o += 1;
<       n += 1;							      n += 1;
<     }								    }
< 
<     // Reset to the end of the current window.			    // Reset to the end of the current window.
< 
<     o = eoOldWindow;						    o = eoOldWindow;
<     n = eoNewWindow;						    n = eoNewWindow;
<   }								  }
< }								}
< 
< void pass6e () {						void pass6e () {
<   fprintf (stderr, "pass6e() is unimplemented!\n");		  fprintf (stderr, "pass6e() is unimplemented!\n");
<   fflush (stderr);						  fflush (stderr);
< }								}
< 
< void pass6i () {						void pass6i () {
<   fprintf (stderr, "pass6i() is unimplemented!\n");		  fprintf (stderr, "pass6i() is unimplemented!\n");
<   fflush (stderr);						  fflush (stderr);
< }								}
< 
< void pass6n ()							void pass6n ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #6n (walking the differences)...	    fprintf (stderr, "# Pass #6n (walking the differences)...
<     fflush (stderr);						    fflush (stderr);
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Write the header.  (None for normal.)			  // Write the header.  (None for normal.)
< 
<   // Starting at the top of both files,...			  // Starting at the top of both files,...
< 
<   unsigned o = 0;						  unsigned o = 0;
<   unsigned n = 0;						  unsigned n = 0;
< 
<   while (o < lines[0].size () || n < lines[1].size ()) {	  while (o < lines[0].size () || n < lines[1].size ()) {
< 
<     // Find any unmatched lines at this point in the old file	    // Find any unmatched lines at this point in the old file
<     // are deletes.						    // are deletes.
< 
<     unsigned boDeletes;						    unsigned boDeletes;
<     for (boDeletes = o;						    for (boDeletes = o;
<          o < lines[0].size () && lines[0][o].l == ~0;		         o < lines[0].size () && lines[0][o].l == ~0;
<          o += 1							         o += 1
<         )							        )
<     {}								    {}
< 
<     // Find any unmatched lines at this point in the new file	    // Find any unmatched lines at this point in the new file
<     // are inserts.						    // are inserts.
< 
<     unsigned boInserts;						    unsigned boInserts;
<     for (boInserts = n;						    for (boInserts = n;
<          n < lines[1].size () && lines[1][n].l == ~0;		         n < lines[1].size () && lines[1][n].l == ~0;
<          n += 1							         n += 1
<         )							        )
<     {}								    {}
< 
<     // We've got deleted line(s) from boDeletes .. o.		    // We've got deleted line(s) from boDeletes .. o.
<     // We've got deleted line(s) from boInserts .. n.		    // We've got deleted line(s) from boInserts .. n.
< 
<     unsigned nDeletes = o - boDeletes;				    unsigned nDeletes = o - boDeletes;
<     unsigned nInserts = n - boInserts;				    unsigned nInserts = n - boInserts;
< 
<     // We've got...						    // We've got...
< 
<     if (nDeletes && nInserts) {					    if (nDeletes && nInserts) {
< 
<       // ... deletes and inserts.				      // ... deletes and inserts.
< 
<       if (1 < nDeletes && 1 < nInserts) {			      if (1 < nDeletes && 1 < nInserts) {
<         fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, b	        fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, b
<       } else if (1 < nDeletes) {				      } else if (1 < nDeletes) {
<         fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boIn	        fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boIn
<       } else if (1 < nInserts) {				      } else if (1 < nInserts) {
<         fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInser	        fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInser
<       } 							      } 
<       for (unsigned l = boDeletes; l < o; l += 1) {		      for (unsigned l = boDeletes; l < o; l += 1) {
<         fprintf (stdout, "< %s\n", lines[0][l].line->c_str ()	        fprintf (stdout, "< %s\n", lines[0][l].line->c_str ()
<       }								      }
<       fprintf (stdout, "---\n");				      fprintf (stdout, "---\n");
<       for (unsigned l = boInserts; l < n; l += 1) {		      for (unsigned l = boInserts; l < n; l += 1) {
<         fprintf (stdout, "> %s\n", lines[1][l].line->c_str ()	        fprintf (stdout, "> %s\n", lines[1][l].line->c_str ()
<       }								      }
<     } else if (nDeletes) {					    } else if (nDeletes) {
< 
<       //  ... just deletes.					      //  ... just deletes.
< 
<       if (1 < nDeletes) {					      if (1 < nDeletes) {
<         fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);	        fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
<       } else {							      } else {
<         fprintf (stdout, "%dd%d\n", boDeletes + 1, n);		        fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
<       }								      }
<       for (unsigned l = boDeletes; l < o; l += 1) {		      for (unsigned l = boDeletes; l < o; l += 1) {
<         fprintf (stdout, "< %s\n", lines[0][l].line->c_str ()	        fprintf (stdout, "< %s\n", lines[0][l].line->c_str ()
<       }								      }
<     } else if (nInserts) {					    } else if (nInserts) {
< 
<       //  ... just inserts.					      //  ... just inserts.
< 
<       if (1 < nInserts) {					      if (1 < nInserts) {
<         fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);	        fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
<       } else {							      } else {
<         fprintf (stdout, "%da%d\n", o, boInserts + 1);		        fprintf (stdout, "%da%d\n", o, boInserts + 1);
<       }								      }
<       for (unsigned l = boInserts; l < n; l += 1) {		      for (unsigned l = boInserts; l < n; l += 1) {
<         fprintf (stdout, "> %s\n", lines[1][l].line->c_str ()	        fprintf (stdout, "> %s\n", lines[1][l].line->c_str ()
<       }								      }
<     }								    }
< 
<     // When we get here, we're dealing with matching lines.	    // When we get here, we're dealing with matching lines.
< 
<     o += 1;							    o += 1;
<     n += 1;							    n += 1;
<   }								  }
< }								}
< 
< void pass6r () {						void pass6r () {
<   fprintf (stderr, "pass6r() is unimplemented!\n");		  fprintf (stderr, "pass6r() is unimplemented!\n");
<   fflush (stderr);						  fflush (stderr);
< }								}
< 
< void pass6s () {						void pass6s () {
<   fprintf (stderr, "pass6s() is unimplemented!\n");		  fprintf (stderr, "pass6s() is unimplemented!\n");
<   fflush (stderr);						  fflush (stderr);
< }								}
< 
< void pass6u ()							void pass6u ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #6u (walking the differences)...	    fprintf (stderr, "# Pass #6u (walking the differences)...
<     fflush (stderr);						    fflush (stderr);
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Write the header.						  // Write the header.
< 
<   fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:0	  fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:0
<   fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:0	  fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:0
<   fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), l	  fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), l
< 
<   // Starting at the top of both files,...			  // Starting at the top of both files,...
< 
<   unsigned o = 0;						  unsigned o = 0;
<   unsigned n = 0;						  unsigned n = 0;
< 
<   while (o < lines[0].size () || n < lines[1].size ()) {	  while (o < lines[0].size () || n < lines[1].size ()) {
< 
<     // Find any unmatched lines at this point in the old file	    // Find any unmatched lines at this point in the old file
<     // are deletes.						    // are deletes.
< 
<     unsigned boDeletes;						    unsigned boDeletes;
<     for (boDeletes = o;						    for (boDeletes = o;
<          o < lines[0].size () && lines[0][o].l == ~0;		         o < lines[0].size () && lines[0][o].l == ~0;
<          o += 1							         o += 1
<         )							        )
<     {}								    {}
< 
<     // Find any unmatched lines at this point in the new file	    // Find any unmatched lines at this point in the new file
<     // are inserts.						    // are inserts.
< 
<     unsigned boInserts;						    unsigned boInserts;
<     for (boInserts = n;						    for (boInserts = n;
<          n < lines[1].size () && lines[1][n].l == ~0;		         n < lines[1].size () && lines[1][n].l == ~0;
<          n += 1							         n += 1
<         )							        )
<     {}								    {}
< 
<     // We've got deleted line(s) from boDeletes .. o.		    // We've got deleted line(s) from boDeletes .. o.
<     // We've got deleted line(s) from boInserts .. n.		    // We've got deleted line(s) from boInserts .. n.
< 
<     unsigned nDeletes = o - boDeletes;				    unsigned nDeletes = o - boDeletes;
<     unsigned nInserts = n - boInserts;				    unsigned nInserts = n - boInserts;
< 
<     // We've got...						    // We've got...
< 
<     if (nDeletes && nInserts) {					    if (nDeletes && nInserts) {
< 
<       // ... deletes and inserts.				      // ... deletes and inserts.
< 
<       for (unsigned l = boDeletes; l < o; l += 1) {		      for (unsigned l = boDeletes; l < o; l += 1) {
<         fprintf (stdout, "-%s\n", lines[0][l].line->c_str ())	        fprintf (stdout, "-%s\n", lines[0][l].line->c_str ())
<       }								      }
<       for (unsigned l = boInserts; l < n; l += 1) {		      for (unsigned l = boInserts; l < n; l += 1) {
<         fprintf (stdout, "+%s\n", lines[1][l].line->c_str ())	        fprintf (stdout, "+%s\n", lines[1][l].line->c_str ())
<       }								      }
<     } else if (nDeletes) {					    } else if (nDeletes) {
< 
<       //  ... just deletes.					      //  ... just deletes.
< 
<       for (unsigned l = boDeletes; l < o; l += 1) {		      for (unsigned l = boDeletes; l < o; l += 1) {
<         fprintf (stdout, "-%s\n", lines[0][l].line->c_str ())	        fprintf (stdout, "-%s\n", lines[0][l].line->c_str ())
<       }								      }
<     } else if (nInserts) {					    } else if (nInserts) {
< 
<       //  ... just inserts.					      //  ... just inserts.
< 
<       for (unsigned l = boInserts; l < n; l += 1) {		      for (unsigned l = boInserts; l < n; l += 1) {
<         fprintf (stdout, "+%s\n", lines[1][l].line->c_str ())	        fprintf (stdout, "+%s\n", lines[1][l].line->c_str ())
<       }								      }
<     }								    }
< 
<     // When we get here, we're dealing with matching lines.	    // When we get here, we're dealing with matching lines.
< 
<     fprintf (stdout, " %s\n", lines[0][o].line->c_str ());	    fprintf (stdout, " %s\n", lines[0][o].line->c_str ());
<     o += 1;							    o += 1;
<     n += 1;							    n += 1;
<   }								  }
< }								}
< 
< void pass6y ()							void pass6y ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #6y (walking the differences)...	    fprintf (stderr, "# Pass #6y (walking the differences)...
<     fflush (stderr);						    fflush (stderr);
<   }								  }
< 
<   // Write the header.						  // Write the header.
< 
<   // None for side-by-side.					  // None for side-by-side.
< 
<   // Starting at the top of both files,...			  // Starting at the top of both files,...
< 
<   int columnWidth = (optPageWidth - 7) / 2;		      |	  int columnWidth = (opt_W_MaxPrintColumns - 7) / 2;
< 
<   unsigned o = 0;						  unsigned o = 0;
<   unsigned n = 0;						  unsigned n = 0;
< 
<   while (o < lines[0].size () || n < lines[1].size ()) {	  while (o < lines[0].size () || n < lines[1].size ()) {
< 
<     // Find any unmatched lines at this point in the old file	    // Find any unmatched lines at this point in the old file
<     // are deletes.						    // are deletes.
< 
<     unsigned boDeletes = o;					    unsigned boDeletes = o;
<     while (o < lines[0].size () && lines[0][o].l == ~0) {	    while (o < lines[0].size () && lines[0][o].l == ~0) {
<       o += 1;							      o += 1;
<     }								    }
< 
<     // Find any unmatched lines at this point in the new file	    // Find any unmatched lines at this point in the new file
<     // are inserts.						    // are inserts.
< 
<     unsigned boInserts = n;					    unsigned boInserts = n;
<     while (n < lines[1].size () && lines[1][n].l == ~0) {	    while (n < lines[1].size () && lines[1][n].l == ~0) {
<       n += 1;							      n += 1;
<     }								    }
< 
<     // We've got deleted line(s) from boDeletes .. o.		    // We've got deleted line(s) from boDeletes .. o.
<     // We've got deleted line(s) from boInserts .. n.		    // We've got deleted line(s) from boInserts .. n.
< 
<     unsigned nDeletes = o - boDeletes;				    unsigned nDeletes = o - boDeletes;
<     unsigned nInserts = n - boInserts;				    unsigned nInserts = n - boInserts;
< 
<     // We've got...						    // We've got...
< 
<     while (boDeletes < o && boInserts < n) {			    while (boDeletes < o && boInserts < n) {
< 
<       // ... deletes and inserts.				      // ... deletes and inserts.
< 
<       fprintf (stdout,						      fprintf (stdout,
<                "%-*s | %s\n",					               "%-*s | %s\n",
<                columnWidth,					               columnWidth,
<                lines[0][boDeletes].line->substr (0, columnWid	               lines[0][boDeletes].line->substr (0, columnWid
<                lines[1][boInserts].line->substr (0, columnWid	               lines[1][boInserts].line->substr (0, columnWid
<               );						              );
<       boDeletes += 1;						      boDeletes += 1;
<       boInserts += 1;						      boInserts += 1;
<     }								    }
< 
<     while (boDeletes < o) {					    while (boDeletes < o) {
< 
<       //  ... just deletes.					      //  ... just deletes.
< 
<       fprintf (stdout,						      fprintf (stdout,
<                "%-*s <\n",					               "%-*s <\n",
<                columnWidth,					               columnWidth,
<                lines[0][boDeletes].line->substr (0, columnWid	               lines[0][boDeletes].line->substr (0, columnWid
<               );						              );
<       boDeletes += 1;						      boDeletes += 1;
<     }								    }
< 
<     while (boInserts < n) {					    while (boInserts < n) {
< 
<       //  ... just inserts.					      //  ... just inserts.
< 
<       fprintf (stdout,						      fprintf (stdout,
<                "%-*s > %s\n",					               "%-*s > %s\n",
<                columnWidth,					               columnWidth,
<                "",						               "",
<                lines[1][boInserts].line->substr (0, columnWid	               lines[1][boInserts].line->substr (0, columnWid
<               );						              );
<       boInserts += 1;						      boInserts += 1;
<     }								    }
< 
<     // When we get here, we're dealing with matching lines.	    // When we get here, we're dealing with matching lines.
< 
<     fprintf (stdout,						    fprintf (stdout,
<              "%-*s   %s\n",					             "%-*s   %s\n",
<              columnWidth,					             columnWidth,
<              lines[0][o].line->substr (0, columnWidth).c_str 	             lines[0][o].line->substr (0, columnWidth).c_str 
<              lines[1][n].line->substr (0, columnWidth).c_str 	             lines[1][n].line->substr (0, columnWidth).c_str 
<             );							            );
<     o += 1;							    o += 1;
<     n += 1;							    n += 1;
<   }								  }
< }								}
---
> #include <algorithm>                                            #include <algorithm>
> using std::find;                                                using std::find;
> #include <string>                                               #include <string>
> using std::string;                                              using std::string;
> #include <list>                                                 #include <list>
> using std::list;                                                using std::list;
> #include <map>                                                  #include <map>
> using std::map;                                                 using std::map;
> #include <vector>                                               #include <vector>
> using std::vector;                                              using std::vector;
> #include <stdio.h>                                              #include <stdio.h>
>                                                               > #include <getopt.h>
>                                                                 
> enum DiffFormat {                                               enum DiffFormat {
>   Default,                                                    |   opt_D_IfThenElse,
>                                                               |   opt___Normal,
>   Context,                                                    |   opt_c_Context,
>   EdScript,                                                   |   opt_e_EdScript,
>   IfThenElse,                                                 |   opt_n_RCS,
>   Normal,                                                     |   opt_u_Unified,
>   RCS,                                                        |   opt_y_SideBySide
>   SideBySide,                                                 <
>   Unified                                                     <
> };                                                              };
>                                                                 
> DiffFormat diffFormat = SideBySide;                           | DiffFormat opt___OutputFormat = opt___Normal;
>                                                               > 
>                                                               > bool       opt_B_IgnoreBlankLines = false;
>                                                               > unsigned   opt_C_LinesOfCopyContext = 3;
>                                                               > string     opt_D_IfdefName;
>                                                               > bool       opt_E_IgnoreTabExpansionChanges = false;
>                                                               > string     opt_F_ShowMostRecentLineMatching;
>                                                               > string     opt_I_IgnoreLinesMatching;
>                                                               > bool       opt_N_TreatAbsentFilesAsEmpty = false;
>                                                               > string     opt_S_StartWithFileMatching;
>                                                               > bool       opt_T_PrependATab = false;
>                                                               > unsigned   opt_U_LinesOfUnifiedContext = 3;
>                                                               > unsigned   opt_W_MaxPrintColumns = 130;
>                                                               > string     opt_X_ExcludeFilesMatching;
>                                                               > bool       opt_a_TreatAllFilesAsText = false;
>                                                               > bool       opt_b_IgnoreWhitespaceChanges = false;
>                                                               > bool       opt_d_TryToFindMinimalChanges = false;
>                                                               > bool       opt_i_IgnoreCaseDifferences = false;
>                                                               > bool       opt_l_PaginateWithPr = false;
>                                                               > bool       opt_p_ShowChangedCFunction = false;
>                                                               > bool       opt_q_OutputOnlyIfFilesDiffer = false;
>                                                               > bool       opt_r_RecursivelyCompareSubdirectories = false;
>                                                               > bool       opt_s_ReportWhenFilesAreSame = false;
>                                                               > bool       opt_t_ExpandTabs = false;
>                                                               > bool       opt_v_ShowVersionInfo = false;
>                                                               > bool       opt_w_IgnoreAllWhitespace = false;
>                                                               > string     opt_x_IgnoreFilesMatching;
>                                                                 
> unsigned optCopyContext = 3;                                  <
> unsigned optPageWidth = 130;                                  <
> unsigned optVerbose = 2;                                        unsigned optVerbose = 2;
>                                                                 
> struct Line : public string {                                   struct Line : public string {
>   Line (string _text) :                                           Line (string _text) :
>     string (_text)                                                  string (_text)
>   {                                                               {
>   }                                                               }
>   ~Line () {                                                      ~Line () {
>     copies[0].erase (copies[0].begin (), copies[0].end ());         copies[0].erase (copies[0].begin (), copies[0].end ());
>     copies[1].erase (copies[1].begin (), copies[1].end ());         copies[1].erase (copies[1].begin (), copies[1].end ());
>   }                                                               }
>   void Dump (FILE *out) {                                         void Dump (FILE *out) {
>     fprintf (out, "{{ ");                                           fprintf (out, "{{ ");
>     for (list<unsigned>::iterator i = copies[0].begin (); i !       for (list<unsigned>::iterator i = copies[0].begin (); i !
>       fprintf (out, "%u ", *i);                                       fprintf (out, "%u ", *i);
>     }                                                               }
>     fprintf (out, "},{ ");                                          fprintf (out, "},{ ");
>     for (list<unsigned>::iterator i = copies[1].begin (); i !       for (list<unsigned>::iterator i = copies[1].begin (); i !
>       fprintf (out, "%u ", *i);                                       fprintf (out, "%u ", *i);
>     }                                                               }
>     fprintf (out, "}}\t%s\n", c_str ());                            fprintf (out, "}}\t%s\n", c_str ());
>   }                                                               }
>   list<unsigned> copies[2];                                       list<unsigned> copies[2];
> };                                                              };
>                                                                 
> struct LinePtr {                                                struct LinePtr {
>   LinePtr (Line *_line) :                                         LinePtr (Line *_line) :
>     line (_line),                                                   line (_line),
>     l (~0u)                                                         l (~0u)
>   {                                                               {
>   }                                                               }
>   void Dump (FILE *out) {                                         void Dump (FILE *out) {
>     fprintf (out, "[%d] ", l);                                      fprintf (out, "[%d] ", l);
>     line->Dump (out);                                               line->Dump (out);
>   }                                                               }
>   Line *line;                                                     Line *line;
>   unsigned l;                                                     unsigned l;
> };                                                              };
>                                                                 
> typedef map<string, Line *> MapStringToLinePtr;                 typedef map<string, Line *> MapStringToLinePtr;
> typedef vector<LinePtr> VectorLinePtr;                          typedef vector<LinePtr> VectorLinePtr;
>                                                                 
> // Our name.                                                    // Our name.
>                                                                 
> char *ARGV0 = "dif3";                                           char *ARGV0 = "dif3";
>                                                                 
> // The 'symbol' (line) table.                                   // The 'symbol' (line) table.
>                                                                 
> MapStringToLinePtr table;                                       MapStringToLinePtr table;
>                                                                 
> // The names of the 2 files to be diff'd.                       // The names of the 2 files to be diff'd.
>                                                                 
> char const *files[2] = { 0, 0 };                                char const *files[2] = { 0, 0 };
>                                                                 
> // The lines of the 2 files to be diff'd.                       // The lines of the 2 files to be diff'd.
>                                                                 
> VectorLinePtr lines[2];                                         VectorLinePtr lines[2];
>                                                                 
> // Miscellaneous metrics.                                       // Miscellaneous metrics.
>                                                                 
> unsigned nTotalMatchedBlocks = 0;                               unsigned nTotalMatchedBlocks = 0;
> unsigned nMatchedBlocks = 0;                                    unsigned nMatchedBlocks = 0;
> unsigned nTotalMatchedLines = 0;                                unsigned nTotalMatchedLines = 0;
> unsigned nMatchedLines = 0;                                     unsigned nMatchedLines = 0;
>                                                                 
> void pass1 ();                                                | void getopts (int argc, char const *const argv[]);
> void pass2 ();                                                <
> void pass3 ();                                                <
> void pass4 ();                                                <
> void pass5 ();                                                <
> void pass6 ();                                                <
>                                                               <
> int main (int argc, char *argv[])                             <
> {                                                             <
>   // Read the old [0] file, and the new [1] file.             <
>                                                               <
>   for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) { <
>     files[n] = argv[a];                                       <
>                                                               <
>     if (FILE *f = fopen (files[n], "r")) {                    <
>       if (0 < optVerbose) {                                   <
>         fprintf (stderr, "# Reading %s...", files[n]);        <
>         fflush (stderr);                                      <
>       }                                                       <
>                                                               <
>       char buffer[1024];                                      <
>       unsigned nUniq = 0;                                     <
>                                                               <
>       while (fgets (buffer, sizeof (buffer), f)) {            <
>         string text (buffer);                                 <
>                                                               <
>         text.erase (text.end () - 1);                         <
>                                                               <
>         Line *line = table[text];                             <
>                                                               <
>         if (!line) {                                          <
>           table[text] = line = new Line (text);               <
>           nUniq += 1;                                         <
>         }                                                     <
>         line->copies[n].push_back (lines[n].size ());         <
>         lines[n].push_back (line);                            <
>       }                                                       <
>                                                               <
>       if (0 < optVerbose) {                                   <
>         fprintf (stderr, " %u lines, %u unique.\n", lines[n]. <
>         fflush (stderr);                                      <
>       }                                                       <
>     } else {                                                  <
>       fprintf (stderr, "%s: Unable to open %s!  Exiting....\n <
>       fflush (stderr);                                        <
>       perror (ARGV0);                                         <
>       exit (1);                                               <
>     }                                                         <
>   }                                                           <
>                                                               <
>   if (0 < optVerbose) {                                       <
>     fprintf (stderr, "# Total unique lines = %d\n", table.siz <
>     fflush (stderr);                                          <
>   }                                                           <
>                                                               <
>   // map<int, int> counts;                                    <
>   // for (MapStringToLinePtr::iterator i = table.begin (); i  <
>   //   Line *l = i->second;                                   <
>   //   counts[l->counts[0].size () + l->counts[1].size ()] += <
>   // }                                                        <
>   // for (map<int, int>::iterator i = counts.begin (); i != c <
>   //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s <
>   // }                                                        <
>                                                               <
>   pass1 ();                                                   <
>   pass2 ();                                                   <
>   pass3 ();                                                   <
>   pass4 ();                                                   <
>   pass5 ();                                                   <
>   pass6 ();                                                   <
>                                                               <
>   return 0;                                                   <
> }                                                             <
>                                                               <
> // Perform pass #1, in which we find all explicit matches amo <
> // unique lines.  For every unique line that appears the same <
> // of times in both files, we declare the lines to match.     <
>                                                               <
> void pass1 ()                                                 <
> {                                                             <
>   if (0 < optVerbose) {                                       <
>     fprintf (stderr, "# Pass 1 (finding matches amongst uniqu <
>     fflush (stderr);                                          <
>   }                                                           <
>                                                               <
>   nMatchedLines = 0;                                          <
>                                                               <
>   for (MapStringToLinePtr::iterator i = table.begin (); i !=  <
>     Line *l = i->second;                                      <
>                                                               <
>     // If the number of old and new lines match, then we decl <
>     // they are (all) the same line.  Note, it isn't possible <
>     // numbers of both files to be 0.                         <
>                                                               <
>     // (In the original algorithm, we only recognized a match <
>     // if there was exactly 1 copy for each file.)            <
>                                                               <
>     if (l->copies[0].size () == l->copies[1].size ()) {       <
>       nMatchedLines += 1;                                     <
>                                                               <
>       // For each matched line in the new file, mark it with  <
>       // corresponding line (number) in the old file.         <
>                                                               <
>       while (!l->copies[0].empty ()) {                        <
>         unsigned o = l->copies[0].front ();                   <
>         unsigned n = l->copies[1].front ();                   <
>                                                               <
>         // Match up the pair.                                 <
>                                                               <
>         lines[0][o].l = n;                                    <
>         lines[1][n].l = o;                                    <
>                                                               <
>         // Remove the matched line numbers from the lists.    <
>                                                               <
>         l->copies[0].pop_front ();                            <
>         l->copies[1].pop_front ();                            <
>       }                                                       <
>     }                                                         <
>   }                                                           <
>   nTotalMatchedLines += nMatchedLines;                        <
>                                                               <
>   // Let's see the intermediate results.                      <
>                                                               <
>   if (0 < optVerbose) {                                       <
>     fprintf (stderr, " found %u matched lines (%u total).\n", <
>     fflush (stderr);                                          <
>                                                               <
>     if (2 < optVerbose) {                                     <
>       for (int f = 0; f < 2; f += 1) {                        <
>         fprintf (stderr, "# file #%d\n", f + 1);              <
>         fflush (stderr);                                      <
>         for (int l = 0; l < lines[f].size (); l += 1) {       <
>           fprintf (stderr, "#   [%d] ", l);                   <
>           fflush (stderr);                                    <
>           lines[f][l].Dump (stderr);                          <
>         }                                                     <
>       }                                                       <
>     }                                                         <
>   }                                                           <
> }                                                             <
>                                                               <
> // Perform Pass #2, in which we attempt to 'widen' blocks of  <
> // lines, by appending lines which are the same in both files <
>                                                               <
> void pass2 ()                                                 <
> {                                                             <
>   if (0 < optVerbose) {                                       <
>     fprintf (stderr, "# Pass #2 (spreading matches down)...") <
>     fflush (stderr);                                          <
>   }                                                           <
>                                                               <
>   nMatchedBlocks = 0;                                         <
>   nMatchedLines = 0;                                          <
>                                                               <
>   // Starting at the top of the old file,...                  <
>                                                               <
>   for (unsigned o = 0; o < lines[0].size (); o += 1) {        <
>                                                               <
>     // ... skip any currently unmatched lines...              <
>                                                               <
>     if (lines[0][o].l == ~0) {                                <
>       continue;                                               <
>     }                                                         <
>                                                               <
>     // ... until we find an [already] matched line.  Then, sk <
>     // the set of 1 or more matched lines, until we reach any <
>     // following, still-unmatched line.                       <
>                                                               <
>     unsigned n;                                               <
>     do {                                                      <
>       n = lines[0][o].l + 1;                                  <
>       o += 1;                                                 <
>     } while (o < lines[0].size () && lines[0][o].l != ~0);    <
>                                                               <
>     // Now, o - 1 is the line number of the last matched old  <
>     // n - 1 is the line number of the last matched new line. <
>     // to add new old and new lines, if they match.           <
>                                                               <
>     // Finally, attempt to add unmatched lines to the preceed <
>     // matched set.                                           <
>                                                               <
>     for (; o < lines[0].size () && lines[0][o].l == ~0; o +=  <
>                                                               <
>       // If the [next] pair of old and new lines aren't the s <
>                                                               <
>       if (lines[0][o].line != lines[1][n].line) {             <
>         break;                                                <
>       }                                                       <
>                                                               <
>       // Match up the pair.                                   <
>                                                               <
>       lines[0][o].l = n;                                      <
>       lines[1][n].l = o;                                      <
>                                                               <
>       // Remove the matched line numbers form the lists.      <
>                                                               <
>       Line *line = lines[0][o].line;                          <
>       list<unsigned> &oldCopies = line->copies[0];            <
>       list<unsigned>::iterator oL = find (oldCopies.begin (), <
>       if (oL != oldCopies.end ()) {                           <
>         oldCopies.erase (oL);                                 <
>       }                                                       <
>       list<unsigned> &newCopies = line->copies[0];            <
>       list<unsigned>::iterator nL = find (newCopies.begin (), <
>       if (nL != newCopies.end ()) {                           <
>         newCopies.erase (nL);                                 <
>       }                                                       <
>                                                               <
>       nMatchedLines += 1;                                     <
>     }                                                         <
>     nMatchedBlocks += 1;                                      <
>   }                                                           <
>   nTotalMatchedLines += nMatchedLines;                        <
>   nTotalMatchedBlocks += nMatchedBlocks;                      <
>                                                               <
>   // Let's see the intermediate results.                      <
>                                                               <
>   if (0 < optVerbose) {                                       <
>     fprintf (stderr,                                          <
>              " found %u/%u matched lines/blocks (%u/%u totals <
>              nMatchedLines,                                   <
>              nMatchedBlocks,                                  <
>              nTotalMatchedLines,                              <
>              nTotalMatchedBlocks                              <
>             );                                                <
>     fflush (stderr);                                          <
>     if (2 < optVerbose) {                                     <
>       for (int f = 0; f < 2; f += 1) {                        <
>         fprintf (stderr, "# file #%d\n", f + 1);              <
>         fflush (stderr);                                      <
>         for (int l = 0; l < lines[f].size (); l += 1) {       <
>           fprintf (stderr, "#   [%d] ", l);                   <
>           fflush (stderr);                                    <
>           lines[f][l].Dump (stderr);                          <
>         }                                                     <
>       }                                                       <
>     }                                                         <
>   }                                                           <
> }                                                             <
>                                                               <
> // Perform Pass #3, in which we attempt to 'widen' blocks of  <
> // lines, by prepending lines which are the same in both file <
>                                                               <
> void pass3 ()                                                 <
> {                                                             <
>   if (0 < optVerbose) {                                       <
>     fprintf (stderr, "# Pass #3 (spreading matches up)...");  <
>     fflush (stderr);                                          <
>   }                                                           <
>                                                               <
>   nMatchedBlocks = 0;                                         <
>   nMatchedLines = 0;                                          <
>                                                               <
>   // Starting at the bottom of the old file,...               <
>                                                               <
>   for (int o = lines[0].size (); 0 <= o; o -= 1) {            <
>                                                               <
>     // ... skip any currently unmatched lines...              <
>                                                               <
>     if (lines[0][o].l == ~0) {                                <
>       continue;                                               <
>     }                                                         <
>                                                               <
>     // ... until we find an [already] matched line.  Then, sk <
>     // the set of 1 or more matched lines, until we reach any <
>     // following, still-unmatched line.                       <
>                                                               <
>     unsigned n;                                               <
>     do {                                                      <
>       n = lines[0][o].l - 1;                                  <
>       o -= 1;                                                 <
>     } while (0 <= o && lines[0][o].l != ~0);                  <
>                                                               <
>     // Now, o + 1 is the line number of the last matched old  <
>     // n + 1 is the line number of the last matched new line. <
>     // to add new old and new lines, if they match.           <
>                                                               <
>     // Finally, attempt to add unmatched lines to the preceed <
>     // matched set.                                           <
>                                                               <
>     for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {   <
>                                                               <
>       // If the [next] pair of old and new lines aren't the s <
>                                                               <
>       if (lines[0][o].line != lines[1][n].line) {             <
>         break;                                                <
>       }                                                       <
>                                                               <
>       // Match up the pair.                                   <
>                                                               <
>       lines[0][o].l = n;                                      <
>       lines[1][n].l = o;                                      <
>                                                               <
>       // Remove the matched line numbers form the lists.      <
>                                                               <
>       Line *line = lines[0][o].line;                          <
>       list<unsigned> &oldCopies = line->copies[0];            <
>       list<unsigned>::iterator oL = find (oldCopies.begin (), <
>       if (oL != oldCopies.end ()) {                           <
>         oldCopies.erase (oL);                                 <
>       }                                                       <
>       list<unsigned> &newCopies = line->copies[0];            <
>       list<unsigned>::iterator nL = find (newCopies.begin (), <
>       if (nL != newCopies.end ()) {                           <
>         newCopies.erase (nL);                                 <
>       }                                                       <
>                                                               <
>       nMatchedLines += 1;                                     <
>     }                                                         <
>     nMatchedBlocks += 1;                                      <
>   }                                                           <
>   nTotalMatchedLines += nMatchedLines;                        <
>                                                               <
>   // Let's see the intermediate results.                      <
>                                                               <
>   if (0 < optVerbose) {                                       <
>     fprintf (stderr,                                          <
>              " found %u/%u matched lines/blocks (%u/%u totals <
>              nMatchedLines,                                   <
>              nMatchedBlocks,                                  <
>              nTotalMatchedLines,                              <
>              nTotalMatchedBlocks                              <
>             );                                                <
>     fflush (stderr);                                          <
>                                                               <
>     if (2 < optVerbose) {                                     <
>       for (int f = 0; f < 2; f += 1) {                        <
>         fprintf (stderr, "# file #%d\n", f + 1);              <
>         fflush (stderr);                                      <
>         for (int l = 0; l < lines[f].size (); l += 1) {       <
>           fprintf (stderr, "#   [%d] ", l);                   <
>           fflush (stderr);                                    <
>           lines[f][l].Dump (stderr);                          <
>         }                                                     <
>       }                                                       <
>     }                                                         <
>   }                                                           <
> }                                                             <
>                                                               <
> // Perform pass #4, in which we find any remaining matches am <
> // unique lines.  For every unique line that has more than 1  <
> // both files, we declare the copies to match.                <
>                                                               <
> void pass4 ()                                                 <
> {                                                             <
>   if (0 < optVerbose) {                                       <
>     fprintf (stderr, "# Pass 4 (finding remaining matches amo <
>     fflush (stderr);                                          <
>   }                                                           <
>                                                               <
>   nMatchedLines = 0;                                          <
>                                                               <
>   for (MapStringToLinePtr::iterator i = table.begin (); i !=  <
>     Line *l = i->second;                                      <
>                                                               <
>     // If there's more than 1 matching old and new lines, the <
>     // declare that each pair are (all) the same line.        <
>                                                               <
>     // (In the original algorithm, we only recognized a match <
>     // if there was exactly 1 copy for each file.)            <
>                                                               <
>     while (0 < l->copies[0].size () && 0 < l->copies[1].size  <
>       nMatchedLines += 1;                                     <
>                                                               <
>       // For each matched line in the new file, mark it with  <
>       // corresponding line (number) in the old file.         <
>                                                               <
>       unsigned o = l->copies[0].front ();                     <
>       unsigned n = l->copies[1].front ();                     <
>                                                               <
>       // Match up the pair.                                   <
>                                                               <
>       lines[0][o].l = n;                                      <
>       lines[1][n].l = o;                                      <
>                                                               <
>       // Remove the matched line numbers from the lists.      <
>                                                               <
>       l->copies[0].pop_front ();                              <
>       l->copies[1].pop_front ();                              <
>     }                                                         <
>   }                                                           <
>   nTotalMatchedLines += nMatchedLines;                        <
>                                                               <
>   // Let's see the intermediate results.                      <
>                                                               <
>   if (0 < optVerbose) {                                       <
>     fprintf (stderr, " found %u matched lines (%u total).\n", <
>     fflush (stderr);                                          <
>                                                               <
>     if (2 < optVerbose) {                                     <
>       for (int f = 0; f < 2; f += 1) {                        <
>         fprintf (stderr, "# file #%d\n", f + 1);              <
>         fflush (stderr);                                      <
>         for (int l = 0; l < lines[f].size (); l += 1) {       <
>           fprintf (stderr, "#   [%d] ", l);                   <
>           fflush (stderr);                                    <
>           lines[f][l].Dump (stderr);                          <
>         }                                                     <
>       }                                                       <
>     }                                                         <
>   }                                                           <
> }                                                             <
>                                                               <
> // Perform Pass #5, in which we look for blocks which match,  <
> // the result of a move (their not in their original position <
> // these, we'll unmatch the blocks, turning them into a delet <
> // insert.                                                    <
>                                                               <
> void pass5 ()                                                 <
> {                                                             <
>   if (0 < optVerbose) {                                       <
>     fprintf (stderr, "# Pass #5 (unmatching block moves)...\n <
>     fflush (stderr);                                          <
>   }                                                           <
>                                                               <
>   nMatchedBlocks = 0;                                         <
>   nMatchedLines = 0;                                          <
>                                                               <
>   // Starting at the top of both files,...                    <
>                                                               <
>   unsigned o = 0;                                             <
>   unsigned n = 0;                                             <
>                                                               <
>   while (o < lines[0].size () || n < lines[1].size ()) {      <
>                                                               <
>     // Skip any unmatched lines at this point in the old file <
>     // are deletes.                                           <
>                                                               <
>     //    Old     New                                         <
>     //   +---+                                                <
>     // 0 | a |                                                <
>     //   +---+   +---+                                        <
>     //         0 | b |                                        <
>     //   +---+   +---+                                        <
>     // 1 | c | 1 | c |                                        <
>     //   +---+   +---+                                        <
>     //         2 | z |                                        <
>     //   +---+   +---+                                        <
>     // 2 | d | 3 | d |                                        <
>     //   +---+   +---+                                        <
>                                                               <
>     while (o < lines[0].size () && lines[0][o].l == ~0) {     <
>       o += 1;                                                 <
>     }                                                         <
>                                                               <
>     // Skip any unmatched lines at this point in the new file <
>     // are inserts.                                           <
>                                                               <
>     while (n < lines[1].size () && lines[1][n].l == ~0) {     <
>       n += 1;                                                 <
>     }                                                         <
>                                                               <
>     // When we get here, we know that we're dealing with matc <
>     // lines (or the end of one or both files).  We're done w <
>     // pass, if we've reached the end of either file.         <
>                                                               <
>     if (lines[0].size () <= o || lines[1].size () <= n) {     <
>       break;                                                  <
>     }                                                         <
>                                                               <
>     // We now know that we've got a pair of matching lines, t <
>     // of a matching block.  If the new file's line number is <
>     // expect, then the matched pair is unmoved, and we can s <
>     // the pair.  (If this is really the start of a block of  <
>     // 1 lines, we'll handle it one pair at a time.)          <
>                                                               <
>     if (lines[0][o].l == n) {                                 <
>       o += 1;                                                 <
>       n += 1;                                                 <
>       continue;                                               <
>     }                                                         <
>                                                               <
>     // If, on the other hand, we don't expect this [new] line <
>     // then this matching block has been moved.  We need to t <
>     // matched pair into an *unmatched* pair, one of deletes, <
>     // of inserts.  First, though, we need to know how big th <
>     // is, and how far it was moved....                       <
>                                                               <
>     // Remember where we were when we started.                <
>                                                               <
>     unsigned oOld = o;                                        <
>     unsigned nOld = n;                                        <
>                                                               <
>     // Remember where the block came from.                    <
>                                                               <
>     unsigned nNew = lines[0][o].l;                            <
>                                                               <
>     // Find the end of this matched pair.                     <
>                                                               <
>     for (n = nNew; o < lines[0].size () && n < lines[1].size  <
>       if (lines[0][o].l != n) {                               <
>         break;                                                <
>       }                                                       <
>     }                                                         <
>                                                               <
>     // When we get here:                                      <
>     // * oOld..o is the old file's block,                     <
>     // * nNew..n is the new file's *moved* block, and         <
>     // * nOld is where we originally expected the new block f <
>                                                               <
>     // We can now calculate the length of the block...        <
>                                                               <
>     unsigned bSize = o - oOld;  // (or n - nNew)              <
>                                                               <
>     // ... and we can calculate how far the block moved:      <
>                                                               <
>     unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew; <
>                                                               <
>     // The larger of the two will become our delete, and the  <
>     // will become our insert.                                <
>                                                               <
>     //    Old     New                                         <
>     //   +---+   +---+                                        <
>     // 0 | a | 0 | b |                                        <
>     //   +---+ 1 | b |                                        <
>     // 1 | b |   +---+                                        <
>     // 2 | b | 2 | a |                                        <
>     //   +---+   +---+                                        <
>     // 3 | c | 3 | c |                                        <
>     //   +---+   +---+                                        <
>                                                               <
>     // (1) Delete a@0, insert a@2, or                         <
>     // (2) insert bb@0, delete bb@1?                          <
>                                                               <
>     // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and <
>     // (of a) is 2-0 or 2, the size of b@0.  We choose to del <
>     // and reinsert a@2.                                      <
>                                                               <
>     // if (bSize <= bMove) {                                  <
>       for (unsigned a = oOld; a < o; a += 1) {                <
>         lines[0][a].l = ~0;                                   <
>       }                                                       <
>       for (unsigned d = nNew; d < n; d += 1) {                <
>         lines[1][d].l = ~0;                                   <
>       }                                                       <
>     // } else {                                               <
>       // for (unsigned a = oOld; a < o; a += 1) {             <
>       //   lines[0][a].l = ~0;                                <
>       // }                                                    <
>       // for (unsigned d = nNew; d < n; d += 1) {             <
>       //   lines[1][d].l = ~0;                                <
>       // }                                                    <
>     // }                                                      <
>                                                               <
>     // Continue from where we left off.                       <
>                                                               <
>     n = nOld;                                                 <
>   }                                                           <
>   nTotalMatchedLines -= nMatchedLines;                        <
>   nTotalMatchedBlocks -= nMatchedBlocks;                      <
>                                                               <
>   // Let's see the intermediate results.                      <
>                                                               <
>   if (0 < optVerbose) {                                       <
>     fprintf (stderr,                                          <
>              " found %u/%u matched lines/blocks (%u/%u totals <
>              nMatchedLines,                                   <
>              nMatchedBlocks,                                  <
>              nTotalMatchedLines,                              <
>              nTotalMatchedBlocks                              <
>             );                                                <
>     fflush (stderr);                                          <
>                                                               <
>     if (2 < optVerbose) {                                     <
>       for (int f = 0; f < 2; f += 1) {                        <
>         fprintf (stderr, "# file #%d\n", f + 1);              <
>         fflush (stderr);                                      <
>         for (int l = 0; l < lines[f].size (); l += 1) {       <
>           fprintf (stderr, "#   [%d] ", l);                   <
>           fflush (stderr);                                    <
>           lines[f][l].Dump (stderr);                          <
>         }                                                     <
>       }                                                       <
>     }                                                         <
>   }                                                           <
> }                                                             <
>                                                               <
> // Perform Pass #6, in which we create the desired output.    <
>                                                               <
> void pass6c ();                                               <
> void pass6e ();                                               <
> void pass6i ();                                               <
> void pass6n ();                                               <
> void pass6r ();                                               <
> void pass6s ();                                               <
> void pass6u ();                                               <
> void pass6y ();                                               <
>                                                               <
> void pass6 ()                                                 <
> {                                                             <
>                                                                 
>   switch (diffFormat) {                                       | void pass1 ();
>   case Context:                                               | void pass2 ();
>     pass6c ();                                                | void pass3 ();
>     break;                                                    | void pass4 ();
>                                                               | void pass5 ();
>   case EdScript:                                              | void pass6 ();
>     pass6e ();                                                | 
>     break;                                                    | int main (int argc, char const *const argv[])
>                                                               | {
>   case IfThenElse:                                            |   getopts (argc, argv);
>     pass6i ();                                                <
>     break;                                                    <
>                                                               <
>   case Normal:                                                <
>     pass6n ();                                                <
>     break;                                                    <
>                                                               <
>   case RCS:                                                   <
>     pass6r ();                                                <
>     break;                                                    <
>                                                               <
>   case SideBySide:                                            <
>     pass6y ();                                                <
>     break;                                                    <
>                                                               <
>   case Unified:                                               <
>     pass6u ();                                                <
>     break;                                                    <
>                                                               <
>   case Default:                                               <
>   default:                                                    <
>     pass6c ();                                                <
>     break;                                                    <
>   }                                                           <
> }                                                             <
>                                                               <
> template<typename T> T min (T l, T r) {                       <
>   if (l < r) {                                                <
>     return l;                                                 <
>   }                                                           <
>   return r;                                                   <
> }                                                             <
>                                                               <
> template<typename T> T max (T l, T r) {                       <
>   if (l < r) {                                                <
>     return r;                                                 <
>   }                                                           <
>   return l;                                                   <
> }                                                             <
>                                                               <
> void pass6c () {                                              <
>   if (0 < optVerbose) {                                       <
>     fprintf (stderr, "# Pass #6c (walking the differences)... <
>     fflush (stderr);                                          <
>   }                                                           <
>                                                               <
>   nMatchedLines = 0;                                          <
>                                                               <
>   // Write the header.                                        <
>                                                               <
>   fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:0 <
>   fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:0 <
>                                                               <
>   // Starting at the top of both files,...                    <
>                                                               <
>   unsigned o = 0;                                             <
>   unsigned n = 0;                                             <
>                                                               <
>   while (o < lines[0].size () || n < lines[1].size ()) {      <
>                                                               <
>     // Find the bounds of the current contextual 'window'.    <
>                                                               <
>     // If we aren't looking at a delete or an insert, we're n <
>     // start of a context window.                             <
>                                                               <
>     if (lines[0][o].l != ~0 && lines[1][n].l != ~0) {         <
>       o += 1;                                                 <
>       n += 1;                                                 <
>       continue;                                               <
>     }                                                         <
>                                                               <
>     // We're now looking at at least 1 delete or insert, so a <
>     // begins here (or, rather, optCopyContext lines earlier) <
>                                                               <
>     int boOldWindow = max (0, int (o) - int (optCopyContext)) <
>     int boNewWindow = max (0, int (n) - int (optCopyContext)) <
>                                                               <
>     if (1 < optVerbose) {                                     <
>       fprintf (stderr, "boOldWindow = %d, boNewWindow = %d\n" <
>       fflush (stderr);                                        <
>     }                                                         <
>                                                               <
>     // Look for the end of the current window.                <
>                                                               <
>     int eoOldWindow;                                          <
>     int eoNewWindow;                                          <
>                                                               <
>     bool widenWindow = true;                                  <
>     while (widenWindow && o < lines[0].size () || n < lines[1 <
>                                                               <
>       // Skip over the delete(s) and/or insert(s) defining th <
>       // context.                                             <
>                                                               <
>       while (o < lines[0].size () && lines[0][o].l == ~0) {   <
>         o += 1;                                               <
>       }                                                       <
>       while (n < lines[1].size () && lines[1][n].l == ~0) {   <
>         n += 1;                                               <
>       }                                                       <
>                                                               <
>       // This context will end optCopyContext matched lines p <
>       // last set of deletes or inserts we find.              <
>                                                               <
>       widenWindow = false;                                    <
>       for (unsigned l = 0; !widenWindow && l < optCopyContext <
>         if (o < lines[0].size ()) {                           <
>           widenWindow |= lines[0][o].l == ~0;                 <
>           o += 1;                                             <
>         }                                                     <
>         if (n < lines[1].size ()) {                           <
>           widenWindow |= lines[1][n].l == ~0;                 <
>           n += 1;                                             <
>         }                                                     <
>       }                                                       <
>                                                               <
>       eoOldWindow = o;                                        <
>       eoNewWindow = n;                                        <
>                                                               <
>       // However, since another window could follow, we look  <
>       // optCopyContext ahead for another delete or insert.   <
>                                                               <
>       if (!widenWindow) {                                     <
>         for (unsigned l = 0; l < (2 * optCopyContext + 1); l  <
>           if (o < lines[0].size ()) {                         <
>             widenWindow |= lines[0][o].l == ~0;               <
>             o += 1;                                           <
>           }                                                   <
>           if (n < lines[1].size ()) {                         <
>             widenWindow |= lines[1][n].l == ~0;               <
>             n += 1;                                           <
>           }                                                   <
>         }                                                     <
>       }                                                       <
>     }                                                         <
>                                                               <
>     // We've found the end of the window.                     <
>                                                               <
>     if (1 < optVerbose) {                                     <
>       fprintf (stderr, "eoOldWindow = %d, eoNewWindow = %d\n" <
>       fflush (stderr);                                        <
>     }                                                         <
>                                                               <
>     // Now, reset ourselves to the start of the window, and w <
>     // produce the output.  We'll walk it twice, first for th <
>     // file part, then for the new file part.                 <
>                                                               <
>     fprintf (stdout, "***************\n");                    <
>     fprintf (stdout, "*** %d,%d ****\n", boOldWindow + 1, eoO <
>                                                               <
>     o = boOldWindow;                                          <
>     n = boNewWindow;                                          <
>                                                               <
>     while (o < eoOldWindow || n < eoNewWindow) {              <
>                                                               <
>       // Find any unmatched lines at this point in the old fi <
>       // are deletes.                                         <
>                                                               <
>       unsigned boDeletes = o;                                 <
>       while (o < eoOldWindow && lines[0][o].l == ~0) {        <
>         o += 1;                                               <
>       }                                                       <
>                                                               <
>       // Find any unmatched lines at this point in the new fi <
>       // are inserts.                                         <
>                                                               <
>       unsigned boInserts = n;                                 <
>       while (n < eoNewWindow && lines[1][n].l == ~0) {        <
>         n += 1;                                               <
>       }                                                       <
>                                                               <
>       // We've got deleted line(s) from boDeletes .. o.       <
>       // We've got deleted line(s) from boInserts .. n.       <
>                                                               <
>       unsigned nDeletes = o - boDeletes;                      <
>       unsigned nInserts = n - boInserts;                      <
>                                                               <
>       // We've got...                                         <
>                                                               <
>       if (nDeletes && nInserts) {                             <
>                                                               <
>         // ... deletes and inserts.                           <
>                                                               <
>         for (unsigned l = boDeletes; l < o; l += 1) {         <
>           fprintf (stdout, "! %s\n", lines[0][l].line->c_str  <
>         }                                                     <
>       } else if (nDeletes) {                                  <
>                                                               <
>         //  ... just deletes.                                 <
>                                                               <
>         for (unsigned l = boDeletes; l < o; l += 1) {         <
>           fprintf (stdout, "- %s\n", lines[0][l].line->c_str  <
>         }                                                     <
>       }                                                       <
>                                                               <
>       // When we get here, we're dealing with matching lines. <
>                                                               <
>       fprintf (stdout, "  %s\n", lines[0][o].line->c_str ()); <
>       o += 1;                                                 <
>       n += 1;                                                 <
>     }                                                         <
>                                                               <
>     fprintf (stdout, "--- %d,%d ----\n", boNewWindow + 1, eoN <
>                                                               <
>     o = boOldWindow;                                          <
>     n = boNewWindow;                                          <
>                                                               <
>     while (o < eoOldWindow && n < eoNewWindow) {              <
>                                                               <
>       // Find any unmatched lines at this point in the old fi <
>       // are deletes.                                         <
>                                                               <
>       unsigned boDeletes = o;                                 <
>       while (o < eoOldWindow && lines[0][o].l == ~0) {        <
>         o += 1;                                               <
>       }                                                       <
>                                                               <
>       // Find any unmatched lines at this point in the new fi <
>       // are inserts.                                         <
>                                                               <
>       unsigned boInserts = n;                                 <
>       while (n < eoNewWindow && lines[1][n].l == ~0) {        <
>         n += 1;                                               <
>       }                                                       <
>                                                               <
>       // We've got deleted line(s) from boDeletes .. o.       <
>       // We've got deleted line(s) from boInserts .. n.       <
>                                                               <
>       unsigned nDeletes = o - boDeletes;                      <
>       unsigned nInserts = n - boInserts;                      <
>                                                               <
>       // We've got...                                         <
>                                                               <
>       if (nDeletes && nInserts) {                             <
>                                                               <
>         // ... deletes and inserts.                           <
>                                                               <
>         for (unsigned l = boInserts; l < n; l += 1) {         <
>           fprintf (stdout, "! %s\n", lines[1][l].line->c_str  <
>         }                                                     <
>       } else if (nInserts) {                                  <
>                                                               <
>         //  ... just inserts.                                 <
>                                                               <
>         for (unsigned l = boInserts; l < n; l += 1) {         <
>           fprintf (stdout, "+ %s\n", lines[1][l].line->c_str  <
>         }                                                     <
>       }                                                       <
>                                                               <
>       // When we get here, we're dealing with matching lines. <
>                                                               <
>       fprintf (stdout, "  %s\n", lines[1][n].line->c_str ()); <
>       o += 1;                                                 <
>       n += 1;                                                 <
>     }                                                         <
>                                                               <
>     // Reset to the end of the current window.                <
>                                                               <
>     o = eoOldWindow;                                          <
>     n = eoNewWindow;                                          <
>   }                                                           <
> }                                                             <
>                                                               <
> void pass6e () {                                              <
>   fprintf (stderr, "pass6e() is unimplemented!\n");           <
>   fflush (stderr);                                            <
> }                                                             <
>                                                               <
> void pass6i () {                                              <
>   fprintf (stderr, "pass6i() is unimplemented!\n");           <
>   fflush (stderr);                                            <
> }                                                             <
>                                                               <
> void pass6n ()                                                <
> {                                                             <
>   if (0 < optVerbose) {                                       <
>     fprintf (stderr, "# Pass #6n (walking the differences)... <
>     fflush (stderr);                                          <
>   }                                                           <
>                                                               <
>   nMatchedLines = 0;                                          <
>                                                               <
>   // Write the header.  (None for normal.)                    <
>                                                               <
>   // Starting at the top of both files,...                    <
>                                                               <
>   unsigned o = 0;                                             <
>   unsigned n = 0;                                             <
>                                                               <
>   while (o < lines[0].size () || n < lines[1].size ()) {      <
>                                                               <
>     // Find any unmatched lines at this point in the old file <
>     // are deletes.                                           <
>                                                               <
>     unsigned boDeletes;                                       <
>     for (boDeletes = o;                                       <
>          o < lines[0].size () && lines[0][o].l == ~0;         <
>          o += 1                                               <
>         )                                                     <
>     {}                                                        <
>                                                               <
>     // Find any unmatched lines at this point in the new file <
>     // are inserts.                                           <
>                                                               <
>     unsigned boInserts;                                       <
>     for (boInserts = n;                                       <
>          n < lines[1].size () && lines[1][n].l == ~0;         <
>          n += 1                                               <
>         )                                                     <
>     {}                                                        <
>                                                               <
>     // We've got deleted line(s) from boDeletes .. o.         <
>     // We've got deleted line(s) from boInserts .. n.         <
>                                                               <
>     unsigned nDeletes = o - boDeletes;                        <
>     unsigned nInserts = n - boInserts;                        <
>                                                               <
>     // We've got...                                           <
>                                                               <
>     if (nDeletes && nInserts) {                               <
>                                                               <
>       // ... deletes and inserts.                             <
>                                                               <
>       if (1 < nDeletes && 1 < nInserts) {                     <
>         fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, b <
>       } else if (1 < nDeletes) {                              <
>         fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boIn <
>       } else if (1 < nInserts) {                              <
>         fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInser <
>       }                                                       <
>       for (unsigned l = boDeletes; l < o; l += 1) {           <
>         fprintf (stdout, "< %s\n", lines[0][l].line->c_str () <
>       }                                                       <
>       fprintf (stdout, "---\n");                              <
>       for (unsigned l = boInserts; l < n; l += 1) {           <
>         fprintf (stdout, "> %s\n", lines[1][l].line->c_str () <
>       }                                                       <
>     } else if (nDeletes) {                                    <
>                                                               <
>       //  ... just deletes.                                   <
>                                                               <
>       if (1 < nDeletes) {                                     <
>         fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);  <
>       } else {                                                <
>         fprintf (stdout, "%dd%d\n", boDeletes + 1, n);        <
>       }                                                       <
>       for (unsigned l = boDeletes; l < o; l += 1) {           <
>         fprintf (stdout, "< %s\n", lines[0][l].line->c_str () <
>       }                                                       <
>     } else if (nInserts) {                                    <
>                                                               <
>       //  ... just inserts.                                   <
>                                                               <
>       if (1 < nInserts) {                                     <
>         fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);  <
>       } else {                                                <
>         fprintf (stdout, "%da%d\n", o, boInserts + 1);        <
>       }                                                       <
>       for (unsigned l = boInserts; l < n; l += 1) {           <
>         fprintf (stdout, "> %s\n", lines[1][l].line->c_str () <
>       }                                                       <
>     }                                                         <
>                                                               <
>     // When we get here, we're dealing with matching lines.   <
>                                                               <
>     o += 1;                                                   <
>     n += 1;                                                   <
>   }                                                           <
> }                                                             <
>                                                               <
> void pass6r () {                                              <
>   fprintf (stderr, "pass6r() is unimplemented!\n");           <
>   fflush (stderr);                                            <
> }                                                             <
>                                                               <
> void pass6s () {                                              <
>   fprintf (stderr, "pass6s() is unimplemented!\n");           <
>   fflush (stderr);                                            <
> }                                                             <
>                                                               <
> void pass6u ()                                                <
> {                                                             <
>   if (0 < optVerbose) {                                       <
>     fprintf (stderr, "# Pass #6u (walking the differences)... <
>     fflush (stderr);                                          <
>   }                                                           <
>                                                               <
>   nMatchedLines = 0;                                          <
>                                                               <
>   // Write the header.                                        <
>                                                               <
>   fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:0 <
>   fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:0 <
>   fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), l <
>                                                               <
>   // Starting at the top of both files,...                    <
>                                                               <
>   unsigned o = 0;                                             <
>   unsigned n = 0;                                             <
>                                                               <
>   while (o < lines[0].size () || n < lines[1].size ()) {      <
>                                                               <
>     // Find any unmatched lines at this point in the old file <
>     // are deletes.                                           <
>                                                               <
>     unsigned boDeletes;                                       <
>     for (boDeletes = o;                                       <
>          o < lines[0].size () && lines[0][o].l == ~0;         <
>          o += 1                                               <
>         )                                                     <
>     {}                                                        <
>                                                               <
>     // Find any unmatched lines at this point in the new file <
>     // are inserts.                                           <
>                                                               <
>     unsigned boInserts;                                       <
>     for (boInserts = n;                                       <
>          n < lines[1].size () && lines[1][n].l == ~0;         <
>          n += 1                                               <
>         )                                                     <
>     {}                                                        <
>                                                               <
>     // We've got deleted line(s) from boDeletes .. o.         <
>     // We've got deleted line(s) from boInserts .. n.         <
>                                                               <
>     unsigned nDeletes = o - boDeletes;                        <
>     unsigned nInserts = n - boInserts;                        <
>                                                               <
>     // We've got...                                           <
>                                                               <
>     if (nDeletes && nInserts) {                               <
>                                                               <
>       // ... deletes and inserts.                             <
>                                                               <
>       for (unsigned l = boDeletes; l < o; l += 1) {           <
>         fprintf (stdout, "-%s\n", lines[0][l].line->c_str ()) <
>       }                                                       <
>       for (unsigned l = boInserts; l < n; l += 1) {           <
>         fprintf (stdout, "+%s\n", lines[1][l].line->c_str ()) <
>       }                                                       <
>     } else if (nDeletes) {                                    <
>                                                               <
>       //  ... just deletes.                                   <
>                                                               <
>       for (unsigned l = boDeletes; l < o; l += 1) {           <
>         fprintf (stdout, "-%s\n", lines[0][l].line->c_str ()) <
>       }                                                       <
>     } else if (nInserts) {                                    <
>                                                               <
>       //  ... just inserts.                                   <
>                                                               <
>       for (unsigned l = boInserts; l < n; l += 1) {           <
>         fprintf (stdout, "+%s\n", lines[1][l].line->c_str ()) <
>       }                                                       <
>     }                                                         <
>                                                               <
>     // When we get here, we're dealing with matching lines.   <
>                                                               <
>     fprintf (stdout, " %s\n", lines[0][o].line->c_str ());    <
>     o += 1;                                                   <
>     n += 1;                                                   <
>   }                                                           <
> }                                                             <
>                                                               <
> void pass6y ()                                                <
> {                                                             <
>   if (0 < optVerbose) {                                       <
>     fprintf (stderr, "# Pass #6y (walking the differences)... <
>     fflush (stderr);                                          <
>   }                                                           <
>                                                               <
>   // Write the header.                                        <
>                                                               <
>   // None for side-by-side.                                   <
>                                                               <
>   // Starting at the top of both files,...                    <
>                                                                 
>   int columnWidth = (optPageWidth - 7) / 2;                   |   if (opt_v_ShowVersionInfo) {
>                                                               >     fprintf
>                                                               >       (stderr,
>                                                               >        "diff () 0.0.1"
>                                                               >        "Copyright (C) 2008 Sidney R Maxwell III"
>                                                               >        ""
>                                                               >        "This program comes with NO WARRANTY, to the extent pe
>                                                               >        "You may redistribute copies of this program"
>                                                               >        "under the terms of the GNU General Public License."
>                                                               >        "For more information about these matters, see the fil
>                                                               >        ""
>                                                               >        "Written by Sid Maxwell."
>                                                               >       );
>                                                               >     exit (0);
>                                                               >   }
>                                                               > 
>                                                               >   // Read the old [0] file, and the new [1] file.
>                                                               > 
>                                                               >   for (int a = optind, n = 0; a < argc && n < 2; a += 1, n +=
>                                                               >     files[n] = argv[a];
>                                                               > 
>                                                               >     if (FILE *f = fopen (files[n], "r")) {
>                                                               >       if (0 < optVerbose) {
>                                                               >         fprintf (stderr, "# Reading %s...", files[n]);
>                                                               >         fflush (stderr);
>                                                               >       }
>                                                               > 
>                                                               >       char buffer[1024];
>                                                               >       unsigned nUniq = 0;
>                                                               > 
>                                                               >       while (fgets (buffer, sizeof (buffer), f)) {
>                                                               >         string text (buffer);
>                                                               > 
>                                                               >         text.erase (text.end () - 1);
>                                                               > 
>                                                               >         Line *line = table[text];
>                                                               > 
>                                                               >         if (!line) {
>                                                               >           table[text] = line = new Line (text);
>                                                               >           nUniq += 1;
>                                                               >         }
>                                                               >         line->copies[n].push_back (lines[n].size ());
>                                                               >         lines[n].push_back (line);
>                                                               >       }
>                                                               > 
>                                                               >       if (0 < optVerbose) {
>                                                               >         fprintf (stderr, " %u lines, %u unique.\n", lines[n].
>                                                               >         fflush (stderr);
>                                                               >       }
>                                                               >     } else {
>                                                               >       fprintf (stderr, "%s: Unable to open %s!  Exiting....\n
>                                                               >       fflush (stderr);
>                                                               >       perror (ARGV0);
>                                                               >       exit (1);
>                                                               >     }
>                                                               >   }
>                                                               > 
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr, "# Total unique lines = %d\n", table.siz
>                                                               >     fflush (stderr);
>                                                               >   }
>                                                               > 
>                                                               >   // map<int, int> counts;
>                                                               >   // for (MapStringToLinePtr::iterator i = table.begin (); i 
>                                                               >   //   Line *l = i->second;
>                                                               >   //   counts[l->counts[0].size () + l->counts[1].size ()] +=
>                                                               >   // }
>                                                               >   // for (map<int, int>::iterator i = counts.begin (); i != c
>                                                               >   //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s
>                                                               >   // }
>                                                               > 
>                                                               >   pass1 ();
>                                                               >   pass2 ();
>                                                               >   pass3 ();
>                                                               >   pass4 ();
>                                                               >   pass5 ();
>                                                               >   pass6 ();
>                                                               > 
>                                                               >   return 0;
>                                                               > }
>                                                               > 
>                                                               > // Usage: diff [OPTION]... FILES
>                                                               > // Compare files line by line.
>                                                               > // 
>                                                               > //   --GTYPE-group-format=GFMT  Similar, but format GTYPE inp
>                                                               > //   --LTYPE-line-format=LFMT  Similar, but format LTYPE inpu
>                                                               > //     LTYPE is `old', `new', or `unchanged'.  GTYPE is LTYPE
>                                                               > //     GFMT may contain:
>                                                               > //       %<  lines from FILE1
>                                                               > //       %>  lines from FILE2
>                                                               > //       %=  lines common to FILE1 and FILE2
>                                                               > //       %[-][WIDTH][.[PREC]]{doxX}LETTER  printf-style spec 
>                                                               > //         LETTERs are as follows for new group, lower case f
>                                                               > //           F  first line number
>                                                               > //           L  last line number
>                                                               > //           N  number of lines = L-F+1
>                                                               > //           E  F-1
>                                                               > //           M  L+1
>                                                               > //     LFMT may contain:
>                                                               > //       %L  contents of line
>                                                               > //       %l  contents of line, excluding any trailing newline
>                                                               > //       %[-][WIDTH][.[PREC]]{doxX}n  printf-style spec for i
>                                                               > //     Either GFMT or LFMT may contain:
>                                                               > //       %%  %
>                                                               > //       %c'C'  the single character C
>                                                               > //       %c'\OOO'  the character with octal code OOO
>                                                               > //
>                                                               > //   --brief  -q  Output only whether files differ.
>                                                               > //   --context[=NUM]  -c  -C NUM  Output NUM (default 3) line
>                                                               > //   --ed  -e  Output an ed script.
>                                                               > //   --exclude-from=FILE  -X FILE  Exclude files that match a
>                                                               > //   --exclude=PAT  -x PAT  Exclude files that match PAT.
>                                                               > //   --expand-tabs  -t  Expand tabs to spaces in output.
>                                                               > //   --from-file=FILE1  Compare FILE1 to all operands.  FILE1
>                                                               > //   --help  Output this help.
>                                                               > //   --horizon-lines=NUM  Keep NUM lines of the common prefix
>                                                               > //   --ifdef=NAME  -D NAME  Output merged file to show `#ifde
>                                                               > //   --ignore-all-space  -w  Ignore all white space.
>                                                               > //   --ignore-blank-lines  -B  Ignore changes whose lines are
>                                                               > //   --ignore-case  -i  Ignore case differences in file conte
>                                                               > //   --ignore-file-name-case  Ignore case when comparing file
>                                                               > //   --ignore-matching-lines=RE  -I RE  Ignore changes whose 
>                                                               > //   --ignore-space-change  -b  Ignore changes in the amount 
>                                                               > //   --ignore-tab-expansion  -E  Ignore changes due to tab ex
>                                                               > //   --initial-tab  -T  Make tabs line up by prepending a tab
>                                                               > //   --label LABEL  Use LABEL instead of file name.
>                                                               > //   --left-column  Output only the left column of common lin
>                                                               > //   --line-format=LFMT  Similar, but format all input lines 
>                                                               > //   --minimal  -d  Try hard to find a smaller set of changes
>                                                               > //   --new-file  -N  Treat absent files as empty.
>                                                               > //   --no-ignore-file-name-case  Consider case when comparing
>                                                               > //   --normal  Output a normal diff.
>                                                               > //   --paginate  -l  Pass the output through `pr' to paginate
>                                                               > //   --rcs  -n  Output an RCS format diff.
>                                                               > //   --recursive  -r  Recursively compare any subdirectories 
>                                                               > //   --report-identical-files  -s  Report when two files are 
>                                                               > //   --show-c-function  -p  Show which C function each change
>                                                               > //   --show-function-line=RE  -F RE  Show the most recent lin
>                                                               > //   --side-by-side  -y  Output in two columns.
>                                                               > //   --speed-large-files  Assume large files and many scatter
>                                                               > //   --starting-file=FILE  -S FILE  Start with FILE when comp
>                                                               > //   --strip-trailing-cr  Strip trailing carriage return on i
>                                                               > //   --suppress-common-lines  Do not output common lines.
>                                                               > //   --text  -a  Treat all files as text.
>                                                               > //   --to-file=FILE2  Compare all operands to FILE2.  FILE2 c
>                                                               > //   --unidirectional-new-file  Treat absent first files as e
>                                                               > //   --unified[=NUM]  -u  -U NUM  Output NUM (default 3) line
>                                                               > //   --version  -v  Output version info.
>                                                               > //   --width=NUM  -W NUM  Output at most NUM (default 130) pr
>                                                               > // 
>                                                               > // FILES are `FILE1 FILE2' or `DIR1 DIR2' or `DIR FILE...' or
>                                                               > // If --from-file or --to-file is given, there are no restric
>                                                               > // If a FILE is `-', read standard input.
>                                                               > // 
>                                                               > // Report bugs to <bug-gnu-utils@gnu.org>.
>                                                               > 
>                                                               > void getopts (int argc, char const *const argv[])
>                                                               > {
>                                                               >   while (1) {
>                                                               >     int option_index = 0;
>                                                               >     static option long_options[] = {
>                                                               >       { "brief",                        0, 0, 'q' }, // Outpu
>                                                               >       { "context",                      2, 0, 'c' }, // Outpu
>                                                               >       { "ed",                           0, 0, 'e' }, // Outpu
>                                                               >       { "exclude-from",                 1, 0, ' ' }, // Exclu
>                                                               >       { "exclude",                      1, 0, 'x' }, // Exclu
>                                                               >       { "expand-tabs",                  0, 0, 't' }, // Expan
>                                                               >       { "from-file",                    1, 0, ' ' }, // Compa
>                                                               >       { "help",                         0, 0, 'h' }, // Outpu
>                                                               >       { "horizon-lines",                1, 0, ' ' }, // Keep 
>                                                               >       { "ifdef",                        1, 0, 'D' }, // Outpu
>                                                               >       { "ignore-all-space",             0, 0, 'w' }, // Ignor
>                                                               >       { "ignore-blank-lines",           0, 0, 'B' }, // Ignor
>                                                               >       { "ignore-case",                  0, 0, 'i' }, // Ignor
>                                                               >       { "ignore-file-name-case",        0, 0, ' ' }, // Ignor
>                                                               >       { "ignore-matching-lines",        1, 0, 'I' }, // Ignor
>                                                               >       { "ignore-space-change",          0, 0, 'b' }, // Ignor
>                                                               >       { "ignore-tab-expansion",         0, 0, 'E' }, // Ignor
>                                                               >       { "initial-tab",                  0, 0, 'T' }, // Make 
>                                                               >       { "label",                        1, 0, ' ' }, // Use L
>                                                               >       { "left-column",                  0, 0, ' ' }, // Outpu
>                                                               >       { "line-format",                  1, 0, ' ' }, // Simil
>                                                               >       { "minimal",                      0, 0, 'd' }, // Try h
>                                                               >       { "new-file",                     0, 0, 'N' }, // Treat
>                                                               >       { "no-ignore-file-name-case",     0, 0, ' ' }, // Consi
>                                                               >       { "normal",                       0, 0, ' ' }, // Outpu
>                                                               >       { "paginate",                     0, 0, 'l' }, // Pass 
>                                                               >       { "rcs",                          0, 0, 'n' }, // Outpu
>                                                               >       { "recursive",                    0, 0, 'r' }, // Recur
>                                                               >       { "report-identical-files",       0, 0, 's' }, // Repor
>                                                               >       { "show-c-function",              0, 0, 'p' }, // Show 
>                                                               >       { "show-function-line",           1, 0, 'F' }, // Show 
>                                                               >       { "side-by-side",                 0, 0, 'y' }, // Outpu
>                                                               >       { "speed-large-files",            0, 0, ' ' }, // Assum
>                                                               >       { "starting-file",                1, 0, 'S' }, // Start
>                                                               >       { "strip-trailing-cr",            0, 0, ' ' }, // Strip
>                                                               >       { "suppress-common-lines",        0, 0, ' ' }, // Do no
>                                                               >       { "text",                         0, 0, 'a' }, // Treat
>                                                               >       { "to-file",                      0, 0, ' ' }, // Compa
>                                                               >       { "unidirectional-new-file",      0, 0, ' ' }, // Treat
>                                                               >       { "unified",                      2, 0, 'u' }, // Outpu
>                                                               >       { "version",                      0, 0, 'v' }, // Outpu
>                                                               >       { "width",                        1, 0, 'W' }, // Outpu
>                                                               >       { 0,				0, 0,   0 }
>                                                               >     };
>                                                               > 
>                                                               >     char const *short_options =
>                                                               >       "B"                       // Ignore changes whose lines
>                                                               >       "C:"                      // Output NUM (default 3) lin
>                                                               >       "D:"                      // Output merged file to show
>                                                               >       "E"                       // Ignore changes due to tab 
>                                                               >       "F:"                      // Show the most recent line 
>                                                               >       "I:"                      // Ignore changes whose lines
>                                                               >       "N"                       // Treat absent files as empt
>                                                               >       "S:"                      // Start with FILE when compa
>                                                               >       "T"                       // Make tabs line up by prepe
>                                                               >       "U:"                      // Output NUM (default 3) lin
>                                                               >       "W:"                      // Output at most NUM (defaul
>                                                               >       "X:"                      // Exclude files that match a
>                                                               >       "a"                       // Treat all files as text.
>                                                               >       "b"                       // Ignore changes in the amou
>                                                               >       "c"                       // Output NUM (default 3) lin
>                                                               >       "d"                       // Try hard to find a smaller
>                                                               >       "e"                       // Output an ed script.
>                                                               >       "i"                       // Ignore case differences in
>                                                               >       "l"                       // Pass the output through `p
>                                                               >       "n"                       // Output an RCS format diff.
>                                                               >       "p"                       // Show which C function each
>                                                               >       "q"                       // Output only whether files 
>                                                               >       "r"                       // Recursively compare any su
>                                                               >       "s"                       // Report when two files are 
>                                                               >       "t"                       // Expand tabs to spaces in o
>                                                               >       "u"                       // Output NUM (default 3) lin
>                                                               >       "v"                       // Output version info.
>                                                               >       "w"                       // Ignore all white space.
>                                                               >       "x:"                      // Exclude files that match P
>                                                               >       "y"                       // Output in two columns.
>                                                               >       ;
>                                                               > 
>                                                               >     int c =
>                                                               >       getopt_long
>                                                               >         (argc,
>                                                               >          const_cast<char *const *> (argv),
>                                                               >          short_options,
>                                                               >          long_options,
>                                                               >          &option_index
>                                                               >         );
>                                                               > 
>                                                               >     switch (c) {
>                                                               >     case -1:
>                                                               >       return;
>                                                               > 
>                                                               >     case 0:
>                                                               >       printf ("option %s", long_options[option_index].name);
>                                                               >       if (optarg)
>                                                               >         printf (" with arg %s", optarg);
>                                                               >       printf ("\n");
>                                                               >       break;
>                                                               >     case 'B':
>                                                               >       opt_B_IgnoreBlankLines = true;
>                                                               >       break;
>                                                               >     case 'C':
>                                                               >       {
>                                                               >         unsigned linesOfContext = 3;
>                                                               >         if (optarg) {
>                                                               >           if (sscanf (optarg, "%u", &linesOfContext) != 1) {
>                                                               >             fprintf (stderr, "-C <NUM> or --context[=<NUM>] (
>                                                               >             exit (1);
>                                                               >           }
>                                                               >         }
>                                                               >         opt_C_LinesOfCopyContext = linesOfContext;
>                                                               >       }
>                                                               >       break;
>                                                               >     case 'D':
>                                                               >       opt_D_IfdefName = optarg;
>                                                               >       break;
>                                                               >     case 'E':
>                                                               >       opt_E_IgnoreTabExpansionChanges = true;
>                                                               >       break;
>                                                               >     case 'F':
>                                                               >       opt_F_ShowMostRecentLineMatching = optarg;
>                                                               >       break;
>                                                               >     case 'I':
>                                                               >       opt_I_IgnoreLinesMatching = optarg;
>                                                               >       break;
>                                                               >     case 'N':
>                                                               >       opt_N_TreatAbsentFilesAsEmpty = true;
>                                                               >       break;
>                                                               >     case 'S':
>                                                               >       opt_S_StartWithFileMatching = optarg;
>                                                               >       break;
>                                                               >     case 'T':
>                                                               >       opt_T_PrependATab = true;
>                                                               >       break;
>                                                               >     case 'U':
>                                                               >       {
>                                                               >         unsigned linesOfContext = 3;
>                                                               >         if (optarg) {
>                                                               >           if (sscanf (optarg, "%u", &linesOfContext) != 1) {
>                                                               >             fprintf (stderr, "-U <NUM> or --unified[=<NUM>] (
>                                                               >             exit (1);
>                                                               >           }
>                                                               >         }
>                                                               >         opt_U_LinesOfUnifiedContext = linesOfContext;
>                                                               >       }
>                                                               >       break;
>                                                               >     case 'W':
>                                                               >       {
>                                                               >         unsigned maxPrintColumns = 130;
>                                                               >         if (optarg) {
>                                                               >           if (sscanf (optarg, "%u", &maxPrintColumns) != 1) {
>                                                               >             fprintf (stderr, "-W <NUM> or --width[=<NUM>] (%d
>                                                               >             exit (1);
>                                                               >           }
>                                                               >         }
>                                                               >         opt_W_MaxPrintColumns = maxPrintColumns;
>                                                               >       }
>                                                               >       break;
>                                                               >     case 'X':
>                                                               >       opt_X_ExcludeFilesMatching = optarg;
>                                                               >       break;
>                                                               >     case 'a':
>                                                               >       opt_a_TreatAllFilesAsText = true;
>                                                               >       break;
>                                                               >     case 'b':
>                                                               >       opt_b_IgnoreWhitespaceChanges = true;
>                                                               >       break;
>                                                               >     case 'c':
>                                                               >       opt___OutputFormat = opt_c_Context;
>                                                               >       break;
>                                                               >     case 'd':
>                                                               >       opt_d_TryToFindMinimalChanges = true;
>                                                               >       break;
>                                                               >     case 'e':
>                                                               >       opt___OutputFormat = opt_e_EdScript;
>                                                               >       break;
>                                                               >     case 'i':
>                                                               >       opt_i_IgnoreCaseDifferences = true;
>                                                               >       break;
>                                                               >     case 'l':
>                                                               >       opt_l_PaginateWithPr = true;
>                                                               >       break;
>                                                               >     case 'n':
>                                                               >       opt___OutputFormat = opt_n_RCS;
>                                                               >       break;
>                                                               >     case 'p':
>                                                               >       opt_p_ShowChangedCFunction = true;
>                                                               >       break;
>                                                               >     case 'q':
>                                                               >       opt_q_OutputOnlyIfFilesDiffer = true;
>                                                               >       break;
>                                                               >     case 'r':
>                                                               >       opt_r_RecursivelyCompareSubdirectories = true;
>                                                               >       break;
>                                                               >     case 's':
>                                                               >       opt_s_ReportWhenFilesAreSame = true;
>                                                               >       break;
>                                                               >     case 't':
>                                                               >       opt_t_ExpandTabs = true;
>                                                               >       break;
>                                                               >     case 'u':
>                                                               >       opt___OutputFormat = opt_u_Unified;
>                                                               >       break;
>                                                               >     case 'v':
>                                                               >       opt_v_ShowVersionInfo = true;
>                                                               >       break;
>                                                               >     case 'w':
>                                                               >       opt_w_IgnoreAllWhitespace = true;
>                                                               >       break;
>                                                               >     case 'x':
>                                                               >       opt_x_IgnoreFilesMatching = optarg;
>                                                               >       break;
>                                                               >     case 'y':
>                                                               >       opt___OutputFormat = opt_y_SideBySide;
>                                                               >       break;
>                                                               >     case 'h':
>                                                               >     case '?':
>                                                               >       fprintf
>                                                               >         (stderr,
>                                                               >          "Usage: diff [OPTION]... FILES\n"
>                                                               >          "Compare files line by line.\n"
>                                                               >          "\n"
>                                                               >          "  --GTYPE-group-format=GFMT  Similar, but format GT
>                                                               >          "  --LTYPE-line-format=LFMT  Similar, but format LTY
>                                                               >          "    LTYPE is `old', `new', or `unchanged'.  GTYPE i
>                                                               >          "    GFMT may contain:\n"
>                                                               >          "      %<  lines from FILE1\n"
>                                                               >          "      %>  lines from FILE2\n"
>                                                               >          "      %=  lines common to FILE1 and FILE2\n"
>                                                               >          "      %[-][WIDTH][.[PREC]]{doxX}LETTER  printf-styl
>                                                               >          "        LETTERs are as follows for new group, lower
>                                                               >          "          F  first line number\n"
>                                                               >          "          L  last line number\n"
>                                                               >          "          N  number of lines = L-F+1\n"
>                                                               >          "          E  F-1\n"
>                                                               >          "          M  L+1\n"
>                                                               >          "    LFMT may contain:\n"
>                                                               >          "      %L  contents of line\n"
>                                                               >          "      %l  contents of line, excluding any trailing 
>                                                               >          "      %[-][WIDTH][.[PREC]]{doxX}n  printf-style spe
>                                                               >          "    Either GFMT or LFMT may contain:\n"
>                                                               >          "      %%  %\n"
>                                                               >          "      %c'C'  the single character C\n"
>                                                               >          "      %c'\\OOO'  the character with octal code OOO\
>                                                               >          "\n"
>                                                               >          "  --brief  -q  Output only whether files differ.\n"
>                                                               >          "  --context[=NUM]  -c  -C NUM  Output NUM (default 
>                                                               >          "  --ed  -e  Output an ed script.\n"
>                                                               >          "  --exclude-from=FILE  -X FILE  Exclude files that 
>                                                               >          "  --exclude=PAT  -x PAT  Exclude files that match P
>                                                               >          "  --expand-tabs  -t  Expand tabs to spaces in outpu
>                                                               >          "  --from-file=FILE1  Compare FILE1 to all operands.
>                                                               >          "  --help  Output this help.\n"
>                                                               >          "  --horizon-lines=NUM  Keep NUM lines of the common
>                                                               >          "  --ifdef=NAME  -D NAME  Output merged file to show
>                                                               >          "  --ignore-all-space  -w  Ignore all white space.\n
>                                                               >          "  --ignore-blank-lines  -B  Ignore changes whose li
>                                                               >          "  --ignore-case  -i  Ignore case differences in fil
>                                                               >          "  --ignore-file-name-case  Ignore case when compari
>                                                               >          "  --ignore-matching-lines=RE  -I RE  Ignore changes
>                                                               >          "  --ignore-space-change  -b  Ignore changes in the 
>                                                               >          "  --ignore-tab-expansion  -E  Ignore changes due to
>                                                               >          "  --initial-tab  -T  Make tabs line up by prependin
>                                                               >          "  --label LABEL  Use LABEL instead of file name.\n"
>                                                               >          "  --left-column  Output only the left column of com
>                                                               >          "  --line-format=LFMT  Similar, but format all input
>                                                               >          "  --minimal  -d  Try hard to find a smaller set of 
>                                                               >          "  --new-file  -N  Treat absent files as empty.\n"
>                                                               >          "  --no-ignore-file-name-case  Consider case when co
>                                                               >          "  --normal  Output a normal diff.\n"
>                                                               >          "  --paginate  -l  Pass the output through `pr' to p
>                                                               >          "  --rcs  -n  Output an RCS format diff.\n"
>                                                               >          "  --recursive  -r  Recursively compare any subdirec
>                                                               >          "  --report-identical-files  -s  Report when two fil
>                                                               >          "  --show-c-function  -p  Show which C function each
>                                                               >          "  --show-function-line=RE  -F RE  Show the most rec
>                                                               >          "  --side-by-side  -y  Output in two columns.\n"
>                                                               >          "  --speed-large-files  Assume large files and many 
>                                                               >          "  --starting-file=FILE  -S FILE  Start with FILE wh
>                                                               >          "  --strip-trailing-cr  Strip trailing carriage retu
>                                                               >          "  --suppress-common-lines  Do not output common lin
>                                                               >          "  --text  -a  Treat all files as text.\n"
>                                                               >          "  --to-file=FILE2  Compare all operands to FILE2.  
>                                                               >          "  --unidirectional-new-file  Treat absent first fil
>                                                               >          "  --unified[=NUM]  -u  -U NUM  Output NUM (default 
>                                                               >          "  --version  -v  Output version info.\n"
>                                                               >          "  --width=NUM  -W NUM  Output at most NUM (default 
>                                                               >          "\n"
>                                                               >          "FILES are `FILE1 FILE2' or `DIR1 DIR2' or `DIR FILE
>                                                               >          "If --from-file or --to-file is given, there are no 
>                                                               >          "If a FILE is `-', read standard input.\n"
>                                                               >          "\n"
>                                                               >          "Report bugs to <bug-gnu-utils@gnu.org>.\n"
>                                                               >         );
>                                                               >       exit (1);
>                                                               >     default:
>                                                               >       fprintf (stderr, "Unhandled option (%c%s)!\n", c, optar
>                                                               >       exit (1);
>                                                               >     }
>                                                               >   }
>                                                               > }
>                                                               > 
>                                                               > // Perform pass #1, in which we find all explicit matches amo
>                                                               > // unique lines.  For every unique line that appears the same
>                                                               > // of times in both files, we declare the lines to match.
>                                                               > 
>                                                               > void pass1 ()
>                                                               > {
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr, "# Pass 1 (finding matches amongst uniqu
>                                                               >     fflush (stderr);
>                                                               >   }
>                                                               > 
>                                                               >   nMatchedLines = 0;
>                                                               > 
>                                                               >   for (MapStringToLinePtr::iterator i = table.begin (); i != 
>                                                               >     Line *l = i->second;
>                                                               > 
>                                                               >     // If the number of old and new lines match, then we decl
>                                                               >     // they are (all) the same line.  Note, it isn't possible
>                                                               >     // numbers of both files to be 0.
>                                                               > 
>                                                               >     // (In the original algorithm, we only recognized a match
>                                                               >     // if there was exactly 1 copy for each file.)
>                                                               > 
>                                                               >     if (l->copies[0].size () == l->copies[1].size ()) {
>                                                               >       nMatchedLines += 1;
>                                                               > 
>                                                               >       // For each matched line in the new file, mark it with 
>                                                               >       // corresponding line (number) in the old file.
>                                                               > 
>                                                               >       while (!l->copies[0].empty ()) {
>                                                               >         unsigned o = l->copies[0].front ();
>                                                               >         unsigned n = l->copies[1].front ();
>                                                               > 
>                                                               >         // Match up the pair.
>                                                               > 
>                                                               >         lines[0][o].l = n;
>                                                               >         lines[1][n].l = o;
>                                                               > 
>                                                               >         // Remove the matched line numbers from the lists.
>                                                               > 
>                                                               >         l->copies[0].pop_front ();
>                                                               >         l->copies[1].pop_front ();
>                                                               >       }
>                                                               >     }
>                                                               >   }
>                                                               >   nTotalMatchedLines += nMatchedLines;
>                                                               > 
>                                                               >   // Let's see the intermediate results.
>                                                               > 
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr, " found %u matched lines (%u total).\n",
>                                                               >     fflush (stderr);
>                                                               > 
>                                                               >     if (2 < optVerbose) {
>                                                               >       for (int f = 0; f < 2; f += 1) {
>                                                               >         fprintf (stderr, "# file #%d\n", f + 1);
>                                                               >         fflush (stderr);
>                                                               >         for (int l = 0; l < lines[f].size (); l += 1) {
>                                                               >           fprintf (stderr, "#   [%d] ", l);
>                                                               >           fflush (stderr);
>                                                               >           lines[f][l].Dump (stderr);
>                                                               >         }
>                                                               >       }
>                                                               >     }
>                                                               >   }
>                                                               > }
>                                                               > 
>                                                               > // Perform Pass #2, in which we attempt to 'widen' blocks of 
>                                                               > // lines, by appending lines which are the same in both files
>                                                               > 
>                                                               > void pass2 ()
>                                                               > {
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr, "# Pass #2 (spreading matches down)...")
>                                                               >     fflush (stderr);
>                                                               >   }
>                                                               > 
>                                                               >   nMatchedBlocks = 0;
>                                                               >   nMatchedLines = 0;
>                                                               > 
>                                                               >   // Starting at the top of the old file,...
>                                                               > 
>                                                               >   for (unsigned o = 0; o < lines[0].size (); o += 1) {
>                                                               > 
>                                                               >     // ... skip any currently unmatched lines...
>                                                               > 
>                                                               >     if (lines[0][o].l == ~0) {
>                                                               >       continue;
>                                                               >     }
>                                                               > 
>                                                               >     // ... until we find an [already] matched line.  Then, sk
>                                                               >     // the set of 1 or more matched lines, until we reach any
>                                                               >     // following, still-unmatched line.
>                                                               > 
>                                                               >     unsigned n;
>                                                               >     do {
>                                                               >       n = lines[0][o].l + 1;
>                                                               >       o += 1;
>                                                               >     } while (o < lines[0].size () && lines[0][o].l != ~0);
>                                                               > 
>                                                               >     // Now, o - 1 is the line number of the last matched old 
>                                                               >     // n - 1 is the line number of the last matched new line.
>                                                               >     // to add new old and new lines, if they match.
>                                                               > 
>                                                               >     // Finally, attempt to add unmatched lines to the preceed
>                                                               >     // matched set.
>                                                               > 
>                                                               >     for (; o < lines[0].size () && lines[0][o].l == ~0; o += 
>                                                               > 
>                                                               >       // If the [next] pair of old and new lines aren't the s
>                                                               > 
>                                                               >       if (lines[0][o].line != lines[1][n].line) {
>                                                               >         break;
>                                                               >       }
>                                                               > 
>                                                               >       // Match up the pair.
>                                                               > 
>                                                               >       lines[0][o].l = n;
>                                                               >       lines[1][n].l = o;
>                                                               > 
>                                                               >       // Remove the matched line numbers form the lists.
>                                                               > 
>                                                               >       Line *line = lines[0][o].line;
>                                                               >       list<unsigned> &oldCopies = line->copies[0];
>                                                               >       list<unsigned>::iterator oL = find (oldCopies.begin (),
>                                                               >       if (oL != oldCopies.end ()) {
>                                                               >         oldCopies.erase (oL);
>                                                               >       }
>                                                               >       list<unsigned> &newCopies = line->copies[0];
>                                                               >       list<unsigned>::iterator nL = find (newCopies.begin (),
>                                                               >       if (nL != newCopies.end ()) {
>                                                               >         newCopies.erase (nL);
>                                                               >       }
>                                                               > 
>                                                               >       nMatchedLines += 1;
>                                                               >     }
>                                                               >     nMatchedBlocks += 1;
>                                                               >   }
>                                                               >   nTotalMatchedLines += nMatchedLines;
>                                                               >   nTotalMatchedBlocks += nMatchedBlocks;
>                                                               > 
>                                                               >   // Let's see the intermediate results.
>                                                               > 
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr,
>                                                               >              " found %u/%u matched lines/blocks (%u/%u totals
>                                                               >              nMatchedLines,
>                                                               >              nMatchedBlocks,
>                                                               >              nTotalMatchedLines,
>                                                               >              nTotalMatchedBlocks
>                                                               >             );
>                                                               >     fflush (stderr);
>                                                               >     if (2 < optVerbose) {
>                                                               >       for (int f = 0; f < 2; f += 1) {
>                                                               >         fprintf (stderr, "# file #%d\n", f + 1);
>                                                               >         fflush (stderr);
>                                                               >         for (int l = 0; l < lines[f].size (); l += 1) {
>                                                               >           fprintf (stderr, "#   [%d] ", l);
>                                                               >           fflush (stderr);
>                                                               >           lines[f][l].Dump (stderr);
>                                                               >         }
>                                                               >       }
>                                                               >     }
>                                                               >   }
>                                                               > }
>                                                               > 
>                                                               > // Perform Pass #3, in which we attempt to 'widen' blocks of 
>                                                               > // lines, by prepending lines which are the same in both file
>                                                               > 
>                                                               > void pass3 ()
>                                                               > {
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr, "# Pass #3 (spreading matches up)...");
>                                                               >     fflush (stderr);
>                                                               >   }
>                                                               > 
>                                                               >   nMatchedBlocks = 0;
>                                                               >   nMatchedLines = 0;
>                                                               > 
>                                                               >   // Starting at the bottom of the old file,...
>                                                               > 
>                                                               >   for (int o = lines[0].size (); 0 <= o; o -= 1) {
>                                                               > 
>                                                               >     // ... skip any currently unmatched lines...
>                                                               > 
>                                                               >     if (lines[0][o].l == ~0) {
>                                                               >       continue;
>                                                               >     }
>                                                               > 
>                                                               >     // ... until we find an [already] matched line.  Then, sk
>                                                               >     // the set of 1 or more matched lines, until we reach any
>                                                               >     // following, still-unmatched line.
>                                                               > 
>                                                               >     unsigned n;
>                                                               >     do {
>                                                               >       n = lines[0][o].l - 1;
>                                                               >       o -= 1;
>                                                               >     } while (0 <= o && lines[0][o].l != ~0);
>                                                               > 
>                                                               >     // Now, o + 1 is the line number of the last matched old 
>                                                               >     // n + 1 is the line number of the last matched new line.
>                                                               >     // to add new old and new lines, if they match.
>                                                               > 
>                                                               >     // Finally, attempt to add unmatched lines to the preceed
>                                                               >     // matched set.
>                                                               > 
>                                                               >     for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
>                                                               > 
>                                                               >       // If the [next] pair of old and new lines aren't the s
>                                                               > 
>                                                               >       if (lines[0][o].line != lines[1][n].line) {
>                                                               >         break;
>                                                               >       }
>                                                               > 
>                                                               >       // Match up the pair.
>                                                               > 
>                                                               >       lines[0][o].l = n;
>                                                               >       lines[1][n].l = o;
>                                                               > 
>                                                               >       // Remove the matched line numbers form the lists.
>                                                               > 
>                                                               >       Line *line = lines[0][o].line;
>                                                               >       list<unsigned> &oldCopies = line->copies[0];
>                                                               >       list<unsigned>::iterator oL = find (oldCopies.begin (),
>                                                               >       if (oL != oldCopies.end ()) {
>                                                               >         oldCopies.erase (oL);
>                                                               >       }
>                                                               >       list<unsigned> &newCopies = line->copies[0];
>                                                               >       list<unsigned>::iterator nL = find (newCopies.begin (),
>                                                               >       if (nL != newCopies.end ()) {
>                                                               >         newCopies.erase (nL);
>                                                               >       }
>                                                               > 
>                                                               >       nMatchedLines += 1;
>                                                               >     }
>                                                               >     nMatchedBlocks += 1;
>                                                               >   }
>                                                               >   nTotalMatchedLines += nMatchedLines;
>                                                               > 
>                                                               >   // Let's see the intermediate results.
>                                                               > 
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr,
>                                                               >              " found %u/%u matched lines/blocks (%u/%u totals
>                                                               >              nMatchedLines,
>                                                               >              nMatchedBlocks,
>                                                               >              nTotalMatchedLines,
>                                                               >              nTotalMatchedBlocks
>                                                               >             );
>                                                               >     fflush (stderr);
>                                                               > 
>                                                               >     if (2 < optVerbose) {
>                                                               >       for (int f = 0; f < 2; f += 1) {
>                                                               >         fprintf (stderr, "# file #%d\n", f + 1);
>                                                               >         fflush (stderr);
>                                                               >         for (int l = 0; l < lines[f].size (); l += 1) {
>                                                               >           fprintf (stderr, "#   [%d] ", l);
>                                                               >           fflush (stderr);
>                                                               >           lines[f][l].Dump (stderr);
>                                                               >         }
>                                                               >       }
>                                                               >     }
>                                                               >   }
>                                                               > }
>                                                               > 
>                                                               > // Perform pass #4, in which we find any remaining matches am
>                                                               > // unique lines.  For every unique line that has more than 1 
>                                                               > // both files, we declare the copies to match.
>                                                               > 
>                                                               > void pass4 ()
>                                                               > {
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr, "# Pass 4 (finding remaining matches amo
>                                                               >     fflush (stderr);
>                                                               >   }
>                                                               > 
>                                                               >   nMatchedLines = 0;
>                                                               > 
>                                                               >   for (MapStringToLinePtr::iterator i = table.begin (); i != 
>                                                               >     Line *l = i->second;
>                                                               > 
>                                                               >     // If there's more than 1 matching old and new lines, the
>                                                               >     // declare that each pair are (all) the same line.
>                                                               > 
>                                                               >     // (In the original algorithm, we only recognized a match
>                                                               >     // if there was exactly 1 copy for each file.)
>                                                               > 
>                                                               >     while (0 < l->copies[0].size () && 0 < l->copies[1].size 
>                                                               >       nMatchedLines += 1;
>                                                               > 
>                                                               >       // For each matched line in the new file, mark it with 
>                                                               >       // corresponding line (number) in the old file.
>                                                               > 
>                                                               >       unsigned o = l->copies[0].front ();
>                                                               >       unsigned n = l->copies[1].front ();
>                                                               > 
>                                                               >       // Match up the pair.
>                                                               > 
>                                                               >       lines[0][o].l = n;
>                                                               >       lines[1][n].l = o;
>                                                               > 
>                                                               >       // Remove the matched line numbers from the lists.
>                                                               > 
>                                                               >       l->copies[0].pop_front ();
>                                                               >       l->copies[1].pop_front ();
>                                                               >     }
>                                                               >   }
>                                                               >   nTotalMatchedLines += nMatchedLines;
>                                                               > 
>                                                               >   // Let's see the intermediate results.
>                                                               > 
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr, " found %u matched lines (%u total).\n",
>                                                               >     fflush (stderr);
>                                                               > 
>                                                               >     if (2 < optVerbose) {
>                                                               >       for (int f = 0; f < 2; f += 1) {
>                                                               >         fprintf (stderr, "# file #%d\n", f + 1);
>                                                               >         fflush (stderr);
>                                                               >         for (int l = 0; l < lines[f].size (); l += 1) {
>                                                               >           fprintf (stderr, "#   [%d] ", l);
>                                                               >           fflush (stderr);
>                                                               >           lines[f][l].Dump (stderr);
>                                                               >         }
>                                                               >       }
>                                                               >     }
>                                                               >   }
>                                                               > }
>                                                               > 
>                                                               > // Perform Pass #5, in which we look for blocks which match, 
>                                                               > // the result of a move (their not in their original position
>                                                               > // these, we'll unmatch the blocks, turning them into a delet
>                                                               > // insert.
>                                                               > 
>                                                               > void pass5 ()
>                                                               > {
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr, "# Pass #5 (unmatching block moves)...\n
>                                                               >     fflush (stderr);
>                                                               >   }
>                                                               > 
>                                                               >   nMatchedBlocks = 0;
>                                                               >   nMatchedLines = 0;
>                                                               > 
>                                                               >   // Starting at the top of both files,...
>                                                               > 
>                                                               >   unsigned o = 0;
>                                                               >   unsigned n = 0;
>                                                               > 
>                                                               >   while (o < lines[0].size () || n < lines[1].size ()) {
>                                                               > 
>                                                               >     // Skip any unmatched lines at this point in the old file
>                                                               >     // are deletes.
>                                                               > 
>                                                               >     //    Old     New
>                                                               >     //   +---+
>                                                               >     // 0 | a |
>                                                               >     //   +---+   +---+
>                                                               >     //         0 | b |
>                                                               >     //   +---+   +---+
>                                                               >     // 1 | c | 1 | c |
>                                                               >     //   +---+   +---+
>                                                               >     //         2 | z |
>                                                               >     //   +---+   +---+
>                                                               >     // 2 | d | 3 | d |
>                                                               >     //   +---+   +---+
>                                                               > 
>                                                               >     while (o < lines[0].size () && lines[0][o].l == ~0) {
>                                                               >       o += 1;
>                                                               >     }
>                                                               > 
>                                                               >     // Skip any unmatched lines at this point in the new file
>                                                               >     // are inserts.
>                                                               > 
>                                                               >     while (n < lines[1].size () && lines[1][n].l == ~0) {
>                                                               >       n += 1;
>                                                               >     }
>                                                               > 
>                                                               >     // When we get here, we know that we're dealing with matc
>                                                               >     // lines (or the end of one or both files).  We're done w
>                                                               >     // pass, if we've reached the end of either file.
>                                                               > 
>                                                               >     if (lines[0].size () <= o || lines[1].size () <= n) {
>                                                               >       break;
>                                                               >     }
>                                                               > 
>                                                               >     // We now know that we've got a pair of matching lines, t
>                                                               >     // of a matching block.  If the new file's line number is
>                                                               >     // expect, then the matched pair is unmoved, and we can s
>                                                               >     // the pair.  (If this is really the start of a block of 
>                                                               >     // 1 lines, we'll handle it one pair at a time.)
>                                                               > 
>                                                               >     if (lines[0][o].l == n) {
>                                                               >       o += 1;
>                                                               >       n += 1;
>                                                               >       continue;
>                                                               >     }
>                                                               > 
>                                                               >     // If, on the other hand, we don't expect this [new] line
>                                                               >     // then this matching block has been moved.  We need to t
>                                                               >     // matched pair into an *unmatched* pair, one of deletes,
>                                                               >     // of inserts.  First, though, we need to know how big th
>                                                               >     // is, and how far it was moved....
>                                                               > 
>                                                               >     // Remember where we were when we started.
>                                                               > 
>                                                               >     unsigned oOld = o;
>                                                               >     unsigned nOld = n;
>                                                               > 
>                                                               >     // Remember where the block came from.
>                                                               > 
>                                                               >     unsigned nNew = lines[0][o].l;
>                                                               > 
>                                                               >     // Find the end of this matched pair.
>                                                               > 
>                                                               >     for (n = nNew; o < lines[0].size () && n < lines[1].size 
>                                                               >       if (lines[0][o].l != n) {
>                                                               >         break;
>                                                               >       }
>                                                               >     }
>                                                               > 
>                                                               >     // When we get here:
>                                                               >     // * oOld..o is the old file's block,
>                                                               >     // * nNew..n is the new file's *moved* block, and
>                                                               >     // * nOld is where we originally expected the new block f
>                                                               >  
>                                                               >     // We can now calculate the length of the block...
>                                                               >     
>                                                               >     unsigned bSize = o - oOld;  // (or n - nNew)
>                                                               > 
>                                                               >     // ... and we can calculate how far the block moved:
>                                                               > 
>                                                               >     unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
>                                                               > 
>                                                               >     // The larger of the two will become our delete, and the 
>                                                               >     // will become our insert.
>                                                               > 
>                                                               >     //    Old     New
>                                                               >     //   +---+   +---+
>                                                               >     // 0 | a | 0 | b |
>                                                               >     //   +---+ 1 | b |
>                                                               >     // 1 | b |   +---+
>                                                               >     // 2 | b | 2 | a |
>                                                               >     //   +---+   +---+
>                                                               >     // 3 | c | 3 | c |
>                                                               >     //   +---+   +---+
>                                                               > 
>                                                               >     // (1) Delete a@0, insert a@2, or
>                                                               >     // (2) insert bb@0, delete bb@1?
>                                                               > 
>                                                               >     // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and
>                                                               >     // (of a) is 2-0 or 2, the size of b@0.  We choose to del
>                                                               >     // and reinsert a@2.
>                                                               > 
>                                                               >     // if (bSize <= bMove) {
>                                                               >       for (unsigned a = oOld; a < o; a += 1) {
>                                                               >         lines[0][a].l = ~0;
>                                                               >       }
>                                                               >       for (unsigned d = nNew; d < n; d += 1) {
>                                                               >         lines[1][d].l = ~0;
>                                                               >       }
>                                                               >     // } else {
>                                                               >       // for (unsigned a = oOld; a < o; a += 1) {
>                                                               >       //   lines[0][a].l = ~0;
>                                                               >       // }
>                                                               >       // for (unsigned d = nNew; d < n; d += 1) {
>                                                               >       //   lines[1][d].l = ~0;
>                                                               >       // }
>                                                               >     // }
>                                                               > 
>                                                               >     // Continue from where we left off.
>                                                               > 
>                                                               >     n = nOld;
>                                                               >   }
>                                                               >   nTotalMatchedLines -= nMatchedLines;
>                                                               >   nTotalMatchedBlocks -= nMatchedBlocks;
>                                                               > 
>                                                               >   // Let's see the intermediate results.
>                                                               > 
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr,
>                                                               >              " found %u/%u matched lines/blocks (%u/%u totals
>                                                               >              nMatchedLines,
>                                                               >              nMatchedBlocks,
>                                                               >              nTotalMatchedLines,
>                                                               >              nTotalMatchedBlocks
>                                                               >             );
>                                                               >     fflush (stderr);
>                                                               > 
>                                                               >     if (2 < optVerbose) {
>                                                               >       for (int f = 0; f < 2; f += 1) {
>                                                               >         fprintf (stderr, "# file #%d\n", f + 1);
>                                                               >         fflush (stderr);
>                                                               >         for (int l = 0; l < lines[f].size (); l += 1) {
>                                                               >           fprintf (stderr, "#   [%d] ", l);
>                                                               >           fflush (stderr);
>                                                               >           lines[f][l].Dump (stderr);
>                                                               >         }
>                                                               >       }
>                                                               >     }
>                                                               >   }
>                                                               > }
>                                                               > 
>                                                               > // Perform Pass #6, in which we create the desired output.
>                                                               > 
>                                                               > void pass6c ();
>                                                               > void pass6e ();
>                                                               > void pass6i ();
>                                                               > void pass6n ();
>                                                               > void pass6r ();
>                                                               > void pass6s ();
>                                                               > void pass6u ();
>                                                               > void pass6y ();
>                                                               > 
>                                                               > void pass6 ()
>                                                               > {
>                                                               >   switch (opt___OutputFormat) {
>                                                               >   case opt_c_Context:
>                                                               >     pass6c ();
>                                                               >     break;
>                                                               > 
>                                                               >   case opt_e_EdScript:
>                                                               >     pass6e ();
>                                                               >     break;
>                                                               > 
>                                                               >   case opt_D_IfThenElse:
>                                                               >     pass6i ();
>                                                               >     break;
>                                                               > 
>                                                               >   case opt___Normal:
>                                                               >     pass6n ();
>                                                               >     break;
>                                                               > 
>                                                               >   case opt_n_RCS:
>                                                               >     pass6r ();
>                                                               >     break;
>                                                               > 
>                                                               >   case opt_y_SideBySide:
>                                                               >     pass6y ();
>                                                               >     break;
>                                                               > 
>                                                               >   case opt_u_Unified:
>                                                               >     pass6u ();
>                                                               >     break;
>                                                               > 
>                                                               >   default:
>                                                               >     pass6n ();
>                                                               >     break;
>                                                               >   }
>                                                               > }
>                                                               > 
>                                                               > template<typename T> T min (T l, T r) {
>                                                               >   if (l < r) {
>                                                               >     return l;
>                                                               >   }
>                                                               >   return r;
>                                                               > }
>                                                               > 
>                                                               > template<typename T> T max (T l, T r) {
>                                                               >   if (l < r) {
>                                                               >     return r;
>                                                               >   }
>                                                               >   return l;
>                                                               > }
>                                                               > 
>                                                               > void pass6c () {
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr, "# Pass #6c (walking the differences)...
>                                                               >     fflush (stderr);
>                                                               >   }
>                                                               > 
>                                                               >   nMatchedLines = 0;
>                                                               > 
>                                                               >   // Write the header.
>                                                               > 
>                                                               >   fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:0
>                                                               >   fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:0
>                                                               > 
>                                                               >   // Starting at the top of both files,...
>                                                               > 
>                                                               >   unsigned o = 0;
>                                                               >   unsigned n = 0;
>                                                               > 
>                                                               >   while (o < lines[0].size () || n < lines[1].size ()) {
>                                                               > 
>                                                               >     // Find the bounds of the current contextual 'window'.
>                                                               > 
>                                                               >     // If we aren't looking at a delete or an insert, we're n
>                                                               >     // start of a context window.
>                                                               > 
>                                                               >     if (lines[0][o].l != ~0 && lines[1][n].l != ~0) {
>                                                               >       o += 1;
>                                                               >       n += 1;
>                                                               >       continue;
>                                                               >     }
>                                                               > 
>                                                               >     // We're now looking at at least 1 delete or insert, so a
>                                                               >     // begins here (or, rather, opt_C_LinesOfCopyContext line
>                                                               >     
>                                                               >     int boOldWindow = max (0, int (o) - int (opt_C_LinesOfCop
>                                                               >     int boNewWindow = max (0, int (n) - int (opt_C_LinesOfCop
>                                                               > 
>                                                               >     if (1 < optVerbose) {
>                                                               >       fprintf (stderr, "boOldWindow = %d, boNewWindow = %d\n"
>                                                               >       fflush (stderr);
>                                                               >     }
>                                                               > 
>                                                               >     // Look for the end of the current window.
>                                                               > 
>                                                               >     int eoOldWindow;
>                                                               >     int eoNewWindow;
>                                                               > 
>                                                               >     bool widenWindow = true;
>                                                               >     while (widenWindow && o < lines[0].size () || n < lines[1
>                                                               > 
>                                                               >       // Skip over the delete(s) and/or insert(s) defining th
>                                                               >       // context.
>                                                               > 
>                                                               >       while (o < lines[0].size () && lines[0][o].l == ~0) {
>                                                               >         o += 1;
>                                                               >       }
>                                                               >       while (n < lines[1].size () && lines[1][n].l == ~0) {
>                                                               >         n += 1;
>                                                               >       }
>                                                               > 
>                                                               >       // This context will end opt_C_LinesOfCopyContext match
>                                                               >       // last set of deletes or inserts we find.
>                                                               > 
>                                                               >       widenWindow = false;
>                                                               >       for (unsigned l = 0; !widenWindow && l < opt_C_LinesOfC
>                                                               >         if (o < lines[0].size ()) {
>                                                               >           widenWindow |= lines[0][o].l == ~0;
>                                                               >           o += 1;
>                                                               >         }
>                                                               >         if (n < lines[1].size ()) {
>                                                               >           widenWindow |= lines[1][n].l == ~0;
>                                                               >           n += 1;
>                                                               >         }
>                                                               >       }
>                                                               > 
>                                                               >       eoOldWindow = o;
>                                                               >       eoNewWindow = n;
>                                                               > 
>                                                               >       // However, since another window could follow, we look
>                                                               >       // opt_C_LinesOfCopyContext ahead for another delete or
>                                                               > 
>                                                               >       if (!widenWindow) {
>                                                               >         for (unsigned l = 0; l < (2 * opt_C_LinesOfCopyContex
>                                                               >           if (o < lines[0].size ()) {
>                                                               >             widenWindow |= lines[0][o].l == ~0;
>                                                               >             o += 1;
>                                                               >           }
>                                                               >           if (n < lines[1].size ()) {
>                                                               >             widenWindow |= lines[1][n].l == ~0;
>                                                               >             n += 1;
>                                                               >           }
>                                                               >         }
>                                                               >       }
>                                                               >     }
>                                                               > 
>                                                               >     // We've found the end of the window.
>                                                               > 
>                                                               >     if (1 < optVerbose) {
>                                                               >       fprintf (stderr, "eoOldWindow = %d, eoNewWindow = %d\n"
>                                                               >       fflush (stderr);
>                                                               >     }
>                                                               > 
>                                                               >     // Now, reset ourselves to the start of the window, and w
>                                                               >     // produce the output.  We'll walk it twice, first for th
>                                                               >     // file part, then for the new file part.
>                                                               > 
>                                                               >     fprintf (stdout, "***************\n");
>                                                               >     fprintf (stdout, "*** %d,%d ****\n", boOldWindow + 1, eoO
>                                                               > 
>                                                               >     o = boOldWindow;
>                                                               >     n = boNewWindow;
>                                                               > 
>                                                               >     while (o < eoOldWindow || n < eoNewWindow) {
>                                                               > 
>                                                               >       // Find any unmatched lines at this point in the old fi
>                                                               >       // are deletes.
>                                                               > 
>                                                               >       unsigned boDeletes = o;
>                                                               >       while (o < eoOldWindow && lines[0][o].l == ~0) {
>                                                               >         o += 1;
>                                                               >       }
>                                                               > 
>                                                               >       // Find any unmatched lines at this point in the new fi
>                                                               >       // are inserts.
>                                                               > 
>                                                               >       unsigned boInserts = n;
>                                                               >       while (n < eoNewWindow && lines[1][n].l == ~0) {
>                                                               >         n += 1;
>                                                               >       }
>                                                               > 
>                                                               >       // We've got deleted line(s) from boDeletes .. o.
>                                                               >       // We've got deleted line(s) from boInserts .. n.
>                                                               > 
>                                                               >       unsigned nDeletes = o - boDeletes;
>                                                               >       unsigned nInserts = n - boInserts;
>                                                               > 
>                                                               >       // We've got...
>                                                               > 
>                                                               >       if (nDeletes && nInserts) {
>                                                               > 
>                                                               >         // ... deletes and inserts.
>                                                               > 
>                                                               >         for (unsigned l = boDeletes; l < o; l += 1) {
>                                                               >           fprintf (stdout, "! %s\n", lines[0][l].line->c_str 
>                                                               >         }
>                                                               >       } else if (nDeletes) {
>                                                               > 
>                                                               >         //  ... just deletes.
>                                                               > 
>                                                               >         for (unsigned l = boDeletes; l < o; l += 1) {
>                                                               >           fprintf (stdout, "- %s\n", lines[0][l].line->c_str 
>                                                               >         }
>                                                               >       }
>                                                               > 
>                                                               >       // When we get here, we're dealing with matching lines.
>                                                               > 
>                                                               >       fprintf (stdout, "  %s\n", lines[0][o].line->c_str ());
>                                                               >       o += 1;
>                                                               >       n += 1;
>                                                               >     }
>                                                               > 
>                                                               >     fprintf (stdout, "--- %d,%d ----\n", boNewWindow + 1, eoN
>                                                               > 
>                                                               >     o = boOldWindow;
>                                                               >     n = boNewWindow;
>                                                               > 
>                                                               >     while (o < eoOldWindow && n < eoNewWindow) {
>                                                               > 
>                                                               >       // Find any unmatched lines at this point in the old fi
>                                                               >       // are deletes.
>                                                               > 
>                                                               >       unsigned boDeletes = o;
>                                                               >       while (o < eoOldWindow && lines[0][o].l == ~0) {
>                                                               >         o += 1;
>                                                               >       }
>                                                               > 
>                                                               >       // Find any unmatched lines at this point in the new fi
>                                                               >       // are inserts.
>                                                               > 
>                                                               >       unsigned boInserts = n;
>                                                               >       while (n < eoNewWindow && lines[1][n].l == ~0) {
>                                                               >         n += 1;
>                                                               >       }
>                                                               > 
>                                                               >       // We've got deleted line(s) from boDeletes .. o.
>                                                               >       // We've got deleted line(s) from boInserts .. n.
>                                                               > 
>                                                               >       unsigned nDeletes = o - boDeletes;
>                                                               >       unsigned nInserts = n - boInserts;
>                                                               > 
>                                                               >       // We've got...
>                                                               > 
>                                                               >       if (nDeletes && nInserts) {
>                                                               > 
>                                                               >         // ... deletes and inserts.
>                                                               > 
>                                                               >         for (unsigned l = boInserts; l < n; l += 1) {
>                                                               >           fprintf (stdout, "! %s\n", lines[1][l].line->c_str 
>                                                               >         }
>                                                               >       } else if (nInserts) {
>                                                               > 
>                                                               >         //  ... just inserts.
>                                                               > 
>                                                               >         for (unsigned l = boInserts; l < n; l += 1) {
>                                                               >           fprintf (stdout, "+ %s\n", lines[1][l].line->c_str 
>                                                               >         }
>                                                               >       }
>                                                               > 
>                                                               >       // When we get here, we're dealing with matching lines.
>                                                               > 
>                                                               >       fprintf (stdout, "  %s\n", lines[1][n].line->c_str ());
>                                                               >       o += 1;
>                                                               >       n += 1;
>                                                               >     }
>                                                               > 
>                                                               >     // Reset to the end of the current window.
>                                                               > 
>                                                               >     o = eoOldWindow;
>                                                               >     n = eoNewWindow;
>                                                               >   }
>                                                               > }
>                                                               > 
>                                                               > void pass6e () {
>                                                               >   fprintf (stderr, "pass6e() is unimplemented!\n");
>                                                               >   fflush (stderr);
>                                                               > }
>                                                               > 
>                                                               > void pass6i () {
>                                                               >   fprintf (stderr, "pass6i() is unimplemented!\n");
>                                                               >   fflush (stderr);
>                                                               > }
>                                                               > 
>                                                               > void pass6n ()
>                                                               > {
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr, "# Pass #6n (walking the differences)...
>                                                               >     fflush (stderr);
>                                                               >   }
>                                                               > 
>                                                               >   nMatchedLines = 0;
>                                                               > 
>                                                               >   // Write the header.  (None for normal.)
>                                                               > 
>                                                               >   // Starting at the top of both files,...
>                                                               > 
>                                                               >   unsigned o = 0;
>                                                               >   unsigned n = 0;
>                                                               > 
>                                                               >   while (o < lines[0].size () || n < lines[1].size ()) {
>                                                               > 
>                                                               >     // Find any unmatched lines at this point in the old file
>                                                               >     // are deletes.
>                                                               > 
>                                                               >     unsigned boDeletes;
>                                                               >     for (boDeletes = o;
>                                                               >          o < lines[0].size () && lines[0][o].l == ~0;
>                                                               >          o += 1
>                                                               >         )
>                                                               >     {}
>                                                               > 
>                                                               >     // Find any unmatched lines at this point in the new file
>                                                               >     // are inserts.
>                                                               > 
>                                                               >     unsigned boInserts;
>                                                               >     for (boInserts = n;
>                                                               >          n < lines[1].size () && lines[1][n].l == ~0;
>                                                               >          n += 1
>                                                               >         )
>                                                               >     {}
>                                                               > 
>                                                               >     // We've got deleted line(s) from boDeletes .. o.
>                                                               >     // We've got deleted line(s) from boInserts .. n.
>                                                               > 
>                                                               >     unsigned nDeletes = o - boDeletes;
>                                                               >     unsigned nInserts = n - boInserts;
>                                                               > 
>                                                               >     // We've got...
>                                                               > 
>                                                               >     if (nDeletes && nInserts) {
>                                                               > 
>                                                               >       // ... deletes and inserts.
>                                                               > 
>                                                               >       if (1 < nDeletes && 1 < nInserts) {
>                                                               >         fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, b
>                                                               >       } else if (1 < nDeletes) {
>                                                               >         fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boIn
>                                                               >       } else if (1 < nInserts) {
>                                                               >         fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInser
>                                                               >       } 
>                                                               >       for (unsigned l = boDeletes; l < o; l += 1) {
>                                                               >         fprintf (stdout, "< %s\n", lines[0][l].line->c_str ()
>                                                               >       }
>                                                               >       fprintf (stdout, "---\n");
>                                                               >       for (unsigned l = boInserts; l < n; l += 1) {
>                                                               >         fprintf (stdout, "> %s\n", lines[1][l].line->c_str ()
>                                                               >       }
>                                                               >     } else if (nDeletes) {
>                                                               > 
>                                                               >       //  ... just deletes.
>                                                               > 
>                                                               >       if (1 < nDeletes) {
>                                                               >         fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
>                                                               >       } else {
>                                                               >         fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
>                                                               >       }
>                                                               >       for (unsigned l = boDeletes; l < o; l += 1) {
>                                                               >         fprintf (stdout, "< %s\n", lines[0][l].line->c_str ()
>                                                               >       }
>                                                               >     } else if (nInserts) {
>                                                               > 
>                                                               >       //  ... just inserts.
>                                                               > 
>                                                               >       if (1 < nInserts) {
>                                                               >         fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
>                                                               >       } else {
>                                                               >         fprintf (stdout, "%da%d\n", o, boInserts + 1);
>                                                               >       }
>                                                               >       for (unsigned l = boInserts; l < n; l += 1) {
>                                                               >         fprintf (stdout, "> %s\n", lines[1][l].line->c_str ()
>                                                               >       }
>                                                               >     }
>                                                               > 
>                                                               >     // When we get here, we're dealing with matching lines.
>                                                               > 
>                                                               >     o += 1;
>                                                               >     n += 1;
>                                                               >   }
>                                                               > }
>                                                               > 
>                                                               > void pass6r () {
>                                                               >   fprintf (stderr, "pass6r() is unimplemented!\n");
>                                                               >   fflush (stderr);
>                                                               > }
>                                                               > 
>                                                               > void pass6s () {
>                                                               >   fprintf (stderr, "pass6s() is unimplemented!\n");
>                                                               >   fflush (stderr);
>                                                               > }
>                                                               > 
>                                                               > void pass6u ()
>                                                               > {
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr, "# Pass #6u (walking the differences)...
>                                                               >     fflush (stderr);
>                                                               >   }
>                                                               > 
>                                                               >   nMatchedLines = 0;
>                                                               > 
>                                                               >   // Write the header.
>                                                               > 
>                                                               >   fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:0
>                                                               >   fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:0
>                                                               >   fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), l
>                                                               > 
>                                                               >   // Starting at the top of both files,...
>                                                               > 
>                                                               >   unsigned o = 0;
>                                                               >   unsigned n = 0;
>                                                               > 
>                                                               >   while (o < lines[0].size () || n < lines[1].size ()) {
>                                                               > 
>                                                               >     // Find any unmatched lines at this point in the old file
>                                                               >     // are deletes.
>                                                               > 
>                                                               >     unsigned boDeletes;
>                                                               >     for (boDeletes = o;
>                                                               >          o < lines[0].size () && lines[0][o].l == ~0;
>                                                               >          o += 1
>                                                               >         )
>                                                               >     {}
>                                                               > 
>                                                               >     // Find any unmatched lines at this point in the new file
>                                                               >     // are inserts.
>                                                               > 
>                                                               >     unsigned boInserts;
>                                                               >     for (boInserts = n;
>                                                               >          n < lines[1].size () && lines[1][n].l == ~0;
>                                                               >          n += 1
>                                                               >         )
>                                                               >     {}
>                                                               > 
>                                                               >     // We've got deleted line(s) from boDeletes .. o.
>                                                               >     // We've got deleted line(s) from boInserts .. n.
>                                                               > 
>                                                               >     unsigned nDeletes = o - boDeletes;
>                                                               >     unsigned nInserts = n - boInserts;
>                                                               > 
>                                                               >     // We've got...
>                                                               > 
>                                                               >     if (nDeletes && nInserts) {
>                                                               > 
>                                                               >       // ... deletes and inserts.
>                                                               > 
>                                                               >       for (unsigned l = boDeletes; l < o; l += 1) {
>                                                               >         fprintf (stdout, "-%s\n", lines[0][l].line->c_str ())
>                                                               >       }
>                                                               >       for (unsigned l = boInserts; l < n; l += 1) {
>                                                               >         fprintf (stdout, "+%s\n", lines[1][l].line->c_str ())
>                                                               >       }
>                                                               >     } else if (nDeletes) {
>                                                               > 
>                                                               >       //  ... just deletes.
>                                                               > 
>                                                               >       for (unsigned l = boDeletes; l < o; l += 1) {
>                                                               >         fprintf (stdout, "-%s\n", lines[0][l].line->c_str ())
>                                                               >       }
>                                                               >     } else if (nInserts) {
>                                                               > 
>                                                               >       //  ... just inserts.
>                                                               > 
>                                                               >       for (unsigned l = boInserts; l < n; l += 1) {
>                                                               >         fprintf (stdout, "+%s\n", lines[1][l].line->c_str ())
>                                                               >       }
>                                                               >     }
>                                                               > 
>                                                               >     // When we get here, we're dealing with matching lines.
>                                                               > 
>                                                               >     fprintf (stdout, " %s\n", lines[0][o].line->c_str ());
>                                                               >     o += 1;
>                                                               >     n += 1;
>                                                               >   }
>                                                               > }
>                                                               > 
>                                                               > void pass6y ()
>                                                               > {
>                                                               >   if (0 < optVerbose) {
>                                                               >     fprintf (stderr, "# Pass #6y (walking the differences)...
>                                                               >     fflush (stderr);
>                                                               >   }
>                                                               > 
>                                                               >   // Write the header.
>                                                               > 
>                                                               >   // None for side-by-side.
>                                                               > 
>                                                               >   // Starting at the top of both files,...
>                                                               > 
>                                                               >   int columnWidth = (opt_W_MaxPrintColumns - 7) / 2;
>                                                                 
>   unsigned o = 0;                                                 unsigned o = 0;
>   unsigned n = 0;                                                 unsigned n = 0;
>                                                                 
>   while (o < lines[0].size () || n < lines[1].size ()) {          while (o < lines[0].size () || n < lines[1].size ()) {
>                                                                 
>     // Find any unmatched lines at this point in the old file       // Find any unmatched lines at this point in the old file
>     // are deletes.                                                 // are deletes.
>                                                                 
>     unsigned boDeletes = o;                                         unsigned boDeletes = o;
>     while (o < lines[0].size () && lines[0][o].l == ~0) {           while (o < lines[0].size () && lines[0][o].l == ~0) {
>       o += 1;                                                         o += 1;
>     }                                                               }
>                                                                 
>     // Find any unmatched lines at this point in the new file       // Find any unmatched lines at this point in the new file
>     // are inserts.                                                 // are inserts.
>                                                                 
>     unsigned boInserts = n;                                         unsigned boInserts = n;
>     while (n < lines[1].size () && lines[1][n].l == ~0) {           while (n < lines[1].size () && lines[1][n].l == ~0) {
>       n += 1;                                                         n += 1;
>     }                                                               }
>                                                                 
>     // We've got deleted line(s) from boDeletes .. o.               // We've got deleted line(s) from boDeletes .. o.
>     // We've got deleted line(s) from boInserts .. n.               // We've got deleted line(s) from boInserts .. n.
>                                                                 
>     unsigned nDeletes = o - boDeletes;                              unsigned nDeletes = o - boDeletes;
>     unsigned nInserts = n - boInserts;                              unsigned nInserts = n - boInserts;
>                                                                 
>     // We've got...                                                 // We've got...
>                                                                 
>     while (boDeletes < o && boInserts < n) {                        while (boDeletes < o && boInserts < n) {
>                                                                 
>       // ... deletes and inserts.                                     // ... deletes and inserts.
>                                                                 
>       fprintf (stdout,                                                fprintf (stdout,
>                "%-*s | %s\n",                                                  "%-*s | %s\n",
>                columnWidth,                                                    columnWidth,
>                lines[0][boDeletes].line->substr (0, columnWid                  lines[0][boDeletes].line->substr (0, columnWid
>                lines[1][boInserts].line->substr (0, columnWid                  lines[1][boInserts].line->substr (0, columnWid
>               );                                                              );
>       boDeletes += 1;                                                 boDeletes += 1;
>       boInserts += 1;                                                 boInserts += 1;
>     }                                                               }
>                                                                 
>     while (boDeletes < o) {                                         while (boDeletes < o) {
>                                                                 
>       //  ... just deletes.                                           //  ... just deletes.
>                                                                 
>       fprintf (stdout,                                                fprintf (stdout,
>                "%-*s <\n",                                                     "%-*s <\n",
>                columnWidth,                                                    columnWidth,
>                lines[0][boDeletes].line->substr (0, columnWid                  lines[0][boDeletes].line->substr (0, columnWid
>               );                                                              );
>       boDeletes += 1;                                                 boDeletes += 1;
>     }                                                               }
>                                                                 
>     while (boInserts < n) {                                         while (boInserts < n) {
>                                                                 
>       //  ... just inserts.                                           //  ... just inserts.
>                                                                 
>       fprintf (stdout,                                                fprintf (stdout,
>                "%-*s > %s\n",                                                  "%-*s > %s\n",
>                columnWidth,                                                    columnWidth,
>                "",                                                             "",
>                lines[1][boInserts].line->substr (0, columnWid                  lines[1][boInserts].line->substr (0, columnWid
>               );                                                              );
>       boInserts += 1;                                                 boInserts += 1;
>     }                                                               }
>                                                                 
>     // When we get here, we're dealing with matching lines.         // When we get here, we're dealing with matching lines.
>                                                                 
>     fprintf (stdout,                                                fprintf (stdout,
>              "%-*s   %s\n",                                                  "%-*s   %s\n",
>              columnWidth,                                                    columnWidth,
>              lines[0][o].line->substr (0, columnWidth).c_str                 lines[0][o].line->substr (0, columnWidth).c_str 
>              lines[1][n].line->substr (0, columnWidth).c_str                 lines[1][n].line->substr (0, columnWidth).c_str 
>             );                                                              );
>     o += 1;                                                         o += 1;
>     n += 1;                                                         n += 1;
>   }                                                               }
> }                                                               }
# ../sdiff -y dif.8.cpp dif.7.cpp >& dif.8.7.diff-y.test
./test: line 46: 23600 Aborted                 (core dumped) ${DIFF} "${option}" "${oSrc}" "${nSrc}" 1>&"${dst}.test"
# dif.8.7.diff-y ---------------------------------------------------------------
1,51c1,44
< #include <algorithm>						#include <algorithm>
< using std::find;						using std::find;
< #include <string>						#include <string>
< using std::string;						using std::string;
< #include <list>							#include <list>
< using std::list;						using std::list;
< #include <map>							#include <map>
< using std::map;							using std::map;
< #include <vector>						#include <vector>
< using std::vector;						using std::vector;
< #include <stdio.h>						#include <stdio.h>
< #include <getopt.h>					      <
< 
< enum DiffFormat {						enum DiffFormat {
<   opt_D_IfThenElse,					      |	  Default,
<   opt___Normal,						      <
<   opt_c_Context,					      <
<   opt_e_EdScript,					      <
<   opt_n_RCS,						      <
<   opt_u_Unified,					      <
<   opt_y_SideBySide					      <
< };							      <
< 
< DiffFormat opt___OutputFormat = opt___Normal;		      |	  Context,
< 							      >	  EdScript,
< 							      >	  IfThenElse,
< 							      >	  Normal,
< 							      >	  RCS,
< 							      >	  SideBySide,
< 							      >	  Unified
< 							      >	};
< 
< bool       opt_B_IgnoreBlankLines = false;		      |	DiffFormat diffFormat = SideBySide;
< unsigned   opt_C_LinesOfCopyContext = 3;		      <
< string     opt_D_IfdefName;				      <
< bool       opt_E_IgnoreTabExpansionChanges = false;	      <
< string     opt_F_ShowMostRecentLineMatching;		      <
< string     opt_I_IgnoreLinesMatching;			      <
< bool       opt_N_TreatAbsentFilesAsEmpty = false;	      <
< string     opt_S_StartWithFileMatching;			      <
< bool       opt_T_PrependATab = false;			      <
< unsigned   opt_U_LinesOfUnifiedContext = 3;		      <
< unsigned   opt_W_MaxPrintColumns = 130;			      <
< string     opt_X_ExcludeFilesMatching;			      <
< bool       opt_a_TreatAllFilesAsText = false;		      <
< bool       opt_b_IgnoreWhitespaceChanges = false;	      <
< bool       opt_d_TryToFindMinimalChanges = false;	      <
< bool       opt_i_IgnoreCaseDifferences = false;		      <
< bool       opt_l_PaginateWithPr = false;		      <
< bool       opt_p_ShowChangedCFunction = false;		      <
< bool       opt_q_OutputOnlyIfFilesDiffer = false;	      <
---
> #include <algorithm>                                            #include <algorithm>
> using std::find;                                                using std::find;
> #include <string>                                               #include <string>
> using std::string;                                              using std::string;
> #include <list>                                                 #include <list>
> using std::list;                                                using std::list;
> #include <map>                                                  #include <map>
> using std::map;                                                 using std::map;
> #include <vector>                                               #include <vector>
> using std::vector;                                              using std::vector;
> #include <stdio.h>                                              #include <stdio.h>
> #include <getopt.h>                                           <
>                                                                 
> enum DiffFormat {                                               enum DiffFormat {
>   opt_D_IfThenElse,                                           |   Default,
>   opt___Normal,                                               <
>   opt_c_Context,                                              <
>   opt_e_EdScript,                                             <
>   opt_n_RCS,                                                  <
>   opt_u_Unified,                                              <
>   opt_y_SideBySide                                            <
> };                                                            <
>                                                               <
> DiffFormat opt___OutputFormat = opt___Normal;                 <
>                                                                 
> bool       opt_B_IgnoreBlankLines = false;                    |   Context,
> unsigned   opt_C_LinesOfCopyContext = 3;                      |   EdScript,
> string     opt_D_IfdefName;                                   |   IfThenElse,
> bool       opt_E_IgnoreTabExpansionChanges = false;           |   Normal,
> string     opt_F_ShowMostRecentLineMatching;                  |   RCS,
> string     opt_I_IgnoreLinesMatching;                         |   SideBySide,
> bool       opt_N_TreatAbsentFilesAsEmpty = false;             |   Unified
> string     opt_S_StartWithFileMatching;                       | };
> bool       opt_T_PrependATab = false;                         | 
> unsigned   opt_U_LinesOfUnifiedContext = 3;                   | DiffFormat diffFormat = SideBySide;
> unsigned   opt_W_MaxPrintColumns = 130;                       <
> string     opt_X_ExcludeFilesMatching;                        <
> bool       opt_a_TreatAllFilesAsText = false;                 <
> bool       opt_b_IgnoreWhitespaceChanges = false;             <
> bool       opt_d_TryToFindMinimalChanges = false;             <
> bool       opt_i_IgnoreCaseDifferences = false;               <
> bool       opt_l_PaginateWithPr = false;                      <
> bool       opt_p_ShowChangedCFunction = false;                <
> bool       opt_q_OutputOnlyIfFilesDiffer = false;             <
53,1685c46,127
< bool       opt_s_ReportWhenFilesAreSame = false;	      <
< bool       opt_t_ExpandTabs = false;			      <
< bool       opt_v_ShowVersionInfo = false;		      <
< bool       opt_w_IgnoreAllWhitespace = false;		      <
< string     opt_x_IgnoreFilesMatching;			      <
< 
< 							      >	unsigned optCopyContext = 3;
< 							      >	unsigned optPageWidth = 130;
< unsigned optVerbose = 2;					unsigned optVerbose = 2;
< 
< struct Line : public string {					struct Line : public string {
<   Line (string _text) :						  Line (string _text) :
<     string (_text)						    string (_text)
<   {								  {
<   }								  }
<   ~Line () {							  ~Line () {
<     copies[0].erase (copies[0].begin (), copies[0].end ());	    copies[0].erase (copies[0].begin (), copies[0].end ());
<     copies[1].erase (copies[1].begin (), copies[1].end ());	    copies[1].erase (copies[1].begin (), copies[1].end ());
<   }								  }
<   void Dump (FILE *out) {					  void Dump (FILE *out) {
<     fprintf (out, "{{ ");					    fprintf (out, "{{ ");
<     for (list<unsigned>::iterator i = copies[0].begin (); i !	    for (list<unsigned>::iterator i = copies[0].begin (); i !
<       fprintf (out, "%u ", *i);					      fprintf (out, "%u ", *i);
<     }								    }
<     fprintf (out, "},{ ");					    fprintf (out, "},{ ");
<     for (list<unsigned>::iterator i = copies[1].begin (); i !	    for (list<unsigned>::iterator i = copies[1].begin (); i !
<       fprintf (out, "%u ", *i);					      fprintf (out, "%u ", *i);
<     }								    }
<     fprintf (out, "}}\t%s\n", c_str ());			    fprintf (out, "}}\t%s\n", c_str ());
<   }								  }
<   list<unsigned> copies[2];					  list<unsigned> copies[2];
< };								};
< 
< struct LinePtr {						struct LinePtr {
<   LinePtr (Line *_line) :					  LinePtr (Line *_line) :
<     line (_line),						    line (_line),
<     l (~0u)							    l (~0u)
<   {								  {
<   }								  }
<   void Dump (FILE *out) {					  void Dump (FILE *out) {
<     fprintf (out, "[%d] ", l);					    fprintf (out, "[%d] ", l);
<     line->Dump (out);						    line->Dump (out);
<   }								  }
<   Line *line;							  Line *line;
<   unsigned l;							  unsigned l;
< };								};
< 
< typedef map<string, Line *> MapStringToLinePtr;			typedef map<string, Line *> MapStringToLinePtr;
< typedef vector<LinePtr> VectorLinePtr;				typedef vector<LinePtr> VectorLinePtr;
< 
< // Our name.							// Our name.
< 
< char *ARGV0 = "dif3";						char *ARGV0 = "dif3";
< 
< // The 'symbol' (line) table.					// The 'symbol' (line) table.
< 
< MapStringToLinePtr table;					MapStringToLinePtr table;
< 
< // The names of the 2 files to be diff'd.			// The names of the 2 files to be diff'd.
< 
< char const *files[2] = { 0, 0 };				char const *files[2] = { 0, 0 };
< 
< // The lines of the 2 files to be diff'd.			// The lines of the 2 files to be diff'd.
< 
< VectorLinePtr lines[2];						VectorLinePtr lines[2];
< 
< // Miscellaneous metrics.					// Miscellaneous metrics.
< 
< unsigned nTotalMatchedBlocks = 0;				unsigned nTotalMatchedBlocks = 0;
< unsigned nMatchedBlocks = 0;					unsigned nMatchedBlocks = 0;
< unsigned nTotalMatchedLines = 0;				unsigned nTotalMatchedLines = 0;
< unsigned nMatchedLines = 0;					unsigned nMatchedLines = 0;
< 
< void getopts (int argc, char const *const argv[]);	      <
< 							      <
< void pass1 ();							void pass1 ();
< void pass2 ();							void pass2 ();
< void pass3 ();							void pass3 ();
< void pass4 ();							void pass4 ();
< void pass5 ();							void pass5 ();
< void pass6 ();							void pass6 ();
< 
< int main (int argc, char const *const argv[])		      |	int main (int argc, char *argv[])
< {								{
<   getopts (argc, argv);					      <
< 							      <
<   if (opt_v_ShowVersionInfo) {				      <
<     fprintf						      <
<       (stderr,						      <
<        "diff () 0.0.1"					      <
<        "Copyright (C) 2008 Sidney R Maxwell III"	      <
<        ""						      <
<        "This program comes with NO WARRANTY, to the extent pe <
<        "You may redistribute copies of this program"	      <
<        "under the terms of the GNU General Public License."   <
<        "For more information about these matters, see the fil <
<        ""						      <
<        "Written by Sid Maxwell."			      <
<       );						      <
<     exit (0);						      <
<   }							      <
< 							      <
<   // Read the old [0] file, and the new [1] file.		  // Read the old [0] file, and the new [1] file.
< 
<   for (int a = optind, n = 0; a < argc && n < 2; a += 1, n += |	  for (int a = 1, n = 0; a < argc && n < 2; a += 1, n += 1) {
<     files[n] = argv[a];						    files[n] = argv[a];
< 
<     if (FILE *f = fopen (files[n], "r")) {			    if (FILE *f = fopen (files[n], "r")) {
<       if (0 < optVerbose) {					      if (0 < optVerbose) {
<         fprintf (stderr, "# Reading %s...", files[n]);		        fprintf (stderr, "# Reading %s...", files[n]);
<         fflush (stderr);					        fflush (stderr);
<       }								      }
< 
<       char buffer[1024];					      char buffer[1024];
<       unsigned nUniq = 0;					      unsigned nUniq = 0;
< 
<       while (fgets (buffer, sizeof (buffer), f)) {		      while (fgets (buffer, sizeof (buffer), f)) {
<         string text (buffer);					        string text (buffer);
< 
<         text.erase (text.end () - 1);				        text.erase (text.end () - 1);
< 
<         Line *line = table[text];				        Line *line = table[text];
< 
<         if (!line) {						        if (!line) {
<           table[text] = line = new Line (text);			          table[text] = line = new Line (text);
<           nUniq += 1;						          nUniq += 1;
<         }							        }
<         line->copies[n].push_back (lines[n].size ());		        line->copies[n].push_back (lines[n].size ());
<         lines[n].push_back (line);				        lines[n].push_back (line);
<       }								      }
< 
<       if (0 < optVerbose) {					      if (0 < optVerbose) {
<         fprintf (stderr, " %u lines, %u unique.\n", lines[n].	        fprintf (stderr, " %u lines, %u unique.\n", lines[n].
<         fflush (stderr);					        fflush (stderr);
<       }								      }
<     } else {							    } else {
<       fprintf (stderr, "%s: Unable to open %s!  Exiting....\n	      fprintf (stderr, "%s: Unable to open %s!  Exiting....\n
<       fflush (stderr);						      fflush (stderr);
<       perror (ARGV0);						      perror (ARGV0);
<       exit (1);							      exit (1);
<     }								    }
<   }								  }
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Total unique lines = %d\n", table.siz	    fprintf (stderr, "# Total unique lines = %d\n", table.siz
<     fflush (stderr);						    fflush (stderr);
<   }								  }
< 
<   // map<int, int> counts;					  // map<int, int> counts;
<   // for (MapStringToLinePtr::iterator i = table.begin (); i 	  // for (MapStringToLinePtr::iterator i = table.begin (); i 
<   //   Line *l = i->second;					  //   Line *l = i->second;
<   //   counts[l->counts[0].size () + l->counts[1].size ()] +=	  //   counts[l->counts[0].size () + l->counts[1].size ()] +=
<   // }								  // }
<   // for (map<int, int>::iterator i = counts.begin (); i != c	  // for (map<int, int>::iterator i = counts.begin (); i != c
<   //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s	  //   fprintf (stderr, "# counts[%d] = %d\n", i->first, i->s
<   // }								  // }
< 
<   pass1 ();							  pass1 ();
<   pass2 ();							  pass2 ();
<   pass3 ();							  pass3 ();
<   pass4 ();							  pass4 ();
<   pass5 ();							  pass5 ();
<   pass6 ();							  pass6 ();
< 
<   return 0;							  return 0;
< }								}
< 
< // Usage: diff [OPTION]... FILES			      <
< // Compare files line by line.				      <
< // 							      <
< //   --GTYPE-group-format=GFMT  Similar, but format GTYPE inp <
< //   --LTYPE-line-format=LFMT  Similar, but format LTYPE inpu <
< //     LTYPE is `old', `new', or `unchanged'.  GTYPE is LTYPE <
< //     GFMT may contain:				      <
< //       %<  lines from FILE1				      <
< //       %>  lines from FILE2				      <
< //       %=  lines common to FILE1 and FILE2		      <
< //       %[-][WIDTH][.[PREC]]{doxX}LETTER  printf-style spec  <
< //         LETTERs are as follows for new group, lower case f <
< //           F  first line number			      <
< //           L  last line number			      <
< //           N  number of lines = L-F+1			      <
< //           E  F-1					      <
< //           M  L+1					      <
< //     LFMT may contain:				      <
< //       %L  contents of line				      <
< //       %l  contents of line, excluding any trailing newline <
< //       %[-][WIDTH][.[PREC]]{doxX}n  printf-style spec for i <
< //     Either GFMT or LFMT may contain:			      <
< //       %%  %						      <
< //       %c'C'  the single character C			      <
< //       %c'\OOO'  the character with octal code OOO	      <
< //							      <
< //   --brief  -q  Output only whether files differ.	      <
< //   --context[=NUM]  -c  -C NUM  Output NUM (default 3) line <
< //   --ed  -e  Output an ed script.			      <
< //   --exclude-from=FILE  -X FILE  Exclude files that match a <
< //   --exclude=PAT  -x PAT  Exclude files that match PAT.     <
< //   --expand-tabs  -t  Expand tabs to spaces in output.      <
< //   --from-file=FILE1  Compare FILE1 to all operands.  FILE1 <
< //   --help  Output this help.				      <
< //   --horizon-lines=NUM  Keep NUM lines of the common prefix <
< //   --ifdef=NAME  -D NAME  Output merged file to show `#ifde <
< //   --ignore-all-space  -w  Ignore all white space.	      <
< //   --ignore-blank-lines  -B  Ignore changes whose lines are <
< //   --ignore-case  -i  Ignore case differences in file conte <
< //   --ignore-file-name-case  Ignore case when comparing file <
< //   --ignore-matching-lines=RE  -I RE  Ignore changes whose  <
< //   --ignore-space-change  -b  Ignore changes in the amount  <
< //   --ignore-tab-expansion  -E  Ignore changes due to tab ex <
< //   --initial-tab  -T  Make tabs line up by prepending a tab <
< //   --label LABEL  Use LABEL instead of file name.	      <
< //   --left-column  Output only the left column of common lin <
< //   --line-format=LFMT  Similar, but format all input lines  <
< //   --minimal  -d  Try hard to find a smaller set of changes <
< //   --new-file  -N  Treat absent files as empty.	      <
< //   --no-ignore-file-name-case  Consider case when comparing <
< //   --normal  Output a normal diff.			      <
< //   --paginate  -l  Pass the output through `pr' to paginate <
< //   --rcs  -n  Output an RCS format diff.		      <
< //   --recursive  -r  Recursively compare any subdirectories  <
< //   --report-identical-files  -s  Report when two files are  <
< //   --show-c-function  -p  Show which C function each change <
< //   --show-function-line=RE  -F RE  Show the most recent lin <
< //   --side-by-side  -y  Output in two columns.		      <
< //   --speed-large-files  Assume large files and many scatter <
< //   --starting-file=FILE  -S FILE  Start with FILE when comp <
< //   --strip-trailing-cr  Strip trailing carriage return on i <
< //   --suppress-common-lines  Do not output common lines.     <
< //   --text  -a  Treat all files as text.		      <
< //   --to-file=FILE2  Compare all operands to FILE2.  FILE2 c <
< //   --unidirectional-new-file  Treat absent first files as e <
< //   --unified[=NUM]  -u  -U NUM  Output NUM (default 3) line <
< //   --version  -v  Output version info.		      <
< //   --width=NUM  -W NUM  Output at most NUM (default 130) pr <
< // 							      <
< // FILES are `FILE1 FILE2' or `DIR1 DIR2' or `DIR FILE...' or <
< // If --from-file or --to-file is given, there are no restric <
< // If a FILE is `-', read standard input.		      <
< // 							      <
< // Report bugs to <bug-gnu-utils@gnu.org>.		      <
< 							      <
< void getopts (int argc, char const *const argv[])	      <
< {							      <
<   while (1) {						      <
<     int option_index = 0;				      <
<     static option long_options[] = {			      <
<       { "brief",                        0, 0, 'q' }, // Outpu <
<       { "context",                      2, 0, 'c' }, // Outpu <
<       { "ed",                           0, 0, 'e' }, // Outpu <
<       { "exclude-from",                 1, 0, ' ' }, // Exclu <
<       { "exclude",                      1, 0, 'x' }, // Exclu <
<       { "expand-tabs",                  0, 0, 't' }, // Expan <
<       { "from-file",                    1, 0, ' ' }, // Compa <
<       { "help",                         0, 0, 'h' }, // Outpu <
<       { "horizon-lines",                1, 0, ' ' }, // Keep  <
<       { "ifdef",                        1, 0, 'D' }, // Outpu <
<       { "ignore-all-space",             0, 0, 'w' }, // Ignor <
<       { "ignore-blank-lines",           0, 0, 'B' }, // Ignor <
<       { "ignore-case",                  0, 0, 'i' }, // Ignor <
<       { "ignore-file-name-case",        0, 0, ' ' }, // Ignor <
<       { "ignore-matching-lines",        1, 0, 'I' }, // Ignor <
<       { "ignore-space-change",          0, 0, 'b' }, // Ignor <
<       { "ignore-tab-expansion",         0, 0, 'E' }, // Ignor <
<       { "initial-tab",                  0, 0, 'T' }, // Make  <
<       { "label",                        1, 0, ' ' }, // Use L <
<       { "left-column",                  0, 0, ' ' }, // Outpu <
<       { "line-format",                  1, 0, ' ' }, // Simil <
<       { "minimal",                      0, 0, 'd' }, // Try h <
<       { "new-file",                     0, 0, 'N' }, // Treat <
<       { "no-ignore-file-name-case",     0, 0, ' ' }, // Consi <
<       { "normal",                       0, 0, ' ' }, // Outpu <
<       { "paginate",                     0, 0, 'l' }, // Pass  <
<       { "rcs",                          0, 0, 'n' }, // Outpu <
<       { "recursive",                    0, 0, 'r' }, // Recur <
<       { "report-identical-files",       0, 0, 's' }, // Repor <
<       { "show-c-function",              0, 0, 'p' }, // Show  <
<       { "show-function-line",           1, 0, 'F' }, // Show  <
<       { "side-by-side",                 0, 0, 'y' }, // Outpu <
<       { "speed-large-files",            0, 0, ' ' }, // Assum <
<       { "starting-file",                1, 0, 'S' }, // Start <
<       { "strip-trailing-cr",            0, 0, ' ' }, // Strip <
<       { "suppress-common-lines",        0, 0, ' ' }, // Do no <
<       { "text",                         0, 0, 'a' }, // Treat <
<       { "to-file",                      0, 0, ' ' }, // Compa <
<       { "unidirectional-new-file",      0, 0, ' ' }, // Treat <
<       { "unified",                      2, 0, 'u' }, // Outpu <
<       { "version",                      0, 0, 'v' }, // Outpu <
<       { "width",                        1, 0, 'W' }, // Outpu <
<       { 0,				0, 0,   0 }	      <
<     };							      <
< 							      <
<     char const *short_options =				      <
<       "B"                       // Ignore changes whose lines <
<       "C:"                      // Output NUM (default 3) lin <
<       "D:"                      // Output merged file to show <
<       "E"                       // Ignore changes due to tab  <
<       "F:"                      // Show the most recent line  <
<       "I:"                      // Ignore changes whose lines <
<       "N"                       // Treat absent files as empt <
<       "S:"                      // Start with FILE when compa <
<       "T"                       // Make tabs line up by prepe <
<       "U:"                      // Output NUM (default 3) lin <
<       "W:"                      // Output at most NUM (defaul <
<       "X:"                      // Exclude files that match a <
<       "a"                       // Treat all files as text.   <
<       "b"                       // Ignore changes in the amou <
<       "c"                       // Output NUM (default 3) lin <
<       "d"                       // Try hard to find a smaller <
<       "e"                       // Output an ed script.	      <
<       "i"                       // Ignore case differences in <
<       "l"                       // Pass the output through `p <
<       "n"                       // Output an RCS format diff. <
<       "p"                       // Show which C function each <
<       "q"                       // Output only whether files  <
<       "r"                       // Recursively compare any su <
<       "s"                       // Report when two files are  <
<       "t"                       // Expand tabs to spaces in o <
<       "u"                       // Output NUM (default 3) lin <
<       "v"                       // Output version info.	      <
<       "w"                       // Ignore all white space.    <
<       "x:"                      // Exclude files that match P <
<       "y"                       // Output in two columns.     <
<       ;							      <
< 							      <
<     int c =						      <
<       getopt_long					      <
<         (argc,						      <
<          const_cast<char *const *> (argv),		      <
<          short_options,					      <
<          long_options,					      <
<          &option_index					      <
<         );						      <
< 							      <
<     switch (c) {					      <
<     case -1:						      <
<       return;						      <
< 							      <
<     case 0:						      <
<       printf ("option %s", long_options[option_index].name);  <
<       if (optarg)					      <
<         printf (" with arg %s", optarg);		      <
<       printf ("\n");					      <
<       break;						      <
<     case 'B':						      <
<       opt_B_IgnoreBlankLines = true;			      <
<       break;						      <
<     case 'C':						      <
<       {							      <
<         unsigned linesOfContext = 3;			      <
<         if (optarg) {					      <
<           if (sscanf (optarg, "%u", &linesOfContext) != 1) {  <
<             fprintf (stderr, "-C <NUM> or --context[=<NUM>] ( <
<             exit (1);					      <
<           }						      <
<         }						      <
<         opt_C_LinesOfCopyContext = linesOfContext;	      <
<       }							      <
<       break;						      <
<     case 'D':						      <
<       opt_D_IfdefName = optarg;				      <
<       break;						      <
<     case 'E':						      <
<       opt_E_IgnoreTabExpansionChanges = true;		      <
<       break;						      <
<     case 'F':						      <
<       opt_F_ShowMostRecentLineMatching = optarg;	      <
<       break;						      <
<     case 'I':						      <
<       opt_I_IgnoreLinesMatching = optarg;		      <
<       break;						      <
<     case 'N':						      <
<       opt_N_TreatAbsentFilesAsEmpty = true;		      <
<       break;						      <
<     case 'S':						      <
<       opt_S_StartWithFileMatching = optarg;		      <
<       break;						      <
<     case 'T':						      <
<       opt_T_PrependATab = true;				      <
<       break;						      <
<     case 'U':						      <
<       {							      <
<         unsigned linesOfContext = 3;			      <
<         if (optarg) {					      <
<           if (sscanf (optarg, "%u", &linesOfContext) != 1) {  <
<             fprintf (stderr, "-U <NUM> or --unified[=<NUM>] ( <
<             exit (1);					      <
<           }						      <
<         }						      <
<         opt_U_LinesOfUnifiedContext = linesOfContext;	      <
<       }							      <
<       break;						      <
<     case 'W':						      <
<       {							      <
<         unsigned maxPrintColumns = 130;			      <
<         if (optarg) {					      <
<           if (sscanf (optarg, "%u", &maxPrintColumns) != 1) { <
<             fprintf (stderr, "-W <NUM> or --width[=<NUM>] (%d <
<             exit (1);					      <
<           }						      <
<         }						      <
<         opt_W_MaxPrintColumns = maxPrintColumns;	      <
<       }							      <
<       break;						      <
<     case 'X':						      <
<       opt_X_ExcludeFilesMatching = optarg;		      <
<       break;						      <
<     case 'a':						      <
<       opt_a_TreatAllFilesAsText = true;			      <
<       break;						      <
<     case 'b':						      <
<       opt_b_IgnoreWhitespaceChanges = true;		      <
<       break;						      <
<     case 'c':						      <
<       opt___OutputFormat = opt_c_Context;		      <
<       break;						      <
<     case 'd':						      <
<       opt_d_TryToFindMinimalChanges = true;		      <
<       break;						      <
<     case 'e':						      <
<       opt___OutputFormat = opt_e_EdScript;		      <
<       break;						      <
<     case 'i':						      <
<       opt_i_IgnoreCaseDifferences = true;		      <
<       break;						      <
<     case 'l':						      <
<       opt_l_PaginateWithPr = true;			      <
<       break;						      <
<     case 'n':						      <
<       opt___OutputFormat = opt_n_RCS;			      <
<       break;						      <
<     case 'p':						      <
<       opt_p_ShowChangedCFunction = true;		      <
<       break;						      <
<     case 'q':						      <
<       opt_q_OutputOnlyIfFilesDiffer = true;		      <
<       break;						      <
<     case 'r':						      <
<       opt_r_RecursivelyCompareSubdirectories = true;	      <
<       break;						      <
<     case 's':						      <
<       opt_s_ReportWhenFilesAreSame = true;		      <
<       break;						      <
<     case 't':						      <
<       opt_t_ExpandTabs = true;				      <
<       break;						      <
<     case 'u':						      <
<       opt___OutputFormat = opt_u_Unified;		      <
<       break;						      <
<     case 'v':						      <
<       opt_v_ShowVersionInfo = true;			      <
<       break;						      <
<     case 'w':						      <
<       opt_w_IgnoreAllWhitespace = true;			      <
<       break;						      <
<     case 'x':						      <
<       opt_x_IgnoreFilesMatching = optarg;		      <
<       break;						      <
<     case 'y':						      <
<       opt___OutputFormat = opt_y_SideBySide;		      <
<       break;						      <
<     case 'h':						      <
<     case '?':						      <
<       fprintf						      <
<         (stderr,					      <
<          "Usage: diff [OPTION]... FILES\n"		      <
<          "Compare files line by line.\n"		      <
<          "\n"						      <
<          "  --GTYPE-group-format=GFMT  Similar, but format GT <
<          "  --LTYPE-line-format=LFMT  Similar, but format LTY <
<          "    LTYPE is `old', `new', or `unchanged'.  GTYPE i <
<          "    GFMT may contain:\n"			      <
<          "      %<  lines from FILE1\n"			      <
<          "      %>  lines from FILE2\n"			      <
<          "      %=  lines common to FILE1 and FILE2\n"	      <
<          "      %[-][WIDTH][.[PREC]]{doxX}LETTER  printf-styl <
<          "        LETTERs are as follows for new group, lower <
<          "          F  first line number\n"		      <
<          "          L  last line number\n"		      <
<          "          N  number of lines = L-F+1\n"	      <
<          "          E  F-1\n"				      <
<          "          M  L+1\n"				      <
<          "    LFMT may contain:\n"			      <
<          "      %L  contents of line\n"			      <
<          "      %l  contents of line, excluding any trailing  <
<          "      %[-][WIDTH][.[PREC]]{doxX}n  printf-style spe <
<          "    Either GFMT or LFMT may contain:\n"	      <
<          "      %%  %\n"				      <
<          "      %c'C'  the single character C\n"	      <
<          "      %c'\\OOO'  the character with octal code OOO\ <
<          "\n"						      <
<          "  --brief  -q  Output only whether files differ.\n" <
<          "  --context[=NUM]  -c  -C NUM  Output NUM (default  <
<          "  --ed  -e  Output an ed script.\n"		      <
<          "  --exclude-from=FILE  -X FILE  Exclude files that  <
<          "  --exclude=PAT  -x PAT  Exclude files that match P <
<          "  --expand-tabs  -t  Expand tabs to spaces in outpu <
<          "  --from-file=FILE1  Compare FILE1 to all operands. <
<          "  --help  Output this help.\n"		      <
<          "  --horizon-lines=NUM  Keep NUM lines of the common <
<          "  --ifdef=NAME  -D NAME  Output merged file to show <
<          "  --ignore-all-space  -w  Ignore all white space.\n <
<          "  --ignore-blank-lines  -B  Ignore changes whose li <
<          "  --ignore-case  -i  Ignore case differences in fil <
<          "  --ignore-file-name-case  Ignore case when compari <
<          "  --ignore-matching-lines=RE  -I RE  Ignore changes <
<          "  --ignore-space-change  -b  Ignore changes in the  <
<          "  --ignore-tab-expansion  -E  Ignore changes due to <
<          "  --initial-tab  -T  Make tabs line up by prependin <
<          "  --label LABEL  Use LABEL instead of file name.\n" <
<          "  --left-column  Output only the left column of com <
<          "  --line-format=LFMT  Similar, but format all input <
<          "  --minimal  -d  Try hard to find a smaller set of  <
<          "  --new-file  -N  Treat absent files as empty.\n"   <
<          "  --no-ignore-file-name-case  Consider case when co <
<          "  --normal  Output a normal diff.\n"		      <
<          "  --paginate  -l  Pass the output through `pr' to p <
<          "  --rcs  -n  Output an RCS format diff.\n"	      <
<          "  --recursive  -r  Recursively compare any subdirec <
<          "  --report-identical-files  -s  Report when two fil <
<          "  --show-c-function  -p  Show which C function each <
<          "  --show-function-line=RE  -F RE  Show the most rec <
<          "  --side-by-side  -y  Output in two columns.\n"     <
<          "  --speed-large-files  Assume large files and many  <
<          "  --starting-file=FILE  -S FILE  Start with FILE wh <
<          "  --strip-trailing-cr  Strip trailing carriage retu <
<          "  --suppress-common-lines  Do not output common lin <
<          "  --text  -a  Treat all files as text.\n"	      <
<          "  --to-file=FILE2  Compare all operands to FILE2.   <
<          "  --unidirectional-new-file  Treat absent first fil <
<          "  --unified[=NUM]  -u  -U NUM  Output NUM (default  <
<          "  --version  -v  Output version info.\n"	      <
<          "  --width=NUM  -W NUM  Output at most NUM (default  <
<          "\n"						      <
<          "FILES are `FILE1 FILE2' or `DIR1 DIR2' or `DIR FILE <
<          "If --from-file or --to-file is given, there are no  <
<          "If a FILE is `-', read standard input.\n"	      <
<          "\n"						      <
<          "Report bugs to <bug-gnu-utils@gnu.org>.\n"	      <
<         );						      <
<       exit (1);						      <
<     default:						      <
<       fprintf (stderr, "Unhandled option (%c%s)!\n", c, optar <
<       exit (1);						      <
<     }							      <
<   }							      <
< }							      <
< 							      <
< // Perform pass #1, in which we find all explicit matches amo	// Perform pass #1, in which we find all explicit matches amo
< // unique lines.  For every unique line that appears the same	// unique lines.  For every unique line that appears the same
< // of times in both files, we declare the lines to match.	// of times in both files, we declare the lines to match.
< 
< void pass1 ()							void pass1 ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass 1 (finding matches amongst uniqu	    fprintf (stderr, "# Pass 1 (finding matches amongst uniqu
<     fflush (stderr);						    fflush (stderr);
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   for (MapStringToLinePtr::iterator i = table.begin (); i != 	  for (MapStringToLinePtr::iterator i = table.begin (); i != 
<     Line *l = i->second;					    Line *l = i->second;
< 
<     // If the number of old and new lines match, then we decl	    // If the number of old and new lines match, then we decl
<     // they are (all) the same line.  Note, it isn't possible	    // they are (all) the same line.  Note, it isn't possible
<     // numbers of both files to be 0.				    // numbers of both files to be 0.
< 
<     // (In the original algorithm, we only recognized a match	    // (In the original algorithm, we only recognized a match
<     // if there was exactly 1 copy for each file.)		    // if there was exactly 1 copy for each file.)
< 
<     if (l->copies[0].size () == l->copies[1].size ()) {		    if (l->copies[0].size () == l->copies[1].size ()) {
<       nMatchedLines += 1;					      nMatchedLines += 1;
< 
<       // For each matched line in the new file, mark it with 	      // For each matched line in the new file, mark it with 
<       // corresponding line (number) in the old file.		      // corresponding line (number) in the old file.
< 
<       while (!l->copies[0].empty ()) {				      while (!l->copies[0].empty ()) {
<         unsigned o = l->copies[0].front ();			        unsigned o = l->copies[0].front ();
<         unsigned n = l->copies[1].front ();			        unsigned n = l->copies[1].front ();
< 
<         // Match up the pair.					        // Match up the pair.
< 
<         lines[0][o].l = n;					        lines[0][o].l = n;
<         lines[1][n].l = o;					        lines[1][n].l = o;
< 
<         // Remove the matched line numbers from the lists.	        // Remove the matched line numbers from the lists.
< 
<         l->copies[0].pop_front ();				        l->copies[0].pop_front ();
<         l->copies[1].pop_front ();				        l->copies[1].pop_front ();
<       }								      }
<     }								    }
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, " found %u matched lines (%u total).\n",	    fprintf (stderr, " found %u matched lines (%u total).\n",
<     fflush (stderr);						    fflush (stderr);
< 
<     if (2 < optVerbose) {					    if (2 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         fflush (stderr);					        fflush (stderr);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           fflush (stderr);					          fflush (stderr);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< }								}
< 
< // Perform Pass #2, in which we attempt to 'widen' blocks of 	// Perform Pass #2, in which we attempt to 'widen' blocks of 
< // lines, by appending lines which are the same in both files	// lines, by appending lines which are the same in both files
< 
< void pass2 ()							void pass2 ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #2 (spreading matches down)...")	    fprintf (stderr, "# Pass #2 (spreading matches down)...")
<     fflush (stderr);						    fflush (stderr);
<   }								  }
< 
<   nMatchedBlocks = 0;						  nMatchedBlocks = 0;
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Starting at the top of the old file,...			  // Starting at the top of the old file,...
< 
<   for (unsigned o = 0; o < lines[0].size (); o += 1) {		  for (unsigned o = 0; o < lines[0].size (); o += 1) {
< 
<     // ... skip any currently unmatched lines...		    // ... skip any currently unmatched lines...
< 
<     if (lines[0][o].l == ~0) {					    if (lines[0][o].l == ~0) {
<       continue;							      continue;
<     }								    }
< 
<     // ... until we find an [already] matched line.  Then, sk	    // ... until we find an [already] matched line.  Then, sk
<     // the set of 1 or more matched lines, until we reach any	    // the set of 1 or more matched lines, until we reach any
<     // following, still-unmatched line.				    // following, still-unmatched line.
< 
<     unsigned n;							    unsigned n;
<     do {							    do {
<       n = lines[0][o].l + 1;					      n = lines[0][o].l + 1;
<       o += 1;							      o += 1;
<     } while (o < lines[0].size () && lines[0][o].l != ~0);	    } while (o < lines[0].size () && lines[0][o].l != ~0);
< 
<     // Now, o - 1 is the line number of the last matched old 	    // Now, o - 1 is the line number of the last matched old 
<     // n - 1 is the line number of the last matched new line.	    // n - 1 is the line number of the last matched new line.
<     // to add new old and new lines, if they match.		    // to add new old and new lines, if they match.
< 
<     // Finally, attempt to add unmatched lines to the preceed	    // Finally, attempt to add unmatched lines to the preceed
<     // matched set.						    // matched set.
< 
<     for (; o < lines[0].size () && lines[0][o].l == ~0; o += 	    for (; o < lines[0].size () && lines[0][o].l == ~0; o += 
< 
<       // If the [next] pair of old and new lines aren't the s	      // If the [next] pair of old and new lines aren't the s
< 
<       if (lines[0][o].line != lines[1][n].line) {		      if (lines[0][o].line != lines[1][n].line) {
<         break;							        break;
<       }								      }
< 
<       // Match up the pair.					      // Match up the pair.
< 
<       lines[0][o].l = n;					      lines[0][o].l = n;
<       lines[1][n].l = o;					      lines[1][n].l = o;
< 
<       // Remove the matched line numbers form the lists.	      // Remove the matched line numbers form the lists.
< 
<       Line *line = lines[0][o].line;				      Line *line = lines[0][o].line;
<       list<unsigned> &oldCopies = line->copies[0];		      list<unsigned> &oldCopies = line->copies[0];
<       list<unsigned>::iterator oL = find (oldCopies.begin (),	      list<unsigned>::iterator oL = find (oldCopies.begin (),
<       if (oL != oldCopies.end ()) {				      if (oL != oldCopies.end ()) {
<         oldCopies.erase (oL);					        oldCopies.erase (oL);
<       }								      }
<       list<unsigned> &newCopies = line->copies[0];		      list<unsigned> &newCopies = line->copies[0];
<       list<unsigned>::iterator nL = find (newCopies.begin (),	      list<unsigned>::iterator nL = find (newCopies.begin (),
<       if (nL != newCopies.end ()) {				      if (nL != newCopies.end ()) {
<         newCopies.erase (nL);					        newCopies.erase (nL);
<       }								      }
< 
<       nMatchedLines += 1;					      nMatchedLines += 1;
<     }								    }
<     nMatchedBlocks += 1;					    nMatchedBlocks += 1;
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
<   nTotalMatchedBlocks += nMatchedBlocks;			  nTotalMatchedBlocks += nMatchedBlocks;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr,						    fprintf (stderr,
<              " found %u/%u matched lines/blocks (%u/%u totals	             " found %u/%u matched lines/blocks (%u/%u totals
<              nMatchedLines,					             nMatchedLines,
<              nMatchedBlocks,					             nMatchedBlocks,
<              nTotalMatchedLines,				             nTotalMatchedLines,
<              nTotalMatchedBlocks				             nTotalMatchedBlocks
<             );							            );
<     fflush (stderr);						    fflush (stderr);
<     if (2 < optVerbose) {					    if (2 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         fflush (stderr);					        fflush (stderr);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           fflush (stderr);					          fflush (stderr);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< }								}
< 
< // Perform Pass #3, in which we attempt to 'widen' blocks of 	// Perform Pass #3, in which we attempt to 'widen' blocks of 
< // lines, by prepending lines which are the same in both file	// lines, by prepending lines which are the same in both file
< 
< void pass3 ()							void pass3 ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #3 (spreading matches up)...");	    fprintf (stderr, "# Pass #3 (spreading matches up)...");
<     fflush (stderr);						    fflush (stderr);
<   }								  }
< 
<   nMatchedBlocks = 0;						  nMatchedBlocks = 0;
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Starting at the bottom of the old file,...			  // Starting at the bottom of the old file,...
< 
<   for (int o = lines[0].size (); 0 <= o; o -= 1) {		  for (int o = lines[0].size (); 0 <= o; o -= 1) {
< 
<     // ... skip any currently unmatched lines...		    // ... skip any currently unmatched lines...
< 
<     if (lines[0][o].l == ~0) {					    if (lines[0][o].l == ~0) {
<       continue;							      continue;
<     }								    }
< 
<     // ... until we find an [already] matched line.  Then, sk	    // ... until we find an [already] matched line.  Then, sk
<     // the set of 1 or more matched lines, until we reach any	    // the set of 1 or more matched lines, until we reach any
<     // following, still-unmatched line.				    // following, still-unmatched line.
< 
<     unsigned n;							    unsigned n;
<     do {							    do {
<       n = lines[0][o].l - 1;					      n = lines[0][o].l - 1;
<       o -= 1;							      o -= 1;
<     } while (0 <= o && lines[0][o].l != ~0);			    } while (0 <= o && lines[0][o].l != ~0);
< 
<     // Now, o + 1 is the line number of the last matched old 	    // Now, o + 1 is the line number of the last matched old 
<     // n + 1 is the line number of the last matched new line.	    // n + 1 is the line number of the last matched new line.
<     // to add new old and new lines, if they match.		    // to add new old and new lines, if they match.
< 
<     // Finally, attempt to add unmatched lines to the preceed	    // Finally, attempt to add unmatched lines to the preceed
<     // matched set.						    // matched set.
< 
<     for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {	    for (; 0 <= o && lines[0][o].l == ~0; o -= 1, n -= 1) {
< 
<       // If the [next] pair of old and new lines aren't the s	      // If the [next] pair of old and new lines aren't the s
< 
<       if (lines[0][o].line != lines[1][n].line) {		      if (lines[0][o].line != lines[1][n].line) {
<         break;							        break;
<       }								      }
< 
<       // Match up the pair.					      // Match up the pair.
< 
<       lines[0][o].l = n;					      lines[0][o].l = n;
<       lines[1][n].l = o;					      lines[1][n].l = o;
< 
<       // Remove the matched line numbers form the lists.	      // Remove the matched line numbers form the lists.
< 
<       Line *line = lines[0][o].line;				      Line *line = lines[0][o].line;
<       list<unsigned> &oldCopies = line->copies[0];		      list<unsigned> &oldCopies = line->copies[0];
<       list<unsigned>::iterator oL = find (oldCopies.begin (),	      list<unsigned>::iterator oL = find (oldCopies.begin (),
<       if (oL != oldCopies.end ()) {				      if (oL != oldCopies.end ()) {
<         oldCopies.erase (oL);					        oldCopies.erase (oL);
<       }								      }
<       list<unsigned> &newCopies = line->copies[0];		      list<unsigned> &newCopies = line->copies[0];
<       list<unsigned>::iterator nL = find (newCopies.begin (),	      list<unsigned>::iterator nL = find (newCopies.begin (),
<       if (nL != newCopies.end ()) {				      if (nL != newCopies.end ()) {
<         newCopies.erase (nL);					        newCopies.erase (nL);
<       }								      }
< 
<       nMatchedLines += 1;					      nMatchedLines += 1;
<     }								    }
<     nMatchedBlocks += 1;					    nMatchedBlocks += 1;
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr,						    fprintf (stderr,
<              " found %u/%u matched lines/blocks (%u/%u totals	             " found %u/%u matched lines/blocks (%u/%u totals
<              nMatchedLines,					             nMatchedLines,
<              nMatchedBlocks,					             nMatchedBlocks,
<              nTotalMatchedLines,				             nTotalMatchedLines,
<              nTotalMatchedBlocks				             nTotalMatchedBlocks
<             );							            );
<     fflush (stderr);						    fflush (stderr);
< 
<     if (2 < optVerbose) {					    if (2 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         fflush (stderr);					        fflush (stderr);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           fflush (stderr);					          fflush (stderr);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< }								}
< 
< // Perform pass #4, in which we find any remaining matches am	// Perform pass #4, in which we find any remaining matches am
< // unique lines.  For every unique line that has more than 1 	// unique lines.  For every unique line that has more than 1 
< // both files, we declare the copies to match.			// both files, we declare the copies to match.
< 
< void pass4 ()							void pass4 ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass 4 (finding remaining matches amo	    fprintf (stderr, "# Pass 4 (finding remaining matches amo
<     fflush (stderr);						    fflush (stderr);
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   for (MapStringToLinePtr::iterator i = table.begin (); i != 	  for (MapStringToLinePtr::iterator i = table.begin (); i != 
<     Line *l = i->second;					    Line *l = i->second;
< 
<     // If there's more than 1 matching old and new lines, the	    // If there's more than 1 matching old and new lines, the
<     // declare that each pair are (all) the same line.		    // declare that each pair are (all) the same line.
< 
<     // (In the original algorithm, we only recognized a match	    // (In the original algorithm, we only recognized a match
<     // if there was exactly 1 copy for each file.)		    // if there was exactly 1 copy for each file.)
< 
<     while (0 < l->copies[0].size () && 0 < l->copies[1].size 	    while (0 < l->copies[0].size () && 0 < l->copies[1].size 
<       nMatchedLines += 1;					      nMatchedLines += 1;
< 
<       // For each matched line in the new file, mark it with 	      // For each matched line in the new file, mark it with 
<       // corresponding line (number) in the old file.		      // corresponding line (number) in the old file.
< 
<       unsigned o = l->copies[0].front ();			      unsigned o = l->copies[0].front ();
<       unsigned n = l->copies[1].front ();			      unsigned n = l->copies[1].front ();
< 
<       // Match up the pair.					      // Match up the pair.
< 
<       lines[0][o].l = n;					      lines[0][o].l = n;
<       lines[1][n].l = o;					      lines[1][n].l = o;
< 
<       // Remove the matched line numbers from the lists.	      // Remove the matched line numbers from the lists.
< 
<       l->copies[0].pop_front ();				      l->copies[0].pop_front ();
<       l->copies[1].pop_front ();				      l->copies[1].pop_front ();
<     }								    }
<   }								  }
<   nTotalMatchedLines += nMatchedLines;				  nTotalMatchedLines += nMatchedLines;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, " found %u matched lines (%u total).\n",	    fprintf (stderr, " found %u matched lines (%u total).\n",
<     fflush (stderr);						    fflush (stderr);
< 
<     if (2 < optVerbose) {					    if (2 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         fflush (stderr);					        fflush (stderr);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           fflush (stderr);					          fflush (stderr);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< }								}
< 
< // Perform Pass #5, in which we look for blocks which match, 	// Perform Pass #5, in which we look for blocks which match, 
< // the result of a move (their not in their original position	// the result of a move (their not in their original position
< // these, we'll unmatch the blocks, turning them into a delet	// these, we'll unmatch the blocks, turning them into a delet
< // insert.							// insert.
< 
< void pass5 ()							void pass5 ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #5 (unmatching block moves)...\n	    fprintf (stderr, "# Pass #5 (unmatching block moves)...\n
<     fflush (stderr);						    fflush (stderr);
<   }								  }
< 
<   nMatchedBlocks = 0;						  nMatchedBlocks = 0;
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Starting at the top of both files,...			  // Starting at the top of both files,...
< 
<   unsigned o = 0;						  unsigned o = 0;
<   unsigned n = 0;						  unsigned n = 0;
< 
<   while (o < lines[0].size () || n < lines[1].size ()) {	  while (o < lines[0].size () || n < lines[1].size ()) {
< 
<     // Skip any unmatched lines at this point in the old file	    // Skip any unmatched lines at this point in the old file
<     // are deletes.						    // are deletes.
< 
<     //    Old     New						    //    Old     New
<     //   +---+							    //   +---+
<     // 0 | a |							    // 0 | a |
<     //   +---+   +---+						    //   +---+   +---+
<     //         0 | b |						    //         0 | b |
<     //   +---+   +---+						    //   +---+   +---+
<     // 1 | c | 1 | c |						    // 1 | c | 1 | c |
<     //   +---+   +---+						    //   +---+   +---+
<     //         2 | z |						    //         2 | z |
<     //   +---+   +---+						    //   +---+   +---+
<     // 2 | d | 3 | d |						    // 2 | d | 3 | d |
<     //   +---+   +---+						    //   +---+   +---+
< 
<     while (o < lines[0].size () && lines[0][o].l == ~0) {	    while (o < lines[0].size () && lines[0][o].l == ~0) {
<       o += 1;							      o += 1;
<     }								    }
< 
<     // Skip any unmatched lines at this point in the new file	    // Skip any unmatched lines at this point in the new file
<     // are inserts.						    // are inserts.
< 
<     while (n < lines[1].size () && lines[1][n].l == ~0) {	    while (n < lines[1].size () && lines[1][n].l == ~0) {
<       n += 1;							      n += 1;
<     }								    }
< 
<     // When we get here, we know that we're dealing with matc	    // When we get here, we know that we're dealing with matc
<     // lines (or the end of one or both files).  We're done w	    // lines (or the end of one or both files).  We're done w
<     // pass, if we've reached the end of either file.		    // pass, if we've reached the end of either file.
< 
<     if (lines[0].size () <= o || lines[1].size () <= n) {	    if (lines[0].size () <= o || lines[1].size () <= n) {
<       break;							      break;
<     }								    }
< 
<     // We now know that we've got a pair of matching lines, t	    // We now know that we've got a pair of matching lines, t
<     // of a matching block.  If the new file's line number is	    // of a matching block.  If the new file's line number is
<     // expect, then the matched pair is unmoved, and we can s	    // expect, then the matched pair is unmoved, and we can s
<     // the pair.  (If this is really the start of a block of 	    // the pair.  (If this is really the start of a block of 
<     // 1 lines, we'll handle it one pair at a time.)		    // 1 lines, we'll handle it one pair at a time.)
< 
<     if (lines[0][o].l == n) {					    if (lines[0][o].l == n) {
<       o += 1;							      o += 1;
<       n += 1;							      n += 1;
<       continue;							      continue;
<     }								    }
< 
<     // If, on the other hand, we don't expect this [new] line	    // If, on the other hand, we don't expect this [new] line
<     // then this matching block has been moved.  We need to t	    // then this matching block has been moved.  We need to t
<     // matched pair into an *unmatched* pair, one of deletes,	    // matched pair into an *unmatched* pair, one of deletes,
<     // of inserts.  First, though, we need to know how big th	    // of inserts.  First, though, we need to know how big th
<     // is, and how far it was moved....				    // is, and how far it was moved....
< 
<     // Remember where we were when we started.			    // Remember where we were when we started.
< 
<     unsigned oOld = o;						    unsigned oOld = o;
<     unsigned nOld = n;						    unsigned nOld = n;
< 
<     // Remember where the block came from.			    // Remember where the block came from.
< 
<     unsigned nNew = lines[0][o].l;				    unsigned nNew = lines[0][o].l;
< 
<     // Find the end of this matched pair.			    // Find the end of this matched pair.
< 
<     for (n = nNew; o < lines[0].size () && n < lines[1].size 	    for (n = nNew; o < lines[0].size () && n < lines[1].size 
<       if (lines[0][o].l != n) {					      if (lines[0][o].l != n) {
<         break;							        break;
<       }								      }
<     }								    }
< 
<     // When we get here:					    // When we get here:
<     // * oOld..o is the old file's block,			    // * oOld..o is the old file's block,
<     // * nNew..n is the new file's *moved* block, and		    // * nNew..n is the new file's *moved* block, and
<     // * nOld is where we originally expected the new block f	    // * nOld is where we originally expected the new block f
<  								 
<     // We can now calculate the length of the block...		    // We can now calculate the length of the block...
<     								    
<     unsigned bSize = o - oOld;  // (or n - nNew)		    unsigned bSize = o - oOld;  // (or n - nNew)
< 
<     // ... and we can calculate how far the block moved:	    // ... and we can calculate how far the block moved:
< 
<     unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;	    unsigned bMove = nOld < nNew ? nNew - nOld : nOld - nNew;
< 
<     // The larger of the two will become our delete, and the 	    // The larger of the two will become our delete, and the 
<     // will become our insert.					    // will become our insert.
< 
<     //    Old     New						    //    Old     New
<     //   +---+   +---+						    //   +---+   +---+
<     // 0 | a | 0 | b |						    // 0 | a | 0 | b |
<     //   +---+ 1 | b |						    //   +---+ 1 | b |
<     // 1 | b |   +---+						    // 1 | b |   +---+
<     // 2 | b | 2 | a |						    // 2 | b | 2 | a |
<     //   +---+   +---+						    //   +---+   +---+
<     // 3 | c | 3 | c |						    // 3 | c | 3 | c |
<     //   +---+   +---+						    //   +---+   +---+
< 
<     // (1) Delete a@0, insert a@2, or				    // (1) Delete a@0, insert a@2, or
<     // (2) insert bb@0, delete bb@1?				    // (2) insert bb@0, delete bb@1?
< 
<     // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and	    // In (1), bSize (of a) is 1-0 or 1, the size of a@0, and
<     // (of a) is 2-0 or 2, the size of b@0.  We choose to del	    // (of a) is 2-0 or 2, the size of b@0.  We choose to del
<     // and reinsert a@2.					    // and reinsert a@2.
< 
<     // if (bSize <= bMove) {					    // if (bSize <= bMove) {
<       for (unsigned a = oOld; a < o; a += 1) {			      for (unsigned a = oOld; a < o; a += 1) {
<         lines[0][a].l = ~0;					        lines[0][a].l = ~0;
<       }								      }
<       for (unsigned d = nNew; d < n; d += 1) {			      for (unsigned d = nNew; d < n; d += 1) {
<         lines[1][d].l = ~0;					        lines[1][d].l = ~0;
<       }								      }
<     // } else {							    // } else {
<       // for (unsigned a = oOld; a < o; a += 1) {		      // for (unsigned a = oOld; a < o; a += 1) {
<       //   lines[0][a].l = ~0;					      //   lines[0][a].l = ~0;
<       // }							      // }
<       // for (unsigned d = nNew; d < n; d += 1) {		      // for (unsigned d = nNew; d < n; d += 1) {
<       //   lines[1][d].l = ~0;					      //   lines[1][d].l = ~0;
<       // }							      // }
<     // }							    // }
< 
<     // Continue from where we left off.				    // Continue from where we left off.
< 
<     n = nOld;							    n = nOld;
<   }								  }
<   nTotalMatchedLines -= nMatchedLines;				  nTotalMatchedLines -= nMatchedLines;
<   nTotalMatchedBlocks -= nMatchedBlocks;			  nTotalMatchedBlocks -= nMatchedBlocks;
< 
<   // Let's see the intermediate results.			  // Let's see the intermediate results.
< 
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr,						    fprintf (stderr,
<              " found %u/%u matched lines/blocks (%u/%u totals	             " found %u/%u matched lines/blocks (%u/%u totals
<              nMatchedLines,					             nMatchedLines,
<              nMatchedBlocks,					             nMatchedBlocks,
<              nTotalMatchedLines,				             nTotalMatchedLines,
<              nTotalMatchedBlocks				             nTotalMatchedBlocks
<             );							            );
<     fflush (stderr);						    fflush (stderr);
< 
<     if (2 < optVerbose) {					    if (2 < optVerbose) {
<       for (int f = 0; f < 2; f += 1) {				      for (int f = 0; f < 2; f += 1) {
<         fprintf (stderr, "# file #%d\n", f + 1);		        fprintf (stderr, "# file #%d\n", f + 1);
<         fflush (stderr);					        fflush (stderr);
<         for (int l = 0; l < lines[f].size (); l += 1) {		        for (int l = 0; l < lines[f].size (); l += 1) {
<           fprintf (stderr, "#   [%d] ", l);			          fprintf (stderr, "#   [%d] ", l);
<           fflush (stderr);					          fflush (stderr);
<           lines[f][l].Dump (stderr);				          lines[f][l].Dump (stderr);
<         }							        }
<       }								      }
<     }								    }
<   }								  }
< }								}
< 
< // Perform Pass #6, in which we create the desired output.	// Perform Pass #6, in which we create the desired output.
< 
< void pass6c ();							void pass6c ();
< void pass6e ();							void pass6e ();
< void pass6i ();							void pass6i ();
< void pass6n ();							void pass6n ();
< void pass6r ();							void pass6r ();
< void pass6s ();							void pass6s ();
< void pass6u ();							void pass6u ();
< void pass6y ();							void pass6y ();
< 
< void pass6 ()							void pass6 ()
< {								{
<   switch (opt___OutputFormat) {				      |
<   case opt_c_Context:					      |	  switch (diffFormat) {
< 							      >	  case Context:
<     pass6c ();							    pass6c ();
<     break;							    break;
< 
<   case opt_e_EdScript:					      |	  case EdScript:
<     pass6e ();							    pass6e ();
<     break;							    break;
< 
<   case opt_D_IfThenElse:				      |	  case IfThenElse:
<     pass6i ();							    pass6i ();
<     break;							    break;
< 
<   case opt___Normal:					      |	  case Normal:
<     pass6n ();							    pass6n ();
<     break;							    break;
< 
<   case opt_n_RCS:					      |	  case RCS:
<     pass6r ();							    pass6r ();
<     break;							    break;
< 
<   case opt_y_SideBySide:				      |	  case SideBySide:
<     pass6y ();							    pass6y ();
<     break;							    break;
< 
<   case opt_u_Unified:					      |	  case Unified:
<     pass6u ();							    pass6u ();
<     break;							    break;
< 
< 							      >	  case Default:
<   default:							  default:
<     pass6n ();						      |	    pass6c ();
<     break;							    break;
<   }								  }
< }								}
< 
< template<typename T> T min (T l, T r) {				template<typename T> T min (T l, T r) {
<   if (l < r) {							  if (l < r) {
<     return l;							    return l;
<   }								  }
<   return r;							  return r;
< }								}
< 
< template<typename T> T max (T l, T r) {				template<typename T> T max (T l, T r) {
<   if (l < r) {							  if (l < r) {
<     return r;							    return r;
<   }								  }
<   return l;							  return l;
< }								}
< 
< void pass6c () {						void pass6c () {
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #6c (walking the differences)...	    fprintf (stderr, "# Pass #6c (walking the differences)...
<     fflush (stderr);						    fflush (stderr);
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Write the header.						  // Write the header.
< 
<   fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:0	  fprintf (stdout, "*** %s\t%s\n", files[0], "0000-00-00 00:0
<   fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:0	  fprintf (stdout, "--- %s\t%s\n", files[1], "0000-00-00 00:0
< 
<   // Starting at the top of both files,...			  // Starting at the top of both files,...
< 
<   unsigned o = 0;						  unsigned o = 0;
<   unsigned n = 0;						  unsigned n = 0;
< 
<   while (o < lines[0].size () || n < lines[1].size ()) {	  while (o < lines[0].size () || n < lines[1].size ()) {
< 
<     // Find the bounds of the current contextual 'window'.	    // Find the bounds of the current contextual 'window'.
< 
<     // If we aren't looking at a delete or an insert, we're n	    // If we aren't looking at a delete or an insert, we're n
<     // start of a context window.				    // start of a context window.
< 
<     if (lines[0][o].l != ~0 && lines[1][n].l != ~0) {		    if (lines[0][o].l != ~0 && lines[1][n].l != ~0) {
<       o += 1;							      o += 1;
<       n += 1;							      n += 1;
<       continue;							      continue;
<     }								    }
< 
<     // We're now looking at at least 1 delete or insert, so a	    // We're now looking at at least 1 delete or insert, so a
<     // begins here (or, rather, opt_C_LinesOfCopyContext line |	    // begins here (or, rather, optCopyContext lines earlier)
<     								    
<     int boOldWindow = max (0, int (o) - int (opt_C_LinesOfCop |	    int boOldWindow = max (0, int (o) - int (optCopyContext))
<     int boNewWindow = max (0, int (n) - int (opt_C_LinesOfCop |	    int boNewWindow = max (0, int (n) - int (optCopyContext))
< 
<     if (1 < optVerbose) {					    if (1 < optVerbose) {
<       fprintf (stderr, "boOldWindow = %d, boNewWindow = %d\n"	      fprintf (stderr, "boOldWindow = %d, boNewWindow = %d\n"
<       fflush (stderr);						      fflush (stderr);
<     }								    }
< 
<     // Look for the end of the current window.			    // Look for the end of the current window.
< 
<     int eoOldWindow;						    int eoOldWindow;
<     int eoNewWindow;						    int eoNewWindow;
< 
<     bool widenWindow = true;					    bool widenWindow = true;
<     while (widenWindow && o < lines[0].size () || n < lines[1	    while (widenWindow && o < lines[0].size () || n < lines[1
< 
<       // Skip over the delete(s) and/or insert(s) defining th	      // Skip over the delete(s) and/or insert(s) defining th
<       // context.						      // context.
< 
<       while (o < lines[0].size () && lines[0][o].l == ~0) {	      while (o < lines[0].size () && lines[0][o].l == ~0) {
<         o += 1;							        o += 1;
<       }								      }
<       while (n < lines[1].size () && lines[1][n].l == ~0) {	      while (n < lines[1].size () && lines[1][n].l == ~0) {
<         n += 1;							        n += 1;
<       }								      }
< 
<       // This context will end opt_C_LinesOfCopyContext match |	      // This context will end optCopyContext matched lines p
<       // last set of deletes or inserts we find.		      // last set of deletes or inserts we find.
< 
<       widenWindow = false;					      widenWindow = false;
<       for (unsigned l = 0; !widenWindow && l < opt_C_LinesOfC |	      for (unsigned l = 0; !widenWindow && l < optCopyContext
<         if (o < lines[0].size ()) {				        if (o < lines[0].size ()) {
<           widenWindow |= lines[0][o].l == ~0;			          widenWindow |= lines[0][o].l == ~0;
<           o += 1;						          o += 1;
<         }							        }
<         if (n < lines[1].size ()) {				        if (n < lines[1].size ()) {
<           widenWindow |= lines[1][n].l == ~0;			          widenWindow |= lines[1][n].l == ~0;
<           n += 1;						          n += 1;
<         }							        }
<       }								      }
< 
<       eoOldWindow = o;						      eoOldWindow = o;
<       eoNewWindow = n;						      eoNewWindow = n;
< 
<       // However, since another window could follow, we look	      // However, since another window could follow, we look
<       // opt_C_LinesOfCopyContext ahead for another delete or |	      // optCopyContext ahead for another delete or insert.
< 
<       if (!widenWindow) {					      if (!widenWindow) {
<         for (unsigned l = 0; l < (2 * opt_C_LinesOfCopyContex |	        for (unsigned l = 0; l < (2 * optCopyContext + 1); l 
<           if (o < lines[0].size ()) {				          if (o < lines[0].size ()) {
<             widenWindow |= lines[0][o].l == ~0;			            widenWindow |= lines[0][o].l == ~0;
<             o += 1;						            o += 1;
<           }							          }
<           if (n < lines[1].size ()) {				          if (n < lines[1].size ()) {
<             widenWindow |= lines[1][n].l == ~0;			            widenWindow |= lines[1][n].l == ~0;
<             n += 1;						            n += 1;
<           }							          }
<         }							        }
<       }								      }
<     }								    }
< 
<     // We've found the end of the window.			    // We've found the end of the window.
< 
<     if (1 < optVerbose) {					    if (1 < optVerbose) {
<       fprintf (stderr, "eoOldWindow = %d, eoNewWindow = %d\n"	      fprintf (stderr, "eoOldWindow = %d, eoNewWindow = %d\n"
<       fflush (stderr);						      fflush (stderr);
<     }								    }
< 
<     // Now, reset ourselves to the start of the window, and w	    // Now, reset ourselves to the start of the window, and w
<     // produce the output.  We'll walk it twice, first for th	    // produce the output.  We'll walk it twice, first for th
<     // file part, then for the new file part.			    // file part, then for the new file part.
< 
<     fprintf (stdout, "***************\n");			    fprintf (stdout, "***************\n");
<     fprintf (stdout, "*** %d,%d ****\n", boOldWindow + 1, eoO	    fprintf (stdout, "*** %d,%d ****\n", boOldWindow + 1, eoO
< 
<     o = boOldWindow;						    o = boOldWindow;
<     n = boNewWindow;						    n = boNewWindow;
< 
<     while (o < eoOldWindow || n < eoNewWindow) {		    while (o < eoOldWindow || n < eoNewWindow) {
< 
<       // Find any unmatched lines at this point in the old fi	      // Find any unmatched lines at this point in the old fi
<       // are deletes.						      // are deletes.
< 
<       unsigned boDeletes = o;					      unsigned boDeletes = o;
<       while (o < eoOldWindow && lines[0][o].l == ~0) {		      while (o < eoOldWindow && lines[0][o].l == ~0) {
<         o += 1;							        o += 1;
<       }								      }
< 
<       // Find any unmatched lines at this point in the new fi	      // Find any unmatched lines at this point in the new fi
<       // are inserts.						      // are inserts.
< 
<       unsigned boInserts = n;					      unsigned boInserts = n;
<       while (n < eoNewWindow && lines[1][n].l == ~0) {		      while (n < eoNewWindow && lines[1][n].l == ~0) {
<         n += 1;							        n += 1;
<       }								      }
< 
<       // We've got deleted line(s) from boDeletes .. o.		      // We've got deleted line(s) from boDeletes .. o.
<       // We've got deleted line(s) from boInserts .. n.		      // We've got deleted line(s) from boInserts .. n.
< 
<       unsigned nDeletes = o - boDeletes;			      unsigned nDeletes = o - boDeletes;
<       unsigned nInserts = n - boInserts;			      unsigned nInserts = n - boInserts;
< 
<       // We've got...						      // We've got...
< 
<       if (nDeletes && nInserts) {				      if (nDeletes && nInserts) {
< 
<         // ... deletes and inserts.				        // ... deletes and inserts.
< 
<         for (unsigned l = boDeletes; l < o; l += 1) {		        for (unsigned l = boDeletes; l < o; l += 1) {
<           fprintf (stdout, "! %s\n", lines[0][l].line->c_str 	          fprintf (stdout, "! %s\n", lines[0][l].line->c_str 
<         }							        }
<       } else if (nDeletes) {					      } else if (nDeletes) {
< 
<         //  ... just deletes.					        //  ... just deletes.
< 
<         for (unsigned l = boDeletes; l < o; l += 1) {		        for (unsigned l = boDeletes; l < o; l += 1) {
<           fprintf (stdout, "- %s\n", lines[0][l].line->c_str 	          fprintf (stdout, "- %s\n", lines[0][l].line->c_str 
<         }							        }
<       }								      }
< 
<       // When we get here, we're dealing with matching lines.	      // When we get here, we're dealing with matching lines.
< 
<       fprintf (stdout, "  %s\n", lines[0][o].line->c_str ());	      fprintf (stdout, "  %s\n", lines[0][o].line->c_str ());
<       o += 1;							      o += 1;
<       n += 1;							      n += 1;
<     }								    }
< 
<     fprintf (stdout, "--- %d,%d ----\n", boNewWindow + 1, eoN	    fprintf (stdout, "--- %d,%d ----\n", boNewWindow + 1, eoN
< 
<     o = boOldWindow;						    o = boOldWindow;
<     n = boNewWindow;						    n = boNewWindow;
< 
<     while (o < eoOldWindow && n < eoNewWindow) {		    while (o < eoOldWindow && n < eoNewWindow) {
< 
<       // Find any unmatched lines at this point in the old fi	      // Find any unmatched lines at this point in the old fi
<       // are deletes.						      // are deletes.
< 
<       unsigned boDeletes = o;					      unsigned boDeletes = o;
<       while (o < eoOldWindow && lines[0][o].l == ~0) {		      while (o < eoOldWindow && lines[0][o].l == ~0) {
<         o += 1;							        o += 1;
<       }								      }
< 
<       // Find any unmatched lines at this point in the new fi	      // Find any unmatched lines at this point in the new fi
<       // are inserts.						      // are inserts.
< 
<       unsigned boInserts = n;					      unsigned boInserts = n;
<       while (n < eoNewWindow && lines[1][n].l == ~0) {		      while (n < eoNewWindow && lines[1][n].l == ~0) {
<         n += 1;							        n += 1;
<       }								      }
< 
<       // We've got deleted line(s) from boDeletes .. o.		      // We've got deleted line(s) from boDeletes .. o.
<       // We've got deleted line(s) from boInserts .. n.		      // We've got deleted line(s) from boInserts .. n.
< 
<       unsigned nDeletes = o - boDeletes;			      unsigned nDeletes = o - boDeletes;
<       unsigned nInserts = n - boInserts;			      unsigned nInserts = n - boInserts;
< 
<       // We've got...						      // We've got...
< 
<       if (nDeletes && nInserts) {				      if (nDeletes && nInserts) {
< 
<         // ... deletes and inserts.				        // ... deletes and inserts.
< 
<         for (unsigned l = boInserts; l < n; l += 1) {		        for (unsigned l = boInserts; l < n; l += 1) {
<           fprintf (stdout, "! %s\n", lines[1][l].line->c_str 	          fprintf (stdout, "! %s\n", lines[1][l].line->c_str 
<         }							        }
<       } else if (nInserts) {					      } else if (nInserts) {
< 
<         //  ... just inserts.					        //  ... just inserts.
< 
<         for (unsigned l = boInserts; l < n; l += 1) {		        for (unsigned l = boInserts; l < n; l += 1) {
<           fprintf (stdout, "+ %s\n", lines[1][l].line->c_str 	          fprintf (stdout, "+ %s\n", lines[1][l].line->c_str 
<         }							        }
<       }								      }
< 
<       // When we get here, we're dealing with matching lines.	      // When we get here, we're dealing with matching lines.
< 
<       fprintf (stdout, "  %s\n", lines[1][n].line->c_str ());	      fprintf (stdout, "  %s\n", lines[1][n].line->c_str ());
<       o += 1;							      o += 1;
<       n += 1;							      n += 1;
<     }								    }
< 
<     // Reset to the end of the current window.			    // Reset to the end of the current window.
< 
<     o = eoOldWindow;						    o = eoOldWindow;
<     n = eoNewWindow;						    n = eoNewWindow;
<   }								  }
< }								}
< 
< void pass6e () {						void pass6e () {
<   fprintf (stderr, "pass6e() is unimplemented!\n");		  fprintf (stderr, "pass6e() is unimplemented!\n");
<   fflush (stderr);						  fflush (stderr);
< }								}
< 
< void pass6i () {						void pass6i () {
<   fprintf (stderr, "pass6i() is unimplemented!\n");		  fprintf (stderr, "pass6i() is unimplemented!\n");
<   fflush (stderr);						  fflush (stderr);
< }								}
< 
< void pass6n ()							void pass6n ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #6n (walking the differences)...	    fprintf (stderr, "# Pass #6n (walking the differences)...
<     fflush (stderr);						    fflush (stderr);
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Write the header.  (None for normal.)			  // Write the header.  (None for normal.)
< 
<   // Starting at the top of both files,...			  // Starting at the top of both files,...
< 
<   unsigned o = 0;						  unsigned o = 0;
<   unsigned n = 0;						  unsigned n = 0;
< 
<   while (o < lines[0].size () || n < lines[1].size ()) {	  while (o < lines[0].size () || n < lines[1].size ()) {
< 
<     // Find any unmatched lines at this point in the old file	    // Find any unmatched lines at this point in the old file
<     // are deletes.						    // are deletes.
< 
<     unsigned boDeletes;						    unsigned boDeletes;
<     for (boDeletes = o;						    for (boDeletes = o;
<          o < lines[0].size () && lines[0][o].l == ~0;		         o < lines[0].size () && lines[0][o].l == ~0;
<          o += 1							         o += 1
<         )							        )
<     {}								    {}
< 
<     // Find any unmatched lines at this point in the new file	    // Find any unmatched lines at this point in the new file
<     // are inserts.						    // are inserts.
< 
<     unsigned boInserts;						    unsigned boInserts;
<     for (boInserts = n;						    for (boInserts = n;
<          n < lines[1].size () && lines[1][n].l == ~0;		         n < lines[1].size () && lines[1][n].l == ~0;
<          n += 1							         n += 1
<         )							        )
<     {}								    {}
< 
<     // We've got deleted line(s) from boDeletes .. o.		    // We've got deleted line(s) from boDeletes .. o.
<     // We've got deleted line(s) from boInserts .. n.		    // We've got deleted line(s) from boInserts .. n.
< 
<     unsigned nDeletes = o - boDeletes;				    unsigned nDeletes = o - boDeletes;
<     unsigned nInserts = n - boInserts;				    unsigned nInserts = n - boInserts;
< 
<     // We've got...						    // We've got...
< 
<     if (nDeletes && nInserts) {					    if (nDeletes && nInserts) {
< 
<       // ... deletes and inserts.				      // ... deletes and inserts.
< 
<       if (1 < nDeletes && 1 < nInserts) {			      if (1 < nDeletes && 1 < nInserts) {
<         fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, b	        fprintf (stdout, "%d,%dc%d,%d\n", boDeletes + 1, o, b
<       } else if (1 < nDeletes) {				      } else if (1 < nDeletes) {
<         fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boIn	        fprintf (stdout, "%d,%dc%d\n", boDeletes + 1, o, boIn
<       } else if (1 < nInserts) {				      } else if (1 < nInserts) {
<         fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInser	        fprintf (stdout, "%dc%d,%d\n", boDeletes + 1, boInser
<       } 							      } 
<       for (unsigned l = boDeletes; l < o; l += 1) {		      for (unsigned l = boDeletes; l < o; l += 1) {
<         fprintf (stdout, "< %s\n", lines[0][l].line->c_str ()	        fprintf (stdout, "< %s\n", lines[0][l].line->c_str ()
<       }								      }
<       fprintf (stdout, "---\n");				      fprintf (stdout, "---\n");
<       for (unsigned l = boInserts; l < n; l += 1) {		      for (unsigned l = boInserts; l < n; l += 1) {
<         fprintf (stdout, "> %s\n", lines[1][l].line->c_str ()	        fprintf (stdout, "> %s\n", lines[1][l].line->c_str ()
<       }								      }
<     } else if (nDeletes) {					    } else if (nDeletes) {
< 
<       //  ... just deletes.					      //  ... just deletes.
< 
<       if (1 < nDeletes) {					      if (1 < nDeletes) {
<         fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);	        fprintf (stdout, "%d,%dd%d\n", boDeletes + 1, o, n);
<       } else {							      } else {
<         fprintf (stdout, "%dd%d\n", boDeletes + 1, n);		        fprintf (stdout, "%dd%d\n", boDeletes + 1, n);
<       }								      }
<       for (unsigned l = boDeletes; l < o; l += 1) {		      for (unsigned l = boDeletes; l < o; l += 1) {
<         fprintf (stdout, "< %s\n", lines[0][l].line->c_str ()	        fprintf (stdout, "< %s\n", lines[0][l].line->c_str ()
<       }								      }
<     } else if (nInserts) {					    } else if (nInserts) {
< 
<       //  ... just inserts.					      //  ... just inserts.
< 
<       if (1 < nInserts) {					      if (1 < nInserts) {
<         fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);	        fprintf (stdout, "%da%d,%d\n", o, boInserts + 1, n);
<       } else {							      } else {
<         fprintf (stdout, "%da%d\n", o, boInserts + 1);		        fprintf (stdout, "%da%d\n", o, boInserts + 1);
<       }								      }
<       for (unsigned l = boInserts; l < n; l += 1) {		      for (unsigned l = boInserts; l < n; l += 1) {
<         fprintf (stdout, "> %s\n", lines[1][l].line->c_str ()	        fprintf (stdout, "> %s\n", lines[1][l].line->c_str ()
<       }								      }
<     }								    }
< 
<     // When we get here, we're dealing with matching lines.	    // When we get here, we're dealing with matching lines.
< 
<     o += 1;							    o += 1;
<     n += 1;							    n += 1;
<   }								  }
< }								}
< 
< void pass6r () {						void pass6r () {
<   fprintf (stderr, "pass6r() is unimplemented!\n");		  fprintf (stderr, "pass6r() is unimplemented!\n");
<   fflush (stderr);						  fflush (stderr);
< }								}
< 
< void pass6s () {						void pass6s () {
<   fprintf (stderr, "pass6s() is unimplemented!\n");		  fprintf (stderr, "pass6s() is unimplemented!\n");
<   fflush (stderr);						  fflush (stderr);
< }								}
< 
< void pass6u ()							void pass6u ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #6u (walking the differences)...	    fprintf (stderr, "# Pass #6u (walking the differences)...
<     fflush (stderr);						    fflush (stderr);
<   }								  }
< 
<   nMatchedLines = 0;						  nMatchedLines = 0;
< 
<   // Write the header.						  // Write the header.
< 
<   fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:0	  fprintf (stdout, "--- %s\t%s\n", files[0], "0000-00-00 00:0
<   fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:0	  fprintf (stdout, "+++ %s\t%s\n", files[1], "0000-00-00 00:0
<   fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), l	  fprintf (stdout, "@@ -1,%d +1,%d @@\n", lines[0].size (), l
< 
<   // Starting at the top of both files,...			  // Starting at the top of both files,...
< 
<   unsigned o = 0;						  unsigned o = 0;
<   unsigned n = 0;						  unsigned n = 0;
< 
<   while (o < lines[0].size () || n < lines[1].size ()) {	  while (o < lines[0].size () || n < lines[1].size ()) {
< 
<     // Find any unmatched lines at this point in the old file	    // Find any unmatched lines at this point in the old file
<     // are deletes.						    // are deletes.
< 
<     unsigned boDeletes;						    unsigned boDeletes;
<     for (boDeletes = o;						    for (boDeletes = o;
<          o < lines[0].size () && lines[0][o].l == ~0;		         o < lines[0].size () && lines[0][o].l == ~0;
<          o += 1							         o += 1
<         )							        )
<     {}								    {}
< 
<     // Find any unmatched lines at this point in the new file	    // Find any unmatched lines at this point in the new file
<     // are inserts.						    // are inserts.
< 
<     unsigned boInserts;						    unsigned boInserts;
<     for (boInserts = n;						    for (boInserts = n;
<          n < lines[1].size () && lines[1][n].l == ~0;		         n < lines[1].size () && lines[1][n].l == ~0;
<          n += 1							         n += 1
<         )							        )
<     {}								    {}
< 
<     // We've got deleted line(s) from boDeletes .. o.		    // We've got deleted line(s) from boDeletes .. o.
<     // We've got deleted line(s) from boInserts .. n.		    // We've got deleted line(s) from boInserts .. n.
< 
<     unsigned nDeletes = o - boDeletes;				    unsigned nDeletes = o - boDeletes;
<     unsigned nInserts = n - boInserts;				    unsigned nInserts = n - boInserts;
< 
<     // We've got...						    // We've got...
< 
<     if (nDeletes && nInserts) {					    if (nDeletes && nInserts) {
< 
<       // ... deletes and inserts.				      // ... deletes and inserts.
< 
<       for (unsigned l = boDeletes; l < o; l += 1) {		      for (unsigned l = boDeletes; l < o; l += 1) {
<         fprintf (stdout, "-%s\n", lines[0][l].line->c_str ())	        fprintf (stdout, "-%s\n", lines[0][l].line->c_str ())
<       }								      }
<       for (unsigned l = boInserts; l < n; l += 1) {		      for (unsigned l = boInserts; l < n; l += 1) {
<         fprintf (stdout, "+%s\n", lines[1][l].line->c_str ())	        fprintf (stdout, "+%s\n", lines[1][l].line->c_str ())
<       }								      }
<     } else if (nDeletes) {					    } else if (nDeletes) {
< 
<       //  ... just deletes.					      //  ... just deletes.
< 
<       for (unsigned l = boDeletes; l < o; l += 1) {		      for (unsigned l = boDeletes; l < o; l += 1) {
<         fprintf (stdout, "-%s\n", lines[0][l].line->c_str ())	        fprintf (stdout, "-%s\n", lines[0][l].line->c_str ())
<       }								      }
<     } else if (nInserts) {					    } else if (nInserts) {
< 
<       //  ... just inserts.					      //  ... just inserts.
< 
<       for (unsigned l = boInserts; l < n; l += 1) {		      for (unsigned l = boInserts; l < n; l += 1) {
<         fprintf (stdout, "+%s\n", lines[1][l].line->c_str ())	        fprintf (stdout, "+%s\n", lines[1][l].line->c_str ())
<       }								      }
<     }								    }
< 
<     // When we get here, we're dealing with matching lines.	    // When we get here, we're dealing with matching lines.
< 
<     fprintf (stdout, " %s\n", lines[0][o].line->c_str ());	    fprintf (stdout, " %s\n", lines[0][o].line->c_str ());
<     o += 1;							    o += 1;
<     n += 1;							    n += 1;
<   }								  }
< }								}
< 
< void pass6y ()							void pass6y ()
< {								{
<   if (0 < optVerbose) {						  if (0 < optVerbose) {
<     fprintf (stderr, "# Pass #6y (walking the differences)...	    fprintf (stderr, "# Pass #6y (walking the differences)...
<     fflush (stderr);						    fflush (stderr);
<   }								  }
< 
<   // Write the header.						  // Write the header.
< 
<   // None for side-by-side.					  // None for side-by-side.
< 
<   // Starting at the top of both files,...			  // Starting at the top of both files,...
< 
<   int columnWidth = (opt_W_MaxPrintColumns - 7) / 2;	      |	  int columnWidth = (optPageWidth - 7) / 2;
< 
<   unsigned o = 0;						  unsigned o = 0;
<   unsigned n = 0;						  unsigned n = 0;
< 
<   while (o < lines[0].size () || n < lines[1].size ()) {	  while (o < lines[0].size () || n < lines[1].size ()) {
< 
<     // Find any unmatched lines at this point in the old file	    // Find any unmatched lines at this point in the old file
<     // are deletes.						    // are deletes.
< 
<     unsigned boDeletes = o;					    unsigned boDeletes = o;
<     while (o < lines[0].size () && lines[0][o].l == ~0) {	    while (o < lines[0].size () && lines[0][o].l == ~0) {
<       o += 1;							      o += 1;
<     }								    }
< 
<     // Find any unmatched lines at this point in the new file	    // Find any unmatched lines at this point in the new file
<     // are inserts.						    // are inserts.
< 
<     unsigned boInserts = n;					    unsigned boInserts = n;
<     while (n < lines[1].size () && lines[1][n].l == ~0) {	    while (n < lines[1].size () && lines[1][n].l == ~0) {
<       n += 1;							      n += 1;
<     }								    }
< 
<     // We've got deleted line(s) from boDeletes .. o.		    // We've got deleted line(s) from boDeletes .. o.
<     // We've got deleted line(s) from boInserts .. n.		    // We've got deleted line(s) from boInserts .. n.
< 
<     unsigned nDeletes = o - boDeletes;				    unsigned nDeletes = o - boDeletes;
<     unsigned nInserts = n - boInserts;				    unsigned nInserts = n - boInserts;
< 
<     // We've got...						    // We've got...
< 
<     while (boDeletes < o && boInserts < n) {			    while (boDeletes < o && boInserts < n) {
< 
<       // ... deletes and inserts.				      // ... deletes and inserts.
< 
<       fprintf (stdout,						      fprintf (stdout,
<                "%-*s | %s\n",					               "%-*s | %s\n",
<                columnWidth,					               columnWidth,
<                lines[0][boDeletes].line->substr (0, columnWid	               lines[0][boDeletes].line->substr (0, columnWid
<                lines[1][boInserts].line->substr (0, columnWid	               lines[1][boInserts].line->substr (0, columnWid
<               );						              );
<       boDeletes += 1;						      boDeletes += 1;
<       boInserts += 1;						      boInserts += 1;
<     }								    }
< 
<     while (boDeletes < o) {					    while (boDeletes < o) {
< 
<       //  ... just deletes.					      //  ... just deletes.
< 
<       fprintf (stdout,						      fprintf (stdout,
<                "%-*s <\n",					               "%-*s <\n",
<                columnWidth,					               columnWidth,
<                lines[0][boDeletes].line->substr (0, columnWid	               lines[0][boDeletes].line->substr (0, columnWid
<               );						              );
<       boDeletes += 1;						      boDeletes += 1;
<     }								    }
< 
<     while (boInserts < n) {					    while (boInserts < n) {
< 
<       //  ... just inserts.					      //  ... just inserts.
< 
<       fprintf (stdout,						      fprintf (stdout,
<                "%-*s > %s\n",					               "%-*s > %s\n",
<                columnWidth,					               columnWidth,
<                "",						               "",
<                lines[1][boInserts].line->substr (0, columnWid	               lines[1][boInserts].line->substr (0, columnWid
<               );						              );
<       boInserts += 1;						      boInserts += 1;
<     }								    }
< 
<     // When we get here, we're dealing with matching lines.	    // When we get here, we're dealing with matching lines.
< 
<     fprintf (stdout,						    fprintf (stdout,
<              "%-*s   %s\n",					             "%-*s   %s\n",
<              columnWidth,					             columnWidth,
<              lines[0][o].line->substr (0, columnWidth).c_str 	             lines[0][o].line->substr (0, columnWidth).c_str 
<              lines[1][n].line->substr (0, columnWidth).c_str 	             lines[1][n].line->substr (0, columnWidth).c_str 
<             );							            );
<     o += 1;							    o += 1;
<     n += 1;							    n += 1;
<   }								  }
< }								}
---
> bool       opt_s_ReportWhenFilesAreSame = false;              <
> bool       opt_t_ExpandTabs = false;                          <
> bool       opt_v_ShowVersionInfo = false;                     <
> bool       opt_w_IgnoreAllWhitespace = false;                 <
> string     opt_x_IgnoreFilesMatching;                         <
>                                                                 
>                                                               > unsigned optCopyContext = 3;
>                                                               > unsigned optPageWidth = 130;
> unsigned optVerbose = 2;                                        unsigned optVerbose = 2;
>                                                                 
> struct Line : public string {                                   struct Line : public string {
>   Line (string _text) :                                           Line (string _text) :
>     string (_text)                                                  string (_text)
>   {                                                               {
>   }                                                               }
>   ~Line () {                                                      ~Line () {
>     copies[0].erase (copies[0].begin (), copies[0].end ());         copies[0].erase (copies[0].begin (), copies[0].end ());
>     copies[1].erase (copies[1].begin (), copies[1].end ());         copies[1].erase (copies[1].begin (), copies[1].end ());
>   }                                                               }
>   void Dump (FILE *out) {                                         void Dump (FILE *out) {
>     fprintf (out, "{{ ");                                           fprintf (out, "{{ ");
>     for (list<unsigned>::iterator i = copies[0].begin (); i !       for (list<unsigned>::iterator i = copies[0].begin (); i !
>       fprintf (out, "%u ", *i);                                       fprintf (out, "%u ", *i);
>     }                                                               }
>     fprintf (out, "},{ ");                                          fprintf (out, "},{ ");
>     for (list<unsigned>::iterator i = copies[1].begin (); i !       for (list<unsigned>::iterator i = copies[1].begin (); i !
>       fprintf (out, "%u ", *i);                                       fprintf (out, "%u ", *i);
>     }                                                               }
>     fprintf (out, "}}\t%s\n", c_str ());                            fprintf (out, "}}\t%s\n", c_str ());
>   }                                                               }
>   list<unsigned> copies[2];                                       list<unsigned> copies[2];
> };                                                              };
>                                                                 
> struct LinePtr {                                                struct LinePtr {
>   LinePtr (Line *_line) :                                         LinePtr (Line *_line) :
>     line (_line),                                                   line (_line),
>     l (~0u)                                                         l (~0u)
>   {                                                               {
>   }                                                               }
>   void Dump (FILE *out) {                                         void Dump (FILE *out) {
>     fprintf (out, "[%d] ", l);                                      fprintf (out, "[%d] ", l);
>     line->Dump (out);                                               line->Dump (out);
>   }                                                               }
>   Line *line;                                                     Line *line;
>   unsigned l;                                                     unsigned l;
> };                                                              };
>                                                                 
> typedef map<string, Line *> MapStringToLinePtr;                 typedef map<string, Line *> MapStringToLinePtr;
> typedef vector<LinePtr> VectorLinePtr;                          typedef vector<LinePtr> VectorLinePtr;
>                                                                 
> // Our name.                                                    // Our name.
>                                                                 
> char *ARGV0 = "dif3";                                           char *ARGV0 = "dif3";
>                                                                 
> // The 'symbol' (line) table.                                   // The 'symbol' (line) table.
>                                                                 
> MapStringToLinePtr table;                                       MapStringToLinePtr table;
>                                                                 
> // The names of the 2 files to be diff'd.                       // The names of the 2 files to be diff'd.
>                                                                 
> char const *files[2] = { 0, 0 };               sdiff: sdiff.cpp:1858: void pass6y(): Assertion `lines[0][o].line == lines[1][n].line' failed.
>                  char const *files[2] = { 0, 0 };
>                                                                 
> // The lines of the 2 files to be diff'd.                       // The lines of the 2 files to be diff'd.
>                                                                 
> VectorLinePtr lines[2];                                         VectorLinePtr lines[2];
>                                                                 
> // Miscellaneous metrics.                                       // Miscellaneous metrics.
>                                                                 
> unsigned nTotalMatchedBlocks = 0;                               unsigned nTotalMatchedBlocks = 0;
> unsigned nMatchedBlocks = 0;                                    unsigned nMatchedBlocks = 0;
> unsigned nTotalMatchedLines = 0;                                unsigned nTotalMatchedLines = 0;
> unsigned nMatchedLines = 0;                                     unsigned nMatchedLines = 0;
>                                                               > 
>                                                               > void pass1 ();
>                                                               > void pass2 ();
>                                                               > void pass3 ();
>                                                               > void pass4 ();
>                                                               > void pass5 ();
>                                                               > void pass6 ();
>                                                               > 
>                                                               > int main (int argc, char *argv[])
